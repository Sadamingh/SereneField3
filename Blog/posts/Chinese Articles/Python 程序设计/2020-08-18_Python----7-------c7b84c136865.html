<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Python程序设计7 元组和排序</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Python程序设计7 元组和排序</h1>
</header>
<section data-field="subtitle" class="p-summary">
系列：Python程序设计
</section>
<section data-field="body" class="e-content">
<section name="3550" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1e60" id="1e60" class="graf graf--h3 graf--leading graf--title">Python程序设计7 元组和排序</h3><figure name="24b5" id="24b5" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*nMQTiDVkQq7j6ZlqQEKLbQ.jpeg" data-width="2689" data-height="1513" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*nMQTiDVkQq7j6ZlqQEKLbQ.jpeg"></figure><p name="6b50" id="6b50" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">一、元组</strong></p><ol class="postList"><li name="5689" id="5689" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">元组的定义</strong></li></ol><p name="98e6" id="98e6" class="graf graf--p graf-after--li">元素是用来跟踪一系列有序元素（item）的一种对象。元组具有如下的特征：</p><ul class="postList"><li name="7d49" id="7d49" class="graf graf--li graf-after--p">元组类似于列表，但是元组是不可变的 immutable</li><li name="1e28" id="1e28" class="graf graf--li graf-after--li">有序性：可以通过元素的地址查找元素</li><li name="817b" id="817b" class="graf graf--li graf-after--li">集合性：元组可以包括一系列的元素</li></ul><p name="1a0c" id="1a0c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">2. 元组的常见用处</strong></p><p name="27d3" id="27d3" class="graf graf--p graf-after--p">元组的作用经常是用来跟踪一系列概念上相近的变量。元组也可以用于返回函数的return结果。例如：</p><ul class="postList"><li name="2746" id="2746" class="graf graf--li graf-after--p">某个点的坐标：（x，y）</li><li name="90c1" id="90c1" class="graf graf--li graf-after--li">某个像素的RGB颜色：（r，g，b）</li><li name="899e" id="899e" class="graf graf--li graf-after--li">某个地址的成分：（street，city，state，zipcode）</li></ul><p name="99c1" id="99c1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">3. 元组的性质</strong></p><p name="dbd4" id="dbd4" class="graf graf--p graf-after--p">元组以小括号 parenthese 开始，以小括号结束，并且元组通过逗号 comma 分隔开。下面是一些元组的示例，例如：</p><pre name="81ca" id="81ca" class="graf graf--pre graf-after--p">my_tuple = (1, 2, 3) <br>point = (4.7, -6.0) <br>strs = (&#39;strings&#39;, &#39;in&#39;, &#39;tuple&#39;) <br>addr = (&#39;102 Ray Ln&#39;, &#39;Stanford&#39;, &#39;CA&#39;, 94305) <br>empty_tuple = ()</pre><p name="25e2" id="25e2" class="graf graf--p graf-after--pre">如果我们想要得到一个元素的元组，我们也需要输出逗号，否则的话只表示一个元素。例如：</p><pre name="f52b" id="f52b" class="graf graf--pre graf-after--p">tuple_one = (1, )<br>type(tuple_one)</pre><p name="ff54" id="ff54" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4. 引用元组的元素</strong></p><p name="6e49" id="6e49" class="graf graf--p graf-after--p">元组和列表的引用方式完全一样，例如对于下面的元组，我们可以通过索引的方式输出指定位置的元素。</p><pre name="a8e9" id="a8e9" class="graf graf--pre graf-after--p">letters = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;)</pre><figure name="7ad7" id="7ad7" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*trvhee_vfHO11JYCXNPVlg.png" data-width="1542" data-height="154" src="https://cdn-images-1.medium.com/max/800/1*trvhee_vfHO11JYCXNPVlg.png"></figure><p name="3635" id="3635" class="graf graf--p graf-after--figure">我们可以通过下面的方法输出：</p><pre name="df48" id="df48" class="graf graf--pre graf-after--p">letters[0]        # &#39;a&#39;<br>letters[4]        # &#39;e&#39;</pre><p name="9949" id="9949" class="graf graf--p graf-after--pre">但是我们不可以通过上面的方法直接对元组进行赋值，这是因为元组是 immutable 变量。采用下面的语句直接赋值，我们会得到报错。例如：</p><pre name="2127" id="2127" class="graf graf--pre graf-after--p">letters[0] = &#39;x&#39;</pre><p name="a960" id="a960" class="graf graf--p graf-after--pre">得到报错：</p><pre name="d435" id="d435" class="graf graf--pre graf-after--p">TypeError: &#39;tuple&#39; object does not support item assignment</pre><p name="72fa" id="72fa" class="graf graf--p graf-after--pre">我们也可以直接输出元组。例如：</p><pre name="6f20" id="6f20" class="graf graf--pre graf-after--p">chartreuse_rgb = (127, 255, 0)<br>print(chartreuse_rgb)</pre><p name="19b9" id="19b9" class="graf graf--p graf-after--pre">得到输出：</p><pre name="2640" id="2640" class="graf graf--pre graf-after--p">(127, 255, 0)</pre><p name="f478" id="f478" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">5. 返回元组的长度</strong></p><p name="8a14" id="8a14" class="graf graf--p graf-after--p">我们可以通过len函数来返回元组的长度。例如：</p><pre name="71aa" id="71aa" class="graf graf--pre graf-after--p">len(letters)          # 5</pre><p name="8551" id="8551" class="graf graf--p graf-after--pre">因此，我们可以通过len函数来遍历一个数组。例如：</p><pre name="a439" id="a439" class="graf graf--pre graf-after--p">for i in range(len(letters)): <br>     print(f&quot;{i} -&gt; {letters[i]}&quot;)</pre><p name="7c42" id="7c42" class="graf graf--p graf-after--pre">得到输出：</p><pre name="b147" id="b147" class="graf graf--pre graf-after--p">0 -&gt; a <br>1 -&gt; b <br>2 -&gt; c <br>3 -&gt; d <br>4 -&gt; e</pre><p name="7134" id="7134" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">6. 元组的负索引和切片</strong></p><p name="2924" id="2924" class="graf graf--p graf-after--p">对于负索引和切片来说，元组和列表是非常类似的。例如对于元组：</p><pre name="3fe7" id="3fe7" class="graf graf--pre graf-after--p">letters = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;)</pre><p name="7077" id="7077" class="graf graf--p graf-after--pre">如果有：</p><pre name="f276" id="f276" class="graf graf--pre graf-after--p">letters[-1]       # &#39;e&#39;</pre><p name="b03e" id="b03e" class="graf graf--p graf-after--pre">另外如果有切片：</p><pre name="c8f6" id="c8f6" class="graf graf--pre graf-after--p">aslice = letters[2:4]<br>aslice</pre><p name="3071" id="3071" class="graf graf--p graf-after--pre">则会输出：</p><pre name="a063" id="a063" class="graf graf--pre graf-after--p">(&#39;c&#39;, &#39;d&#39;)</pre><p name="ec21" id="ec21" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">7. 元组的判断</strong></p><p name="6756" id="6756" class="graf graf--p graf-after--p">如果在if语句的后面直接加元组，那么如果元组为空，就相当于False，如果元组不为空，就相当于True。例如：</p><pre name="7116" id="7116" class="graf graf--pre graf-after--p">stanford = (&#39;450 Jane Stanford Way&#39;, &#39;Stanford&#39;, &#39;CA&#39;, 94305)</pre><p name="c38e" id="c38e" class="graf graf--p graf-after--pre">有如下代码：</p><pre name="69d9" id="69d9" class="graf graf--pre graf-after--p">if stanford: <br>    print(&#39;stanford is not empty&#39;) <br>else: <br>    print(&#39;stanford is empty&#39;)</pre><p name="cdfb" id="cdfb" class="graf graf--p graf-after--pre">会得到输出为：</p><pre name="cd12" id="cd12" class="graf graf--pre graf-after--p">stanford is not empty</pre><p name="f214" id="f214" class="graf graf--p graf-after--pre">element in tuple 的语句可以用来检测一个元素是否在元组内。如果element在元组内，则该语句返回True，反之则返回False。同时，此语句相反输出的语句是 not in，也非常常用。例如：</p><pre name="c3b7" id="c3b7" class="graf graf--pre graf-after--p">state = &#39;CA&#39; <br>if state in stanford: <br>    # do something</pre><p name="4412" id="4412" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">8. 元组的计算</strong></p><p name="405c" id="405c" class="graf graf--p graf-after--p">我们可以通过max，min，以及sum三个函数对元组内的元素进行简单运算。例如：</p><pre name="4130" id="4130" class="graf graf--pre graf-after--p">chartreuse_rgb = (127, 255, 0)<br>max(chartreuse_rgb)       # 255<br>min(chartreuse_rgb)       # 0<br>sum(chartreuse_rgb)       # 382</pre><p name="129a" id="129a" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">9. 通过循环来遍历输出元组中的元素</strong></p><p name="9c5e" id="9c5e" class="graf graf--p graf-after--p">我们有两种方法（和之前一样），range法和直接法来输出元组中的元素。例如：</p><pre name="4f59" id="4f59" class="graf graf--pre graf-after--p">for i in range(len(stanford)): <br>    elem = stanford[i] <br>    print(elem)</pre><p name="35e0" id="35e0" class="graf graf--p graf-after--pre">以及：</p><pre name="beff" id="beff" class="graf graf--pre graf-after--p">for elem in stanford: <br>    print(elem)</pre><p name="db48" id="db48" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">10. 元组作为参数</strong></p><p name="f95c" id="f95c" class="graf graf--p graf-after--p">由于元组是immutable，所以元组在作为参数传递的过程中是不能只传递元组的元素的，而是要将元组整体进行传递。例如：</p><pre name="0f49" id="0f49" class="graf graf--pre graf-after--p">def remove_red(rgb_tuple): <br>    rgb_tuple = (0, rgb_tuple[1], rgb_tuple[2]) <br>    print(f&quot;In remove_red: {rgb_tuple}&quot;) </pre><pre name="8e9d" id="8e9d" class="graf graf--pre graf-after--pre">def main(): <br>    chartreuse_rgb = (127, 255, 0) <br>    remove_red(chartreuse_rgb) <br>    print(f&quot;In main: {chartreuse_rgb}&quot;)</pre><p name="6ad0" id="6ad0" class="graf graf--p graf-after--pre">得到输出：</p><pre name="9fd8" id="9fd8" class="graf graf--pre graf-after--p">In remove_red: (0, 255, 0) <br>In main: (127, 255, 0)</pre><p name="3719" id="3719" class="graf graf--p graf-after--pre">11. 通过元组来指派变量</p><p name="4bd8" id="4bd8" class="graf graf--p graf-after--p">我们可以直接通过元组来指派变量，也就是说我们可以直接给元组赋值。但是这种赋值的方法并不是通过索引来赋值，而是在初始化元组的时候就向元组进行赋值。例如：</p><pre name="43ba" id="43ba" class="graf graf--pre graf-after--p">(x, y) = (3, 4)<br>x                       # 3<br>y                       # 4</pre><p name="f41d" id="f41d" class="graf graf--p graf-after--pre">我们甚至不需要小括号就可以进行元组内元素的交换，这非常神奇，但是确实是可以运行的。</p><pre name="ce13" id="ce13" class="graf graf--pre graf-after--p">x, y = y, x             # swap x and y<br>x                       # 4<br>y                       # 3</pre><p name="ffad" id="ffad" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">12. 通过函数返回元组</strong></p><p name="6b88" id="6b88" class="graf graf--p graf-after--p">我们可以通过函数的返回值得到一个元组，并且在得到元组的同时对元组内各个变量进行赋值。例如：</p><pre name="9ebd" id="9ebd" class="graf graf--pre graf-after--p">def get_date(): <br>    day = int(input(&quot;Day (DD): &quot;)) <br>    month = int(input(&quot;Month (MM): &quot;)) <br>    year = int(input(&quot;Year (YYYY): &quot;)) <br>    return day, month, year </pre><pre name="b9e4" id="b9e4" class="graf graf--pre graf-after--pre">def main(): <br>    (dd, mm, yyyy) = get_date() <br>    print(f&quot;{mm}/{dd}/{yyyy}&quot;)</pre><p name="8963" id="8963" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">13. 元组、字典、和列表</strong></p><p name="923c" id="923c" class="graf graf--p graf-after--p">元组可以被list函数强制转换为列表。例如：</p><pre name="850e" id="850e" class="graf graf--pre graf-after--p">my_tuple = (10, 20, 30, 40, 50)<br>my_list = list(my_tuple)<br>my_list</pre><p name="0c13" id="0c13" class="graf graf--p graf-after--pre">得到输出：</p><pre name="9341" id="9341" class="graf graf--pre graf-after--p">[10, 20, 30, 40, 50]</pre><p name="6290" id="6290" class="graf graf--p graf-after--pre">同样地，列表也可以被tuple函数强制转换为元组。例如：</p><pre name="f79d" id="f79d" class="graf graf--pre graf-after--p">a_list = [&#39;summer&#39;, &#39;of&#39;, 2020]<br>a_tuple = tuple(a_list)<br>a_tuple</pre><p name="d504" id="d504" class="graf graf--p graf-after--pre">得到输出：</p><pre name="c657" id="c657" class="graf graf--pre graf-after--p">(‘summer&#39;, &#39;of&#39;, 2020)</pre><p name="4c0b" id="4c0b" class="graf graf--p graf-after--pre">我们可以将字典通过items和list函数强制转换为列表和元组的嵌套结构。例如：</p><pre name="badd" id="badd" class="graf graf--pre graf-after--p">dict = {&#39;a&#39;:1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:4}<br>list(dict.items())</pre><p name="26cb" id="26cb" class="graf graf--p graf-after--pre">得到输出：</p><pre name="515c" id="515c" class="graf graf--pre graf-after--p">[(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4)]</pre><p name="a08f" id="a08f" class="graf graf--p graf-after--pre">我们可以通过类似元组的方法遍历字典。例如：</p><pre name="f95b" id="f95b" class="graf graf--pre graf-after--p">for key, value in dict.items(): <br>    print(f&quot;{key} -&gt; {value})</pre><p name="0ef4" id="0ef4" class="graf graf--p graf-after--pre">得到输出：</p><pre name="357b" id="357b" class="graf graf--pre graf-after--p">a -&gt; 1 <br>b -&gt; 2 <br>c -&gt; 3 <br>d -&gt; 4</pre><p name="2245" id="2245" class="graf graf--p graf-after--pre">我们可以创建以元组为关键字的字典。例如：</p><pre name="860f" id="860f" class="graf graf--pre graf-after--p">dict = {(&#39;a&#39;,1): 10, (&#39;b&#39;,1): 20, (&#39;a&#39;,2): 30}</pre><p name="be5d" id="be5d" class="graf graf--p graf-after--pre">我们还可以创建以元组为值的字典。例如：</p><pre name="ab81" id="ab81" class="graf graf--pre graf-after--p">colors = {  &#39;orange&#39;: (255, 165, 0), <br>            &#39;yellow&#39;: (255, 255, 0), <br>            &#39;aqua&#39;: (0, 128, 128)     }</pre><p name="8c68" id="8c68" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">二、排序</strong></p><ol class="postList"><li name="0b00" id="0b00" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">基本的排序方法</strong></li></ol><p name="26a4" id="26a4" class="graf graf--p graf-after--li">Python内置了sorted函数，它可以将元素按照首字母A到z（大写排在小写前面）或者数字由小到大的顺序进行排序。sorted函数返回的结果是排序后的结果，但是原来的列表本身元素顺序是不会改变的。例如：</p><pre name="8093" id="8093" class="graf graf--pre graf-after--p">nums = [8, 42, 4, 8, 15, 16]<br>sorted(nums)               # [4, 8, 8, 15, 16, 42]<br>nums                       # [8, 42, 4, 8, 15, 16]</pre><p name="fbfa" id="fbfa" class="graf graf--p graf-after--pre">另外，</p><pre name="5b4d" id="5b4d" class="graf graf--pre graf-after--p">strs = [&#39;banana&#39;, &#39;zebra&#39;, &#39;apple&#39;, &#39;donut&#39;]<br>sorted(strs)</pre><p name="d119" id="d119" class="graf graf--p graf-after--pre">得到输出：</p><pre name="a7cb" id="a7cb" class="graf graf--pre graf-after--p">[&#39;apple&#39;, &#39;banana&#39;, &#39;donut&#39;, &#39;zebra&#39;]</pre><p name="3112" id="3112" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. 反向排序</strong></p><p name="4e0d" id="4e0d" class="graf graf--p graf-after--p">我们可以通过设置sorted函数中的reverse数值，令其等于True，就可以得到列表的反向排序输出。例如：</p><pre name="47a4" id="47a4" class="graf graf--pre graf-after--p">nums = [8, 42, 4, 8, 15, 16]<br>sorted(nums, reverse=True)</pre><p name="b968" id="b968" class="graf graf--p graf-after--pre">得到输出：</p><pre name="5537" id="5537" class="graf graf--pre graf-after--p">[42, 16, 15, 8, 8, 4]</pre><p name="b7eb" id="b7eb" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. 自定义函数排序</strong></p><p name="b176" id="b176" class="graf graf--p graf-after--p">通过设置key参数，我们可以指定排序方法为按某个函数的返回值进行排序。例如：</p><pre name="b882" id="b882" class="graf graf--pre graf-after--p">def get_len(s): <br>    return len(s) </pre><pre name="ab96" id="ab96" class="graf graf--pre graf-after--pre">def main(): <br>    strs = [&#39;a&#39;, &#39;bbbb&#39;, &#39;cc&#39;, &#39;zzzz&#39;] <br>    sorted_strs = sorted(strs, key=get_len) <br>    print(sorted_strs)</pre><p name="1382" id="1382" class="graf graf--p graf-after--pre">得到输出：</p><pre name="8e49" id="8e49" class="graf graf--pre graf-after--p">[&#39;a&#39;, &#39;cc&#39;, &#39;bbbb&#39;, &#39;zzzz&#39;]</pre><p name="c532" id="c532" class="graf graf--p graf-after--pre">4. 总结</p><p name="f965" id="f965" class="graf graf--p graf-after--p">下面是一个示例代码，总结并且对比了上面几种排序方法。例如：</p><pre name="c5d6" id="c5d6" class="graf graf--pre graf-after--p">def get_count(food): <br>    return food[1] </pre><pre name="3bc7" id="3bc7" class="graf graf--pre graf-after--pre">def main(): <br>    foods = [(&#39;apple&#39;, 5), (&#39;banana&#39;, 2), (&#39;chocolate&#39;, 137)] <br>    sort_names = sorted(foods) <br>    print(sort_names) </pre><pre name="ef58" id="ef58" class="graf graf--pre graf-after--pre">    sort_count = sorted(foods, key=get_count) <br>    print(sort_count) </pre><pre name="bb17" id="bb17" class="graf graf--pre graf-after--pre">    rev_sort_count = sorted(foods, key=get_count, reverse=True)<br>    print(rev_sort_count)</pre><p name="b04f" id="b04f" class="graf graf--p graf-after--pre">得到输出为：</p><pre name="3085" id="3085" class="graf graf--pre graf-after--p graf--trailing">[(&#39;apple&#39;, 5), (&#39;banana&#39;, 2), (&#39;chocolate&#39;, 137)] <br>[(&#39;banana&#39;, 2), (&#39;apple&#39;, 5), (&#39;chocolate&#39;, 137)] <br>[(&#39;chocolate&#39;, 137), (&#39;apple&#39;, 5), (&#39;banana&#39;, 2)]</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/c7b84c136865"><time class="dt-published" datetime="2020-08-18T08:49:47.594Z">August 18, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A17-%E5%85%83%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F-c7b84c136865" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>