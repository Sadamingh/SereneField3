<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Video Game Design 7 | Introduction to Game AI</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Video Game Design 7 | Introduction to Game AI</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Video Game Design
</section>
<section data-field="body" class="e-content">
<section name="b842" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8c2d" id="8c2d" class="graf graf--h3 graf--leading graf--title">Video Game Design 7 | Introduction to Game AI</h3><figure name="0b90" id="0b90" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*g1QhYITpnVqCG_pb.png" data-width="1216" data-height="672" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*g1QhYITpnVqCG_pb.png"></figure><ol class="postList"><li name="630c" id="630c" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">AI Movement and Steering Behaviors</strong></li></ol><p name="f0fc" id="f0fc" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Chase/Evade Pattern</strong></p><p name="2b45" id="2b45" class="graf graf--p graf-after--p">A common behavior pattern for the game AI is the chase/evade pattern. Suppose there are two characters in the game, the NPC and the User Controlled one.</p><ul class="postList"><li name="8e63" id="8e63" class="graf graf--li graf-after--p">NPC: predator</li><li name="e4ed" id="e4ed" class="graf graf--li graf-after--li">User Control: prey</li></ul><figure name="6d7a" id="6d7a" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*AnzRHc9GX065oyR8nWx_1Q.png" data-width="1552" data-height="556" src="https://cdn-images-1.medium.com/max/800/1*AnzRHc9GX065oyR8nWx_1Q.png"></figure><p name="0d86" id="0d86" class="graf graf--p graf-after--figure">So now, we have to figure out the algorithm of the predator.</p><p name="0f39" id="0f39" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Direction and Distance</strong></p><p name="37e8" id="37e8" class="graf graf--p graf-after--p">To detect the position of prey, it is basically just leveraging the aspects of linear algebra.</p><ul class="postList"><li name="e053" id="e053" class="graf graf--li graf-after--p">Relative Position Vector: The predator’s position vector subtract the prey’s position vector</li></ul><figure name="7ad1" id="7ad1" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*3lNZL0iz24mW1yuCdLQT_A.png" data-width="1280" data-height="90" src="https://cdn-images-1.medium.com/max/800/1*3lNZL0iz24mW1yuCdLQT_A.png"></figure><ul class="postList"><li name="1788" id="1788" class="graf graf--li graf-after--figure">Direction: Normalize the relative position vector</li></ul><figure name="5d9c" id="5d9c" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*vZwdJLNt8a-7CR8rt7oDEQ.png" data-width="1280" data-height="126" src="https://cdn-images-1.medium.com/max/800/1*vZwdJLNt8a-7CR8rt7oDEQ.png"></figure><ul class="postList"><li name="0fd4" id="0fd4" class="graf graf--li graf-after--figure">Distance: Modulus of the relative position vector</li></ul><figure name="ff51" id="ff51" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*bVWYobRzxJ7J8tuN3hwGIw.png" data-width="1280" data-height="146" src="https://cdn-images-1.medium.com/max/800/1*bVWYobRzxJ7J8tuN3hwGIw.png"></figure><p name="02bf" id="02bf" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) Types of Movements</strong></p><ul class="postList"><li name="6fa7" id="6fa7" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Simple Movement</strong>: Orient agent velocity in the target direction. This can be very aggressive and the behavior doesn’t look natural. This movement is usually used for grid movement.</li></ul><figure name="4f27" id="4f27" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*eV0tyCwWsBUQOMPmrzpNig.png" data-width="1536" data-height="268" src="https://cdn-images-1.medium.com/max/800/1*eV0tyCwWsBUQOMPmrzpNig.png"></figure><ul class="postList"><li name="52e6" id="52e6" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Steering Movement</strong>: This movement to animate turns towards the target. It will also adjust the speed (e.g. slower when close to the target) to make the behavior more realistic.</li></ul><figure name="df6b" id="df6b" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*6F33C5soWHwcNWey5GaRNQ.png" data-width="1536" data-height="318" src="https://cdn-images-1.medium.com/max/800/1*6F33C5soWHwcNWey5GaRNQ.png"></figure><p name="d7d9" id="d7d9" class="graf graf--p graf-after--figure">The steering movement can enhance the <strong class="markup--strong markup--p-strong">performance envelope</strong>, which means the behavior has constant acceleration and enforced max velocity for transactions and rotations.</p><ul class="postList"><li name="a4a6" id="a4a6" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Fleeing Movement</strong>: Simply calculate the opposite ordered position vector.</li></ul><figure name="93db" id="93db" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*gtBRQGhY3BAZaJ3OfhyoQA.png" data-width="1358" data-height="318" src="https://cdn-images-1.medium.com/max/800/1*gtBRQGhY3BAZaJ3OfhyoQA.png"></figure><p name="e6a6" id="e6a6" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Continuous Simulation</strong></p><p name="e280" id="e280" class="graf graf--p graf-after--p">Also, we have to be mindful of continuous simulation in the nature of frame-based animation. With respect to the Unity platform, we have to be mindful of the time component when updating the velocity and so on because they are updated in the update cycles.</p><figure name="29af" id="29af" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*QhStUwleoH8lmN0deyhCNw.png" data-width="1276" data-height="306" src="https://cdn-images-1.medium.com/max/800/1*QhStUwleoH8lmN0deyhCNw.png"></figure><p name="2027" id="2027" class="graf graf--p graf-after--figure">This brings us to the time dependency problem. We have talked about this problem before, and now let’s review it.</p><p name="c370" id="c370" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Time Dependency</strong></p><p name="4acb" id="4acb" class="graf graf--p graf-after--p">Time dependency is a problem that occurs because the frame rates in Unity demonstration are not constant. The <code class="markup--code markup--p-code">Update</code> function in the script is called once per frame, but the <code class="markup--code markup--p-code">FixedUpdate</code> function runs zero, once, or several times per frame based on how many physics frames per second are set in the time settings, and how fast or slow the frame rate is.</p><p name="2831" id="2831" class="graf graf--p graf-after--p">So to talk about its impact on the steering behavior, we used to think about using,</p><figure name="d568" id="d568" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*wwQ-eDEFqbafuuEpGb8LWA.png" data-width="1158" data-height="74" src="https://cdn-images-1.medium.com/max/800/1*wwQ-eDEFqbafuuEpGb8LWA.png"></figure><p name="7438" id="7438" class="graf graf--p graf-after--figure">Instead, we should use,</p><figure name="e04c" id="e04c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*FIP542wGDC-qxSxoTp8huw.png" data-width="1158" data-height="74" src="https://cdn-images-1.medium.com/max/800/1*FIP542wGDC-qxSxoTp8huw.png"></figure><p name="3670" id="3670" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) Prediction</strong></p><p name="f196" id="f196" class="graf graf--p graf-after--p">We can keep on adding more features on the steering based on more use cases. And one feature we can add to the agent is the prediction of the target. Actually, there’s no need to calculate the precise intercept of the target because the target keeps moving and we will recalculate the prediction every frame. The calculation should be as follows,</p><ul class="postList"><li name="17d9" id="17d9" class="graf graf--li graf-after--p">Distance: <code class="markup--code markup--li-code">Dist = (target.pos — agent.pos).Length()</code></li><li name="a277" id="a277" class="graf graf--li graf-after--li">lookAheadT: <code class="markup--code markup--li-code">lookAheadT = Dist/agent.maxSpeed</code></li><li name="0bf1" id="0bf1" class="graf graf--li graf-after--li">futureTarget: <code class="markup--code markup--li-code">futureTarget = target.pos + lookAheadT * target.velocity</code></li></ul><figure name="223f" id="223f" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*bVr47Qk2KjE-7_U14txzgw.png" data-width="1148" data-height="384" src="https://cdn-images-1.medium.com/max/800/1*bVr47Qk2KjE-7_U14txzgw.png"></figure><p name="cc3a" id="cc3a" class="graf graf--p graf-after--figure">There are also some traps for the prediction method,</p><ul class="postList"><li name="c9ac" id="c9ac" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Extreme Predictions</strong>: very large lookahead <em class="markup--em markup--li-em">t</em> values</li><li name="9db5" id="9db5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Outta Map or Inside Obstacle Predictions</strong>: Could be spending your agent off the map or result in odd behavior. One solution for this is to clamp maximum map prediction, and the other one for this is to clip extrapolated future positions to fit on the map.</li></ul><p name="5e4f" id="5e4f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Zero or Small Vector Problem</strong></p><p name="2764" id="2764" class="graf graf--p graf-after--p">When the relative position vector <strong class="markup--strong markup--p-strong">AB</strong> is small or zero, we can get some undesired behaviors. Consider the situation of a vector normalization operation, the vector can become messier because the modulus of the vector is relatively small or zero. So we should be mindful about where the divided by zero problems crop up.</p><p name="67dc" id="67dc" class="graf graf--p graf-after--p">There are some solutions to this problem:</p><ul class="postList"><li name="ee9f" id="ee9f" class="graf graf--li graf-after--p">Hold the current head and speed or perhaps a buffered sliding average of the last several measures</li><li name="5c1b" id="5c1b" class="graf graf--li graf-after--li">Add a condition to decide upon an alternative steering strategy, for example, a state machine state transition that we will talk about later.</li></ul><p name="6a50" id="6a50" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) Static Targets Problems</strong></p><ul class="postList"><li name="12e6" id="12e6" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Stopping Radius</strong>: Another scenario that we have here is arriving at static targets. If you are heading towards a target and you want to stop right on the target, you may not be able to do that based on a realistic performance envelope. So you actually need to detect when you are within a <strong class="markup--strong markup--li-strong">stopping radius</strong> (r). You are able to have the full speed outside the stopping radius. And the stopping radius is actually used for decreasing the velocity by distance from max to 0, abiding by maximum deceleration possible.</li><li name="6b59" id="6b59" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Orbit Problem</strong>: If you are not planning on having your agent stop at the target, then what you need to do is to determine what the orbit radius is. Then the agent has to make a change to its current maximum term rate and its maximum forward velocity. They will just indefinitely orbit so the radius is easy to calculate.</li></ul><p name="b529" id="b529" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(9) Obstacle Avoidance</strong></p><p name="a863" id="a863" class="graf graf--p graf-after--p">Next up, we will introduce a little bit of some other concepts to make our steering behavior agent more effective. So what we can do is to perform obstacle avoidance. This requires some sort of look-ahead window and generally, the simplest case is a raycast in the forward direction of the agent.</p><figure name="06b5" id="06b5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qtu-mA6ORo0ZPFhV6kgJ1Q.png" data-width="1188" data-height="268" src="https://cdn-images-1.medium.com/max/800/1*qtu-mA6ORo0ZPFhV6kgJ1Q.png"></figure><p name="e32c" id="e32c" class="graf graf--p graf-after--figure">There are different probabilities for improvements of adding additional raycasts. The following diagram shows some patterns of the ray casts.</p><figure name="34b8" id="34b8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WQsKDsRrjG3shTzhM9-4Ag.png" data-width="1620" data-height="402" src="https://cdn-images-1.medium.com/max/800/1*WQsKDsRrjG3shTzhM9-4Ag.png"></figure><p name="3591" id="3591" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(10) Wandering</strong></p><p name="935f" id="935f" class="graf graf--p graf-after--p">Another behavior that we would like to mention here is wandering. This is useful for non-player characters that are not violent. So maybe like someone in a town or in a role-playing game, you just want them to wander around aimlessly but not look unnatural. So rather than adding a random vector periodically to the agent, this approach works by placing an invisible wander radius ring in front of the agent (sort of like a carrot).</p><figure name="6c5d" id="6c5d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*glqmbQd85JYcecgAxEfaMg.png" data-width="1626" data-height="310" src="https://cdn-images-1.medium.com/max/800/1*glqmbQd85JYcecgAxEfaMg.png"></figure><p name="67ea" id="67ea" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(11) Combination of Steering Behaviors</strong></p><p name="2694" id="2694" class="graf graf--p graf-after--p">Sometimes we may have multiple steering goals, and the best approach to it is to use a combination of steering behaviors. Generally speaking, there are two kinds of combination,</p><ul class="postList"><li name="2b99" id="2b99" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Simple Sum</strong>: we have to enforce the maximum speed</li><li name="92a3" id="92a3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Weighted Sum</strong>: weights can be based on some metrics like distance</li></ul><figure name="10e5" id="10e5" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*kBGcAnh8SB2x-i0Ulz9FZg.png" data-width="1284" data-height="460" src="https://cdn-images-1.medium.com/max/800/1*kBGcAnh8SB2x-i0Ulz9FZg.png"></figure><p name="282b" id="282b" class="graf graf--p graf-after--figure">However, there are some examples when things fall apart when you implement the combined steering behaviors, especially for the situation that the <strong class="markup--strong markup--p-strong">enemy runs behind an obstacle</strong>. The pursuing velocity combined with the wall avoidance velocity may generate some unwanted behaviors like detours. One solution to this situation may be that we don’t have to combine these steers at the same time. The agent has to make some higher-level decisions, and rather than continue to track the enemy from right to left and turning, it would be head just to the right of the obstacle until passing the obstacle. Then, they will have no worry about the turning.</p><figure name="e6e1" id="e6e1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0XSvuQzWW-_SVoWNP1k9uw.png" data-width="1440" data-height="460" src="https://cdn-images-1.medium.com/max/800/1*0XSvuQzWW-_SVoWNP1k9uw.png"></figure><p name="0e94" id="0e94" class="graf graf--p graf-after--figure">In the extreme situation, if the steering behaviors are totally opposite, you may result in a zero or small vector, which we have discussed above. One result is that the agent can go back and forth forever, or it will be orbiting forever. We need higher-level control logic to deal with this problem.</p><p name="0228" id="0228" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(12) Motion Table for Blended Root Motion</strong></p><p name="e6ef" id="e6ef" class="graf graf--p graf-after--p">So how can the agent select animation blend parameters that best direct its movement towards the steering target? Ultimately, what we need to do is to select animation parameters that will cause these different animation blends, and then the result is the root motion moment to release the frame. We could fit a function, but this solution becomes difficult for higher-order functions. Or we could create a lookup table. Finally, we can use this table to find animation parameters with the closest root motion to the steering target.</p><p name="bec3" id="bec3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(13) Ballistic Projectile Aiming</strong></p><p name="3d3c" id="3d3c" class="graf graf--p graf-after--p">Then, let’s discuss the topic of ballistic projectile aiming. This is a sort of behavior related to steering behaviors but it’s not exactly the same sort of issue. It is probably closest to prediction as we have discussed so far, but this is where we have non-instantaneous projectiles. So, it is not just like a raycast that hits you and makes you know that you have a hit. This is more like you have fired a cannonball thrown a grenade. The agent is probably running very fast, but it can not turn that fast. So the simplest solution is that we will use some predictions on that, but we can also try some iterative techniques like Newton’s method.</p><p name="07b3" id="07b3" class="graf graf--p graf-after--p">We will skip some of the calculations here and we will see how we can implement them later. We can actually solve this problem with/without accelerations.</p><ul class="postList"><li name="3d15" id="3d15" class="graf graf--li graf-after--p">Without Accelerations: Law of cosines</li><li name="6a35" id="6a35" class="graf graf--li graf-after--li">With Accelerations: Simple iterative approach</li></ul><p name="4428" id="4428" class="graf graf--p graf-after--li">Sometimes, the agent may be able to throw a ballistic to the target, and this lobbed projectile can bypass the obstacles in between. To implement this, we have to consider the ballistic trajectory and predict the lobbed projectile collisions. The parabola should be divided into line segments, and we have to do a raycast for each segment.</p><p name="f16f" id="f16f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(14) Perceptual Models</strong></p><p name="94a5" id="94a5" class="graf graf--p graf-after--p">When considering the implementation of an agent, another important thing to think about is the fairness issue. Because the agent can do things that are beyond the human’s ability, for example, they can know you behind an obstacle even if you are being extra careful and quiet, the players don’t think that is fair.</p><p name="4f6a" id="4f6a" class="graf graf--p graf-after--p">One solution to this is that we strictly restrict the access to information of an agent according to what you think that the agent could reasonably perceive or at least what your gameplay audience has expectations. We can add some constraints on,</p><ul class="postList"><li name="3d83" id="3d83" class="graf graf--li graf-after--p">Vision: introduce a distance restriction so that the agent can only see so far</li><li name="84af" id="84af" class="graf graf--li graf-after--li">Field of view: introduce a direction or a forward vector of the agent’s head so that the agent can only view the target it is facing towards</li><li name="8cb1" id="8cb1" class="graf graf--li graf-after--li">Single raycast from eyes: the single raycast from the eyes of the agent really enhance the realism of the game</li><li name="d1e5" id="d1e5" class="graf graf--li graf-after--li">Consider sounds: the agent can be aware of the audio events generated</li><li name="01d4" id="01d4" class="graf graf--li graf-after--li">Focus range: the agent can only pay attention to some of the objects in the field of view and then make react to them</li></ul><figure name="7107" id="7107" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*b0H25xNhPKutPe8OoGrq7A.png" data-width="1410" data-height="502" src="https://cdn-images-1.medium.com/max/800/1*b0H25xNhPKutPe8OoGrq7A.png"></figure><ul class="postList"><li name="e126" id="e126" class="graf graf--li graf-after--figure">Vague directions for projectiles: if we have some exact projectiles towards the players, the situation can be too challenging for the game players. The negative thing is that it is also quite simple to make some AI helper in your game to make all sorts of things unfair. Probably, we have to make sense to human players by enhancing the Gaussian distribution, and we can also model a reaction time for recognizing.</li></ul><figure name="1320" id="1320" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*OozqSnie56DhlUiXpvX6dQ.png" data-width="1316" data-height="382" src="https://cdn-images-1.medium.com/max/800/1*OozqSnie56DhlUiXpvX6dQ.png"></figure><p name="e0bf" id="e0bf" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">3. Path Planning</strong></p><p name="1676" id="1676" class="graf graf--p graf-after--p">Now, let’s see something about path planning. Path planning is a way we can extend the sort of behavior of our agent. We will still use our steering behaviors, but when we generate a path, the agent will be able to follow.</p><p name="628a" id="628a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Graphics</strong></p><p name="d270" id="d270" class="graf graf--p graf-after--p">Before we start, let’s review some tools that can be used to facilitate searching. You have to be familiar with the following concepts,</p><ul class="postList"><li name="21aa" id="21aa" class="graf graf--li graf-after--p">Graph</li><li name="c8b5" id="c8b5" class="graf graf--li graf-after--li">Node</li><li name="3475" id="3475" class="graf graf--li graf-after--li">Edge</li><li name="fbf9" id="fbf9" class="graf graf--li graf-after--li">Cost/Weight</li></ul><p name="a998" id="a998" class="graf graf--p graf-after--li">If you have any problems with these concepts, you can refer to the following article for more information.</p><div name="4661" id="4661" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/adamedelwiess/linear-algebra-11-graph-theory-fundamentals-random-walk-problem-laplacian-matrix-and-pagerank-27c5962901b3" data-href="https://medium.com/adamedelwiess/linear-algebra-11-graph-theory-fundamentals-random-walk-problem-laplacian-matrix-and-pagerank-27c5962901b3" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/adamedelwiess/linear-algebra-11-graph-theory-fundamentals-random-walk-problem-laplacian-matrix-and-pagerank-27c5962901b3"><strong class="markup--strong markup--mixtapeEmbed-strong">Linear Algebra 11 | Graph Theory Fundamentals, Random Walk Problem, Laplacian Matrix, and PageRank</strong><br><em class="markup--em markup--mixtapeEmbed-em">Series: Linear Algebra</em>medium.com</a><a href="https://medium.com/adamedelwiess/linear-algebra-11-graph-theory-fundamentals-random-walk-problem-laplacian-matrix-and-pagerank-27c5962901b3" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a631619dad036b1f26e08e4bbf5a4143" data-thumbnail-img-id="1*Yj4DEKztkbPyDrnciYX9dQ.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*Yj4DEKztkbPyDrnciYX9dQ.jpeg);"></a></div><p name="739c" id="739c" class="graf graf--p graf-after--mixtapeEmbed"><strong class="markup--strong markup--p-strong">(2) Types of Graphics</strong></p><p name="6f58" id="6f58" class="graf graf--p graf-after--p">The graphics really vary in the challenge we have for that graph. Some of the types are,</p><ul class="postList"><li name="d235" id="d235" class="graf graf--li graf-after--p">Directed acyclic graph</li><li name="ad70" id="ad70" class="graf graf--li graf-after--li">Directed cycle graph</li><li name="071f" id="071f" class="graf graf--li graf-after--li">Undirected graph</li><li name="0400" id="0400" class="graf graf--li graf-after--li">Binary tree</li><li name="91f1" id="91f1" class="graf graf--li graf-after--li">Digraph</li></ul><p name="0a72" id="0a72" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Examples of Graphics</strong></p><ul class="postList"><li name="a0da" id="a0da" class="graf graf--li graf-after--p">Risk: In the game Risk, we have a graph that is the map for players to move across.</li></ul><figure name="4bbf" id="4bbf" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*3BJGpwLnz9Iq658TRv5nNg.png" data-width="1542" data-height="600" src="https://cdn-images-1.medium.com/max/800/1*3BJGpwLnz9Iq658TRv5nNg.png"></figure><ul class="postList"><li name="e999" id="e999" class="graf graf--li graf-after--figure">Civilization: In the Civilization games, we do have a technology tree for interpreting primitive technologies and advanced technologies. This tree is called an RTS dependency tree.</li></ul><figure name="1488" id="1488" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*phDMAmZerOljpvWoRhuGZw.png" data-width="1542" data-height="584" src="https://cdn-images-1.medium.com/max/800/1*phDMAmZerOljpvWoRhuGZw.png"></figure><ul class="postList"><li name="533c" id="533c" class="graf graf--li graf-after--figure">Zelda: In some of the Zelda games, the graph is in the form of a grid and it is based on sprite tiles.</li></ul><figure name="a18f" id="a18f" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*_JzKfaPs_Qn1zrrKbVJjcQ.png" data-width="1542" data-height="584" src="https://cdn-images-1.medium.com/max/800/1*_JzKfaPs_Qn1zrrKbVJjcQ.png"></figure><ul class="postList"><li name="47a8" id="47a8" class="graf graf--li graf-after--figure">Door: In the Door game, you have to identify which are the rooms and where are the doorways connecting the rooms. This allows you to place nodes at some coordinate in the game and then define edges based on the room adjacency.</li></ul><figure name="2fd6" id="2fd6" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*6NhjzY_QrMNxJUA_NqWr-w.png" data-width="1732" data-height="428" src="https://cdn-images-1.medium.com/max/800/1*6NhjzY_QrMNxJUA_NqWr-w.png"></figure><p name="6c3c" id="6c3c" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) The Definition of Planning</strong></p><p name="a316" id="a316" class="graf graf--p graf-after--p">The plan is a series of pre-decisions before we accomplish a goal. We need to have,</p><ul class="postList"><li name="0758" id="0758" class="graf graf--li graf-after--p">Goal: a goal state</li><li name="644c" id="644c" class="graf graf--li graf-after--li">World: a set of <strong class="markup--strong markup--li-strong">states</strong></li><li name="faf6" id="faf6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Operators</strong>: an operator changes configuration from one state to another state</li></ul><p name="f1e5" id="f1e5" class="graf graf--p graf-after--li">As it is defined, a plan is a part of the intelligence. So in terms of intelligence planning, we need to have some notion of the current state of the problem, and we need to have some notion of what the state of the problem would look like if we have a solution.</p><p name="4dd7" id="4dd7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) The Definition of Path Planning</strong></p><p name="d6ff" id="d6ff" class="graf graf--p graf-after--p">Plan planning is one kind of intelligence planning. It has,</p><ul class="postList"><li name="e76a" id="e76a" class="graf graf--li graf-after--p">Current State: current location of the agent in the space</li><li name="76f0" id="76f0" class="graf graf--li graf-after--li">Operators: planned movements of the agent</li><li name="515d" id="515d" class="graf graf--li graf-after--li">World: discretized space such as tiles in a tile-based game, floor locations in 3D, voxels, waypoints, navigation mesh, and so on</li><li name="1dd6" id="1dd6" class="graf graf--li graf-after--li">Goal State: move the agent somewhere</li></ul><p name="6e3e" id="6e3e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) Planning Algorithms Metrics</strong></p><p name="b19b" id="b19b" class="graf graf--p graf-after--p">Provided the discretized world and came up with a state representation with that discretized model, you will then apply an algorithm that will search through all the different possibilities of operators being applied to the current state. Then we might go about implementing some algorithm to do this. To find the proper algorithm, we are binding to some metrics,</p><ul class="postList"><li name="b644" id="b644" class="graf graf--li graf-after--p">Time Complexity: How long does it take to find the answer?</li><li name="105d" id="105d" class="graf graf--li graf-after--li">Space Complexity: How much memory do we need to find the answer?</li><li name="f024" id="f024" class="graf graf--li graf-after--li">Completeness: will it find the answer if there’s only one answer exists?</li><li name="236b" id="236b" class="graf graf--li graf-after--li">Optimizations: will it find the best solution if there’s more than one solution?</li></ul><p name="367e" id="367e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Search Strategies</strong></p><p name="be9d" id="be9d" class="graf graf--p graf-after--p">In terms of search strategies, there are two kinds of solutions that we can probably take.</p><ul class="postList"><li name="a6cc" id="a6cc" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Blind Search</strong>: no assumptions of the graph and no domain knowledge. The only thing we know is the goal state.</li><li name="72c3" id="72c3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Heuristic Search</strong>: there is some domain knowledge (e.g. spatial relationships) that we may leverage by heuristic rules. For video games, there is always some domain knowledge we can get.</li></ul><p name="db7f" id="db7f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) Breadth-First Search (BFS)</strong></p><p name="9b34" id="9b34" class="graf graf--p graf-after--p">Breadth-first search (BFS) is an algorithm for searching a tree data structure for a node that satisfies a given property. It starts at the tree root and explores all nodes at the present depth prior to moving on to the nodes at the next depth level. The algorithm should be,</p><ul class="postList"><li name="a3d3" id="a3d3" class="graf graf--li graf-after--p">Expand the root node, search</li><li name="0ef0" id="0ef0" class="graf graf--li graf-after--li">Expand all root node’s children, search</li><li name="0d8f" id="0d8f" class="graf graf--li graf-after--li">Expand all root node’s grandchildren, search</li><li name="425c" id="425c" class="graf graf--li graf-after--li">Continue</li></ul><figure name="966f" id="966f" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*tga0zvA3poHZvsw3.gif" data-width="187" data-height="175" src="https://cdn-images-1.medium.com/max/800/0*tga0zvA3poHZvsw3.gif"></figure><p name="75d4" id="75d4" class="graf graf--p graf-after--figure">This algorithm is problematic if we have,</p><ul class="postList"><li name="3f68" id="3f68" class="graf graf--li graf-after--p">Varying weight edges</li><li name="a33f" id="a33f" class="graf graf--li graf-after--li">Small memory</li></ul><p name="5a25" id="5a25" class="graf graf--p graf-after--li">Here, you can see the outcome of this algorithm.</p><figure name="eb5b" id="eb5b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*pg48LRafkAXrBfzf8QOZQA.png" data-width="1400" data-height="448" src="https://cdn-images-1.medium.com/max/800/1*pg48LRafkAXrBfzf8QOZQA.png"></figure><p name="9f5e" id="9f5e" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(9) Depth-First Search</strong></p><p name="4c79" id="4c79" class="graf graf--p graf-after--p">Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.</p><ul class="postList"><li name="57d8" id="57d8" class="graf graf--li graf-after--p">Expand the root node, search</li><li name="d785" id="d785" class="graf graf--li graf-after--li">Expand the node deepest in the tree, and if there’s no deepest node in the tree, then find the most left one, then search.</li><li name="1051" id="1051" class="graf graf--li graf-after--li">Loop</li></ul><figure name="6620" id="6620" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*ED-pwWYwDl7OMQwN.jpg" data-width="320" data-height="225" src="https://cdn-images-1.medium.com/max/800/0*ED-pwWYwDl7OMQwN.jpg"></figure><p name="44d6" id="44d6" class="graf graf--p graf-after--figure">This algorithm is problematic if we have,</p><ul class="postList"><li name="732a" id="732a" class="graf graf--li graf-after--p">Requirements for optimizations because we may end up searching the whole tree</li><li name="9f35" id="9f35" class="graf graf--li graf-after--li">Very silly behavior for an agent. You may find it out from the following outcome because it nearly searched the whole map.</li></ul><figure name="1021" id="1021" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*pXeEIEJodI5IXK-vUR2Llg.png" data-width="1416" data-height="446" src="https://cdn-images-1.medium.com/max/800/1*pXeEIEJodI5IXK-vUR2Llg.png"></figure><p name="0e5e" id="0e5e" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(10) Pathfinding Examples</strong></p><p name="ed37" id="ed37" class="graf graf--p graf-after--p">There are still some problems with pathfinding. Here is a video showing what’s going on in modern games.</p><figure name="acbb" id="acbb" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://www.youtube.com/embed/dobDQQivhCU?feature=oembed" width="640" height="480" frameborder="0" scrolling="no"></iframe></figure><p name="a32d" id="a32d" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(11) Path Planning for Tile-Based Games</strong></p><p name="4688" id="4688" class="graf graf--p graf-after--p">Tile-based games are quite common with path planning. These games tend to have discrete locations where there is an agent or an object occupying a cell and then move to another with some atomic discrete movements. You will also occasionally see a tile-based discretized representation where the agents move in a continuous way. So in summary, tile-based games usually have 1-to-1 coordination of path-planning graph and simulation space. And the AIs exist in discrete locations.</p><p name="5c16" id="5c16" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(12) Path Planning for Grid Navigation</strong></p><p name="449f" id="449f" class="graf graf--p graf-after--p">Commonly, games with grid navigation have 2D tile representations of squares (means 4 to 8 connectivity) or hex (means 6-way connectivity). They often enforce one unit per cell and each cell has a terrain type. We usually don’t have a graph data structure for this type. Instead, we have the grid itself that will implicitly define how we find the path.</p><p name="8e78" id="8e78" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(13) Path Planning for Continuous Space</strong></p><p name="274f" id="274f" class="graf graf--p graf-after--p">A more complicated situation is that we can hardly do path planning as a graph if we have a continuous space. So we might wish to generate a grid or some other discretized spaces as well. When we do have these issues of generating a discretized space, we have issues of,</p><ul class="postList"><li name="17ac" id="17ac" class="graf graf--li graf-after--p">Validity</li><li name="9b1c" id="9b1c" class="graf graf--li graf-after--li">Quantization</li><li name="5841" id="5841" class="graf graf--li graf-after--li">Localization</li><li name="cbca" id="cbca" class="graf graf--li graf-after--li">Agent Movement</li><li name="41c4" id="41c4" class="graf graf--li graf-after--li">Search Efficiency</li></ul><p name="7cd1" id="7cd1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(14) Discretization Generation: Grid Lattice</strong></p><p name="c0e1" id="c0e1" class="graf graf--p graf-after--p">In terms of generating, we need to determine boundaries and terrain type regions, and also these transitions across the terrain. Grid lattice is the common solution and we might have arbitrary polygonal geometry. From that, we need to figure out which cells can we traverse to.</p><figure name="e68a" id="e68a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OVWOYXDQQvdBAp0TiEbMzA.png" data-width="1578" data-height="414" src="https://cdn-images-1.medium.com/max/800/1*OVWOYXDQQvdBAp0TiEbMzA.png"></figure><p name="a083" id="a083" class="graf graf--p graf-after--figure">Besides, there are some scenarios we should notice when generating the grids. So we should verify,</p><ul class="postList"><li name="3a9a" id="3a9a" class="graf graf--li graf-after--p">world boundaries don’t go through grid lines</li><li name="3b41" id="3b41" class="graf graf--li graf-after--li">no obstacle point within a grid cell, or vice versa</li><li name="2bbd" id="2bbd" class="graf graf--li graf-after--li">obstacle edges do not intersect grid cell edge</li></ul><figure name="bcbe" id="bcbe" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*rHoGSqRrtEvsUq2i_R8ITQ.png" data-width="1578" data-height="352" src="https://cdn-images-1.medium.com/max/800/1*rHoGSqRrtEvsUq2i_R8ITQ.png"></figure><p name="c2b7" id="c2b7" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(15) Discretization Generation Issues</strong></p><ul class="postList"><li name="db42" id="db42" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Validity</strong>: Suppose A and B are nodes in a discretized space. From any points in node A, can an agent travel in a straight line to any point in adjacent node B? The validity issue really has to do with whether you can move from any point in a discretized area to an adjacent discretized area that is in one of those locations as well.</li><li name="6c0d" id="6c0d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Off-Grid</strong>: this issue is what to do if an AI entity is off a navigable grid cell? The solution may probably be some random movement and physics engine to slide or bump around and hopefully, this eventually gets to a valid position. Or if the game player isn’t looking, we can just cheat a teleport!</li><li name="d84b" id="d84b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Continuous Position Vs. Discrete Graph Path</strong>: Another issue is the discrete path because of the generated grids. Because the agent follows the discrete pathing plan, it will have awkward and blocky movement which is kind of weird and not natural. Just as the illustration in the following picture, the path we want is actually the green one, however, the one we may finally have is the blue one. However, there are basically two solutions, and we can either do a pre-process or a post-process (aka. string pulling) depending on our perspective.</li></ul><figure name="0a50" id="0a50" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*AB_fEEb7LMqzgcnQ6ToqBg.png" data-width="1630" data-height="498" src="https://cdn-images-1.medium.com/max/800/1*AB_fEEb7LMqzgcnQ6ToqBg.png"></figure><p name="543b" id="543b" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(17) Post Process</strong></p><p name="8399" id="8399" class="graf graf--p graf-after--p">The post-process is also called the string-pulling. In the beginning, we may generate some rectangular paths, but then we can clean them up. This method was firstly discussed in the paper <a href="https://www.aaai.org/Papers/Symposia/Spring/2000/SS-00-02/SS00-02-004.pdf" data-href="https://www.aaai.org/Papers/Symposia/Spring/2000/SS-00-02/SS00-02-004.pdf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">Warp Speed: Path Planning for Star Trek®: Armada</em></a> in 2000. And let’s see figure 3 and figure 5 in this paper for how this works,</p><figure name="4465" id="4465" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*UEnp5V1rGzeMvHF-fuXHuQ.png" data-width="1616" data-height="588" src="https://cdn-images-1.medium.com/max/800/1*UEnp5V1rGzeMvHF-fuXHuQ.png"></figure><p name="f0ce" id="f0ce" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(18) Heuristic Greedy Best-First Search</strong></p><p name="3e36" id="3e36" class="graf graf--p graf-after--p">The search efficiency for a <strong class="markup--strong markup--p-strong">grid search</strong> is terrible and the search spaces can quickly become huge if we have a bigger map.</p><p name="dd99" id="dd99" class="graf graf--p graf-after--p">So in terms of searches, we might introduce some heuristic (aka. knowledge of the world or some domain knowledge). The easiest way to do that in video games is to consider how close we are to the target. This method is actually called the <strong class="markup--strong markup--p-strong">simple greedy search</strong> in which we only expand the nodes that yield the minimum cost. However, there are two issues with this method. First, this algorithm is not complete. Second, greedy means the working solution is not revised, but revisiting the nodes may be beneficial.</p><p name="94ee" id="94ee" class="graf graf--p graf-after--p">Another heuristic is that we can expand nodes closest to the goal first. This is called the <strong class="markup--strong markup--p-strong">heuristic greedy best-first search</strong>. In this case, when we hit a dead-end, the algorithm doesn’t give up. Instead, it will backtrack and head down to the actual goal.</p><figure name="f3ee" id="f3ee" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*C0WqV06aaRimm-rLw_3sJQ.png" data-width="1496" data-height="402" src="https://cdn-images-1.medium.com/max/800/1*C0WqV06aaRimm-rLw_3sJQ.png"></figure><p name="0086" id="0086" class="graf graf--p graf-after--figure">Also, from the following outcome, we can tell that this algorithm has a better performance than DFS and BFS.</p><figure name="f700" id="f700" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XZY__h5I7sV1MngwzfFgIA.png" data-width="1512" data-height="508" src="https://cdn-images-1.medium.com/max/800/1*XZY__h5I7sV1MngwzfFgIA.png"></figure><p name="a930" id="a930" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(19) Dijkstra’s Algorithm</strong></p><p name="9e9d" id="9e9d" class="graf graf--p graf-after--p">Dijkstra’s algorithm for path searching is actually the weighted-graph version of BFS. It considers the cost of different paths, but BFS simply treats all the edges with the same weight. When all the edges have the same cost, Dijkstra’s algorithm should be exactly the same as BFS. In BFS, we simply have a FIFO model with nodes expanded from left to right in the same layer. However, in Dijkstra’s algorithm, the node with the lowest cost would be expanded first.</p><figure name="3712" id="3712" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*oxXyBbqKK40NSzNGI9yIkg.png" data-width="1564" data-height="548" src="https://cdn-images-1.medium.com/max/800/1*oxXyBbqKK40NSzNGI9yIkg.png"></figure><p name="e62b" id="e62b" class="graf graf--p graf-after--figure">Here, we can find out the outcome of this algorithm is the same as BFS because all the edges have the same cost.</p><figure name="4801" id="4801" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-lzNqgBxBuPX2r2bO62tow.png" data-width="1366" data-height="532" src="https://cdn-images-1.medium.com/max/800/1*-lzNqgBxBuPX2r2bO62tow.png"></figure><p name="fd24" id="fd24" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(20) A* Search</strong></p><p name="7062" id="7062" class="graf graf--p graf-after--p">A* search is actually a combination of the heuristic greedy best-first search and Dijkstra’s algorithm. For greedy best-first search, we tend to expand the node that is closest to the target first. For Dijkstra’s, we tend to expand the node with the minimum cost. The A* algorithm combines these two approaches for pathfinding.</p><figure name="1825" id="1825" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IZ-dhsBE9B0mEDnl8ZeqNw.png" data-width="1360" data-height="166" src="https://cdn-images-1.medium.com/max/800/1*IZ-dhsBE9B0mEDnl8ZeqNw.png"></figure><p name="6ec4" id="6ec4" class="graf graf--p graf-after--figure">Here the heuristic part can be any heuristic algorithm. A common heuristic is an Euclidean distance. This is a complete algorithm and it fails only if there’s no solution.</p><p name="753e" id="753e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(21) Pathfinding List</strong></p><p name="876d" id="876d" class="graf graf--p graf-after--p">In terms of implementing the algorithms, we do need some implementing structures like sorted list, sorted list, priority list, priority queue, or hash table. These are called pathfinding lists. To have the best performance, we have to find a balance between the following four operations of those structures,</p><ul class="postList"><li name="7f7d" id="7f7d" class="graf graf--li graf-after--p">adding an entry to the list</li><li name="c531" id="c531" class="graf graf--li graf-after--li">removing an entry from the list</li><li name="52d2" id="52d2" class="graf graf--li graf-after--li">finding the smallest element</li><li name="83c9" id="83c9" class="graf graf--li graf-after--li">finding an entry in the list corresponding to a particular node</li></ul><p name="b177" id="b177" class="graf graf--p graf-after--li">Commonly, we can have different types of pathfinding lists and here are some examples of them.</p><ul class="postList"><li name="9bd2" id="9bd2" class="graf graf--li graf-after--p">Linked list: bad efficient because finding may visit all element</li><li name="3fc3" id="3fc3" class="graf graf--li graf-after--li">Sorted list: finding is efficient but cost to add increases. This is no good for A* because it adds a lot with relatively fewer find-smallest element calls</li><li name="f78a" id="f78a" class="graf graf--li graf-after--li">Priority queue/heap: this is an array-based tree structure. Remove the smallest element and add a new element take O(log n).</li><li name="d21e" id="d21e" class="graf graf--li graf-after--li">Bucketed Priority Queue: this means we have sorted buckets of unsorted lists, and they can be turned for application. This structure is often not worth the trouble.</li></ul><p name="1935" id="1935" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(22) Problems of A*</strong></p><p name="a4ce" id="a4ce" class="graf graf--p graf-after--p">It is probably the goal that can not be reached by A*. A possibility is that the agent will search nodes connected to the start node and try to get to the target as close as it can. So the perfect heuristic function that we want for A* should be A* going straight to the correct node in O(p), but this is not possible because such a heuristic solves exactly what we are looking for in the first place. To think about the heuristics, we have to think about some issues like cost.</p><ul class="postList"><li name="b502" id="b502" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Admissible Heuristic</strong>: An admissible heuristic is the one that guarantees that the shortest path can be found with the search because it never overestimated the cost of reaching the goal. In short, a heuristic that does not overestimate it is admissible (e.g. Euclidean Distance). In games, it is perfectly acceptable to use either admissible or inadmissible heuristics.</li></ul><p name="0e54" id="0e54" class="graf graf--p graf-after--li">We have the following admissible or inadmissible heuristics for A*,</p><ul class="postList"><li name="94f9" id="94f9" class="graf graf--li graf-after--p">Euclidian Distance: admissible</li><li name="8312" id="8312" class="graf graf--li graf-after--li">Cluster Heuristic: may be inadmissible if we need to have the pre-computed distance between cluster</li></ul><p name="308b" id="308b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(25) Evaluation of Grid Lattice Navigation</strong></p><p name="6b29" id="6b29" class="graf graf--p graf-after--p">We have discussed lattice navigation and now it’s time to evaluate this method. Some pros are</p><ul class="postList"><li name="bfad" id="bfad" class="graf graf--li graf-after--p">Discrete space is uniform and simple</li><li name="8643" id="8643" class="graf graf--li graf-after--li">Usually for games with discrete agent locations but it can be used with continuous coordinates</li><li name="99cd" id="99cd" class="graf graf--li graf-after--li">Easy to automatically generate</li><li name="2bcf" id="2bcf" class="graf graf--li graf-after--li">Good for a large number of units</li><li name="5408" id="5408" class="graf graf--li graf-after--li">A* works well with the grid</li></ul><p name="7eb2" id="7eb2" class="graf graf--p graf-after--li">But there are also some cons,</p><ul class="postList"><li name="b33f" id="b33f" class="graf graf--li graf-after--p">Inefficient use of memory</li><li name="36bf" id="36bf" class="graf graf--li graf-after--li">The resulting path are jagged/blocky resulting in unnatural movement</li><li name="2a1f" id="2a1f" class="graf graf--li graf-after--li">Doesn’t work well to maximize the navigable area</li><li name="de4e" id="de4e" class="graf graf--li graf-after--li">Search efficiency</li><li name="5cca" id="5cca" class="graf graf--li graf-after--li">Memory usage</li></ul><p name="f3a5" id="f3a5" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(26) Quadtree</strong></p><p name="17fe" id="17fe" class="graf graf--p graf-after--p">Briefly, we can consider using a quadtree rather than the grid lattice navigation. This is more like a hierarchical grid that we start off with a very large cell, and we check if there are any obstacles within it. Then we subdivide it into four parts for quadtree. Then we just continue that recursively until we figure out a perfect path.</p><figure name="394f" id="394f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*gINxBEAXiJApA1XRkxabLg.png" data-width="1458" data-height="452" src="https://cdn-images-1.medium.com/max/800/1*gINxBEAXiJApA1XRkxabLg.png"></figure><p name="b69c" id="b69c" class="graf graf--p graf-after--figure">This is a representation of efficient space but it does have some problems.</p><ul class="postList"><li name="277b" id="277b" class="graf graf--li graf-after--p">This structure is more complicated and parsing</li><li name="f9e0" id="f9e0" class="graf graf--li graf-after--li">This structure can result in undesirable quadtree subdivisions if obstacle details don’t line up with quadtree cell boundaries</li></ul><p name="49ce" id="49ce" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(27) Path Network</strong></p><p name="eb75" id="eb75" class="graf graf--p graf-after--p">The path network is another structure that does not require the agent to be at one of the path nodes at all times. The agent can be at any point in the terrain allowed by physical simulation. When the agent needs to move to a different location and an obstacle is in the way, the agent can move to the nearest path node accessible by straight-line movement and then find a path through the edges of the path network to another path node near to the desired destination.</p><figure name="22df" id="22df" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rO80FQdZkTZyi3VDREpOTA.png" data-width="1458" data-height="578" src="https://cdn-images-1.medium.com/max/800/1*rO80FQdZkTZyi3VDREpOTA.png"></figure><p name="1757" id="1757" class="graf graf--p graf-after--figure">The algorithm of the path network should be as follows,</p><ul class="postList"><li name="5c91" id="5c91" class="graf graf--li graf-after--p">Find the closest visible graph node (A)</li><li name="4c03" id="4c03" class="graf graf--li graf-after--li">Find the closest visible graph node to X (B)</li><li name="b510" id="b510" class="graf graf--li graf-after--li">Search for lowest cost path from A to B</li><li name="c509" id="c509" class="graf graf--li graf-after--li">Move to A</li><li name="2c69" id="2c69" class="graf graf--li graf-after--li">Traverse path</li><li name="973d" id="973d" class="graf graf--li graf-after--li">Move from B to X</li></ul><p name="c99d" id="c99d" class="graf graf--p graf-after--li">The problem with this structure is that sometimes we may end up in a narrow alley or something else because we can not find a point on the nearby edge. It would be even worse if we can not see a navigation point in the present position. In that situation, what we need to do is to go back and revise the network.</p><p name="2856" id="2856" class="graf graf--p graf-after--p">To generate a path network, we can implement some <strong class="markup--strong markup--p-strong">automatic placement</strong>. For example, we can,</p><ul class="postList"><li name="a342" id="a342" class="graf graf--li graf-after--p">Start with seed</li><li name="7e54" id="7e54" class="graf graf--li graf-after--li">Expand by adding uniformly</li><li name="c8c8" id="c8c8" class="graf graf--li graf-after--li">The designer might move, delete, and add manually afterward</li><li name="55d5" id="55d5" class="graf graf--li graf-after--li">Ensure all the nodes and edges are at least as far from walls as the agent’s collider radius</li></ul><p name="4ae5" id="4ae5" class="graf graf--p graf-after--li">Another method is called <strong class="markup--strong markup--p-strong">points of visibility</strong> (aka. POV) and this means to identify convex angles, and these features create natural inflection points for an efficient path through the environment. The inflection points must be offset by some distance to leave room for the agent. This is one sort of automatic path network and the network is also called the POV graph. This method also has some certain downsides, for example</p><ul class="postList"><li name="e100" id="e100" class="graf graf--li graf-after--p">it can result in graph bloat</li><li name="dc99" id="dc99" class="graf graf--li graf-after--li">it can end up going down a rabbit hole of adding more and more software features that never quite work</li><li name="8e81" id="8e81" class="graf graf--li graf-after--li">it often requires a lot of manual tweaks for offsetting the benefits</li></ul><p name="e9f1" id="e9f1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(28) Evaluation of Path Network</strong></p><p name="bc51" id="bc51" class="graf graf--p graf-after--p">Aggressive lookahead can result in problems,</p><ul class="postList"><li name="072d" id="072d" class="graf graf--li graf-after--p">Turns too sharp that causing NPC to slow down</li><li name="3ac7" id="3ac7" class="graf graf--li graf-after--li">Overshoot it NPC performance envelope doesn’t match</li></ul><p name="ad81" id="ad81" class="graf graf--p graf-after--li">Also, NPC steering behavior ultimately is not a perfect solution to fixing path network problems. For example,</p><ul class="postList"><li name="1646" id="1646" class="graf graf--li graf-after--p">Raycasting will still miss some things</li><li name="e2ea" id="e2ea" class="graf graf--li graf-after--li">Raycasting can easily become expensive</li><li name="01b8" id="01b8" class="graf graf--li graf-after--li">Especially problematic on variable height terrain and different terrain types</li><li name="605f" id="605f" class="graf graf--li graf-after--li">NPC make take a shortcut but end up walking in slow terrain instead of staying on the path of fast terrain</li></ul><p name="394d" id="394d" class="graf graf--p graf-after--li">So, the path network has some nice benefits like,</p><ul class="postList"><li name="b77a" id="b77a" class="graf graf--li graf-after--p">Discretization of space is very small</li><li name="dcce" id="dcce" class="graf graf--li graf-after--li">Does not require the agent to be at one of the path nodes at all times</li><li name="0679" id="0679" class="graf graf--li graf-after--li">Continuous, non-grid movement in the local area</li><li name="0056" id="0056" class="graf graf--li graf-after--li">Switch between local and remote navigation</li><li name="2b36" id="2b36" class="graf graf--li graf-after--li">Plays nice with steering behaviors</li><li name="2331" id="2331" class="graf graf--li graf-after--li">Good for FPS and RPGs</li><li name="a166" id="a166" class="graf graf--li graf-after--li">Can indicate special spots (e.g. sniping, crouching, etc.)</li></ul><p name="3c75" id="3c75" class="graf graf--p graf-after--li">But the downsides are,</p><ul class="postList"><li name="09f5" id="09f5" class="graf graf--li graf-after--p">Valid NPC positions might not be able to see a node in the network</li><li name="1fa9" id="1fa9" class="graf graf--li graf-after--li">Jagged path shape</li><li name="ccae" id="ccae" class="graf graf--li graf-after--li">Dynamic and rolling terrain issues</li><li name="9034" id="9034" class="graf graf--li graf-after--li">Storage/complexity of network to get good coverage and good path shape</li><li name="3eec" id="3eec" class="graf graf--li graf-after--li">NPC going off the network path can be dangerous (e.g. getting stuck or so on)</li></ul><p name="8c1b" id="8c1b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(29) Navigation Mesh (NavMesh)</strong></p><p name="b9f4" id="b9f4" class="graf graf--p graf-after--p">The navigation mesh defines navigable polygonal areas using convex regions that each has shared adjacent edges that are used to define a graph. So in fact, in the following graph, the blue areas with green edges are the navigation mesh, and the red line denotes the graph which is defined by the navigation mesh. The red line is very much like a path network so it can be searched in that graph. This graph is created by connecting may be the centroid of each of the polygons or in other possibilities, we could use as well. Then across each of these adjacent edges, or we call these the <strong class="markup--strong markup--p-strong">portal edges</strong>, is actually the place we can perform an A* search on.</p><figure name="85a9" id="85a9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jSDcJJzDFdLEA0suc_4-jw.png" data-width="1184" data-height="382" src="https://cdn-images-1.medium.com/max/800/1*jSDcJJzDFdLEA0suc_4-jw.png"></figure><p name="5399" id="5399" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(30) Convexity and Convex Polygon</strong></p><p name="2e6b" id="2e6b" class="graf graf--p graf-after--p">By definition, convex polygons are polygons that have all internal angles of less than 180 degrees. So all diagonals are contained within the polygon, and a line drawn through a convex polygon in any direction will intersect at exactly two points, and this means that the agent has nothing to collide with.</p><p name="363f" id="363f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(33) Greedy Mesh Generation</strong></p><p name="f15e" id="f15e" class="graf graf--p graf-after--p">As far as generating a NavMesh, there is a simple algorithm. So the main thing you need is just a triangulation of the navigable space and you can simply triangulate around from the borders of the space to the edges of the obstacles. So the algorithm is,</p><ul class="postList"><li name="dc9b" id="dc9b" class="graf graf--li graf-after--p">for point A in world points:</li><li name="e92c" id="e92c" class="graf graf--li graf-after--li">for point B in world points:</li><li name="6d0d" id="6d0d" class="graf graf--li graf-after--li">for point C in world points:</li><li name="9c38" id="9c38" class="graf graf--li graf-after--li">if (it is a valid triangle &amp;&amp; !exists):</li><li name="c876" id="c876" class="graf graf--li graf-after--li">add triangle to the mesh</li></ul><p name="a35f" id="a35f" class="graf graf--p graf-after--li">The condition of a valid triangle should be as follows,</p><ul class="postList"><li name="5be4" id="5be4" class="graf graf--li graf-after--p">No triangle edge coincident with an obstacle edge unless the same edge</li><li name="62c4" id="62c4" class="graf graf--li graf-after--li">It can not cross the existing triangle</li></ul><p name="a19c" id="a19c" class="graf graf--p graf-after--li">A greedy version of mesh generation on finding all the triangles is,</p><ul class="postList"><li name="061a" id="061a" class="graf graf--li graf-after--p">Pick a point on an obstacle or boundary</li><li name="842a" id="842a" class="graf graf--li graf-after--li">Successor points are (1) along the edge of a common obstacle or (2) through world space</li><li name="d0b9" id="d0b9" class="graf graf--li graf-after--li">Pick two successor points for the candidate triangle</li><li name="3009" id="3009" class="graf graf--li graf-after--li">see if they are successors of each other</li><li name="3926" id="3926" class="graf graf--li graf-after--li">can not across an existing triangle</li><li name="b1f3" id="b1f3" class="graf graf--li graf-after--li">repeat until you can not make more triangles from the original point</li><li name="6fef" id="6fef" class="graf graf--li graf-after--li">pick a new starting point</li></ul><p name="2ab7" id="2ab7" class="graf graf--p graf-after--li">So once you have a triangulation, then you can go about merging triangles to make larger regions. There’s no reason to stick with triangles in fact, but if you can make bigger convex regions, you can just attempt to delete an edge between two adjacent triangles and then later on any adjacent convex shapes.</p><p name="ab97" id="ab97" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. Decision Making</strong></p><p name="c67d" id="c67d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Agent’s Behavior</strong></p><p name="c92d" id="c92d" class="graf graf--p graf-after--p">So now the agent is able to move based on our previous discussion. But actually, it should also be able to gather resources, attack, access the computer terminal, open the door, and so on. So the steering behavior blending can sometimes address multiple behaviors but often agents need higher levels of control supported by a decision-making process. For instance, it should be able to avoid steering vectors that negatively interfere, cancel each other out, etc.</p><p name="1a03" id="1a03" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition Decision Making</strong></p><p name="f2e6" id="f2e6" class="graf graf--p graf-after--p">In terms of decision-making, the developers have to determine the <strong class="markup--strong markup--p-strong">recipe</strong> for agent pre-planned behaviors. In other words, the programmers should implement the plans. So all the contingencies or exceptional cases anticipated are part of the recipe and if something was missed, the agent is unable to adapt. The decisions are internally made by conditional logic, and they can also include deterministic on non-deterministic conditions.</p><p name="2d42" id="2d42" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Types of Decision Making</strong></p><p name="111a" id="111a" class="graf graf--p graf-after--p">There are different types of strategies for decision making,</p><ul class="postList"><li name="7fa4" id="7fa4" class="graf graf--li graf-after--p">Reactive decision making: response directly to the environmental state and pre-planned conditional actions</li><li name="4d40" id="4d40" class="graf graf--li graf-after--li">Deliberative decision making: models discretized environment and interfaces are made to determine the plan that can achieve the goal state</li><li name="4e17" id="4e17" class="graf graf--li graf-after--li">Reflective decision making: learn from experience</li></ul><p name="21b7" id="21b7" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Types of Pre-planned Behaviors</strong></p><p name="1050" id="1050" class="graf graf--p graf-after--p">There are several types of pre-planned behaviors as follows,</p><ul class="postList"><li name="2de2" id="2de2" class="graf graf--li graf-after--p">Production rules</li><li name="3125" id="3125" class="graf graf--li graf-after--li">Decision trees</li><li name="28f9" id="28f9" class="graf graf--li graf-after--li">Finite state machine (FSM)</li><li name="4316" id="4316" class="graf graf--li graf-after--li">Behavior trees</li></ul><p name="e095" id="e095" class="graf graf--p graf-after--li">And we are going to explain them in the following parts.</p><p name="bea2" id="bea2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Production Rules</strong></p><p name="48ca" id="48ca" class="graf graf--p graf-after--p">The Productions Rules is a simple method for decision making. It actually defines actions to be executed in response to different conditions. So it only has a simple architecture. The problem is that the developers may make some decisions arbitrarily and this makes the project difficult to organize. What’s more, it can also be difficult to understand behavior from looking at the rules. We may also have some situations when rules are ambiguous and conflict. So it makes it kind of a challenge if you want to have your agent perform a sequence of actions, then it requires making a series of rules with stateful triggers.</p><p name="7d0f" id="7d0f" class="graf graf--p graf-after--p">Here is a quick and dirty example of some production rules,</p><pre name="464e" id="464e" class="graf graf--pre graf-after--p">if (big enemy in sight)<br>    run away;<br>if (enemy in sight)<br>    fight;<br>if (...)<br>    ...;</pre><p name="015e" id="015e" class="graf graf--p graf-after--pre">Advanced production rules systems utilize an arbiter that selects from matching rules. A <strong class="markup--strong markup--p-strong">fixed priority arbiter</strong> means we will just evaluate the first one that matches from an ordered list for a simple version. We can conduct some priority weighting for rules or sensor events like the firewall rules, or we can simply do some random selection. The production rules can be stateless. An example of random selection with fixed priority is,</p><pre name="6160" id="6160" class="graf graf--pre graf-after--p">if (big enemy in sight &amp;&amp; rand() &gt; thresh_1)<br>    run away;<br>if (enemy in sight &amp;&amp; rand() &gt; thresh_2)<br>    fight;<br>if (...)<br>    ...;</pre><p name="1f3d" id="1f3d" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(6) Simple Decision Tree</strong></p><p name="5a78" id="5a78" class="graf graf--p graf-after--p">The decision trees are in some way similar to rule-based systems except for the isolated conditional coupled actions, we now have tree-structured decision logic in terms like a data structure. This is also more readable compared to the rule-based system because we can easily find some dependencies from this tree, so it is really good for simple decision making. However, it can quickly become a mess to manage manually.</p><figure name="d422" id="d422" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3-ZXY4_ARlNgZx522W0ONw.png" data-width="1608" data-height="438" src="https://cdn-images-1.medium.com/max/800/1*3-ZXY4_ARlNgZx522W0ONw.png"></figure><p name="655a" id="655a" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(7) Finite State Machine (FSM) Theory</strong></p><p name="fa40" id="fa40" class="graf graf--p graf-after--p">Consider the finite state machine, now we have fairly similar concepts of this kind of conditions on which we act upon. But now, we are going to maintain the stateful information and with a graph structure. So the nodes are the states we have and the edges are transitions. They are directional and the transitions are associated with logic. There are variations where the actions are associated with the transitions but we are not going to mention them in this part. What we are just going to assume is that our states perform an action and continue to perform an action like every time you ask the finite machine to update.</p><p name="7dc1" id="7dc1" class="graf graf--p graf-after--p">So the model of a finite state machine has the following components,</p><ul class="postList"><li name="b486" id="b486" class="graf graf--li graf-after--p">a finite number of states <em class="markup--em markup--li-em">S</em></li><li name="d2fe" id="d2fe" class="graf graf--li graf-after--li">an input vocabulary <em class="markup--em markup--li-em">I</em></li><li name="e383" id="e383" class="graf graf--li graf-after--li">a transition function T(<em class="markup--em markup--li-em">S</em>, <em class="markup--em markup--li-em">I</em>) -&gt; <em class="markup--em markup--li-em">S’</em></li><li name="0945" id="0945" class="graf graf--li graf-after--li">a start state <em class="markup--em markup--li-em">S₀</em> ∈ <em class="markup--em markup--li-em">S</em></li><li name="b990" id="b990" class="graf graf--li graf-after--li">zero or more final states <em class="markup--em markup--li-em">F</em> ⊂ <em class="markup--em markup--li-em">S</em></li></ul><p name="968e" id="968e" class="graf graf--p graf-after--li">The behavior of a finite state machine is that, it</p><ul class="postList"><li name="8d0a" id="8d0a" class="graf graf--li graf-after--p">can only be in one state at a given amount of time</li><li name="9800" id="9800" class="graf graf--li graf-after--li">can make transitions from one state to another to cause an output to take place</li><li name="3be7" id="3be7" class="graf graf--li graf-after--li">has many states and each of them represents some desired behavior</li><li name="a5db" id="a5db" class="graf graf--li graf-after--li">can poll the world or respond to events</li><li name="3ee4" id="3ee4" class="graf graf--li graf-after--li">can support actions that depend on the state triggering event (Mealy machine)</li><li name="8d79" id="8d79" class="graf graf--li graf-after--li">can support entry and exit actions associated with states (Moore machine)</li></ul><p name="0bf7" id="0bf7" class="graf graf--p graf-after--li">The following diagram is a simple example of FSM,</p><figure name="6b85" id="6b85" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*m_33w5QGsD2_Ao9t2PQoCw.png" data-width="1496" data-height="418" src="https://cdn-images-1.medium.com/max/800/1*m_33w5QGsD2_Ao9t2PQoCw.png"></figure><p name="1593" id="1593" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(8) State Machine Problems</strong></p><p name="23ac" id="23ac" class="graf graf--p graf-after--p">There are some problems with the state machines,</p><ul class="postList"><li name="8e8c" id="8e8c" class="graf graf--li graf-after--p">It can be very <strong class="markup--strong markup--li-strong">predictable</strong> because we have these specific fixed transactions. This can be solved by using a fuzzy or <strong class="markup--strong markup--li-strong">probabilistic state machine</strong>.</li><li name="4f3f" id="4f3f" class="graf graf--li graf-after--li">It is also <strong class="markup--strong markup--li-strong">simplistic</strong> in what they can do and it can be really hard to scale if we want to have some complicated strategies. But it can be effective by using a hierarchy of <strong class="markup--strong markup--li-strong">FSM stack</strong>.</li></ul><p name="532b" id="532b" class="graf graf--p graf-after--li">Besides, because the number of states can grow fast because we have an exponential number of events in the world, the FSM can become really huge. So there will be even more problems,</p><ul class="postList"><li name="a05d" id="a05d" class="graf graf--li graf-after--p">When it fails, it fails hard. This is because a transition from one state to another requires forethought, and this means we can get stuck in a state or can’t do the correct next action.</li><li name="cce3" id="cce3" class="graf graf--li graf-after--li">The number of transitions can grow even faster, this means we can not work easily with the sequences of actions</li><li name="33cb" id="33cb" class="graf graf--li graf-after--li">Memory limitations</li></ul><p name="1608" id="1608" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(9) Finite State Machine Advantage</strong></p><p name="66d3" id="66d3" class="graf graf--p graf-after--p">However, there are also some benefits of the FSM,</p><ul class="postList"><li name="45bc" id="45bc" class="graf graf--li graf-after--p">Ubiquitous: they are popular so we have lots of tools and APIs</li><li name="41de" id="41de" class="graf graf--li graf-after--li">Quick and simple to code: can start from scratch</li><li name="7061" id="7061" class="graf graf--li graf-after--li">Can be easy to debug: because the size is small</li><li name="35dc" id="35dc" class="graf graf--li graf-after--li">Fast: only have small computational overhead</li><li name="aab6" id="aab6" class="graf graf--li graf-after--li">Intuitive</li><li name="0ec0" id="0ec0" class="graf graf--li graf-after--li">Flexible</li><li name="ba0d" id="ba0d" class="graf graf--li graf-after--li">Easy for designers without coding knowledge</li></ul><p name="b238" id="b238" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(10) Hierarchical Finite State Machine</strong></p><p name="d9d7" id="d9d7" class="graf graf--p graf-after--p">In terms of some more advanced FSM, one critical model is the hierarchical finite state machine. So if you get to a point that has too many states which can be unmanageable, you may probably need a hierarchical structure. Let’s see an example here,</p><figure name="607c" id="607c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*yFFz5X9yfODD-uoGGIu_ow.png" data-width="1302" data-height="394" src="https://cdn-images-1.medium.com/max/800/1*yFFz5X9yfODD-uoGGIu_ow.png"></figure><p name="231e" id="231e" class="graf graf--p graf-after--figure">So this hierarchical FSM is equivalent to regular FSMs, but it adds recursive multi-level evaluations. So is easier for us to think about encapsulation. It seems fairly reasonable if we can maintain a small number of high-level states and then as needed, we can whittle our way down with something specific.</p><p name="b95a" id="b95a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) FSM Stack</strong></p><p name="d776" id="d776" class="graf graf--p graf-after--p">Another approach we can handle the complexity of the FSM is by using a stack. The stack approach allows us to handle the transitions in a slightly different way by pushing onto the stack this new activity. An action is considered complete when it is popped from the stack. So you can pop an activity and then push something new, or you can only pop itself, or if you like, you can just push a new one without popping it out.</p><figure name="9ef7" id="9ef7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BBETjDaa3ZbebbOC_BbxXQ.png" data-width="1666" data-height="434" src="https://cdn-images-1.medium.com/max/800/1*BBETjDaa3ZbebbOC_BbxXQ.png"></figure><p name="545f" id="545f" class="graf graf--p graf-after--figure">There are some dangers of this approach,</p><ul class="postList"><li name="8da3" id="8da3" class="graf graf--li graf-after--p">Potential memory leaks: if keep pushing</li><li name="b327" id="b327" class="graf graf--li graf-after--li">May need more restrictions enforced (e.g. we can not have two of the same state on the stack at the same time)</li></ul><p name="1e06" id="1e06" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(11) Probabilistic State Machines</strong></p><p name="5982" id="5982" class="graf graf--p graf-after--p">Back to the issue of making the agent less predictable, we may consider using a probabilistic state machine.</p><figure name="5b46" id="5b46" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mfWBa2P3fNjuvofbAHGSYA.png" data-width="1364" data-height="294" src="https://cdn-images-1.medium.com/max/800/1*mfWBa2P3fNjuvofbAHGSYA.png"></figure><p name="626b" id="626b" class="graf graf--p graf-after--figure">The basic idea here whenever we have a transition, we are going to couple it with some randomly determined value. We are then going to compare that to a threshold so we might have some basic boolean conditions to decide a transition.</p><figure name="0fe4" id="0fe4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*A_81WeyZ6-YofEiFGFy6yA.png" data-width="1716" data-height="370" src="https://cdn-images-1.medium.com/max/800/1*A_81WeyZ6-YofEiFGFy6yA.png"></figure><p name="bef1" id="bef1" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(12) Behavior Trees</strong></p><p name="3d8f" id="3d8f" class="graf graf--p graf-after--p">Rather than the PSM, the behavior trees are more declarative and generally more understandable. It has some components like,</p><ul class="postList"><li name="6655" id="6655" class="graf graf--li graf-after--p">Composite</li><li name="b627" id="b627" class="graf graf--li graf-after--li">Decorator</li><li name="3f0e" id="3f0e" class="graf graf--li graf-after--li">Leaf: the behaviors</li></ul><figure name="e7f4" id="e7f4" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*Vc21X0uSuNxQ9a2Cg094-g.png" data-width="1122" data-height="248" src="https://cdn-images-1.medium.com/max/800/1*Vc21X0uSuNxQ9a2Cg094-g.png"></figure><p name="a650" id="a650" class="graf graf--p graf-after--figure">Each component has three return values,</p><ul class="postList"><li name="f704" id="f704" class="graf graf--li graf-after--p">Success: like true</li><li name="6e07" id="6e07" class="graf graf--li graf-after--li">Failure: like false</li><li name="3293" id="3293" class="graf graf--li graf-after--li">Running: the behaviors take multiple frames to execute</li></ul><p name="d46e" id="d46e" class="graf graf--p graf-after--li">The behavior trees are still just the reactive planning systems that are very similar to what we have discussed so far for another reactive decision-making. So the tree of behaviors specifies what an agent should do under all circumstances.</p><p name="9e63" id="9e63" class="graf graf--p graf-after--p">The benefit of using the behavior trees is that transitions are decoupled from the states so we have standalone behaviors and we can reuse the tree structure.</p><figure name="8ab0" id="8ab0" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*I7PnQOxBYXZdt2dkCg6QUA.png" data-width="1594" data-height="420" src="https://cdn-images-1.medium.com/max/800/1*I7PnQOxBYXZdt2dkCg6QUA.png"></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/91884055a9f6"><time class="dt-published" datetime="2021-10-20T04:13:30.269Z">October 20, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/video-game-design-7-introduction-to-game-ai-91884055a9f6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>