<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Python程序设计4 列表和文本处理</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Python程序设计4 列表和文本处理</h1>
</header>
<section data-field="subtitle" class="p-summary">
系列：Python程序设计
</section>
<section data-field="body" class="e-content">
<section name="fde5" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bd69" id="bd69" class="graf graf--h3 graf--leading graf--title">Python程序设计4 列表和文本处理</h3><figure name="d439" id="d439" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*nMQTiDVkQq7j6ZlqQEKLbQ.jpeg" data-width="2689" data-height="1513" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*nMQTiDVkQq7j6ZlqQEKLbQ.jpeg"></figure><p name="de29" id="de29" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">一、一维列表 List</strong></p><p name="f9ef" id="f9ef" class="graf graf--p graf-after--p">列表是一种用来存储一系列项（items）的一种方式。这些项被称为元素（elements）。列表有两个特点，一是有序性，可以根据元素的位置来找到对应的元素）；二是集合性，列表可以含有多种元素。在python中，列表的特性是根据元素的加入和移除自动调整列表的大小（size），所以相比于其他语言更加直观。</p><ol class="postList"><li name="905f" id="905f" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">获得列表中的元素</strong></li></ol><p name="4b74" id="4b74" class="graf graf--p graf-after--li">在python中，列表的序号是从0开始编号的，所以第0位置上元素实际上指的是列表中的第一个元素。考虑下面的列表：</p><pre name="7a2e" id="7a2e" class="graf graf--pre graf-after--p">letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</pre><p name="1d6f" id="1d6f" class="graf graf--p graf-after--pre">由于序号是从0开始编号的，所以它的位置有如下图所示：</p><figure name="7060" id="7060" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*RGQg6XW794JLkGX7ci12KQ.png" data-width="1576" data-height="190" src="https://cdn-images-1.medium.com/max/800/1*RGQg6XW794JLkGX7ci12KQ.png"></figure><p name="7afb" id="7afb" class="graf graf--p graf-after--figure">如果我们想要得到某个元素，那么我们就用 列表名[位置] 的形式将他们标示出来。例如：</p><ul class="postList"><li name="3edf" id="3edf" class="graf graf--li graf-after--p">letters[0] 表示 a</li><li name="02fd" id="02fd" class="graf graf--li graf-after--li">letters[4] 表示 e</li></ul><p name="0e07" id="0e07" class="graf graf--p graf-after--li">同样地，我们也可以通过这种方法替换列表中的某个元素。例如下面的代码将列表中第0位置替换为 ’x’ ：</p><pre name="6274" id="6274" class="graf graf--pre graf-after--p">letters[0] = &#39;x&#39;</pre><p name="7fe2" id="7fe2" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. 获得列表的长度</strong></p><p name="4499" id="4499" class="graf graf--p graf-after--p">我们可以通过len()函数来计算一个列表的长度。例如:</p><pre name="c008" id="c008" class="graf graf--pre graf-after--p">len(letters)</pre><p name="fcea" id="fcea" class="graf graf--p graf-after--pre">我们通常也通过len()函数来遍历一个列表，例如：</p><pre name="40a1" id="40a1" class="graf graf--pre graf-after--p">for i in range(len(letters)):</pre><p name="5cdd" id="5cdd" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. 负索引</strong></p><p name="7c87" id="7c87" class="graf graf--p graf-after--p">在python中，我们也可以在列表名后面通过负索引来调用元素。在Python语言中 –x 等同于 len(list)–x 。所以当我们在引用下列语句：</p><pre name="e1ec" id="e1ec" class="graf graf--pre graf-after--p">letters[-1]</pre><p name="6e83" id="6e83" class="graf graf--p graf-after--pre">的时候，我们实际上在引用：</p><pre name="09f2" id="09f2" class="graf graf--pre graf-after--p">letters[len(letters)-1]</pre><p name="95aa" id="95aa" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4. 创建列表</strong></p><p name="7f2c" id="7f2c" class="graf graf--p graf-after--p">我们可以在构造列表的同时给列表中的元素赋值，我们也可以初始定义一个空列表。由于python中列表自动定义列表长度，所以我们不需要指定一个列表的长度。</p><pre name="9875" id="9875" class="graf graf--pre graf-after--p">alist = [10, 20, 30, 40, 50]<br>alist = []</pre><p name="a38b" id="a38b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">5. 添加或者删除元素</strong></p><p name="58c3" id="58c3" class="graf graf--p graf-after--p">对于list来说，我们只能在list的末尾添加新的元素。所以从数据结构上来说，list实际上是一个栈的结构。</p><p name="5a37" id="5a37" class="graf graf--p graf-after--p">我们通过append函数在list末尾追加新的元素：</p><pre name="95f1" id="95f1" class="graf graf--pre graf-after--p">alist.append()</pre><p name="e834" id="e834" class="graf graf--p graf-after--pre">例如：</p><pre name="f3f6" id="f3f6" class="graf graf--pre graf-after--p">alist = [10, 20, 30] <br>alist.append(40) <br>alist.append(50)</pre><p name="6b5a" id="6b5a" class="graf graf--p graf-after--pre">结果为：</p><figure name="f54c" id="f54c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*CD1h_qNJfka-jAYKx3W00g.png" data-width="1620" data-height="206" src="https://cdn-images-1.medium.com/max/800/1*CD1h_qNJfka-jAYKx3W00g.png"></figure><p name="66ac" id="66ac" class="graf graf--p graf-after--figure">我们通过pop函数在list末尾弹出最后的元素：</p><pre name="db2d" id="db2d" class="graf graf--pre graf-after--p">x = alist.pop()</pre><p name="d834" id="d834" class="graf graf--p graf-after--pre">例如：</p><pre name="5f66" id="5f66" class="graf graf--pre graf-after--p">alist = [10, 20, 30, 40, 50] <br>x = alist.pop() <br>x = alist.pop()</pre><p name="6b2c" id="6b2c" class="graf graf--p graf-after--pre">结果为：</p><figure name="10e6" id="10e6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*uKCaeak_LVlcGq-MDEDfcA.png" data-width="1358" data-height="332" src="https://cdn-images-1.medium.com/max/800/1*uKCaeak_LVlcGq-MDEDfcA.png"></figure><p name="bcb3" id="bcb3" class="graf graf--p graf-after--figure">我们不能对空列表使用pop函数，否则会报错。例如：</p><pre name="a068" id="a068" class="graf graf--pre graf-after--p">alist = [10, 20, 30, 40, 50] <br>x = alist.pop() <br>x = alist.pop() <br>x = alist.pop() <br>x = alist.pop() <br>x = alist.pop()<br>x = alist.pop()</pre><p name="1ac6" id="1ac6" class="graf graf--p graf-after--pre">显示错误为：</p><pre name="8666" id="8666" class="graf graf--pre graf-after--p">IndexError: pop from empty list</pre><p name="9237" id="9237" class="graf graf--p graf-after--pre">另外，我们可以给予pop函数参数，这个参数指的是我们将倒数第几个元素弹出。例如下面的代码：</p><pre name="0c59" id="0c59" class="graf graf--pre graf-after--p">alist = [10, 20, 30, 40, 50]<br>x = alist.pop(2)</pre><p name="3327" id="3327" class="graf graf--p graf-after--pre">最后结果为：</p><pre name="bc8f" id="bc8f" class="graf graf--pre graf-after--p">x = 40<br>alist = [10, 20, 30, 50]</pre><p name="0196" id="0196" class="graf graf--p graf-after--pre">我们还可以通过remove函数来删除列表中的元素，需要注意的是，我们需要已知该元素存在在列表中，否则会产生错误。例如：</p><pre name="8263" id="8263" class="graf graf--pre graf-after--p">another_list = [&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;]<br>another_list.remove(&#39;b&#39;)<br>another_list</pre><p name="1b14" id="1b14" class="graf graf--p graf-after--pre">得到的结果为：</p><pre name="f152" id="f152" class="graf graf--pre graf-after--p">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</pre><p name="68ee" id="68ee" class="graf graf--p graf-after--pre">如果我们使用语句：</p><pre name="d378" id="d378" class="graf graf--pre graf-after--p">another_list.remove(&#39;d&#39;)</pre><p name="6a8a" id="6a8a" class="graf graf--p graf-after--pre">则会报错：</p><pre name="607b" id="607b" class="graf graf--pre graf-after--p">- ValueError if you try to remove an element that isn&#39;t in list</pre><p name="6869" id="6869" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">6. 列表的输出</strong></p><p name="e032" id="e032" class="graf graf--p graf-after--p">我们可以直接print整个列表，例如：</p><pre name="a243" id="a243" class="graf graf--pre graf-after--p">print(alist)</pre><p name="ff66" id="ff66" class="graf graf--p graf-after--pre">我们也可以通过循环依次print列表中的每一个元素，例如：</p><pre name="ce60" id="ce60" class="graf graf--pre graf-after--p">for element in alist:<br>      print(element)</pre><p name="183f" id="183f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">7. 列表和判断</strong></p><p name="f95c" id="f95c" class="graf graf--p graf-after--p">如果要判断一个列表是否为空，我们直接在if函数后面添加列表名判断即可。例如：</p><pre name="e337" id="e337" class="graf graf--pre graf-after--p">if num_list:<br>     print(&#39;num_list is not empty&#39;) <br>else: <br>     print(&#39;num_list is empty&#39;)</pre><p name="e42e" id="e42e" class="graf graf--p graf-after--pre">判断一个元素是否在一个数组中，可以通过 <em class="markup--em markup--p-em">element in list</em> 来判断：</p><pre name="fb9b" id="fb9b" class="graf graf--pre graf-after--p">x = 1<br>if x in num_list:<br>    # do something</pre><p name="8ca3" id="8ca3" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">8. 列表合并</strong></p><p name="1385" id="1385" class="graf graf--p graf-after--p">如果要将两个列表进行合并需要用到的函数为extend()。例如：</p><pre name="08d2" id="08d2" class="graf graf--pre graf-after--p">list1 = [1, 2]<br>list2 = [3, 4, 5]<br>list1.extend(list2)<br>list1</pre><p name="d8ce" id="d8ce" class="graf graf--p graf-after--pre">输出的结果为：</p><pre name="e424" id="e424" class="graf graf--pre graf-after--p">[1, 2, 3, 4, 5]</pre><p name="f047" id="f047" class="graf graf--p graf-after--pre">注意，append和extend是非常不同的。例如：</p><pre name="a2d0" id="a2d0" class="graf graf--pre graf-after--p">list1 = [1, 2]<br>list2 = [3, 4, 5]<br>list1.append(list2)<br>list1</pre><p name="d6cd" id="d6cd" class="graf graf--p graf-after--pre">得到的结果为：</p><pre name="b7e3" id="b7e3" class="graf graf--pre graf-after--p">[1, 2, [3, 4, 5]]</pre><p name="6c2c" id="6c2c" class="graf graf--p graf-after--pre">另外，+ 运算符也可以起到合并两个列表的作用。例如：</p><pre name="f671" id="f671" class="graf graf--pre graf-after--p">list1 = [1, 2]<br>list2 = [3, 4, 5]<br>list3 = list1 + list2<br>list3</pre><p name="4694" id="4694" class="graf graf--p graf-after--pre">得到的结果为：</p><pre name="f3cc" id="f3cc" class="graf graf--pre graf-after--p">[1, 2, 3, 4, 5]</pre><p name="dfff" id="dfff" class="graf graf--p graf-after--pre">我们也可以使用 += 运算符来进行自身赋值。例如：</p><pre name="02cb" id="02cb" class="graf graf--pre graf-after--p">list1 = [1, 2]<br>list2 = [3, 4, 5]<br>list1 += list2<br>list1</pre><p name="7e4d" id="7e4d" class="graf graf--p graf-after--pre">得到的结果为：</p><pre name="837d" id="837d" class="graf graf--pre graf-after--p">[1, 2, 3, 4, 5]</pre><p name="6bb4" id="6bb4" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">9. 位置查找</strong></p><p name="b713" id="b713" class="graf graf--p graf-after--p">我们可以使用index函数来查找列表中某个元素的位置。结果将返回该元素对应的第一个元素的索引。如果该元素不存在于数组之中，则会产生报错。例如：</p><pre name="7e07" id="7e07" class="graf graf--pre graf-after--p">alist = [&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;]<br>i = alist.index(&#39;b&#39;)<br>i</pre><p name="9d41" id="9d41" class="graf graf--p graf-after--pre">得到结果：</p><pre name="9d30" id="9d30" class="graf graf--pre graf-after--p">1</pre><p name="a19e" id="a19e" class="graf graf--p graf-after--pre">另外，如果代码为：</p><pre name="2c76" id="2c76" class="graf graf--pre graf-after--p">alist = [&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;]<br>i = alist.index(&#39;d&#39;)<br>i</pre><p name="69d3" id="69d3" class="graf graf--p graf-after--pre">则得到报错：</p><pre name="26aa" id="26aa" class="graf graf--pre graf-after--p">– ValueError if you ask for index of an element that isn&#39;t in list</pre><p name="2a72" id="2a72" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">10. 插入元素</strong></p><p name="c184" id="c184" class="graf graf--p graf-after--p">如果我们指定索引，那么我们就可以通过insert函数来在数列中插入新的元素。插入后，原来的元素依次向后移动。例如：</p><pre name="0d89" id="0d89" class="graf graf--pre graf-after--p">jedi = [&#39;luke&#39;, &#39;obiwan&#39;]<br>jedi.insert(1, &#39;rey&#39;)<br>jedi</pre><p name="3501" id="3501" class="graf graf--p graf-after--pre">得到输出：</p><pre name="faa7" id="faa7" class="graf graf--pre graf-after--p">[&#39;luke&#39;, &#39;rey&#39;, &#39;obiwan&#39;]</pre><p name="9968" id="9968" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">11. 拷贝列表</strong></p><p name="9a73" id="9a73" class="graf graf--p graf-after--p">如果想要得到一个一模一样的列表，最常见的方法是直接赋值。但是这种方法我们得到的并不是数值的拷贝。如果list的值被修改，那么list1的值也会被修改。例如：</p><pre name="fc24" id="fc24" class="graf graf--pre graf-after--p">list = [1, 2, 3]<br>list1 = list<br>list1</pre><p name="695a" id="695a" class="graf graf--p graf-after--pre">得到输出：</p><pre name="a9a2" id="a9a2" class="graf graf--pre graf-after--p">[1, 2, 3]</pre><p name="eeae" id="eeae" class="graf graf--p graf-after--pre">如果我们仅仅想要得到数值而不想让两个变量连锁，那么我们可以通过copy函数来进行赋值，看起来效果是一样的。但是此时如果我们修改列表list中的值，列表list1的值不会改变：</p><pre name="86ca" id="86ca" class="graf graf--pre graf-after--p">list = [1, 2, 3]<br>list1 = list.copy()<br>list1</pre><p name="2f46" id="2f46" class="graf graf--p graf-after--pre">得到输出：</p><pre name="ac07" id="ac07" class="graf graf--pre graf-after--p">[1, 2, 3]</pre><p name="2151" id="2151" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">12. 列表计算</strong></p><p name="f71c" id="f71c" class="graf graf--p graf-after--p">我们可以通过max函数求某个列表中元素的最大值。此处max()是一个函数而不是列表数据的一个方法，所以列表只能作为max函数的参数来使用。后面的min和sum同理可推。例如：</p><pre name="a64d" id="a64d" class="graf graf--pre graf-after--p">max(list)</pre><p name="f3f0" id="f3f0" class="graf graf--p graf-after--pre">这里list中的元素只能为数字，如果有字符类型的数据就会报错：</p><pre name="5f69" id="5f69" class="graf graf--pre graf-after--p">TypeError: &#39;&gt;&#39; not supported between instances of &#39;str&#39; and &#39;int&#39;</pre><p name="e2d6" id="e2d6" class="graf graf--p graf-after--pre">我们可以通过min函数求某个列表中元素的最小值。</p><pre name="2efc" id="2efc" class="graf graf--pre graf-after--p">min(list)</pre><p name="8beb" id="8beb" class="graf graf--p graf-after--pre">我们还可以通过sum函数来求某个列表内元素的和。</p><pre name="7a47" id="7a47" class="graf graf--pre graf-after--p">sum(list)</pre><p name="3a19" id="3a19" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">13. 通过range函数来遍历列表</strong></p><p name="b331" id="b331" class="graf graf--p graf-after--p">我们在之前介绍了如果我们想要遍历列表输出所有元素，我们可以使用代码：</p><pre name="dc97" id="dc97" class="graf graf--pre graf-after--p">for element in list:<br>    print(element)</pre><p name="3694" id="3694" class="graf graf--p graf-after--pre">还有一种遍历方法是通过range函数来遍历，range函数会生成一个列表，列表中的元素是[0, 1, …, n-1]，n指的是list的长度。因此，如果我们通过这种方法来遍历list，我们就有下面的代码：</p><pre name="16c0" id="16c0" class="graf graf--pre graf-after--p">for i in range(len(list)):<br>    print(element[i])</pre><p name="6539" id="6539" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">14. 变量赋值的注意事项</strong></p><p name="c4ef" id="c4ef" class="graf graf--p graf-after--p">在python中，有些变量的赋值是是只赋值，但是有的变量赋值是指向了原来的变量。在前者中原变量的改变不会引起后面变量的变化，但是在后者中原变量的改变会引起后面变量的变化。</p><p name="7bc4" id="7bc4" class="graf graf--p graf-after--p">只赋值的变量类型有：</p><ul class="postList"><li name="3373" id="3373" class="graf graf--li graf-after--p">integer</li><li name="373b" id="373b" class="graf graf--li graf-after--li">float</li><li name="7b35" id="7b35" class="graf graf--li graf-after--li">boolean</li><li name="5272" id="5272" class="graf graf--li graf-after--li">string</li></ul><p name="16aa" id="16aa" class="graf graf--p graf-after--li">指向原变量的变量类型有：</p><ul class="postList"><li name="5cae" id="5cae" class="graf graf--li graf-after--p">canvas</li><li name="8bc9" id="8bc9" class="graf graf--li graf-after--li">pixel</li><li name="64c7" id="64c7" class="graf graf--li graf-after--li">SimpleImage</li><li name="9134" id="9134" class="graf graf--li graf-after--li">list</li></ul><p name="2b99" id="2b99" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">15. 列表中的元素位置交换</strong></p><p name="327c" id="327c" class="graf graf--p graf-after--p">在列表中进行元素交换的时候，如果没有特别注意，非常容易只改变了局部参数。例如下面的代码：</p><pre name="465f" id="465f" class="graf graf--pre graf-after--p">def swap_elements_buggy(elem1, elem2):<br>   temp = elem1<br>   elem1 = elem2<br>   elem2 = temp </pre><pre name="1ad8" id="1ad8" class="graf graf--pre graf-after--pre">def main():<br>   my_list = [10, 20, 30]<br>   swap_elements_buggy(my_list[0], my_list[1])<br>   print(my_list)</pre><p name="93c6" id="93c6" class="graf graf--p graf-after--pre">上面的代码并不能实现交换元素的功能，输出的结果仍然是：</p><pre name="d54b" id="d54b" class="graf graf--pre graf-after--p">[10, 20, 30]</pre><p name="54d3" id="54d3" class="graf graf--p graf-after--pre">原因是swap函数中进行交换的时候，只是局部变量elem1和elem2的数值改变了，mylist中元素的数值并没有发生改变。所以，如果想要使mylist中数值发生改变，那么在交换元素的函数中必须将mylist作为参数进行传递。例如：</p><pre name="2fe7" id="2fe7" class="graf graf--pre graf-after--p">def swap_elements_working(alist, index1, index2):<br>   temp = alist[index1]<br>   alist[index1] = alist[index2]<br>   alist[index2] = temp</pre><pre name="471d" id="471d" class="graf graf--pre graf-after--pre">def main():<br>   my_list = [10, 20, 30]<br>   swap_elements_working(my_list, 0, 1)<br>   print(my_list)</pre><p name="5dcc" id="5dcc" class="graf graf--p graf-after--pre">得到输出：</p><pre name="39df" id="39df" class="graf graf--pre graf-after--p">[20, 10, 30]</pre><p name="4ba9" id="4ba9" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">16. 列表的切片</strong></p><p name="6c06" id="6c06" class="graf graf--p graf-after--p">列表就像一个长法棍面包，有的时候它太长了，而我们又不需要它里面全部的部分，所以我们就可以切出来一份。这个由切出来的一部分构成的新列表，就叫做列表的一个切片。</p><p name="2bd7" id="2bd7" class="graf graf--p graf-after--p">例如我们有下面的列表：</p><pre name="e3f3" id="e3f3" class="graf graf--pre graf-after--p">alist = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</pre><figure name="1c9d" id="1c9d" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*ZqegVby6eU1HGhygDj2uaA.png" data-width="1800" data-height="190" src="https://cdn-images-1.medium.com/max/800/1*ZqegVby6eU1HGhygDj2uaA.png"></figure><p name="161a" id="161a" class="graf graf--p graf-after--figure">aslice是alist的一个切片，代码如下：</p><pre name="ba9a" id="ba9a" class="graf graf--pre graf-after--p">aslice = alist[2:4]</pre><figure name="b5e7" id="b5e7" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*ME6KNVDWuqyENMe_9KMQqA.png" data-width="1434" data-height="190" src="https://cdn-images-1.medium.com/max/800/1*ME6KNVDWuqyENMe_9KMQqA.png"></figure><p name="4d32" id="4d32" class="graf graf--p graf-after--figure">由上面的示例可以看出，列表切片的一般形式如下。它从start的索引开始（并包括start）到end索引结束（但是不包括end）。</p><pre name="a6f5" id="a6f5" class="graf graf--pre graf-after--p">list[start:end]</pre><p name="8e35" id="8e35" class="graf graf--p graf-after--pre">例如，对于列表alist来说：</p><pre name="9da0" id="9da0" class="graf graf--pre graf-after--p">alist = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</pre><p name="11fe" id="11fe" class="graf graf--p graf-after--pre">它的切片示意图如下所示：</p><figure name="7f68" id="7f68" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*nc49elxcGCT_-Yh7jK9A8Q.png" data-width="1874" data-height="256" src="https://cdn-images-1.medium.com/max/800/1*nc49elxcGCT_-Yh7jK9A8Q.png"></figure><p name="9ffe" id="9ffe" class="graf graf--p graf-after--figure">有的时候我们也会运用到负索引，那么负索引和正索引的对应关系如下所示：</p><figure name="d76d" id="d76d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*QMXnTW3DxigB5NjwtBvKjw.png" data-width="1784" data-height="334" src="https://cdn-images-1.medium.com/max/800/1*QMXnTW3DxigB5NjwtBvKjw.png"></figure><p name="e525" id="e525" class="graf graf--p graf-after--figure">例如：</p><pre name="5fbe" id="5fbe" class="graf graf--pre graf-after--p">alist[2:-2]     #[&#39;c&#39;, &#39;d&#39;]</pre><p name="64a3" id="64a3" class="graf graf--p graf-after--pre">此外，如果我们不写出索引，那么start默认的是0，而end默认的是到列表的结束。例如：</p><pre name="e03c" id="e03c" class="graf graf--pre graf-after--p">alist[-2:]       # [&#39;e&#39;, &#39;f&#39;] <br>alist[:-1]       # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] <br>alist[:]         # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]</pre><p name="ed50" id="ed50" class="graf graf--p graf-after--pre">我们还可以通过设置步长的方式来跳过某些元素。步长可以是正数也可以是负数。在没有给出步长的情况下，它默认的值为0。需要注意的是，当我们的step为负数的时候，切片是从列表的右端向左端切片的，也就是默认的start为列表最右端，默认的end为0。设置步长的切片的一般形式如下：</p><pre name="18ce" id="18ce" class="graf graf--pre graf-after--p">list[start:end:step]</pre><p name="f520" id="f520" class="graf graf--p graf-after--pre">例子如下：</p><pre name="8f3d" id="8f3d" class="graf graf--pre graf-after--p">alist[1:5:2]         # [&#39;b&#39;, &#39;d&#39;] <br>alist[::2]           # [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;] <br>alist[4:1:-1]        # [&#39;e&#39;, &#39;d&#39;, &#39;c&#39;] <br>alist[1:4:-1]        # [] <br>alist[::-1]          # [&#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</pre><p name="0d98" id="0d98" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">17. 切片和循环</strong></p><p name="7135" id="7135" class="graf graf--p graf-after--p">列表的切片也是一个列表，所以用于列表的循环也可以用于切片！例如：</p><pre name="d1ab" id="d1ab" class="graf graf--pre graf-after--p">for i in range(start, end, step): <br>    # do something with list[i]</pre><p name="1cea" id="1cea" class="graf graf--p graf-after--pre">它等价于：</p><pre name="6bfd" id="6bfd" class="graf graf--pre graf-after--p">for elem in list[start:end:step]: <br>    # do something with elem</pre><p name="cc33" id="cc33" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">18. del指令</strong></p><p name="3000" id="3000" class="graf graf--p graf-after--p">对于列表中，我们可以随时用del指令来删除列表中的某一个元素或者某一段切片。例如：</p><pre name="e67f" id="e67f" class="graf graf--pre graf-after--p">num_list = [50, 30, 40, 60, 90, 80] <br>del num_list[1] <br>num_list</pre><p name="d7e8" id="d7e8" class="graf graf--p graf-after--pre">输出为：</p><pre name="d728" id="d728" class="graf graf--pre graf-after--p">[50, 40, 60, 90, 80]</pre><p name="8d6a" id="8d6a" class="graf graf--p graf-after--pre">另外例如：</p><pre name="8dbd" id="8dbd" class="graf graf--pre graf-after--p">num_list = [50, 30, 40, 60, 90, 80]<br>del num_list[1:4]<br>num_list</pre><p name="7bdb" id="7bdb" class="graf graf--p graf-after--pre">输出为：</p><pre name="4000" id="4000" class="graf graf--pre graf-after--p">[50, 90, 80]</pre><p name="91b1" id="91b1" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">19. 列表的重排</strong></p><p name="c7c2" id="c7c2" class="graf graf--p graf-after--p">有的时候我们会需要将列表重排。常见的重排方式是筛选和转置。其中，筛选可以通过sort函数实现，转置可以通过reverse函数来实现。例如：</p><pre name="0fb0" id="0fb0" class="graf graf--pre graf-after--p">fun_list = [6, 3, 12, 4] <br>fun_list.reverse() <br>fun_list</pre><p name="f4e4" id="f4e4" class="graf graf--p graf-after--pre">输出为：</p><pre name="edff" id="edff" class="graf graf--pre graf-after--p">[4, 12, 3, 6]</pre><p name="835d" id="835d" class="graf graf--p graf-after--pre">以及，</p><pre name="f61e" id="f61e" class="graf graf--pre graf-after--p">fun_list = [6, 3, 12, 4] <br>fun_list.sort() <br>fun_list</pre><p name="4383" id="4383" class="graf graf--p graf-after--pre">输出为：</p><pre name="7813" id="7813" class="graf graf--pre graf-after--p">[3, 4, 6, 12]</pre><p name="b230" id="b230" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">二、二维列表 grid</strong></p><ol class="postList"><li name="f970" id="f970" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">二维列表的形式</strong></li></ol><p name="a9b5" id="a9b5" class="graf graf--p graf-after--li">二维列表就是有两个纬度的列表，相对于一维列表来说，二维列表中的每个元素也同样是一个列表。例如，我们有二维列表如下：</p><pre name="03e8" id="03e8" class="graf graf--pre graf-after--p">grid = [[1, 2], [3, 4], [5, 6]]</pre><p name="da3f" id="da3f" class="graf graf--p graf-after--pre">它可以被理解为下面的任何一种形式：</p><figure name="3a8a" id="3a8a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Q8MZ5cm9RXt4ulJ6oLa3AQ.png" data-width="1220" data-height="406" src="https://cdn-images-1.medium.com/max/800/1*Q8MZ5cm9RXt4ulJ6oLa3AQ.png"></figure><p name="97dc" id="97dc" class="graf graf--p graf-after--figure">类似地，如果我们在列表中再嵌套列表，那么我们将会得到三维四维以至于更高维度的列表。在这里我们不再赘述。</p><p name="3492" id="3492" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. 二维列表中元素的交换</strong></p><p name="14c7" id="14c7" class="graf graf--p graf-after--p">同样地，如果我们在二维列表中交换某两个元素，我们也不能够仅仅传递这两个元素，而是应该传递二维列表和索引。例如：</p><pre name="157c" id="157c" class="graf graf--pre graf-after--p">def swap(grid, row1, col1, row2, col2): <br>    temp = grid[row1][col1] <br>    grid[row1][col1] = grid[row2][col2] <br>    grid[row2][col2] = temp def </pre><pre name="d5ef" id="d5ef" class="graf graf--pre graf-after--pre">main():<br>    my_grid = [[10, 20, 30], [40, 50, 60]]<br>    swap (my_grid, 0, 1, 1, 2)<br>    print(my_grid)</pre><p name="2893" id="2893" class="graf graf--p graf-after--pre">输出的结果为：</p><pre name="a846" id="a846" class="graf graf--pre graf-after--p">[[10, 60, 30], [40, 50, 20]]</pre><p name="f94e" id="f94e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. 二维列表的循环</strong></p><p name="6a34" id="6a34" class="graf graf--p graf-after--p">二维列表的循环是通过range来实现的。在实现的同时需要运用到for语句的嵌套。例如：</p><pre name="5264" id="5264" class="graf graf--pre graf-after--p">def main():<br>     grid = [[10, 20], [40], [70, 80, 100]]<br>     rows = len(grid)<br>     for row in range(rows):<br>          cols = len(grid[row])<br>          for col in range(cols):<br>                 print(f&quot;grid[{row}][{col}] = {grid[row][col]}&quot;)</pre><p name="8ec2" id="8ec2" class="graf graf--p graf-after--pre">此外，也可以不通过range 来直接遍历。例如：</p><pre name="61d1" id="61d1" class="graf graf--pre graf-after--p">def main():<br>    grid = [[10, 20], [40], [70, 80, 100]]<br>    for row in grid:<br>         for col in row:<br>               print(col)</pre><p name="f5ad" id="f5ad" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">三、文本处理</strong></p><ol class="postList"><li name="ab53" id="ab53" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">文本的存储方式</strong></li></ol><p name="ed1f" id="ed1f" class="graf graf--p graf-after--li">我们在一开始就介绍了print函数的使用，现在我们来更加深入一些。在python中，文本的数据类型被称为字符串 String 。一个字符串是一系列的字符 Characters 所组成的。来看下面一段代码：</p><pre name="61df" id="61df" class="graf graf--pre graf-after--p">def main(): <br>    text = &quot;hello!&quot; <br>    print(text)</pre><p name="645c" id="645c" class="graf graf--p graf-after--pre">我们可以很明显地看出上面的函数会输出 hello! 作为结果，那么， hello! 这个字符串是如何在计算机中进行储存的呢？实际上，字符串 hello! 是储存在heap上的，在stack上我们储存的是text变量和一个指针，该指针指向了heap上的一个列表。这个列表中每个元素都是 hello! 中一个字符。如下图所示：</p><figure name="8ab4" id="8ab4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ePT_LCDRhTX3kyTW44mYSw.png" data-width="1552" data-height="370" src="https://cdn-images-1.medium.com/max/800/1*ePT_LCDRhTX3kyTW44mYSw.png"></figure><figure name="fbd6" id="fbd6" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*6o0phxm7PuENCInknZzNug.png" data-width="2086" data-height="370" src="https://cdn-images-1.medium.com/max/800/1*6o0phxm7PuENCInknZzNug.png"></figure><p name="a83f" id="a83f" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">2. 字符串的两种循环方式</strong></p><p name="4602" id="4602" class="graf graf--p graf-after--p">同样地，我们依然可以用两种方法来遍历字符串，第一种方法是利用range的方法：</p><pre name="7ea0" id="7ea0" class="graf graf--pre graf-after--p">for i in range(len(example)):<br>     ch = example[i] <br>     print(i, ch)</pre><p name="4c47" id="4c47" class="graf graf--p graf-after--pre">第二种方法是直接遍历的方法：</p><pre name="1735" id="1735" class="graf graf--pre graf-after--p">for ch in example: <br>     print(ch)</pre><p name="0519" id="0519" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. 关于字符串必须掌握的方法</strong></p><pre name="7d28" id="7d28" class="graf graf--pre graf-after--p">x = &#39;this is a Test &#39;</pre><ul class="postList"><li name="4535" id="4535" class="graf graf--li graf-after--pre">split方法：按照指定的参数划分元素组成列表</li></ul><pre name="4de8" id="4de8" class="graf graf--pre graf-after--li">x.split(&#39; &#39;)               # [&#39;this&#39;, &#39;is&#39;, &#39;a&#39;, &#39;Test&#39;]</pre><ul class="postList"><li name="0195" id="0195" class="graf graf--li graf-after--pre">upper方法：全部大写</li></ul><pre name="3233" id="3233" class="graf graf--pre graf-after--li">x.upper()                  # &#39;THIS IS A TEST &#39;</pre><ul class="postList"><li name="c46e" id="c46e" class="graf graf--li graf-after--pre">lower方法：全部小写</li></ul><pre name="19c1" id="19c1" class="graf graf--pre graf-after--li">x.lower()                  # &#39;this is a test &#39;</pre><ul class="postList"><li name="8f9e" id="8f9e" class="graf graf--li graf-after--pre">replace方法：用参数2替换全部参数1</li></ul><pre name="0263" id="0263" class="graf graf--pre graf-after--li">x.replace(&#39;is&#39;,&#39;lol&#39;)      # &#39;thlol lol a Test&#39;</pre><ul class="postList"><li name="970a" id="970a" class="graf graf--li graf-after--pre">find方法：某个字符串在原字符串中出现了几次</li></ul><pre name="86a2" id="86a2" class="graf graf--pre graf-after--li">x.find(&#39;is&#39;)               # 2</pre><ul class="postList"><li name="c01a" id="c01a" class="graf graf--li graf-after--pre">strip方法：默认移除首尾空格，也可以指定移除首尾其他字符</li></ul><pre name="dc82" id="dc82" class="graf graf--pre graf-after--li">x.strip()                  # &#39;this is a Test&#39;</pre><p name="e5cb" id="e5cb" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4. 关于字符串必须要了解的方法</strong></p><pre name="f1f5" id="f1f5" class="graf graf--pre graf-after--p">x = &#39;this is a Test &#39;</pre><ul class="postList"><li name="d313" id="d313" class="graf graf--li graf-after--pre">startswith方法：判断字符串是否是由指定参数开头</li></ul><pre name="a308" id="a308" class="graf graf--pre graf-after--li">x.startswith(&#39;th&#39;)        # True</pre><ul class="postList"><li name="62e2" id="62e2" class="graf graf--li graf-after--pre">endswith方法：判断字符串是否是由指定参数结尾</li></ul><pre name="dc64" id="dc64" class="graf graf--pre graf-after--li">x.endswith(&#39;th&#39;)          # False</pre><ul class="postList"><li name="ecf4" id="ecf4" class="graf graf--li graf-after--pre">title方法：每个单词首字母大写</li></ul><pre name="d327" id="d327" class="graf graf--pre graf-after--li">x.title()                 # &#39;This Is A Test &#39;</pre><ul class="postList"><li name="e49e" id="e49e" class="graf graf--li graf-after--pre">isalpha方法：检测字符串是否只由字母构成</li></ul><pre name="0b0f" id="0b0f" class="graf graf--pre graf-after--li">x.isalpha()              # False</pre><ul class="postList"><li name="ad24" id="ad24" class="graf graf--li graf-after--pre">isdigit方法：检测字符串是否只由数字构成</li></ul><pre name="bab3" id="bab3" class="graf graf--pre graf-after--li">&#39;521&#39;.isdigit()          # True</pre><ul class="postList"><li name="e949" id="e949" class="graf graf--li graf-after--pre">isspace方法：检测字符串是否只由空格构成</li></ul><pre name="133a" id="133a" class="graf graf--pre graf-after--li">&#39; &#39;.isspace()           # True</pre><p name="b84a" id="b84a" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">5. 字符串和列表的区别</strong></p><p name="5b7e" id="5b7e" class="graf graf--p graf-after--p">（1）字符串中的字符不能通过索引更改（通过索引输出是可以的，所以这个相当于可读不可写）</p><p name="1a75" id="1a75" class="graf graf--p graf-after--p">如果使用索引更改字符串中的字符，那么就会出现错误：</p><pre name="8348" id="8348" class="graf graf--pre graf-after--p">TypeError: &#39;str&#39; object does not support item assignment</pre><p name="1fda" id="1fda" class="graf graf--p graf-after--pre">例如，对于变量：</p><pre name="8d76" id="8d76" class="graf graf--pre graf-after--p">x = &#39;abc&#39;</pre><p name="0225" id="0225" class="graf graf--p graf-after--pre">如下图所示：</p><figure name="9223" id="9223" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vjga15rlxe9kuMDt4Hiw6g.png" data-width="1008" data-height="520" src="https://cdn-images-1.medium.com/max/800/1*vjga15rlxe9kuMDt4Hiw6g.png"></figure><p name="ad2e" id="ad2e" class="graf graf--p graf-after--figure">造成这一结果的原因是堆上的内容是不可更改的（unchangable），但是可以在堆上创建新的数值，然后重新指派给变量（reassignable）。如下图所示：</p><figure name="890b" id="890b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-q9upONFADMYGAQXowpfWA.png" data-width="1370" data-height="792" src="https://cdn-images-1.medium.com/max/800/1*-q9upONFADMYGAQXowpfWA.png"></figure><p name="73ec" id="73ec" class="graf graf--p graf-after--figure">（2）字符串是不可变变量 immutable ，列表是可变变量 mutable</p><p name="b362" id="b362" class="graf graf--p graf-after--p">这指的是列表在赋值的时候赋值的是地址，但是字符串赋值的时候是实际数据的一份拷贝。二者的区别是，a. 在函数的传参过程中，传递列表是可以改变原变量的，但是传递字符串不会导致原变量的任何改变；b. 在赋值语句中，用列表赋值后改变原列表的值，赋值后的列表的数值也改变，但是字符串赋值后原字符串改变并不会导致赋值后的字符串的改变。</p><p name="6c11" id="6c11" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">6. 字符串的串接</strong></p><p name="889d" id="889d" class="graf graf--p graf-after--p">我们刚才说到了，字符串是不可更改的。但是在实际的操作中，我们经常通过 + 运算符将两个字符串连接在一起。例如：</p><pre name="0622" id="0622" class="graf graf--pre graf-after--p">def main(): <br>    s1 = &quot;CS106&quot; <br>    s2 = &quot;A&quot; <br>    s3 = &quot;I got an &quot; + s2 + &quot; in &quot; + s1 + s2 </pre><pre name="650d" id="650d" class="graf graf--pre graf-after--pre">    print(s3)</pre><p name="adc2" id="adc2" class="graf graf--p graf-after--pre">会得到输出：</p><pre name="6f12" id="6f12" class="graf graf--pre graf-after--p">I got an A in CS106A</pre><p name="72f3" id="72f3" class="graf graf--p graf-after--pre">实际上，这种操作我们一般称为字符串的串接。在串接的过程中，堆上的字符串并没有被改变，而是每次串接的时候都会创建一个新的字符串，这就会避免上面的字符串不可更改的问题。</p><p name="7643" id="7643" class="graf graf--p graf-after--p">7. 转置字符串算法</p><p name="d57d" id="d57d" class="graf graf--p graf-after--p">我们刚才说到可以直接通过reverse对一串字符串进行转置。但是，我们有必要去探究这一方法在背后的算法。为了实现这一功能，通常来说最容易想到的方法就是将元素一个一个地得到，然后通过字符串的串接重新连接。例如：</p><pre name="7708" id="7708" class="graf graf--pre graf-after--p"># Swiss army knife pattern<br>def rev_str(s):</pre><pre name="99db" id="99db" class="graf graf--pre graf-after--pre">    result = &quot;&quot;<br>    <br>    for i in range(len(s)):<br>        result = s[i] + result</pre><pre name="de41" id="de41" class="graf graf--pre graf-after--pre">    return result</pre><p name="f714" id="f714" class="graf graf--p graf-after--pre">稍稍加以改进，我们也可以不通过索引得到字符，而是直接遍历。例如：</p><pre name="8345" id="8345" class="graf graf--pre graf-after--p"># Medium bear<br>def rev_str(s):</pre><pre name="d6a9" id="d6a9" class="graf graf--pre graf-after--pre">    result = &quot;&quot;<br>    <br>    for i in s:<br>        result = i + result</pre><pre name="05b1" id="05b1" class="graf graf--pre graf-after--pre">    return result</pre><p name="a6bc" id="a6bc" class="graf graf--p graf-after--pre">如果我们灵光一现，那么我们也可以用列表切片的特性进行转置。例如：</p><pre name="0bc3" id="0bc3" class="graf graf--pre graf-after--p graf--trailing"># One cool trick that will blow your mind<br>def rev_str(s):<br>    return s[::-1]</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/234df751cc25"><time class="dt-published" datetime="2020-08-14T06:34:27.949Z">August 14, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14-%E5%88%97%E8%A1%A8%E5%92%8C%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86-234df751cc25" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>