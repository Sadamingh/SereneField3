<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Python程序设计3 图像、图形、以及动画</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Python程序设计3 图像、图形、以及动画</h1>
</header>
<section data-field="subtitle" class="p-summary">
系列：Python程序设计
</section>
<section data-field="body" class="e-content">
<section name="5213" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="edc1" id="edc1" class="graf graf--h3 graf--leading graf--title">Python程序设计3 图像、图形、以及动画</h3><figure name="cfa1" id="cfa1" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*nMQTiDVkQq7j6ZlqQEKLbQ.jpeg" data-width="2689" data-height="1513" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*nMQTiDVkQq7j6ZlqQEKLbQ.jpeg"></figure><p name="1a13" id="1a13" class="graf graf--p graf-after--figure">一、图像</p><p name="cd4e" id="cd4e" class="graf graf--p graf-after--p">对于任何一个图像Image来说，它是由许多正方形的像素点Pixels组成的，每一个像素点是三种原色（RGB）的值叠加形成的（R = red; G = green; B = blue）。每一个数值表示的是三种颜色的亮度（Brightness，最大值为255），也就是 RGB = 0 0 0表示黑色，RGB = 255 255 255表示白色。</p><p name="5bd3" id="5bd3" class="graf graf--p graf-after--p">每一个二维图像相当于一个平面坐标系，其中，最左上角的第一个像素点被人为规定为坐标原点，如下图所示。我们也可以在线体会像素编辑的过程，比如，我们点击<a href="https://www.pixilart.com/draw" data-href="https://www.pixilart.com/draw" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">这里</a>，这个网站允许我们在线创作Pixel Arts。</p><figure name="a912" id="a912" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*47nlTv8wsPVXCjNGhYYU5w.png" data-width="1368" data-height="594" src="https://cdn-images-1.medium.com/max/800/1*47nlTv8wsPVXCjNGhYYU5w.png"></figure><ol class="postList"><li name="3714" id="3714" class="graf graf--li graf-after--figure">Pillow包</li></ol><p name="3b7d" id="3b7d" class="graf graf--p graf-after--li">Pillow是PIL库的一个版本，PIL库的全称为Python Image Library，它是一个开源的图片处理库。我们通过SimpleImage包来在Python中编辑图片。来自Stanford大学的Nick Parlante通过Pillow构造了SimpleImage包，因此在使用SimpleImage包之前，我们需要安装Pillow。</p><p name="b631" id="b631" class="graf graf--p graf-after--p">在OSX系统下，如果我们之前安装过anaconda或者其他python版本，这里可能会有一些问题。如果你遇到类似的安装问题，欢迎在下面留言。我们使用下面的语句进行安装：</p><pre name="d576" id="d576" class="graf graf--pre graf-after--p">python3 -m pip install Pillow</pre><p name="9901" id="9901" class="graf graf--p graf-after--pre">在安装正确的情况下，我们可以得到：</p><pre name="c96c" id="c96c" class="graf graf--pre graf-after--p">Collecting Pillow</pre><pre name="d90d" id="d90d" class="graf graf--pre graf-after--pre">Downloading Pillow-7.1.2-cp38-cp38-macosx_10_10_x86_64.whl (2.2 MB)</pre><pre name="d1d2" id="d1d2" class="graf graf--pre graf-after--pre">|████████████████████████████████| 2.2 MB 813 kB/s</pre><pre name="cb3e" id="cb3e" class="graf graf--pre graf-after--pre">Installing collected packages: Pillow</pre><pre name="7625" id="7625" class="graf graf--pre graf-after--pre">Successfully installed Pillow-7.1.2</pre><p name="8956" id="8956" class="graf graf--p graf-after--pre">2. 导入simpleimage包</p><p name="2900" id="2900" class="graf graf--p graf-after--p">我们之前说过，我们在后面的操作中需要使用simpleimage包，它是Stanford大学的教授基于Pillow编写的一个更为简单的图像处理包。这个包的内容如下，我们也可以点击<a href="http://web.stanford.edu/class/cs106a/lectures/9-Images/Lecture9.zip" data-href="http://web.stanford.edu/class/cs106a/lectures/9-Images/Lecture9.zip" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">这里</a>进行下载：</p><pre name="f1bb" id="f1bb" class="graf graf--pre graf-after--p">#!/usr/bin/env python3</pre><pre name="71d6" id="71d6" class="graf graf--pre graf-after--pre">&quot;&quot;&quot;<br>Stanford CS106AP SimpleImage</pre><pre name="994a" id="994a" class="graf graf--pre graf-after--pre">Written by Nick Parlante, Sonja Johnson-Yu, and Nick Bowman.<br> -7/2019  version, has file reading, pix, foreach, hidden get/setpix</pre><pre name="4f55" id="4f55" class="graf graf--pre graf-after--pre">SimpleImage Features:<br>Create image:<br>  image = SimpleImage.blank(400, 200)   # create new image of size<br>  image = SimpleImage(&#39;foo.jpg&#39;)        # create from file</pre><pre name="4e87" id="4e87" class="graf graf--pre graf-after--pre">Access size<br>  image.width, image.height</pre><pre name="db97" id="db97" class="graf graf--pre graf-after--pre">Get pixel at x,y<br>  pix = image.get_pixel(x, y)<br>  # pix is RGB tuple like (100, 200, 0)</pre><pre name="9539" id="9539" class="graf graf--pre graf-after--pre">Set pixel at x,y<br>  image.set_pixel(x, y, pix)   # set data by tuple also</pre><pre name="42c9" id="42c9" class="graf graf--pre graf-after--pre">Get Pixel object at x,y<br>  pixel = image.get_pixel(x, y)<br>  pixel.red = 0<br>  pixel.blue = 255</pre><pre name="efcc" id="efcc" class="graf graf--pre graf-after--pre">Show image on screen<br>  image.show()</pre><pre name="1dd8" id="1dd8" class="graf graf--pre graf-after--pre">The main() function below demonstrates the above functions as a test.<br>&quot;&quot;&quot;</pre><pre name="0fe0" id="0fe0" class="graf graf--pre graf-after--pre">import sys<br># If the following line fails, &quot;Pillow&quot; needs to be installed<br>from PIL import Image</pre><pre name="cdf7" id="cdf7" class="graf graf--pre graf-after--pre">def clamp(num):<br>    &quot;&quot;&quot;<br>    Return a &quot;clamped&quot; version of the given num,<br>    converted to be an int limited to the range 0..255 for 1 byte.<br>    &quot;&quot;&quot;<br>    num = int(num)<br>    if num &lt; 0:<br>        return 0<br>    if num &gt;= 256:<br>        return 255<br>    return num</pre><pre name="1502" id="1502" class="graf graf--pre graf-after--pre">class Pixel(object):<br>    &quot;&quot;&quot;<br>    A pixel at an x,y in a SimpleImage.<br>    Supports set/get .red .green .blue<br>    and get .x .y<br>    &quot;&quot;&quot;<br>    def __init__(self, image, x, y):<br>        self.image = image<br>        self._x = x<br>        self._y = y</pre><pre name="a3cb" id="a3cb" class="graf graf--pre graf-after--pre">def __str__(self):<br>        return &#39;r:&#39; + str(self.red) + &#39; g:&#39; + str(self.green) + &#39; b:&#39; + str(self.blue)</pre><pre name="1a2e" id="1a2e" class="graf graf--pre graf-after--pre"># Pillow image stores each pixel color as a (red, green, blue) tuple.<br>    # So the functions below have to unpack/repack the tuple to change anything.</pre><pre name="f0ca" id="f0ca" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/property" data-href="http://twitter.com/property" class="markup--anchor markup--pre-anchor" title="Twitter profile for @property" rel="noopener" target="_blank">@property</a><br>    def red(self):<br>        return self.image.px[self._x, self._y][0]</pre><pre name="7f57" id="7f57" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/red" data-href="http://twitter.com/red" class="markup--anchor markup--pre-anchor" title="Twitter profile for @red" rel="noopener" target="_blank">@red</a>.setter<br>    def red(self, value):<br>        rgb = self.image.px[self._x, self._y]<br>        self.image.px[self._x, self._y] = (clamp(value), rgb[1], rgb[2])</pre><pre name="33c7" id="33c7" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/property" data-href="http://twitter.com/property" class="markup--anchor markup--pre-anchor" title="Twitter profile for @property" rel="noopener" target="_blank">@property</a><br>    def green(self):<br>        return self.image.px[self._x, self._y][1]</pre><pre name="8355" id="8355" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/green" data-href="http://twitter.com/green" class="markup--anchor markup--pre-anchor" title="Twitter profile for @green" rel="noopener" target="_blank">@green</a>.setter<br>    def green(self, value):<br>        rgb = self.image.px[self._x, self._y]<br>        self.image.px[self._x, self._y] = (rgb[0], clamp(value), rgb[2])</pre><pre name="f034" id="f034" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/property" data-href="http://twitter.com/property" class="markup--anchor markup--pre-anchor" title="Twitter profile for @property" rel="noopener" target="_blank">@property</a><br>    def blue(self):<br>        return self.image.px[self._x, self._y][2]</pre><pre name="475c" id="475c" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/blue" data-href="http://twitter.com/blue" class="markup--anchor markup--pre-anchor" title="Twitter profile for @blue" rel="noopener" target="_blank">@blue</a>.setter<br>    def blue(self, value):<br>        rgb = self.image.px[self._x, self._y]<br>        self.image.px[self._x, self._y] = (rgb[0], rgb[1], clamp(value))</pre><pre name="1c8f" id="1c8f" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/property" data-href="http://twitter.com/property" class="markup--anchor markup--pre-anchor" title="Twitter profile for @property" rel="noopener" target="_blank">@property</a><br>    def x(self):<br>        return self._x</pre><pre name="8d97" id="8d97" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/property" data-href="http://twitter.com/property" class="markup--anchor markup--pre-anchor" title="Twitter profile for @property" rel="noopener" target="_blank">@property</a><br>    def y(self):<br>        return self._y</pre><pre name="d4b1" id="d4b1" class="graf graf--pre graf-after--pre"># color tuples for background color names &#39;red&#39; &#39;white&#39; etc.<br>BACK_COLORS = {<br>    &#39;white&#39;: (255, 255, 255),<br>    &#39;black&#39;: (0, 0, 0),<br>    &#39;red&#39;: (255, 0, 0),<br>    &#39;green&#39;: (0, 255, 0),<br>    &#39;blue&#39;: (0, 0, 255),<br>}</pre><pre name="92a2" id="92a2" class="graf graf--pre graf-after--pre">class SimpleImage(object):<br>    def __init__(self, filename, width=0, height=0, back_color=None):<br>        &quot;&quot;&quot;<br>        Create a new image. This case works: SimpleImage(&#39;foo.jpg&#39;)<br>        To create a blank image use SimpleImage.blank(500, 300)<br>        The other parameters here are for internal/experimental use.<br>        &quot;&quot;&quot;<br>        # Create pil_image either from file, or making blank<br>        if filename:<br>            self.pil_image = Image.open(filename).convert(&quot;RGB&quot;)<br>            if self.pil_image.mode != &#39;RGB&#39;:<br>                raise Exception(&#39;Image file is not RGB&#39;)<br>            self._filename = filename  # hold onto<br>        else:<br>            if not back_color:<br>                back_color = &#39;white&#39;<br>            color_tuple = BACK_COLORS[back_color]<br>            if width == 0 or height == 0:<br>                raise Exception(&#39;Creating blank image requires width/height but got {} {}&#39;<br>                                .format(width, height))<br>            self.pil_image = Image.new(&#39;RGB&#39;, (width, height), color_tuple)<br>        self.px = self.pil_image.load()<br>        size = self.pil_image.size<br>        self._width = size[0]<br>        self._height = size[1]<br>        self.curr_x = 0<br>        self.curr_y = 0</pre><pre name="a824" id="a824" class="graf graf--pre graf-after--pre">def __iter__(self):<br>        return self</pre><pre name="c6d0" id="c6d0" class="graf graf--pre graf-after--pre">def __next__(self):<br>        if self.curr_x &lt; self.width and self.curr_y &lt; self.height:<br>            x = self.curr_x<br>            y = self.curr_y<br>            self.increment_curr_counters()<br>            return Pixel(self, x, y)<br>        else:<br>            self.curr_x = 0<br>            self.curr_y = 0<br>            raise StopIteration()</pre><pre name="dc33" id="dc33" class="graf graf--pre graf-after--pre">def increment_curr_counters(self):<br>        self.curr_x += 1<br>        if self.curr_x == self.width:<br>            self.curr_x = 0<br>            self.curr_y += 1</pre><pre name="5eb4" id="5eb4" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/classmethod" data-href="http://twitter.com/classmethod" class="markup--anchor markup--pre-anchor" title="Twitter profile for @classmethod" rel="noopener" target="_blank">@classmethod</a><br>    def blank(cls, width, height, back_color=None):<br>        &quot;&quot;&quot;Create a new blank image of the given width and height, optional back_color.&quot;&quot;&quot;<br>        return SimpleImage(&#39;&#39;, width, height, back_color=back_color)</pre><pre name="7a4d" id="7a4d" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/classmethod" data-href="http://twitter.com/classmethod" class="markup--anchor markup--pre-anchor" title="Twitter profile for @classmethod" rel="noopener" target="_blank">@classmethod</a><br>    def file(cls, filename):<br>        &quot;&quot;&quot;Create a new image based on a file, alternative to raw constructor.&quot;&quot;&quot;<br>        return SimpleImage(filename)</pre><pre name="b6e0" id="b6e0" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/property" data-href="http://twitter.com/property" class="markup--anchor markup--pre-anchor" title="Twitter profile for @property" rel="noopener" target="_blank">@property</a><br>    def width(self):<br>        &quot;&quot;&quot;Width of image in pixels.&quot;&quot;&quot;<br>        return self._width</pre><pre name="4911" id="4911" class="graf graf--pre graf-after--pre"><a href="http://twitter.com/property" data-href="http://twitter.com/property" class="markup--anchor markup--pre-anchor" title="Twitter profile for @property" rel="noopener" target="_blank">@property</a><br>    def height(self):<br>        &quot;&quot;&quot;Height of image in pixels.&quot;&quot;&quot;<br>        return self._height</pre><pre name="f2f4" id="f2f4" class="graf graf--pre graf-after--pre">def get_pixel(self, x, y):<br>        &quot;&quot;&quot;<br>        Returns a Pixel at the given x,y, suitable for getting/setting<br>        .red .green .blue values.<br>        &quot;&quot;&quot;<br>        if x &lt; 0 or x &gt;= self._width or y &lt; 0 or y &gt;= self.height:<br>            e = Exception(&#39;get_pixel bad coordinate x %d y %d (vs. image width %d height %d)&#39; %<br>                          (x, y, self._width, self.height))<br>            raise e<br>        return Pixel(self, x, y)</pre><pre name="0f6c" id="0f6c" class="graf graf--pre graf-after--pre">def set_pixel(self, x, y, pixel):<br>        if x &lt; 0 or x &gt;= self._width or y &lt; 0 or y &gt;= self.height:<br>            e = Exception(&#39;set_pixel bad coordinate x %d y %d (vs. image width %d height %d)&#39; %<br>                          (x, y, self._width, self.height))<br>            raise e<br>        self.px[x, y] = (pixel.red, pixel.green, pixel.blue)</pre><pre name="1083" id="1083" class="graf graf--pre graf-after--pre">def set_rgb(self, x, y, red, green, blue):<br>        &quot;&quot;&quot;<br>        Set the pixel at the given x,y to have<br>        the given red/green/blue values without<br>        requiring a separate pixel object.<br>        &quot;&quot;&quot;<br>        self.px[x, y] = (red, green, blue)</pre><pre name="42ba" id="42ba" class="graf graf--pre graf-after--pre">def _get_pix_(self, x, y):<br>        &quot;&quot;&quot;Get pix RGB tuple (200, 100, 50) for the given x,y.&quot;&quot;&quot;<br>        return self.px[x, y]</pre><pre name="6e38" id="6e38" class="graf graf--pre graf-after--pre">def _set_pix_(self, x, y, pix):<br>        &quot;&quot;&quot;Set the given pix RGB tuple into the image at the given x,y.&quot;&quot;&quot;<br>        self.px[x, y] = pix</pre><pre name="5470" id="5470" class="graf graf--pre graf-after--pre">def show(self):<br>        &quot;&quot;&quot;Displays the image using an external utility.&quot;&quot;&quot;<br>        self.pil_image.show()</pre><pre name="adae" id="adae" class="graf graf--pre graf-after--pre">def make_as_big_as(self, image):<br>        &quot;&quot;&quot;Resizes image to the shape of the given image&quot;&quot;&quot;<br>        self.pil_image = self.pil_image.resize((image.width, image.height))<br>        self.px = self.pil_image.load()<br>        size = self.pil_image.size<br>        self._width = size[0]<br>        self._height = size[1]</pre><pre name="06ee" id="06ee" class="graf graf--pre graf-after--pre">def main():<br>    &quot;&quot;&quot;<br>    main() exercises the features as a test.<br>    1. With 1 arg like flowers.jpg - opens it<br>    2. With 0 args, creates a yellow square with<br>    a green stripe at the right edge.<br>    &quot;&quot;&quot;<br>    args = sys.argv[1:]<br>    if len(args) == 1:<br>        image = SimpleImage.file(args[0])<br>        image.show()<br>        return</pre><pre name="40b4" id="40b4" class="graf graf--pre graf-after--pre"># Create yellow rectangle, using foreach iterator<br>    image = SimpleImage.blank(400, 200)<br>    for pixel in image:<br>        pixel.red = 255<br>        pixel.green = 255<br>        pixel.blue = 0</pre><pre name="6c65" id="6c65" class="graf graf--pre graf-after--pre"># for pixel in image:<br>    #     print(pixel)</pre><pre name="8f32" id="8f32" class="graf graf--pre graf-after--pre"># Set green stripe using pix access.<br>    pix = image._get_pix_(0, 0)<br>    green = (0, pix[1], 0)<br>    for x in range(image.width - 10, image.width):<br>        for y in range(image.height):<br>            image._set_pix_(x, y, green)<br>    image.show()</pre><pre name="5c1d" id="5c1d" class="graf graf--pre graf-after--pre">if __name__ == &#39;__main__&#39;:<br>    main()</pre><p name="41b1" id="41b1" class="graf graf--p graf-after--pre">我们将这个文件重新命名为simpleimage.py之后，保存到环境目录下，这样可以保证每次运行Python3.8的时候都会检索这一文件。导入该文件到环境目录的方法如下。</p><p name="ea86" id="ea86" class="graf graf--p graf-after--p">我们先打开terminal，之后输入python3：</p><pre name="9e69" id="9e69" class="graf graf--pre graf-after--p">python3</pre><p name="15ac" id="15ac" class="graf graf--p graf-after--pre">在正常情况下，我们会得到输出：</p><pre name="3429" id="3429" class="graf graf--pre graf-after--p">Python 3.8.1 (v3.8.1:1b293b6006, Dec 18 2019, 14:08:53)</pre><pre name="bede" id="bede" class="graf graf--pre graf-after--pre">[Clang 6.0 (clang-600.0.57)] on darwin</pre><pre name="bb2e" id="bb2e" class="graf graf--pre graf-after--pre">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</pre><pre name="a228" id="a228" class="graf graf--pre graf-after--pre">&gt;&gt;&gt;</pre><p name="b822" id="b822" class="graf graf--p graf-after--pre">在下面我们输入：</p><pre name="bf2f" id="bf2f" class="graf graf--pre graf-after--p">&gt;&gt;&gt; import sys</pre><p name="cf52" id="cf52" class="graf graf--p graf-after--pre">之后我们再输入：</p><pre name="fdd4" id="fdd4" class="graf graf--pre graf-after--p">&gt;&gt;&gt; sys.prefix</pre><p name="c7e8" id="c7e8" class="graf graf--p graf-after--pre">通过这一指令，我们可以得到Python3.8版本的&lt;path_prefix&gt;路径。在Python3的运行过程中，它会自动检索三个路径以获得所依赖的文件，他们分别是：</p><ol class="postList"><li name="1735" id="1735" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">&lt;path_prefix&gt;/lib</code>（标准库路径）</li><li name="48c2" id="48c2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">&lt;path_prefix&gt;/lib/pythonX.Y/site-packages</code>（三方库路径，X.Y是对应Python的主次版本号，如3.7, 2.6）</li><li name="5061" id="5061" class="graf graf--li graf-after--li">当前工作目录（<code class="markup--code markup--li-code">pwd</code>命令的返回结果）</li></ol><p name="493c" id="493c" class="graf graf--p graf-after--li">示意图为：</p><figure name="bb5e" id="bb5e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*l_tnDpAN5VQoQjRtP70ElA.png" data-width="1612" data-height="416" src="https://cdn-images-1.medium.com/max/800/1*l_tnDpAN5VQoQjRtP70ElA.png"></figure><p name="4d04" id="4d04" class="graf graf--p graf-after--figure">我们可以将我们刚才通过下载或者保存上面代码得到的simpleimage.py文件保存到site-packages目录下来引用这一文件。我们执行下面的代码（需要将&lt;path&gt;替换为对应的路径）：</p><pre name="2db0" id="2db0" class="graf graf--pre graf-after--p">mv &lt;path&gt;/simpleimage.py <code class="markup--code markup--pre-code">&lt;path_prefix&gt;/lib/python3.8/site-packages</code></pre><p name="aec4" id="aec4" class="graf graf--p graf-after--pre">3. 图像I/O</p><p name="3b17" id="3b17" class="graf graf--p graf-after--p">在使用simpleimage包之前，我们要先导入这个包。</p><pre name="ee36" id="ee36" class="graf graf--pre graf-after--p">from simpleimage import SimpleImage</pre><p name="e77f" id="e77f" class="graf graf--p graf-after--pre">SimpleImage()函数指的是将一个图片导入为一个像素图像对象。</p><pre name="093e" id="093e" class="graf graf--pre graf-after--p">my_image = SimpleImage(filename)</pre><p name="c907" id="c907" class="graf graf--p graf-after--pre">对于SimpleImage对象的show()方法可以将图像输出到电脑显示器上。</p><pre name="7879" id="7879" class="graf graf--pre graf-after--p">my_image.show()</pre><p name="0bb8" id="0bb8" class="graf graf--p graf-after--pre">4. 遍历像素点并编辑</p><p name="f56b" id="f56b" class="graf graf--p graf-after--p">类似于通过range()函数来进行循环，我们可以通过下面的Python语句来遍历某个SimpleImage对象的全部像素点：</p><pre name="17fa" id="17fa" class="graf graf--pre graf-after--p">for pixel in my_image:</pre><p name="b14e" id="b14e" class="graf graf--p graf-after--pre">对于每一个像素点，我们通过三个颜色的组合来决定这一点的颜色，分别是RED，GREEN，以及BLUE。每一个pixel变量都具有这三个常数（范围是0～255，表示亮度Brightness），我们可以通过调用pixel中的这三个变量来修改某像素点的颜色和亮度。</p><p name="51ba" id="51ba" class="graf graf--p graf-after--p">（1）调整亮度算法</p><p name="6cac" id="6cac" class="graf graf--p graf-after--p">如果我们想要将一个图片的亮度降低，我们可以通过下面的代码来实现：</p><pre name="f3a1" id="f3a1" class="graf graf--pre graf-after--p">pixel.red = pixel.red // 2<br>pixel.green = pixel.green // 2<br>pixel.blue = pixel.blue // 2</pre><p name="971e" id="971e" class="graf graf--p graf-after--pre">（2）调整单一颜色算法</p><p name="9c80" id="9c80" class="graf graf--p graf-after--p">另外，如果我们想要将一个图片变为某单三原色的图片（例如RedChannel，只有红色），我们可以通过将其他两个参数设为0来实现：</p><pre name="1307" id="1307" class="graf graf--pre graf-after--p">pixel.green = 0<br>pixel.blue = 0</pre><p name="a51e" id="a51e" class="graf graf--p graf-after--pre">（3）调整为灰度算法</p><p name="a9fa" id="a9fa" class="graf graf--p graf-after--p">此外，如果我们想要将一个图片变为灰度图，我们需要将每个像素点的数值相加之后除以3。这样做的原因是，由于RGB的三个数值表示的是三基色的亮度，而RGB = 0 0 0表示哦黑色，GRB = 255 255 255表示白色，因此在R = G = B的情况下，介于 0 0 0 和 255 255 255 之间的数值都是灰色的。因此，将三个数值相加后除以3表示了不同亮度的灰色，剔除了颜色的信息。</p><pre name="1164" id="1164" class="graf graf--pre graf-after--p">avg_pixel = (pixel.red + pixel.green + pixel.blue) // 3<br>pixel.red = avg_pixel<br>pixel.green = avg_pixel<br>pixel.blue = avg_pixel</pre><p name="26af" id="26af" class="graf graf--p graf-after--pre">（4）替换GreenScreening算法</p><p name="37d6" id="37d6" class="graf graf--p graf-after--p">Green Screening的名字来自于电影，在拍摄电影的时候，如果制片人想要改变电影的背景，那么他们往往要使用的绿色作为背景，之后再将背景完全删除，替换成为所需要的背景。我们可以用simpleimage包对图片实现类似的功能。</p><p name="dddc" id="dddc" class="graf graf--p graf-after--p">在实际的操作中，对于什么程度的绿色算是绿色是需要预先进行判断的，我们需要设置一个“足够绿”（Sufficiently Green）的标准。这个足够绿的标准和两个变量相关，分别是这一像素点的灰度（它表示了这一点亮度的相对数值）和这一像素点的绿的程度（又被成为强度阈值Intensity Threshold，它指的是这一点的绿色和其他两种颜色相比较更亮的程度，这个数值是人为给定的）。</p><p name="ff3f" id="ff3f" class="graf graf--p graf-after--p">x和y是每个pixel点的两个坐标，分别表示的是横坐标和纵坐标。我们可以通过SimpleImage对象的get_pixel方法，通过已知的坐标调用某个像素点，例如：</p><pre name="9e1f" id="9e1f" class="graf graf--pre graf-after--p">my_image.get_pixel(x,y)</pre><p name="1314" id="1314" class="graf graf--p graf-after--pre">另外，我们也可以将一个像素点的数值赋值给另一个像素点。我们可以使用set_pixel方法。该方法的调用方式如下：</p><pre name="c0fa" id="c0fa" class="graf graf--pre graf-after--p">image.set_pixel(x, y, my_image.get_pixel(x, y))</pre><p name="938b" id="938b" class="graf graf--p graf-after--pre">通过Sufficiently Green以及get_pixel和set_pixel方法，我们可以实现类似于Green Screening的功能。</p><pre name="d8ca" id="d8ca" class="graf graf--pre graf-after--p">INTENSITY_THRESHOLD = 1.6</pre><pre name="f031" id="f031" class="graf graf--pre graf-after--pre">def greenscreen(main_filename, back_filename):<br>    image = SimpleImage(main_filename)<br>    back = SimpleImage(back_filename)<br><br>    for pixel in image:<br>        average = (pixel.red + pixel.green + pixel.blue) // 3<br>        # See if this pixel is &quot;sufficiently&quot; green<br><br>        if pixel.green &gt;= average * INTENSITY_THRESHOLD:<br>            # If so, overwrite pixel in original image with<br>            # corresponding pixel from the back image.<br>            x = pixel.x<br>            y = pixel.y<br>            image.set_pixel(x, y, back.get_pixel(x, y))<br><br><br>    return image</pre><p name="bdb5" id="bdb5" class="graf graf--p graf-after--pre">（5）镜像算法</p><p name="5e38" id="5e38" class="graf graf--p graf-after--p">同样地，我们也可以使用上面的get_pixel和set_pixel方法来实现图像的镜像翻转功能（当然也可以实现旋转图像等功能，但是我们不会在这里进行介绍）。在进行翻转之前，我们不得不先知道这个图像的长和宽分别是多少（如果我们不能知道长和宽的话，我们就没有办法进行按行或者列遍历）。我们可以通过调用SimpleImage对象的width和height常数来得到图像的长和宽。</p><pre name="3f11" id="3f11" class="graf graf--pre graf-after--p">width = image.width<br>height = image.height</pre><p name="b500" id="b500" class="graf graf--p graf-after--pre">通过图像的长和宽，我们可以通过SimpleImage.blank(width, height)函数创建一个空白的和原图像同样大小的画布：</p><pre name="c5cb" id="c5cb" class="graf graf--pre graf-after--p">mirror = SimpleImage.blank(width, height)</pre><p name="ad8f" id="ad8f" class="graf graf--p graf-after--pre">通过上面的介绍，我们的镜像算法如下所示。</p><pre name="6eb8" id="6eb8" class="graf graf--pre graf-after--p">def mirror_image(filename):<br><em class="markup--em markup--pre-em"><br>    </em>image = SimpleImage(filename)<br>    width = image.width<br>    height = image.height<br><br>    # Create new image to contain mirror reflection<br>    mirror = SimpleImage.blank(width, height)<br><br>    for y in range(height):<br>        for x in range(width):<br>            pixel = image.get_pixel(x, y)<br>            mirror.set_pixel(width - (x + 1), y, pixel)<br>    return mirror</pre><p name="8758" id="8758" class="graf graf--p graf-after--pre">（6）调整为浅棕色调 Sepia Tone</p><p name="c2de" id="c2de" class="graf graf--p graf-after--p">有的时候，我们并不是想要单纯的灰度图片，我们想要添加滤镜，例如 我们想要如下所示的Sepia Tone色调。我们可以通过StackOverFlow上面给出的<a href="https://stackoverflow.com/questions/1061093/how-is-a-sepia-tone-created" data-href="https://stackoverflow.com/questions/1061093/how-is-a-sepia-tone-created" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">算法</a>来构造这个滤镜。</p><figure name="a155" id="a155" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_GeUQ8a1UxF3uA6lGeXU5Q.png" data-width="1368" data-height="698" src="https://cdn-images-1.medium.com/max/800/1*_GeUQ8a1UxF3uA6lGeXU5Q.png"></figure><p name="fde9" id="fde9" class="graf graf--p graf-after--figure">该算法的代码如下：</p><pre name="ad56" id="ad56" class="graf graf--pre graf-after--p">R = pixel.red<br>G = pixel.green<br>B = pixel.blue<br>pixel.red = 0.393 * R + 0.769 * G + 0.189 * B<br>pixel.green = 0.349 * R + 0.686 * G + 0.168 * B<br>pixel.blue = 0.272 * R + 0.534 * G + 0.131 * B</pre><p name="6d42" id="6d42" class="graf graf--p graf-after--pre">二、图形</p><p name="b7ee" id="b7ee" class="graf graf--p graf-after--p">为了能够更深入地了解如何在Python3中创建图形，我们先要使用tkinter包，它是python在电脑上的标准图形接口。由于tkinter和python是绑定的，因此我们不需要再手动安装tkinter，而是直接调用tkinter包即可。</p><p name="a219" id="a219" class="graf graf--p graf-after--p">下面是一段示例代码，除了tkinter包的引用之外，我们还定义了一个名为make_canvas()的函数，通过这个函数，我们可以更容易地创建canvas对象。在使用这个示例代码的时候，我们不需要改变DO NOT MODIFY ANY CODE BELOW THIS LINE之后的任何内容。</p><pre name="ead6" id="ead6" class="graf graf--pre graf-after--p">import tkinter</pre><pre name="87ad" id="87ad" class="graf graf--pre graf-after--pre">def main():</pre><pre name="e0fd" id="e0fd" class="graf graf--pre graf-after--pre">######Code starts from here######<br>######Code ends here######</pre><pre name="50ae" id="50ae" class="graf graf--pre graf-after--pre"><br>######## DO NOT MODIFY ANY CODE BELOW THIS LINE ###########<br><br># This function is provided to you and should not be modified.<br># It creates a window that contains a drawing canvas that you<br># will use to make your drawings.<br>def make_canvas(width, height, title):<br>    <em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>    DO NOT MODIFY<br>    Creates and returns a drawing canvas<br>    of the given int size with a blue border,<br>    ready for drawing.<br>    &quot;&quot;&quot;<br>    </em>objects = {}<br>    top = tkinter.Tk()<br>    top.minsize(width=width, height=height)<br>    top.title(title)<br>    canvas = tkinter.Canvas(top, width=width + 1, height=height + 1)<br>    canvas.pack()<br>    canvas.xview_scroll(8, &#39;units&#39;)  # add this so (0, 0) works correctly<br>    canvas.yview_scroll(8, &#39;units&#39;)  # otherwise it&#39;s clipped off<br><br>    canvas.bind(&quot;&lt;Button-1&gt;&quot;, lambda e: mouse_pressed(e,canvas))<br>    return canvas<br><br>if __name__ == &#39;__main__&#39;:<br>    main()</pre><ol class="postList"><li name="39db" id="39db" class="graf graf--li graf-after--pre">画一个长方形</li></ol><p name="c022" id="c022" class="graf graf--p graf-after--li">我们按照下面的步骤来绘制一个长方形。</p><p name="3710" id="3710" class="graf graf--p graf-after--p">1）绘制画布</p><p name="f9e2" id="f9e2" class="graf graf--p graf-after--p">通过下面的命令，我们可以创建一个800 x 200的canvas，并且这个canvas对象的名称被指明为Hello Rect。</p><pre name="8967" id="8967" class="graf graf--pre graf-after--p">canvas = make_canvas(800, 200, &#39;Hello Rect&#39;)</pre><figure name="1595" id="1595" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*rP7mQcJLm9lBFfIVjh1GTw.png" data-width="1552" data-height="466" src="https://cdn-images-1.medium.com/max/800/1*rP7mQcJLm9lBFfIVjh1GTw.png"></figure><figure name="f0de" id="f0de" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*yDERO90oGcxrZqYXLKXufQ.png" data-width="1552" data-height="466" src="https://cdn-images-1.medium.com/max/800/1*yDERO90oGcxrZqYXLKXufQ.png"></figure><figure name="33fd" id="33fd" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*w-luUYihQwkmdE5N2KefXg.png" data-width="1552" data-height="466" src="https://cdn-images-1.medium.com/max/800/1*w-luUYihQwkmdE5N2KefXg.png"></figure><figure name="3d2a" id="3d2a" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*yWXax_tqDcKljF9gKzo_fw.png" data-width="1552" data-height="466" src="https://cdn-images-1.medium.com/max/800/1*yWXax_tqDcKljF9gKzo_fw.png"></figure><p name="e322" id="e322" class="graf graf--p graf-after--figure">2）绘制长方形</p><p name="d1aa" id="d1aa" class="graf graf--p graf-after--p">下面的指令帮助我们绘制一个对角线左上端点和右下端点分别位于(20,20)以及(100,100)的长方形，并且，这个长方形的颜色将会被填充为蓝色。</p><pre name="ab08" id="ab08" class="graf graf--pre graf-after--p">canvas.create_rectangle(20, 20, 100, 100, fill=&quot;blue&quot;)</pre><figure name="8cd0" id="8cd0" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*Q7dAmyyUVt3jih7K4XfxGQ.png" data-width="1552" data-height="466" src="https://cdn-images-1.medium.com/max/800/1*Q7dAmyyUVt3jih7K4XfxGQ.png"></figure><figure name="f3bc" id="f3bc" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*5HLspiE4XH4xLks-UbX1jQ.png" data-width="1492" data-height="460" src="https://cdn-images-1.medium.com/max/800/1*5HLspiE4XH4xLks-UbX1jQ.png"></figure><figure name="c83e" id="c83e" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*svowerLArR1YlIY9-1A__A.png" data-width="1254" data-height="398" src="https://cdn-images-1.medium.com/max/800/1*svowerLArR1YlIY9-1A__A.png"></figure><p name="4d7c" id="4d7c" class="graf graf--p graf-after--figure">如果我们不给出fill后面的参数，那么在默认情况下，矩形将会被填充为白色。</p><figure name="3c48" id="3c48" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*wvalXMsnKxTiacr1ON3Vzw.png" data-width="1222" data-height="398" src="https://cdn-images-1.medium.com/max/800/1*wvalXMsnKxTiacr1ON3Vzw.png"></figure><p name="aa9f" id="aa9f" class="graf graf--p graf-after--figure">3）保持canvas输出不变</p><p name="6fa3" id="6fa3" class="graf graf--p graf-after--p">canvas的编辑是一次性的，在canvas对象产生变化语句执行的过程中，我们并不能够在显示器上实际看到当前canvas对象的输出。因此，我们需要通过下面的mainloop()方法维持canvas对象的输出。</p><pre name="07e2" id="07e2" class="graf graf--pre graf-after--p">canvas.mainloop()</pre><p name="3f3c" id="3f3c" class="graf graf--p graf-after--pre">综上所述，我们可以通过下面的代码在Python3中输出一个矩形：</p><pre name="26b5" id="26b5" class="graf graf--pre graf-after--p">import tkinter<br><br>def main():<br>    canvas = make_canvas(800, 200, &#39;Hello Rect&#39;)<br>    canvas.create_rectangle(20, 20, 100, 100, fill=&quot;blue&quot;)<br>    canvas.mainloop()<br><br>def make_canvas(width, height, title=None):<br>    <em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>    DO NOT MODIFY<br>    Creates and returns a drawing canvas<br>    of the given int size with a blue border,<br>    ready for drawing.<br>    &quot;&quot;&quot;<br>    </em>objects = {}<br>    top = tkinter.Tk()<br>    top.minsize(width=width, height=height)<br>    if title:<br>        top.title(title)<br>    canvas = tkinter.Canvas(top, width=width + 1, height=height + 1)<br>    canvas.pack()<br>    canvas.xview_scroll(8, &#39;units&#39;)  # add this so (0, 0) works correctly<br>    canvas.yview_scroll(8, &#39;units&#39;)  # otherwise it&#39;s clipped off<br><br>    return canvas<br><br>if __name__ == &#39;__main__&#39;:<br>    main()</pre><p name="879c" id="879c" class="graf graf--p graf-after--pre">2. 画一条线</p><p name="e6f2" id="e6f2" class="graf graf--p graf-after--p">如果要在canvas对象上绘制一条线，我们就需要使用canvas.create_line()函数。由于平面上面的两个点可以确定一条线段，因此，给定两个平面上的坐标(x1, y1)和(x2, y2)就可以绘制出一条位于两个点之间的线段。例如下面的代码：</p><pre name="9f26" id="9f26" class="graf graf--pre graf-after--p">canvas.create_line(x1, y1, x2, y2)</pre><figure name="4b00" id="4b00" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*_gMNAuWOugx4CgiJ36dUwA.png" data-width="1404" data-height="216" src="https://cdn-images-1.medium.com/max/800/1*_gMNAuWOugx4CgiJ36dUwA.png"></figure><p name="9f70" id="9f70" class="graf graf--p graf-after--figure">3. 画一个椭圆形</p><p name="e452" id="e452" class="graf graf--p graf-after--p">如果需要在canvas对象上面绘制一个椭圆形，那么我们就需要函数canvas.create_oval()。由于椭圆可以内切于一个矩形，因此我们只需要给出一个椭圆的外接矩形的对角线上两端的坐标，就可以确定一个椭圆形。例如下面的代码：</p><pre name="8e11" id="8e11" class="graf graf--pre graf-after--p">canvas.create_oval(x1, y1, x2, y2)</pre><figure name="92ee" id="92ee" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*ZXI_ILnePWU8hfGnJP9upQ.png" data-width="1202" data-height="438" src="https://cdn-images-1.medium.com/max/800/1*ZXI_ILnePWU8hfGnJP9upQ.png"></figure><p name="e572" id="e572" class="graf graf--p graf-after--figure">4. 输入文本</p><p name="41f1" id="41f1" class="graf graf--p graf-after--p">如果需要输入文本内容，我们需要给出文本给出文本的中心点的坐标。例如下面的代码表示了以坐标(x1, y1)为中心的，以字符hi为内容的文本。</p><pre name="a74a" id="a74a" class="graf graf--pre graf-after--p">canvas.create_text(x, y, text=’hi’)</pre><figure name="2ce1" id="2ce1" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*qEIzKgw3CeHkvAku8Kac7g.png" data-width="1294" data-height="236" src="https://cdn-images-1.medium.com/max/800/1*qEIzKgw3CeHkvAku8Kac7g.png"></figure><p name="e5bc" id="e5bc" class="graf graf--p graf-after--figure">另外，我们也可以通过指定anchor的参数来调整给定的坐标表示的位置。例如，如果我们像下面的语句一样指定anchor参数为’w’，那么我们锚点将被确定为字符hi左侧的中间位置。</p><pre name="9401" id="9401" class="graf graf--pre graf-after--p">canvas.create_text(x, y, text=’hi’, anchor=&#39;w&#39;)</pre><figure name="2e6d" id="2e6d" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*OgqW9oRlL4WlXzXdFp0F1A.png" data-width="1294" data-height="236" src="https://cdn-images-1.medium.com/max/800/1*OgqW9oRlL4WlXzXdFp0F1A.png"></figure><p name="2a56" id="2a56" class="graf graf--p graf-after--figure">5. 等一等，还有一个问题</p><p name="a6e7" id="a6e7" class="graf graf--p graf-after--p">我们在之前的说明中并没有说明canvas变量在函数间调用的过程。我们知道，如果我们调用一个通常变量，那么在调用这个变量的时候，实际上是得到了这个函数的一个copy。那也就意味着除非我们返回值（return）给原来的变量，否则原来的变量值不会发生改变。</p><p name="876a" id="876a" class="graf graf--p graf-after--p">但是在使用canvas变量的时候，我们在函数间调用的canvas变量并不是一个拷贝，而是类似于Web中URL的东西。因为是这个指向该canvas变量的URL得到了copy，因此在函数内改变canvas上面的内容，canvas上面的内容也会随之改变。</p><p name="8beb" id="8beb" class="graf graf--p graf-after--p">比如下面的一段代码：</p><pre name="72fd" id="72fd" class="graf graf--pre graf-after--p">def main():<br>    canvas = make_canvas(…)<br>    draw_square(canvas)<br>    <br>def draw_square(canvas):<br>    canvas.create_rectangle(20, 20, 100, 100)</pre><p name="409a" id="409a" class="graf graf--p graf-after--pre">1）执行 def main():</p><p name="80a7" id="80a7" class="graf graf--p graf-after--p">python在stack中创建一个名字为main的函数。</p><figure name="bb57" id="bb57" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Ipvnci9_3Mpla6eplPsjCg.png" data-width="1782" data-height="480" src="https://cdn-images-1.medium.com/max/800/1*Ipvnci9_3Mpla6eplPsjCg.png"></figure><p name="3503" id="3503" class="graf graf--p graf-after--figure">2）执行 canvas = make_canvas(…)</p><p name="75b8" id="75b8" class="graf graf--p graf-after--p">python创建了一个canvas变量，在我们的例子中，我们抽象认为这个canvas变量是有一个类似于URL的值memory.com/42（实际上这个并没任何含义，只是一个例子）。这个canvas变量是存储在heap上的数据。</p><figure name="89b1" id="89b1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*l86ZAFJA2i6HAf3MyOaVIQ.png" data-width="1782" data-height="598" src="https://cdn-images-1.medium.com/max/800/1*l86ZAFJA2i6HAf3MyOaVIQ.png"></figure><p name="37fa" id="37fa" class="graf graf--p graf-after--figure">3）执行 draw_square(canvas)和def draw_square(canvas):</p><p name="2d8e" id="2d8e" class="graf graf--p graf-after--p">python调用draw_square(canvas)函数并且将draw_square函数入栈。在这个过程中，draw_square函数得到的是一个URL而不是一个copy，因此对这个URL内变量的操作仍然是</p><figure name="c794" id="c794" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_8bn9HkcntqiwKc0k7pSGA.png" data-width="1482" data-height="570" src="https://cdn-images-1.medium.com/max/800/1*_8bn9HkcntqiwKc0k7pSGA.png"></figure><figure name="8ed6" id="8ed6" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*Q6airUz32mWFhvS1n5flyQ.png" data-width="1468" data-height="548" src="https://cdn-images-1.medium.com/max/800/1*Q6airUz32mWFhvS1n5flyQ.png"></figure><p name="dd87" id="dd87" class="graf graf--p graf-after--figure">4）执行canvas.create_rectangle(20, 20, 100, 100)</p><p name="f857" id="f857" class="graf graf--p graf-after--p">调用这个指令，在canvas变量上绘制一个矩形。</p><figure name="977a" id="977a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*pzO9AxQqmu3E8Y_QU2U_Kg.png" data-width="1512" data-height="470" src="https://cdn-images-1.medium.com/max/800/1*pzO9AxQqmu3E8Y_QU2U_Kg.png"></figure><p name="b5fe" id="b5fe" class="graf graf--p graf-after--figure">5）draw_square的出栈</p><p name="883c" id="883c" class="graf graf--p graf-after--p">draw_square函数程序执行完毕后会出栈。</p><figure name="f4e4" id="f4e4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0widfeoqXEqkrhyBsidV1A.png" data-width="1314" data-height="484" src="https://cdn-images-1.medium.com/max/800/1*0widfeoqXEqkrhyBsidV1A.png"></figure><p name="d07d" id="d07d" class="graf graf--p graf-after--figure">三、动画</p><p name="95ad" id="95ad" class="graf graf--p graf-after--p">在讲述动画的程序之前，我们先要检查之前graphic的掌握情况。我们需要写一个算法，这个算法要求：不论canvas变量的大小是多少（当然也不能过分小），始终在画布的左侧中间位置生成一个大小为SQUARE_SIZE的黑色正方形。该算法的示例图如下：</p><figure name="be35" id="be35" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*UpyFgB39TZKs9AIfxsTANg.png" data-width="1314" data-height="428" src="https://cdn-images-1.medium.com/max/800/1*UpyFgB39TZKs9AIfxsTANg.png"></figure><p name="36a3" id="36a3" class="graf graf--p graf-after--figure">算法如下：</p><pre name="dcb4" id="dcb4" class="graf graf--pre graf-after--p"><em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>File: square.py<br>----------------<br>This is a demo created by Adam.<br>The programme creates a black square on a 800 x 800-pixel canvas.<br>The square is located atz the mid-left side of the canvas.<br>&quot;&quot;&quot;<br><br><br></em>import tkinter<br><br><br>CANVAS_WIDTH = 800<br>CANVAS_HEIHGT = 800<br>SQUARE_SIZE = 40<br><br><br>def draw_square(canvas):<br>    x1 = 0<br>    y1 = CANVAS_HEIHGT/2 - SQUARE_SIZE/2<br>    x2 = SQUARE_SIZE<br>    y2 = CANVAS_HEIHGT/2 + SQUARE_SIZE/2<br>    canvas.create_rectangle(x1, y1, x2, y2, fill=&#39;black&#39;)<br><br><br>def main():<br>    canvas = make_canvas(CANVAS_WIDTH, CANVAS_HEIHGT, title=&#39;Move Square&#39;)<br>    draw_square(canvas)<br>    canvas.mainloop()<br><br><br><br>######## DO NOT MODIFY ANY CODE BELOW THIS LINE ###########<br><br># This function is provided to you and should not be modified.<br># It creates a window that contains a drawing canvas that you<br># will use to make your drawings.<br>def make_canvas(width, height, title=None):<br>    <em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>    DO NOT MODIFY<br>    Creates and returns a drawing canvas<br>    of the given int size with a blue border,<br>    ready for drawing.<br>    &quot;&quot;&quot;<br>    </em>objects = {}<br>    top = tkinter.Tk()<br>    top.minsize(width=width, height=height)<br>    if title:<br>        top.title(title)<br>    canvas = tkinter.Canvas(top, width=width + 1, height=height + 1)<br>    canvas.pack()<br>    canvas.xview_scroll(8, &#39;units&#39;)  # add this so (0, 0) works correctly<br>    canvas.yview_scroll(8, &#39;units&#39;)  # otherwise it&#39;s clipped off<br><br>    return canvas<br><br><br><br>if __name__ == &#39;__main__&#39;:<br>    main()</pre><p name="e796" id="e796" class="graf graf--p graf-after--pre">运行上面的程序，我们可以得到如下的结果：</p><figure name="7df9" id="7df9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XzVhRIMYKMtgaeRCTnEKvA.png" data-width="1124" data-height="398" src="https://cdn-images-1.medium.com/max/800/1*XzVhRIMYKMtgaeRCTnEKvA.png"></figure><p name="a14b" id="a14b" class="graf graf--p graf-after--figure">该算法的思路如下：</p><ul class="postList"><li name="227b" id="227b" class="graf graf--li graf-after--p">第一步，我们创建一个canvas变量，它的大小通过CANVAS_WIDTH和CANVAS_HEIHGT两个常数指定：</li></ul><figure name="64bd" id="64bd" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*h6rkD8khQOc90gtBBWbdUw.png" data-width="1342" data-height="778" src="https://cdn-images-1.medium.com/max/800/1*h6rkD8khQOc90gtBBWbdUw.png"></figure><ul class="postList"><li name="8271" id="8271" class="graf graf--li graf-after--figure">第二步，我们知道CANVAS_HEIGHT的一半就是画布的中央，但是它并不是我们的起始点。</li></ul><figure name="da31" id="da31" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*1dF8_eGJbG98EtdPbMeRPA.png" data-width="1342" data-height="778" src="https://cdn-images-1.medium.com/max/800/1*1dF8_eGJbG98EtdPbMeRPA.png"></figure><ul class="postList"><li name="9e88" id="9e88" class="graf graf--li graf-after--figure">我们需要将CANVAS_HEIGHT的一半减去SQUARE_SIZE的一半求的的值作为正方形的start_y（y1）。</li></ul><figure name="5d6a" id="5d6a" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*eRDHiED7yyKMJcDnHJ9nLw.png" data-width="1342" data-height="778" src="https://cdn-images-1.medium.com/max/800/1*eRDHiED7yyKMJcDnHJ9nLw.png"></figure><ul class="postList"><li name="fa83" id="fa83" class="graf graf--li graf-after--figure">第三步，类似地我们可以得到end_y的值为CANVAS_HEIGHT的一半加上SQUARE_SIZE的一半。</li></ul><figure name="48b8" id="48b8" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*AnA2CkWYRGt2u6ebO0wpaA.png" data-width="1342" data-height="778" src="https://cdn-images-1.medium.com/max/800/1*AnA2CkWYRGt2u6ebO0wpaA.png"></figure><p name="4bab" id="4bab" class="graf graf--p graf-after--figure">综上所述，我们可以通过上面的算法在画布左侧中央的位置创建一个黑色正方形。</p><figure name="d160" id="d160" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*71cy_2K4CCBhCwVNeZNs0Q.png" data-width="1342" data-height="778" src="https://cdn-images-1.medium.com/max/800/1*71cy_2K4CCBhCwVNeZNs0Q.png"></figure><p name="e007" id="e007" class="graf graf--p graf-after--figure">棒极了！下面我们来真正实现我们想要得到的功能——移动一个小方块：</p><ol class="postList"><li name="2ca2" id="2ca2" class="graf graf--li graf-after--p">移动一个Square</li></ol><p name="593b" id="593b" class="graf graf--p graf-after--li">我们在刚才的操作中已经实现了在画布的左侧创建一个黑色小方框，下面我们将实现向右移动这个黑色小方框的程序。具体的要求如下图所示：</p><figure name="fd44" id="fd44" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rYGTLGayocjPTWwTJ0YgtQ.png" data-width="1610" data-height="1058" src="https://cdn-images-1.medium.com/max/800/1*rYGTLGayocjPTWwTJ0YgtQ.png"></figure><p name="7400" id="7400" class="graf graf--p graf-after--figure">实际上，表面上我们是将这个方框移动到画布的右侧，但是实际上，我们只是每隔一段时间改变画布的输出，让这个输出的结果逐渐靠近右侧的位置。只要这个间隔的时间足够小，那么整个图形就看起来像是在运动一样了。</p><p name="5a18" id="5a18" class="graf graf--p graf-after--p">通常情况下，这个实现动画的程序结构下图所示：</p><figure name="2968" id="2968" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*DVF_fIAwZ05YnDv7Mt_Zpw.png" data-width="1110" data-height="348" src="https://cdn-images-1.medium.com/max/800/1*DVF_fIAwZ05YnDv7Mt_Zpw.png"></figure><p name="aada" id="aada" class="graf graf--p graf-after--figure">#setup部分指的是在此处需要定义所有后面需要的变量（当然，也可以在程序开始的地方通过常数定义）。</p><p name="69ed" id="69ed" class="graf graf--p graf-after--p">#update world部分指的是每次间隔时间之后我们要更新的画布状态。</p><p name="ae05" id="ae05" class="graf graf--p graf-after--p">#pause部分就是最后时间的间隔。在这里我们使用python自带的函数time.sleep()来实现，为了使用这个函数，我们需要先在程序头调用time包文件：</p><pre name="3cba" id="3cba" class="graf graf--pre graf-after--p">import time</pre><p name="279f" id="279f" class="graf graf--p graf-after--pre">另外，我们可以通过canvas的move方法来实现对其中某个对象的移动。例如，如果我们想要移动指定步长STEP_LENGTH的小正方形，那么我们就可以通过下面的代码来实现：</p><pre name="0a40" id="0a40" class="graf graf--pre graf-after--p">canvas.move(rect, STEP_LENGTH, 0)</pre><p name="3577" id="3577" class="graf graf--p graf-after--pre">在使用完move方法之后，我们还要使用upate方法让变化体现在我们的canvas变量上：</p><pre name="cb38" id="cb38" class="graf graf--pre graf-after--p">canvas.update()</pre><p name="2f9d" id="2f9d" class="graf graf--p graf-after--pre">综上所述，我们有下面的程序，经测试通过：</p><pre name="7d56" id="7d56" class="graf graf--pre graf-after--p"><em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>File: square.py<br>----------------<br>This is a demo created by Adam.<br>The programme creates a black square on a 800 x 800-pixel canvas.<br>The square is located firstly at the mid-left side of the canvas.<br>THEN WE MOVE IT TO THE RIGHT.<br>&quot;&quot;&quot;<br><br><br></em>import tkinter<br>import time<br><br><br>CANVAS_WIDTH = 800<br>CANVAS_HEIHGT = 800<br>SQUARE_SIZE = 40<br>DELAY = 1/50.<br>STEP_LENGTH = 1<br><br><br>def draw_square(canvas):<br>    x1 = 0<br>    y1 = CANVAS_HEIHGT/2 - SQUARE_SIZE/2<br>    x2 = SQUARE_SIZE<br>    y2 = CANVAS_HEIHGT/2 + SQUARE_SIZE/2<br>    return canvas.create_rectangle(x1, y1, x2, y2, fill=&#39;black&#39;)<br><br><br>def move_square(canvas, rect):<br>    # animation loop<br>    while True:<br>        # update the world<br>        canvas.move(rect, STEP_LENGTH, 0)<br>        canvas.update()<br><br>        # pause<br>        time.sleep(DELAY)<br>        # parameter is seconds to pause.<br><br><br>def main():<br>    canvas = make_canvas(CANVAS_WIDTH, CANVAS_HEIHGT, title=&#39;Move Square&#39;)<br>    rect = draw_square(canvas)<br>    move_square(canvas, rect)<br>    canvas.mainloop()<br><br><br><br>######## DO NOT MODIFY ANY CODE BELOW THIS LINE ###########<br><br># This function is provided to you and should not be modified.<br># It creates a window that contains a drawing canvas that you<br># will use to make your drawings.<br>def make_canvas(width, height, title=None):<br>    <em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>    DO NOT MODIFY<br>    Creates and returns a drawing canvas<br>    of the given int size with a blue border,<br>    ready for drawing.<br>    &quot;&quot;&quot;<br>    </em>objects = {}<br>    top = tkinter.Tk()<br>    top.minsize(width=width, height=height)<br>    if title:<br>        top.title(title)<br>    canvas = tkinter.Canvas(top, width=width + 1, height=height + 1)<br>    canvas.pack()<br>    canvas.xview_scroll(8, &#39;units&#39;)  # add this so (0, 0) works correctly<br>    canvas.yview_scroll(8, &#39;units&#39;)  # otherwise it&#39;s clipped off<br><br>    return canvas<br><br><br><br>if __name__ == &#39;__main__&#39;:<br>    main()</pre><p name="0b67" id="0b67" class="graf graf--p graf-after--pre">四、更多图像，图形，以及动画</p><p name="8706" id="8706" class="graf graf--p graf-after--p">这一部分是关于前三部分的例题。关于这些例题的代码，请点击<a href="https://web.stanford.edu/class/cs106a/starterCode/Assignment3.zip" data-href="https://web.stanford.edu/class/cs106a/starterCode/Assignment3.zip" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">这里</a>进行下载。</p><p name="df13" id="df13" class="graf graf--p graf-after--p">第一部分：更多图像</p><ol class="postList"><li name="2084" id="2084" class="graf graf--li graf-after--p">写一个程序forestfile.py以找出森林火灾</li></ol><p name="07d9" id="07d9" class="graf graf--p graf-after--li">在这里我们将要通过一个卫星图片高亮标记其中森林火灾的位置。在这个例子中，我们已经提供了intensity threshold的数值为1.05。在我们的例子中，这个常量已经被命名为INTENSITY_THRESHOLD。</p><p name="bc3e" id="bc3e" class="graf graf--p graf-after--p">当我们检测到一个sufficiently red的像素点，我们需要将它的red调整为255，并且将green和blue调整为0。这将会使这个像素点被高亮为红色。对于其他的像素点，我们需要调整数值为平均值，从而使该图片中不高亮的部分变为灰度。下面是一个示例。</p><figure name="c16b" id="c16b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*o_-TGT1VHK8s3-kdH3cpbg.png" data-width="1202" data-height="268" src="https://cdn-images-1.medium.com/max/800/1*o_-TGT1VHK8s3-kdH3cpbg.png"></figure><p name="aa72" id="aa72" class="graf graf--p graf-after--figure">代码如下：</p><pre name="3ef5" id="3ef5" class="graf graf--pre graf-after--p"><em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>File: forestfire.py<br>----------------<br>This program highlights fires in an image by identifying<br>pixels who red intensity is more than INTENSITY_THRESHOLD times<br>the average of the red, green, and blue values at a pixel.<br>Those &quot;sufficiently red&quot; pixels are then highlighted in the<br>image and the rest of the image is turned grey, by setting the<br>pixels red, green, and blue values all to be the same average<br>value.<br>&quot;&quot;&quot;<br><br><br></em># The line below imports SimpleImage for use here<br># Its depends on the Pillow package being installed<br>from simpleimage import SimpleImage<br><br><br># Intensity threshold used to determine is a pixel is<br># &quot;sufficiently red&quot; to indicate that it is a fire.<br>INTENSITY_THRESHOLD = 1.05<br><br><br>def highlight_fires(filename):<br>    <em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>    This function should highlight the &quot;red&quot; pixels in the image passed in<br>    and grayscale all other pixels in the image in order to highlight areas<br>    of wildfires.<br><br>    Input:<br>        filename (string): name of image file to be read in<br><br>    Returns:<br>        highlighted image with &quot;sufficiently red&quot; pixels highlighted<br>    &quot;&quot;&quot;<br>    </em>image = SimpleImage(filename)<br>    for pixel in image:<br>        avg = (pixel.red + pixel.blue + pixel.green) // 3<br>        if pixel.red &gt;= avg * INTENSITY_THRESHOLD:<br>            pixel.red = 255<br>            pixel.blue = 0<br>            pixel.green = 0<br>        else:<br>            pixel.red = avg<br>            pixel.blue = avg<br>            pixel.green = avg<br>    return image<br><br><br>def main():<br>    <em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>    This program tests your highlight_fires function by displaying<br>    the original image of a fire as well as the resulting image<br>    from your highlight_fires function.<br>    &quot;&quot;&quot;<br>    </em>original_fire = SimpleImage(&#39;images/greenland-fire.png&#39;)<br>    original_fire.show()<br>    highlighted_fire = highlight_fires(&#39;images/greenland-fire.png&#39;)<br>    highlighted_fire.show()<br><br><br>if __name__ == &#39;__main__&#39;:<br>    main()</pre><p name="d583" id="d583" class="graf graf--p graf-after--pre">2. 写一个程序ghost.py</p><p name="c038" id="c038" class="graf graf--p graf-after--p">a. 什么是ghost算法</p><p name="c5ca" id="c5ca" class="graf graf--p graf-after--p">假设我们拍摄了很多照片，他们是在同一位置拍摄的。但是不幸的是，每一张照片里面都有人影，我们向要移除这些人影（这称为将这些人影ghost掉）。如下图所示：</p><figure name="ebd3" id="ebd3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*pbpraJwbeOkJPhC6uNLR2A.png" data-width="1280" data-height="254" src="https://cdn-images-1.medium.com/max/800/1*pbpraJwbeOkJPhC6uNLR2A.png"></figure><figure name="9682" id="9682" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*N4xwmy-vX91X9CU56vecAw.png" data-width="1280" data-height="352" src="https://cdn-images-1.medium.com/max/800/1*N4xwmy-vX91X9CU56vecAw.png"></figure><p name="aafa" id="aafa" class="graf graf--p graf-after--figure">这里我们会使用ghost算法，下面我们会对这一算法进行解释：</p><p name="6c7b" id="6c7b" class="graf graf--p graf-after--p">让我们假设我们有三张图片，尽管从大的范围来看，这三张图片非常相似；但是，从更小的范围来看，这三张图片有不同的地方。</p><p name="7d07" id="7d07" class="graf graf--p graf-after--p">由于我们只想要得到背景，而不想要得到人影，所以，对于三张图片上的同一个坐标点(x, y)，我们检测这个坐标点的RGB数值。例如，对于x = 500，y = 1000，RGB数值为：</p><figure name="6d40" id="6d40" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fd3G4vR-vmLFJQTUq0ggUQ.png" data-width="1490" data-height="108" src="https://cdn-images-1.medium.com/max/800/1*fd3G4vR-vmLFJQTUq0ggUQ.png"></figure><p name="60f7" id="60f7" class="graf graf--p graf-after--figure">b. 颜色距离</p><p name="c424" id="c424" class="graf graf--p graf-after--p">让我们</p><p name="bd42" id="bd42" class="graf graf--p graf-after--p graf--trailing">&lt;待更新……&gt;</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/40fe4737d60a"><time class="dt-published" datetime="2020-08-02T00:20:01.382Z">August 2, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13-%E5%9B%BE%E5%83%8F-%E5%9B%BE%E5%BD%A2-%E4%BB%A5%E5%8F%8A%E5%8A%A8%E7%94%BB-40fe4737d60a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>