<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Python程序设计9 类编程和内存</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Python程序设计9 类编程和内存</h1>
</header>
<section data-field="subtitle" class="p-summary">
系列：Python程序设计
</section>
<section data-field="body" class="e-content">
<section name="53a7" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4136" id="4136" class="graf graf--h3 graf--leading graf--title">Python程序设计9 类编程和内存</h3><figure name="f113" id="f113" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*nMQTiDVkQq7j6ZlqQEKLbQ.jpeg" data-width="2689" data-height="1513" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*nMQTiDVkQq7j6ZlqQEKLbQ.jpeg"></figure><p name="85ef" id="85ef" class="graf graf--p graf-after--figure">实际上，很多日常生活中的大项目就是通过Python构建的，例如Youtube和Spotify。在这些大项目中，我们不得不定义新的数据类型 Types。例如，对于 Spotify 来说，我们需要定义song，playlist，user，song player，以及song retriever等数据类型。在过去的章节中我们已经使用了各种各样的数据类型，例如SimpleImage，Canvas，Karel，String，int等等。现在我们也可以通过class来随时构建新的数据类型。</p><p name="0532" id="0532" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">一、狗程序1</strong></p><p name="ff8b" id="ff8b" class="graf graf--p graf-after--p">我们下面来写一个狗程序，这个程序模仿了狗叫。例如，我们先写一个狗的类，要求这个狗对象每叫一次就会输出一次woof，并且还会进行计数，记录当前狗叫了多少次数。例如：</p><pre name="fe9c" id="fe9c" class="graf graf--pre graf-after--p">class dogs:<br>    <br>    def __init__(self):<br>        self.times_barked = 0</pre><pre name="f735" id="f735" class="graf graf--pre graf-after--pre">    def bark(self):<br>        print(&quot;woof&quot;)<br>        self.times_barked += 1</pre><p name="46f6" id="46f6" class="graf graf--p graf-after--pre">通过这种类，我们可以创建狗对象并且得到狗叫和次数的输出。例如下面的主函数为：</p><pre name="d2f0" id="d2f0" class="graf graf--pre graf-after--p">from Dogs import *</pre><pre name="6294" id="6294" class="graf graf--pre graf-after--pre">def main():<br>    jupiter = Dog()<br>    juno = Dog()<br>    jupiter.bark()<br>    juno.bark()<br>    jupiter.bark()<br>    print(jupiter.times_barked)<br>    print(juno.times_barked)<br><br>if __name__ == &#39;__main__&#39;:<br>   main()</pre><p name="2f9d" id="2f9d" class="graf graf--p graf-after--pre">我们可以得到输出：</p><pre name="4a68" id="4a68" class="graf graf--pre graf-after--p">woof<br>woof<br>woof<br>2<br>1</pre><p name="3a61" id="3a61" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">二、狗程序2</strong></p><p name="8b30" id="8b30" class="graf graf--p graf-after--p">我们在上面的程序中实现了我们想要的功能，下面我们将上面的主函数程序稍微加以变化。将其中最后两次输出 times_barked 更换为 __dict__ 并观察程序的输出结果。例如：</p><pre name="d355" id="d355" class="graf graf--pre graf-after--p">from Dogs import *</pre><pre name="e08f" id="e08f" class="graf graf--pre graf-after--pre">def main():<br>    jupiter = Dog()<br>    juno = Dog()<br>    jupiter.bark()<br>    juno.bark()<br>    jupiter.bark()<br>    print(jupiter.__dict__)<br>    print(juno.__dict__)<br><br>if __name__ == &#39;__main__&#39;:<br>   main()</pre><p name="8587" id="8587" class="graf graf--p graf-after--pre">输出为：</p><pre name="f614" id="f614" class="graf graf--pre graf-after--p">woof<br>woof<br>woof<br>{&#39;times_barked&#39;: 2}<br>{&#39;times_barked&#39;: 1}</pre><p name="22f9" id="22f9" class="graf graf--p graf-after--pre">我们看到，最后输出的实际上是一个字典，里面包括了在dogs类中定义的参数times_barked。我们大概可以猜测，.__dict__ 的含义是让对象以字典的形式输出对象所包含的全部参数，下面我们来检测这个推测是否正确。</p><p name="1f63" id="1f63" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">三、狗程序3</strong></p><p name="c3ed" id="c3ed" class="graf graf--p graf-after--p">我们再对上面的类添加一个功能，我们让上面的函数可以保存狗的颜色，并且可以修改狗的颜色。我们在创建狗的同时要传递一个颜色参数，这个参数赋予狗一个可修改的颜色，我们可以通过调用函数 set_color 来重新设置狗的颜色。因此，我们重新编写 newdogs 类如下：</p><pre name="5cfa" id="5cfa" class="graf graf--pre graf-after--p">class Newdogs:</pre><pre name="5cdb" id="5cdb" class="graf graf--pre graf-after--pre">    def __init__(self, color):<br>        self.times_barked = 0<br>        self.color = color<br><br>    def bark(self):<br>        print(&#39;woof&#39;)<br>        self.times_barked += 1<br><br>    def set_color(self, new_color):<br>        self.color = new_color</pre><p name="4617" id="4617" class="graf graf--p graf-after--pre">之后我们调用类似的主函数，但是我们在本次调用的时候需要传递颜色参数。同时，我们在程序中途对狗的颜色进行一次修改，目的是为了测试 set_color函数的结果。例如：</p><pre name="1731" id="1731" class="graf graf--pre graf-after--p">def main():<br>    jupiter = Newdogs(&quot;black&quot;)<br>    juno = Newdogs(&quot;white&quot;)<br>    jupiter.bark()<br>    juno.bark()<br>    jupiter.bark()<br>    jupiter.set_color(&quot;yellow&quot;)<br>    print(jupiter.__dict__)<br>    print(juno.__dict__)<br><br>if __name__ == &#39;__main__&#39;:<br>   main()</pre><p name="3785" id="3785" class="graf graf--p graf-after--pre">得到输出：</p><pre name="d2e8" id="d2e8" class="graf graf--pre graf-after--p">woof<br>woof<br>woof<br>{&#39;times_barked&#39;: 2, &#39;color&#39;: &#39;yellow&#39;}<br>{&#39;times_barked&#39;: 1, &#39;color&#39;: &#39;white&#39;}</pre><p name="2282" id="2282" class="graf graf--p graf-after--pre">由此可见，在输出中不仅仅我们的 times_barked得到了输出，同时，color参数也被输出了。因此我们之前的猜测是是正确的， .__dict__ 允许对象以字典的形式输出所有参数。</p><p name="eb23" id="eb23" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">四、弹力球程序</strong></p><p name="4a0a" id="4a0a" class="graf graf--p graf-after--p">下面我们来实现一个Bouncing Ball的程序，我们用之前学过的SimpleImage和刚刚学过的类和对象来实现。</p><figure name="f5be" id="f5be" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Mj4B2y4t2LJTOMbO2TZNlQ.gif" data-width="600" data-height="411" src="https://cdn-images-1.medium.com/max/800/1*Mj4B2y4t2LJTOMbO2TZNlQ.gif"></figure><ol class="postList"><li name="34a5" id="34a5" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">弹力球的原理</strong></li></ol><p name="1036" id="1036" class="graf graf--p graf-after--li">ball对象应该具有以下属性：</p><ul class="postList"><li name="b4ca" id="b4ca" class="graf graf--li graf-after--p">初始在随机位置生成</li><li name="8d5f" id="8d5f" class="graf graf--li graf-after--li">初始拥有随机的<em class="markup--em markup--li-em"> x </em>方向速度</li><li name="4b0d" id="4b0d" class="graf graf--li graf-after--li">初始拥有随机的 <em class="markup--em markup--li-em">y </em>方向速度</li><li name="e547" id="e547" class="graf graf--li graf-after--li">在遇到竖直墙壁的时候<em class="markup--em markup--li-em"> y </em>方向速度为原来的 -1</li><li name="5674" id="5674" class="graf graf--li graf-after--li">在遇到水平墙壁的时候 <em class="markup--em markup--li-em">x </em>方向速度为原来的 -1</li></ul><p name="c749" id="c749" class="graf graf--p graf-after--li">原理图如下所示：</p><figure name="8951" id="8951" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*7SuuqyJrCC2iq0Zn9YDTPw.png" data-width="1840" data-height="980" src="https://cdn-images-1.medium.com/max/800/1*7SuuqyJrCC2iq0Zn9YDTPw.png"></figure><figure name="e5a6" id="e5a6" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*bhf_rsD_J9dH6fRLkM6q5w.png" data-width="1762" data-height="900" src="https://cdn-images-1.medium.com/max/800/1*bhf_rsD_J9dH6fRLkM6q5w.png"></figure><p name="1b67" id="1b67" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">2. 弹力球的实现</strong></p><p name="b0ff" id="b0ff" class="graf graf--p graf-after--p">弹力球实际上应该是一个类，我们期待所有的弹力球有着类似的性质。因此我们编写Ball类。首先在生成球的同时我们随机生成位置和速度（是通过位移来表示的，相同时间位移越大则速度越快）。</p><pre name="b5a2" id="b5a2" class="graf graf--pre graf-after--p">class Ball:</pre><pre name="80ca" id="80ca" class="graf graf--pre graf-after--pre">    def __init__(self):<br>        x1 = random.randint(0, CANVAS_WIDTH - BALL_SIZE)<br>        y1 = random.randint(0, CANVAS_HEIGHT - BALL_SIZE)<br>        x2 = x1 + BALL_SIZE<br>        y1 = y1 + BALL_SIZE<br>        self.oval = canvas.create_oval(x_1, y_1, x_2, y_2, fill=&#39;blue&#39;, outline=&#39;blue&#39;)<br>        self.change_x = random.randint(5, 15)<br>        self.change_y = random.randint(5, 15)</pre><p name="3f2a" id="3f2a" class="graf graf--p graf-after--pre">之后我们定义update方法，在一次update之后，球会先移动 change_x 以及change_y 所示的位移大小。如果移动之后碰到墙壁，则球对象会将自己的 change_x 或 change_y 参数乘上 -1。例如：</p><pre name="fcab" id="fcab" class="graf graf--pre graf-after--p">    def update(self, canvas):<br><br>        canvas.move(self.oval, self.change_x, self.change_y)</pre><pre name="e166" id="e166" class="graf graf--pre graf-after--pre">        if self._hit_left_or_right_wall(canvas):<br>            self.change_x *= -1<br><br>        if self._hit_top_or_bottom_wall(canvas):<br>            self.change_y *= -1</pre><p name="4f8a" id="4f8a" class="graf graf--p graf-after--pre">同时，我们需要定义碰到墙壁的判断：</p><pre name="b9de" id="b9de" class="graf graf--pre graf-after--p">    def _hit_left_or_right_wall(self, canvas):<br>        ball_x = canvas.coords(self.oval)[0]<br>        return ball_x &lt; 0 or ball_x &gt; CANVAS_WIDTH - BALL_SIZE<br><br>    def _hit_top_or_bottom_wall(self, canvas):<br>        ball_y = canvas.coords(self.oval)[1]<br>        return ball_y &lt; 0 or ball_y &gt; CANVAS_HEIGHT - BALL_SIZE</pre><p name="9a18" id="9a18" class="graf graf--p graf-after--pre">3. 主程序的实现</p><p name="4088" id="4088" class="graf graf--p graf-after--p">在主程序中，首先，我们需要做的是定义constant参数。例如：</p><pre name="f4be" id="f4be" class="graf graf--pre graf-after--p">N_BALLS = 10<br>CANVAS_WIDTH = 600 <br>CANVAS_HEIGHT = 600  <br>BALL_SIZE = 30</pre><p name="2c3a" id="2c3a" class="graf graf--p graf-after--pre">接下来，我们要生成一个画布用来显示弹力球的动画：</p><pre name="ffa5" id="ffa5" class="graf graf--pre graf-after--p">canvas = make_canvas(CANVAS_WIDTH, CANVAS_HEIGHT, &#39;Bouncing Ball&#39;)</pre><p name="b98a" id="b98a" class="graf graf--p graf-after--pre">我们通过定义的 create_balls 函数生成一个balls的列表，其中每一个元素都是一个ball对象。最后此函数返回 balls 列表到主函数中：</p><pre name="10e5" id="10e5" class="graf graf--pre graf-after--p">def create_balls(canvas):<br>    balls = []<br>    for i in range(N_BALLS):<br>        ball = Ball(canvas)<br>        balls.append(ball)<br>    return balls</pre><p name="fa5f" id="fa5f" class="graf graf--p graf-after--pre">最后，我们来实现动画的循环过程。在一次循环中，我们对 balls 列表中所有的 ball 对象进行遍历 update，之后再将 canvas 全局 update，最后间隔一段时间来实现动画的效果。</p><pre name="47cf" id="47cf" class="graf graf--pre graf-after--p">    while True:<br>        for ball in balls:<br>            ball.update(canvas)<br>        canvas.update()<br>        time.sleep(1/50.)</pre><p name="66de" id="66de" class="graf graf--p graf-after--pre">此外，本程序还依赖make_canvas函数，这个函数已经预先给出了。</p><pre name="d519" id="d519" class="graf graf--pre graf-after--p">######## DO NOT MODIFY ANY CODE BELOW THIS LINE ###########<br><br># This function is provided to you and should not be modified.<br># It creates a window that contains a drawing canvas that you<br># will use to make your drawings.<br>def make_canvas(width, height, title):<br>    <em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>    DO NOT MODIFY<br>    Creates and returns a drawing canvas<br>    of the given int size with a blue border,<br>    reachange_y for drawing.<br>    &quot;&quot;&quot;<br>    </em>top = tkinter.Tk()<br>    top.minsize(width=width, height=height)<br>    top.title(title)<br>    canvas = tkinter.Canvas(top, width=width + 1, height=height + 1)<br>    canvas.pack()<br>    return canvas<br><br>if __name__ == &#39;__main__&#39;:<br>    main()</pre><p name="a41c" id="a41c" class="graf graf--p graf-after--pre">综上所属，完整的代码为：</p><pre name="bf73" id="bf73" class="graf graf--pre graf-after--p">import tkinter<br>import time<br>import random</pre><pre name="3c15" id="3c15" class="graf graf--pre graf-after--pre">CANVAS_WIDTH = 600 <br>CANVAS_HEIGHT = 600 <br>BALL_SIZE = 30<br>N_BALLS = 10</pre><pre name="7ca0" id="7ca0" class="graf graf--pre graf-after--pre">class Ball:<em class="markup--em markup--pre-em"><br></em><br>    def __init__(self, canvas):<br>        x_1 = random.randint(0, CANVAS_WIDTH - BALL_SIZE)<br>        y_1 = random.randint(0, CANVAS_HEIGHT - BALL_SIZE)<br>        x_2 = x_1 + BALL_SIZE<br>        y_2 = y_1 + BALL_SIZE<br>        self.oval = canvas.create_oval(x_1, y_1, x_2, y_2, fill=&#39;blue&#39;, outline=&#39;blue&#39;)<br>        self.change_x = random.randint(5, 15)<br>        self.change_y = random.randint(5, 15)<br><br>    def update(self, canvas):<br>        canvas.move(self.oval, self.change_x, self.change_y)<br>        if self._hit_left_or_right_wall(canvas):<br>            self.change_x *= -1<br><br>        if self._hit_top_or_bottom_wall(canvas):<br>            self.change_y *= -1<br><br>    def _hit_left_or_right_wall(self, canvas):<br>        ball_x = canvas.coords(self.oval)[0]<br>        return ball_x &lt; 0 or ball_x &gt; CANVAS_WIDTH - BALL_SIZE<br><br>    def _hit_top_or_bottom_wall(self, canvas):<br>        ball_y = canvas.coords(self.oval)[1]<br>        return ball_y &lt; 0 or ball_y &gt; CANVAS_HEIGHT - BALL_SIZE<br><br>def main():<br>    canvas = make_canvas(CANVAS_WIDTH, CANVAS_HEIGHT, &#39;Bouncing Ball&#39;)<br>    balls = create_balls(canvas)<br>    while True:<br>        for ball in balls:<br>            ball.update(canvas)<br>        canvas.update()<br>        time.sleep(1/50.)<br><br>def create_balls(canvas):<br>    balls = []<br>    for i in range(N_BALLS):<br>        ball = Ball(canvas)<br>        balls.append(ball)<br>    return balls<br><br>######## DO NOT MODIFY ANY CODE BELOW THIS LINE ###########<br><br># This function is provided to you and should not be modified.<br># It creates a window that contains a drawing canvas that you<br># will use to make your drawings.<br>def make_canvas(width, height, title):<br>    <em class="markup--em markup--pre-em">&quot;&quot;&quot;<br>    DO NOT MODIFY<br>    Creates and returns a drawing canvas<br>    of the given int size with a blue border,<br>    reachange_y for drawing.<br>    &quot;&quot;&quot;<br>    </em>top = tkinter.Tk()<br>    top.minsize(width=width, height=height)<br>    top.title(title)<br>    canvas = tkinter.Canvas(top, width=width + 1, height=height + 1)<br>    canvas.pack()<br>    return canvas<br><br>if __name__ == &#39;__main__&#39;:<br>    main()</pre><p name="60d4" id="60d4" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">五、内存</strong></p><p name="03f6" id="03f6" class="graf graf--p graf-after--p">理解内存是编写更大型的程序的基础，我们在这一部分将会着重讲解内存。</p><ol class="postList"><li name="6863" id="6863" class="graf graf--li graf-after--p">内存栈</li></ol><p name="1ff5" id="1ff5" class="graf graf--p graf-after--li">栈是一种后进先出的数据结构，在Python中被用于处理函数的调用问题。每次一个函数被调用的时候，就会在内存上开辟一段新的栈帧 frame。每个被开辟的栈帧空间 space 都包括局部变量 local variables 、以及参数 parameters 。每个变量都有一个唯一的类似于URL一样的地址。当一个函数返回的时候，这个栈帧也就会同时被摧毁。</p><figure name="59c9" id="59c9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IXffXja7gyXZCLHeSWWp3Q.png" data-width="1386" data-height="572" src="https://cdn-images-1.medium.com/max/800/1*IXffXja7gyXZCLHeSWWp3Q.png"></figure><p name="6dea" id="6dea" class="graf graf--p graf-after--figure">2. 内存堆</p><p name="3419" id="3419" class="graf graf--p graf-after--p">每个变量的具体数值不是在栈上，而是在堆上存放的，每个数值有一个唯一确认的类似于URL的地址。当函数返回的时候，储存在堆上的数值并不会消失，但是堆上的储存值可以被手动释放。内存会在下一次循环的时候自动使用已经被释放了的堆空间。但是如果内存堆上的空间没有被完全释放，就会一直占用堆上的空间，从而造成资源浪费。</p><figure name="00b8" id="00b8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qGYEPyN03f40fYA6-EYvEA.png" data-width="1258" data-height="490" src="https://cdn-images-1.medium.com/max/800/1*qGYEPyN03f40fYA6-EYvEA.png"></figure><p name="b3f1" id="b3f1" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">3. 堆栈示例1</strong></p><p name="63e0" id="63e0" class="graf graf--p graf-after--p">下面的代码可以用来演示堆和栈的关系，以及内存的调用的过程。</p><pre name="98dc" id="98dc" class="graf graf--pre graf-after--p">def main(): <br>     x = 5 <br>     print(id(x)) <br>     x += 1 <br>     print(id(x))</pre><figure name="8d0e" id="8d0e" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*FzNNxOZ5ZGxk64VQcEM7FQ.png" data-width="1920" data-height="860" src="https://cdn-images-1.medium.com/max/800/1*FzNNxOZ5ZGxk64VQcEM7FQ.png"></figure><p name="bbfc" id="bbfc" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">4. 引用计数 Reference Count</strong></p><p name="30a3" id="30a3" class="graf graf--p graf-after--p">我们可能已经注意到了在上面的示例图中有ref count这个数字，但是我们目前并不知道它的作用。实际上，当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放。所以，引用计数实际上是判断一个堆上的数值是否可以释放的标志。</p><p name="e703" id="e703" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">5. 堆栈示例2</strong></p><p name="287b" id="287b" class="graf graf--p graf-after--p">下面是另一个用来演示堆栈的示例。代码如下：</p><pre name="d5b7" id="d5b7" class="graf graf--pre graf-after--p">def main(): <br>    x = 5 <br>    binky(9) <br>def binky(y): <br>    pinky(y) <br>def pinky(z): <br>    print(z)</pre><figure name="00dd" id="00dd" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*dXjs7jGC_XzRJn7HF17Ylw.png" data-width="1916" data-height="808" src="https://cdn-images-1.medium.com/max/800/1*dXjs7jGC_XzRJn7HF17Ylw.png"></figure><figure name="fb01" id="fb01" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*7IQsDqzqbz3nx2G6Evnb2w.png" data-width="1916" data-height="728" src="https://cdn-images-1.medium.com/max/800/1*7IQsDqzqbz3nx2G6Evnb2w.png"></figure><p name="e27d" id="e27d" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">6. 堆栈示例3</strong></p><p name="c2e8" id="c2e8" class="graf graf--p graf-after--p">我们之前的示例都没有用到类和对象，那么对于类和对象来说，下面是一个演示堆栈调用的示例。代码如下：</p><pre name="b4dd" id="b4dd" class="graf graf--pre graf-after--p">class Dog:<br>   def __init__(self, name):<br>      print(self)<br>      self.name = name<br>      print(self.name)<br><br># put in another file...<br><br>def main():<br>   first = Dog(&#39;jupiter&#39;) <br>   print(first)<br>   print(type(first))<br>   print(id(first))<br>   print(first.__dict__)<br><br>if __name__ == &#39;__main__&#39;:<br>   main()</pre><figure name="7bf3" id="7bf3" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*L-KEj4F3XH453uai-p-hoA.png" data-width="1940" data-height="660" src="https://cdn-images-1.medium.com/max/800/1*L-KEj4F3XH453uai-p-hoA.png"></figure><figure name="7bc2" id="7bc2" class="graf graf--figure graf-after--figure graf--trailing"><img class="graf-image" data-image-id="1*0FJ14Dz2Qbb23aguWdFWhA.png" data-width="1956" data-height="706" src="https://cdn-images-1.medium.com/max/800/1*0FJ14Dz2Qbb23aguWdFWhA.png"></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/2504e1fa3e29"><time class="dt-published" datetime="2020-08-19T12:17:40.606Z">August 19, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/python%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A19-%E7%B1%BB%E7%BC%96%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98-2504e1fa3e29" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>