<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Linux操作系统实践12 assert指令及数码管的连接</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Linux操作系统实践12 assert指令及数码管的连接</h1>
</header>
<section data-field="subtitle" class="p-summary">
系列：Linux操作系统实践
</section>
<section data-field="body" class="e-content">
<section name="11dc" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1bcc" id="1bcc" class="graf graf--h3 graf--leading graf--title">Linux操作系统实践12 assert指令及数码管的连接</h3><figure name="2ad9" id="2ad9" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*beSHA3cQNnPOOKl4ypDgfw.jpeg" data-width="2689" data-height="1513" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*beSHA3cQNnPOOKl4ypDgfw.jpeg"></figure><p name="1682" id="1682" class="graf graf--p graf-after--figure">一、Makefile文件</p><p name="22e1" id="22e1" class="graf graf--p graf-after--p">我们先从github上clone我们需要的代码：</p><pre name="a282" id="a282" class="graf graf--pre graf-after--p">$ cd ~/cs107e_home<br>$ git clone https://github.com/cs107e/lab2</pre><p name="e4df" id="e4df" class="graf graf--p graf-after--pre">转到目录～/cs107e_home/lab2/code/makefiles下：</p><pre name="9070" id="9070" class="graf graf--pre graf-after--p">$ cd ~/cs107e_home/lab2/code/makefiles</pre><p name="330d" id="330d" class="graf graf--p graf-after--pre">通过vim打开makefile文件：</p><pre name="9157" id="9157" class="graf graf--pre graf-after--p">$ vim makefile</pre><p name="5b34" id="5b34" class="graf graf--p graf-after--pre">可以看到，makefile文件中的代码如下：</p><pre name="455b" id="455b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">    NAME = blink<br><br>    CFLAGS = -g -Wall -Og -std=c99 -ffreestanding<br>    LDFLAGS = -nostdlib -e main<br><br>    all: $(NAME).bin<br><br>    %.bin: %.elf<br>        arm-none-eabi-objcopy $&lt; -O binary $@<br><br>    %.elf: %.o<br>        arm-none-eabi-gcc $(LDFLAGS) $&lt; -o $@<br><br>    %.o: %.c<br>        arm-none-eabi-gcc $(CFLAGS) -c $&lt; -o $@<br><br>    install: $(NAME).bin<br>        rpi-install.py $&lt;<br><br>    clean:<br>        rm -f *.o *.elf *.bin</code></pre><p name="8b4f" id="8b4f" class="graf graf--p graf-after--pre">我们已经介绍过Makefile文件了，现在是一个复习：</p><ul class="postList"><li name="3b9f" id="3b9f" class="graf graf--li graf-after--p">每个CFLAGS的目的是什么？</li><li name="ccb6" id="ccb6" class="graf graf--li graf-after--li">如果您只是键入会<code class="markup--code markup--li-code">make</code>怎样？哪些命令将执行？</li><li name="6447" id="6447" class="graf graf--li graf-after--li">如果修改blink.c并<code class="markup--code markup--li-code">make</code>再次运行，将重新运行哪些命令？每个目标的哪一部分指示先决条件？（先决条件意味着，如果该文件发生更改，则目标是陈旧的，必须重新构建）</li><li name="eb0e" id="eb0e" class="graf graf--li graf-after--li">符号<code class="markup--code markup--li-code">$&lt;</code>和<code class="markup--code markup--li-code">$@</code>含义是什么？</li></ul><p name="d59d" id="d59d" class="graf graf--p graf-after--li">二、通过给出的 assert 指令debug</p><p name="3466" id="3466" class="graf graf--p graf-after--p">一个成熟的开发者应该能够得到来自系统的及时反馈。C标准库中内置了一个名为assert的宏指令，它的目的是用来诊断程序。我们可以在终端输入man assert来在当前计算机上查看当前指令assert的版本。这个assert指令将实现一种功能：该指令期望的数值为true，如果代码表达式实际上为true，则success，程序继续执行；如果代码表达式实际上为false，那么fail，程序会print错误信息并退出。</p><p name="dce4" id="dce4" class="graf graf--p graf-after--p">由于我们是裸机运行的，这意味着我们没有C的标准库。同时，我们也没有printf函数，因此我们暂时无法从软件的角度实现该程序。但是，我们有另外的一种方法，我们可以通过Pi上面两个内置的硬件LED来实现程序的诊断。这两个LED分别被标示为ACT（绿色）和PWR（红色）。我们要求我们的程序能实现下面的功能：如果程序成功运行，那么我们就可以看到绿色的LED一直点亮；如果程序存在错误，那么红色的LED会持续闪烁以报告故障。</p><p name="5da6" id="5da6" class="graf graf--p graf-after--p">我们进入testing目录：</p><pre name="5297" id="5297" class="graf graf--pre graf-after--p">$ cd ~/cs107e_home/lab2/code/testing</pre><p name="3b21" id="3b21" class="graf graf--p graf-after--pre">我们先通过vim打开Makefile文件，在其中加入install语句：</p><pre name="416f" id="416f" class="graf graf--pre graf-after--p">install:<br>     rpi-install.py $(NAME).bin</pre><p name="9c55" id="9c55" class="graf graf--p graf-after--pre">这样我们就省去了重复输入python脚本命令的麻烦。</p><p name="2810" id="2810" class="graf graf--p graf-after--p">之后我们通过vim打开testing.c文件。这个文件中有两个bug。我们先大致浏览一下代码，count_bits函数的目的主要是用来计算在一个给定的无符号数中有几位是1，main函数中间包括了6个通过assert进行的测试用例。</p><p name="91c9" id="91c9" class="graf graf--p graf-after--p">我们在同一目录下已经给出了完整的assert代码，我们在后面会研究这一代码。ACT和PWD灯有几种状态：（1）当我们刚刚连接CP2102串口时，我们可以看到Pi上面绿灯闪烁，红灯长亮，这表示数据等待写入。（2）当我们写入数据之后，如果写入成功，但是没有执行assert指令，绿灯会熄灭，红灯长亮。在我们的例子中表示程序存在问题，没有执行完毕。（3）当assert指令接收到true时，绿灯和红灯都会长亮，表示assert判断成功。（4）当assert指令接收到false时，绿灯熄灭，红灯闪烁，表示assert判断失败，程序在第一次判断失败之后终止。</p><p name="a6fc" id="a6fc" class="graf graf--p graf-after--p">由于我们的程序中存在bug，所以直接运行会产生（4）中解释的状态。比如，如果我们不修改程序，直接编译，就能够观察到红灯闪烁，绿灯熄灭：</p><pre name="0723" id="0723" class="graf graf--pre graf-after--p">$ make<br>$ make install</pre><p name="e2ed" id="e2ed" class="graf graf--p graf-after--pre">下面我们来修正bug，我们通过vim打开testing.c文件。通过观察，我们发现：第一处bug的产生是因为我们在判断之前进行了移位；第二处bug是因为assert最后一项判断本身的数值是错误的。更改代码如下：</p><pre name="9329" id="9329" class="graf graf--pre graf-after--p">// File: testing.c<br>// ---------------<br>// Unit testing example</pre><pre name="8cfc" id="8cfc" class="graf graf--pre graf-after--pre">#include &quot;assert.h&quot;</pre><pre name="c608" id="c608" class="graf graf--pre graf-after--pre">// The count_bits function is intended to return the count of<br>// on bits in a numeric value. But oops-- the code as <br>// written below is buggy!  A program this simple we could try to<br>// validate &quot;by inspection&quot; but instead we will demonstrate<br>// how to find the problem using rudimentary unit tests and<br>// the assert() function.<br>// You assert a condition that must be true and if the expression<br>// evaluates to false, assert treats as an error.<br>// We use the red and greeen LEDs on the Pi board as status indicators. <br>// When an assert fails, it stops executing the program<br>// and flashes the red LED. If the program successfully finishes<br>// executing (no assert failed), the green LED turns on.<br>// Thus the flashing red LED of doom tells you that your<br>// program is failing at least one test.<br>// The solid green light means your program passed the tests you<br>// asked it to check.</pre><pre name="a832" id="a832" class="graf graf--pre graf-after--pre">int count_bits(unsigned int val)<br>{<br>    int count = 0;</pre><pre name="38ad" id="38ad" class="graf graf--pre graf-after--pre">while (val != 0) {<br>        <br>        if (val &amp; 1)      // which inputs are affected by this bug?<br>            count++;<br>        <br>        val = val &gt;&gt; 1;   // BUGGY: should shift AFTER testing low bit <br>            <br>    }<br>    <br>    return count;<br>}</pre><pre name="5f9b" id="5f9b" class="graf graf--pre graf-after--pre">void main(void) <br>{<br>    assert(count_bits(0) == 0);<br>    assert(count_bits(8) == 1);<br>    assert(count_bits(6) == 2);<br>    assert(count_bits(7) == 3);<br>    assert(count_bits(0xffffffff) == 32);<br>    assert(count_bits(5) == 2);   // what happens if my test case is misconstructed?</pre><pre name="fec7" id="fec7" class="graf graf--pre graf-after--pre">// read cstart.c to find out what happens after main() finishes<br>}</pre><p name="4f9a" id="4f9a" class="graf graf--p graf-after--pre">测试，绿灯长亮，表示实例通过。</p><p name="3f67" id="3f67" class="graf graf--p graf-after--p">三、assert指令</p><p name="cc6a" id="cc6a" class="graf graf--p graf-after--p">下面我们来看assert指令在底层是如何实现的。我们通过vim打开assert.h文件。首先，assert.h文件指明了外部函数abort()：</p><pre name="9d0b" id="9d0b" class="graf graf--pre graf-after--p">extern void abort(void);</pre><p name="6ccc" id="6ccc" class="graf graf--p graf-after--pre">之后，通过宏指令，assert()被定义为在参数为false时，跳转到abort()函数：</p><pre name="1dd2" id="1dd2" class="graf graf--pre graf-after--p">#define assert(x) if(!(x)) abort()</pre><p name="6cd6" id="6cd6" class="graf graf--p graf-after--pre">abort()函数通过一个PWD指示灯的死循环将原有程序挂起，不再执行。控制PWD指示灯的pin是GPIO35。我们之前说过，GPIO_FSEL一个寄存器包括了10个pin（3bits/pin）的状态，那么GPIO35就是被第四个寄存器GPIO_FSEL3控制，修改它的状态为OUTPUT就是修改GPIO_FSEL3(5)为100，那么就是通过1 &lt;&lt; 15来实现。同样的，GPIO35的状态是由GPIO_SET1和GPIO_CLR1控制的，那么就需要更改他们从低位开始的第三位的值为1。通过类似于控制LED闪烁过程中的设置，我们可以实现PWD:</p><pre name="c73b" id="c73b" class="graf graf--pre graf-after--p">#define GPIO_FSEL3  ((unsigned int *)0x2020000c)<br>#define GPIO_SET1   ((unsigned int *)0x20200020)<br>#define GPIO_CLR1   ((unsigned int *)0x2020002c)</pre><pre name="e61c" id="e61c" class="graf graf--pre graf-after--pre">// Red power LED (on Pi board) is GPIO 35.<br>#define ABORT_OUTPUT (1 &lt;&lt; (3*5))<br>#define ABORT_BIT    (1 &lt;&lt; (35-32))</pre><pre name="3d10" id="3d10" class="graf graf--pre graf-after--pre">#define DELAY 0x100000</pre><pre name="5925" id="5925" class="graf graf--pre graf-after--pre">// abort goes into an infinite loop that flashes the red power LED.<br>void abort(void) {<br>    // First, configure GPIO 35 function to be output.<br>    // This assignment wipes functions for other pins in this register<br>    // (GPIO 30-39), but that&#39;s okay, because this is a dead-end routine.<br>    *GPIO_FSEL3 = ABORT_OUTPUT;<br>    while (1) {<br>        *GPIO_SET1 = ABORT_BIT;<br>        // These delay loops have volatile counters to prevent being<br>        // optimized out.<br>        for (volatile int i = 0; i &lt; DELAY; i++) ;<br>        *GPIO_CLR1 = ABORT_BIT;<br>        for (volatile int i = 0; i &lt; DELAY; i++) ;<br>    }<br>}</pre><p name="7031" id="7031" class="graf graf--p graf-after--pre">到这里，虽然我们知道了为什么在assert为false的时候红灯会闪烁、程序会挂起，但是我们还是不知道为什么在程序成功执行的时候绿灯会长亮。这一部分我们需要讲解目录中的其他文件。我们在本章的最后会介绍这部分。下面我们先来看一下如何实现一个七位数码管的工作。</p><p name="b896" id="b896" class="graf graf--p graf-after--p">四、七位数码管及布线</p><p name="1247" id="1247" class="graf graf--p graf-after--p">先来了解一下两种数码管。我们在实验中使用的是共阴数码管，另外还有共阳数码管。他们的区别主要是：数码管相当于8个二极管，共阴数码管将他们的阴极连接在一起，而共阳数码管将他们的阳极连接在一起。如下图所示：</p><figure name="fba9" id="fba9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qlvqYFu1eCGVq541rzpxUg.png" data-width="1606" data-height="476" src="https://cdn-images-1.medium.com/max/800/1*qlvqYFu1eCGVq541rzpxUg.png"></figure><p name="6a26" id="6a26" class="graf graf--p graf-after--figure">其中，8个数码管被人为标号规定为A～F和DP。上图表示的是一位数的情况，我们使用的是4位数的数码管，原理图连接情况如下图所示。我们将共阴的四个引脚分别称为Dig.1～Dig.4（简称D1～D4）。</p><figure name="cfda" id="cfda" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*LmkwAGpxp7zIQ-IARUWBDA.png" data-width="1606" data-height="588" src="https://cdn-images-1.medium.com/max/800/1*LmkwAGpxp7zIQ-IARUWBDA.png"></figure><p name="ffd4" id="ffd4" class="graf graf--p graf-after--figure">另外，数码管的阳极又被8个引脚统一控制，这八个引脚分别控制每个数位的LED A～DP。如果想要一个数位工作，那么不仅仅需要Dig引脚接地，还要在阳极输入指定的脉冲。</p><p name="58b9" id="58b9" class="graf graf--p graf-after--p">在我们的四位数码管两端每边有6个引脚，共有12个引脚。我们刚刚说控制8段的引脚有8个，另外有4个Dig引脚，总计也是12个，因此数码管两边的引脚的全部功能我们已经介绍过了。要注意的是，这八个引脚并不是按照顺序的，因此我们需要参考引脚的实际意义。4位共阴数码管的引脚的具体规定如下图所示：</p><figure name="7060" id="7060" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Dt0dM9TKgWy0pJbDB41f4w.png" data-width="886" data-height="316" src="https://cdn-images-1.medium.com/max/800/1*Dt0dM9TKgWy0pJbDB41f4w.png"></figure><p name="61b7" id="61b7" class="graf graf--p graf-after--figure">我们下面来连接各个元件。首先我们需要测试数码管是否可用，同样地，由于数码管也是LED，因此我们需要在连接数码管的时候串联一个1k欧姆的电阻。我们通过如下图所示的电路来确定数码管是否可用，如果可用，我们会看到在第一个数字上的红色横线（实际上，Vdd也可以选择5V；A号横线亮）。</p><figure name="48bf" id="48bf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*i1B0QAlg9HKQcGuiyVI18g.png" data-width="850" data-height="326" src="https://cdn-images-1.medium.com/max/800/1*i1B0QAlg9HKQcGuiyVI18g.png"></figure><p name="d608" id="d608" class="graf graf--p graf-after--figure">同样地，对于每一个连接到数码管的引脚（一共8个），我们都需要串联一个阻值为1k欧姆的电阻，因此，有如下图所示的原理图（实际上，如果使用5V的电源供电也是没问题的；如果连接正确的话，我们能够在数码管上看到“1 1 ”的显示）：</p><figure name="38a1" id="38a1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MsMYR45mvmCn_JyKuQj2dA.png" data-width="1262" data-height="446" src="https://cdn-images-1.medium.com/max/800/1*MsMYR45mvmCn_JyKuQj2dA.png"></figure><p name="ab30" id="ab30" class="graf graf--p graf-after--figure">到这里，我们的数码管引脚都是直接接到Vdd和GND上的。虽然这样能够使数码管工作，但是我们无法对数码管进行控制。在实际的操作中，我们希望通过输出的电位来控制数码管，这就需要我们使用我们在Kit中的2N3094双极晶体管（BJT）来实现。它可以通过电位来控制电路的连通，相当于起到了开关的作用。</p><p name="ce40" id="ce40" class="graf graf--p graf-after--p">BJT晶体管有三个极，分别为基极Base（缩写为B），集电极Collector（缩写为C），发射极Emitter（缩写为E）。我们拿起一个晶体管，将平的一面对着自己，引脚朝下，则最左侧的引脚为E极，最右侧的引脚为B极。在电路的连接中，我们要求E极为电流流出的极，B极为电流流入的极。当B极接入的是Vdd，那么电流就可以从C极流向E极；当B极接入的是GND，那么C极和E极之间就相当于是开路。</p><figure name="64c8" id="64c8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*yCjsHiL7YPj7GpqbuqocKQ.png" data-width="1262" data-height="394" src="https://cdn-images-1.medium.com/max/800/1*yCjsHiL7YPj7GpqbuqocKQ.png"></figure><p name="08d0" id="08d0" class="graf graf--p graf-after--figure">在我们的电路中，我们通过4个2N3904晶体管控制数码的显示，其中，每一个BJT晶体管控制一个数码的显示。对于BJT晶体管的E极，我们需要将它串联后接GND；对于BJT晶体管的B极，我们需要将每一个B极串联一个10k欧姆（1k欧姆也可以）的电阻；对于BJT晶体管的C极，我们将每一个晶体管的C极分别和一个数码管的Dig引脚相连（为了方便，我们在这里BJT晶体管从左到右分别连接到数码管的Dig1～4）。</p><figure name="e19d" id="e19d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*F2Uaf9OecnxXV9WgZcRoMQ.png" data-width="1548" data-height="808" src="https://cdn-images-1.medium.com/max/800/1*F2Uaf9OecnxXV9WgZcRoMQ.png"></figure><p name="5ddd" id="5ddd" class="graf graf--p graf-after--figure">我们将其他的引脚全部连接完毕，就可以得到如下图所示的电路。下图中实物连接图是我的实物图，我全部使用跳线来完成了这个电路。但是同时，你也可以发现他很乱，不利于电路故障的排查。在你的操作中，为了让电路看起来更加简洁，我们可以使用20～22AWG的单芯铜导线和剥皮钳共同来让电路看起来更优美。实际上，下面的图中实物图和原理图并不一样。原理图中各个引脚已经被通Pi上的GPIO10～13以及GPIO20～27相连，所以如果我们这么做的话，如果完全依照原理图，那么在没有写入程序的时候，数码管应该不显示任何数字。</p><p name="2b2f" id="2b2f" class="graf graf--p graf-after--p">在完成测并且可以得到“1111”的输出后，我们需要按照原理图连接GPIO（GPIO10～13）和BJT晶体管的B极，以及输入引脚和GPIO（GPIO20～27）。</p><figure name="699b" id="699b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*38jn-zsANEzvhEJrVopqXw.png" data-width="1548" data-height="856" src="https://cdn-images-1.medium.com/max/800/1*38jn-zsANEzvhEJrVopqXw.png"></figure><p name="8c41" id="8c41" class="graf graf--p graf-after--figure">最后，我们需要在电路的最左侧添加一个按钮，用它来控制时钟的开始和关闭。其中开关的正极端需要连接一个阻值为10k欧姆的上拉电阻，开关的负极端需要连接一个LED用来指示按钮的工作状态。总的电路应该如图所示（在这个图中，我们暂时并没有连接GPIO）：</p><figure name="5b6d" id="5b6d" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*2047w8CRbp2mOorGqnEjRw.png" data-width="1548" data-height="556" src="https://cdn-images-1.medium.com/max/800/1*2047w8CRbp2mOorGqnEjRw.png"></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/2be1c1813a8d"><time class="dt-published" datetime="2020-05-17T05:47:11.964Z">May 17, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B512-assert%E6%8C%87%E4%BB%A4%E5%8F%8A%E6%95%B0%E7%A0%81%E7%AE%A1%E7%9A%84%E8%BF%9E%E6%8E%A5-2be1c1813a8d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>