<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Linux操作系统实践7 ARM数据处理指令和机器码</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Linux操作系统实践7 ARM数据处理指令和机器码</h1>
</header>
<section data-field="subtitle" class="p-summary">
系列：Linux操作系统实践
</section>
<section data-field="body" class="e-content">
<section name="30cf" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4b9c" id="4b9c" class="graf graf--h3 graf--leading graf--title">Linux操作系统实践7 ARM数据处理指令和机器码</h3><figure name="c457" id="c457" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*beSHA3cQNnPOOKl4ypDgfw.jpeg" data-width="2689" data-height="1513" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*beSHA3cQNnPOOKl4ypDgfw.jpeg"></figure><p name="7eba" id="7eba" class="graf graf--p graf-after--figure">一、ARM指令的分类</p><p name="7a91" id="7a91" class="graf graf--p graf-after--p">我们通常会使用到的ARM指令主要分为三类：</p><ul class="postList"><li name="42d5" id="42d5" class="graf graf--li graf-after--p">数据处理指令Data processing instructions</li><li name="cc8c" id="cc8c" class="graf graf--li graf-after--li">写入读取指令Load from and store to memory instructions</li><li name="caf7" id="caf7" class="graf graf--li graf-after--li">条件跳转指令Conditional branches instructions</li></ul><p name="ddf7" id="ddf7" class="graf graf--p graf-after--li">除了已经被精简和归纳的汇编语言之外，我们现在还不知道任何关于机器语言和其底层实现的功能。但是如果你还记得，我们曾经在<a href="https://medium.com/adamedelwiess/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B55-%E8%AE%BE%E7%BD%AEraspberry-pi-f32e7845d3a7" data-href="https://medium.com/adamedelwiess/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B55-%E8%AE%BE%E7%BD%AEraspberry-pi-f32e7845d3a7" class="markup--anchor markup--p-anchor" target="_blank">第5章</a>中讲述了我们如何将一个.s为扩展名的文件转换为一个.bin为扩展名的文件。</p><p name="1ca8" id="1ca8" class="graf graf--p graf-after--p">.s为扩展名的文件是汇编语言文件，也就是说文件内的文本是通过汇编语言的形式去记录的。.o为扩展名的文件是object文件，它是一个二进制文件。在我们的例子中，object文件的存在意义不大，因为我们并不需要通过linker连接不同的程序（这一部分暂时不需要掌握）。.bin文件是二进制可执行文件，它相当于可以供机器执行的机器码，机器可以直接运行。下面的这张图给出了blink三个文件的具体内容，他们在逻辑上是等价的。</p><figure name="01d3" id="01d3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*2lf_Sfv2ZwUrg6VnmivrBA.png" data-width="2482" data-height="1014" src="https://cdn-images-1.medium.com/max/800/1*2lf_Sfv2ZwUrg6VnmivrBA.png"><figcaption class="imageCaption">汇编语言程序，object程序，二进制机器码</figcaption></figure><p name="0767" id="0767" class="graf graf--p graf-after--figure">二、数据处理指令及其机器码</p><p name="c72e" id="c72e" class="graf graf--p graf-after--p">在ARM指令体系中，所有的指令机器码都是32位的，因此不论操作数有多少，指令有多复杂，它都是稳定的32位指令。这种规定为我们或多或少提供了一些便利。</p><p name="9fe6" id="9fe6" class="graf graf--p graf-after--p">我们之前已经介绍过了ORR运算和ADD运算，他们都属于数据处理指令。如果进行运算的两个单位都是CPU内部的寄存器，不涉及立即数，那么我们将这种数据处理称为两个寄存器之间的运算。</p><p name="ec49" id="ec49" class="graf graf--p graf-after--p">对于这种运算，我们有它的一般形式如下：</p><figure name="7583" id="7583" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Rfkru6vhn6DDqSXOhzf27A.png" data-width="1502" data-height="338" src="https://cdn-images-1.medium.com/max/800/1*Rfkru6vhn6DDqSXOhzf27A.png"></figure><p name="cbe9" id="cbe9" class="graf graf--p graf-after--figure">在实际的ARM汇编中，我们也可以只给出两个操作数。此外，我们也还有寄存器和立即数之间的运算：</p><figure name="099f" id="099f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IEYlvT-aQoTSQM1Gc7J5-g.png" data-width="1498" data-height="376" src="https://cdn-images-1.medium.com/max/800/1*IEYlvT-aQoTSQM1Gc7J5-g.png"></figure><p name="44a4" id="44a4" class="graf graf--p graf-after--figure">（1）寄存器信息（3 x 4 bits）</p><p name="e6dc" id="e6dc" class="graf graf--p graf-after--p">那么我们在机器码中就需要规定上面出现的这些变量。首先是寄存器，我们已经知道在处理器中有16个寄存器（r0～r15），那么我们就可以通过4bit来区别不同的寄存器。因此，由于我们需要在运算中给出三个寄存器，我们在32位指令中需要给出12bits来存放寄存器信息。</p><p name="7be4" id="7be4" class="graf graf--p graf-after--p">（2）运算指令信息OP（4bits）</p><p name="78fb" id="78fb" class="graf graf--p graf-after--p">ARM指令规定了16种数据处理指令，因此同样地，我们可以通过4bits来区分这些指令。因为指令和二进制对应关系是人为规定的，所以，通过参考下面的表格，我们可以得到不同运算指令的二进制表示。</p><figure name="e455" id="e455" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*eNZHWKwruRZt1eT22TrEjA.png" data-width="1210" data-height="478" src="https://cdn-images-1.medium.com/max/800/1*eNZHWKwruRZt1eT22TrEjA.png"></figure><p name="dc16" id="dc16" class="graf graf--p graf-after--figure">这些指令的具体用法如下：</p><p name="6196" id="6196" class="graf graf--p graf-after--p">AND</p><ul class="postList"><li name="3803" id="3803" class="graf graf--li graf-after--p">Logical AND指令，逻辑与运算</li></ul><p name="3ee8" id="3ee8" class="graf graf--p graf-after--li">EOR</p><ul class="postList"><li name="95f5" id="95f5" class="graf graf--li graf-after--p">Logical XOR指令，逻辑异或运算</li></ul><p name="f94a" id="f94a" class="graf graf--p graf-after--li">SUB</p><ul class="postList"><li name="4b59" id="4b59" class="graf graf--li graf-after--p">Subtract指令，算数减法运算</li></ul><p name="944b" id="944b" class="graf graf--p graf-after--li">RSB</p><ul class="postList"><li name="0c39" id="0c39" class="graf graf--li graf-after--p">Reversed Subtract指令，算数减法取相反数运算</li></ul><p name="573f" id="573f" class="graf graf--p graf-after--li">ADD</p><ul class="postList"><li name="16b6" id="16b6" class="graf graf--li graf-after--p">Add指令，算数加法运算</li></ul><p name="abf1" id="abf1" class="graf graf--p graf-after--li">ADC</p><ul class="postList"><li name="e08f" id="e08f" class="graf graf--li graf-after--p">Add with CF指令，算数加法运算，并且结果要加上进位标志位CF</li></ul><p name="5003" id="5003" class="graf graf--p graf-after--li">SBC</p><ul class="postList"><li name="d9fa" id="d9fa" class="graf graf--li graf-after--p">Subtract with CF指令，算数减法运算，并且结果要加上进位标志位CF取反</li></ul><p name="2991" id="2991" class="graf graf--p graf-after--li">RSC</p><ul class="postList"><li name="cb5a" id="cb5a" class="graf graf--li graf-after--p">Reversed Subtract with CF指令，算数减法取相反数运算，并且结果要加上进位标志位CF取反</li></ul><p name="4da9" id="4da9" class="graf graf--p graf-after--li">TST</p><ul class="postList"><li name="7f8b" id="7f8b" class="graf graf--li graf-after--p">Test指令，将两个寄存器内的值取逻辑与运算，运算的结果被用来更新到CPSR寄存器（Current Program Status Register）。CPSR寄存器中主要的标志位为NZCV四个标志位：分别表示负（Negative）标志位、零（Zero）标志位、进位（Carry）标志位、以及溢出（Overflow）标志位。</li><li name="0eb2" id="0eb2" class="graf graf--li graf-after--li">TST的运算结果一定会导致N和Z的更新，不一定会导致C位的更新，一定不会导致V位的更新</li><li name="7789" id="7789" class="graf graf--li graf-after--li">如果与运算的结果为负数，那么N被置为1；Vice Versa</li><li name="6c40" id="6c40" class="graf graf--li graf-after--li">如果与运算的结果为0，那么Z被置为1；Vice Versa</li></ul><p name="b975" id="b975" class="graf graf--p graf-after--li">TEQ</p><ul class="postList"><li name="ae57" id="ae57" class="graf graf--li graf-after--p">Test Equation指令，类似于TST指令，将两个寄存器内的值取逻辑或运算，运算的结果被用来更新到CPSR寄存器（Current Program Status Register）。</li><li name="4882" id="4882" class="graf graf--li graf-after--li">TEQ的运算结果一定会导致N和Z的更新，不一定会导致C位的更新，一定不会导致V位的更新</li></ul><p name="1373" id="1373" class="graf graf--p graf-after--li">CMP</p><ul class="postList"><li name="22fc" id="22fc" class="graf graf--li graf-after--p">Compare指令，类似与TST和TEQ指令，将两个寄存器内的值取算数减法运算，运算的结果被用来更新到CPSR寄存器（Current Program Status Register）。</li><li name="1b22" id="1b22" class="graf graf--li graf-after--li">根据运算结果，NZCV四个标志位都可能被更新。</li></ul><p name="c8b7" id="c8b7" class="graf graf--p graf-after--li">CMN</p><ul class="postList"><li name="adeb" id="adeb" class="graf graf--li graf-after--p">Compare Negative指令，类似与CMP指令，将两个寄存器内的值取算数加法运算，运算的结果被用来更新到CPSR寄存器（Current Program Status Register）。</li><li name="8e20" id="8e20" class="graf graf--li graf-after--li">根据运算结果，NZCV四个标志位都可能被更新。</li></ul><p name="3fb8" id="3fb8" class="graf graf--p graf-after--li">ORR</p><ul class="postList"><li name="6520" id="6520" class="graf graf--li graf-after--p">Or指令，将两个寄存器内的值取逻辑或运算。</li></ul><p name="ba5f" id="ba5f" class="graf graf--p graf-after--li">MOV</p><ul class="postList"><li name="1507" id="1507" class="graf graf--li graf-after--p">Move指令，是将一个寄存器内的值赋值给另一个寄存器，只有两个操作数。</li></ul><p name="2f0c" id="2f0c" class="graf graf--p graf-after--li">BIC</p><ul class="postList"><li name="c1dc" id="c1dc" class="graf graf--li graf-after--p">Bit Clear指令，表示的是逻辑与非。</li></ul><p name="ed44" id="ed44" class="graf graf--p graf-after--li">MVN</p><ul class="postList"><li name="8543" id="8543" class="graf graf--li graf-after--p">Move Not指令，是将一个寄存器内的值取反后赋值给另一个寄存器，只有两个操作数。</li></ul><p name="bf25" id="bf25" class="graf graf--p graf-after--li">（3）指令类型标志位（2bits）</p><p name="ee7b" id="ee7b" class="graf graf--p graf-after--p">我们在第一部分说了，在ARM中有三种不同类型的指令，我们可以用至少2bit来区分这三种不同的指令。其中我们人为规定00表示的是数据处理指令。</p><p name="700a" id="700a" class="graf graf--p graf-after--p">（4）条件字段（4bits）</p><p name="0291" id="0291" class="graf graf--p graf-after--p">我们还要给出在什么情况下我们可以执行指令，这个就被称为指令所需要的条件。这里我们通过一个4bits的字段来表述这种条件。二进制数1110表示的是始终执行。</p><p name="2f58" id="2f58" class="graf graf--p graf-after--p">（5）存在立即数条件位i（1bit）</p><p name="d6d4" id="d6d4" class="graf graf--p graf-after--p">我们现在是两个寄存器内的值相加，但是如果是一个寄存器内的数值和一个立即数相加，那么我们就需要考虑立即数对代码的影响。很明显，表示一个立即数我们需要8位，但是表示一个寄存器我们只需要4位。因此含有立即数的指令和不含有立即数的指令虽然机器码可能相同，但是表示的含义完全不同。因此我们要通过一个是否存在立即数的位告知机器如何分析机器码。如果含有立即数，则该位为1，反之为0。</p><p name="4922" id="4922" class="graf graf--p graf-after--p">（6）设置标志位位s（1bit）</p><p name="cb51" id="cb51" class="graf graf--p graf-after--p">在前面的讨论中，我们发现有的指令需要我们对标志位进行更改，但是有的指令则不需要。我们需要给计算机指明什么时候我们需要进行条件位（例如NZCV）的更改。当设置标志位位被设置为1的时候，它指的是我们在运算之后需要更改条件位。反之，则表示我们在运算之后不需要更改条件位。</p><p name="92e9" id="92e9" class="graf graf--p graf-after--p">（7）立即数位imm（8bits）</p><p name="0f47" id="0f47" class="graf graf--p graf-after--p">我们接下来将上面的所有数位加总：需要的总位数 = 寄存器信息（3 x 4 bits）+ 运算指令信息OP（4bits）+ 指令类型标志位（2bits）+ 条件字段（4bits）+ 存在立即数条件位i（1bit）+ 设置标志位位s（1bit）= 24bits</p><p name="fdfa" id="fdfa" class="graf graf--p graf-after--p">因此我们可以看到，我们多出来了32bits - 24bits = 8bits的空间。这一部分空间怎么使用呢？我们刚刚说了，可能我们的指令中是包括立即数的，那么这就要求我们在少一个寄存器的情况下保留8位的立即数位，这需要额外的4bits空间。</p><p name="c6a6" id="c6a6" class="graf graf--p graf-after--p">（8）右旋RoR位（4bits）</p><p name="b6dd" id="b6dd" class="graf graf--p graf-after--p">最后的4bits表示的是右旋法Rotation Right（RoR）的右旋程度。通常来说，我们表示一个立即数能表示的最大数为 1111 1111（0xFF）右旋指的是在32位的范围之内，我们将最低位依次挪到最高位的过程。移动的位数和RoR之间的关系是2倍的关系。下面的一张图表示了这一过程（1RoR=2bits）。</p><figure name="aebf" id="aebf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6tydBqc1lZgLACAmajEl3w.png" data-width="1536" data-height="704" src="https://cdn-images-1.medium.com/max/800/1*6tydBqc1lZgLACAmajEl3w.png"><figcaption class="imageCaption">Right Rotation</figcaption></figure><p name="9dec" id="9dec" class="graf graf--p graf-after--figure">Macbook上自带的编程计算器也具有RoR和LoR的选项，可以用来演示右旋的这一过程。</p><p name="cd19" id="cd19" class="graf graf--p graf-after--p">由于我们右旋位数位4位，这意味着它能够表示0～15的任意数值。由于右旋位数和RoR数值是2倍的关系，因此实际上我们能右旋的数位是0～30之间的全部偶数位，这意味着我们可以刚好遍历整个32位的偶数右旋空间。</p><p name="5bc7" id="5bc7" class="graf graf--p graf-after--p">下面我们将这种人为规定的内容组装在一起，让他们组成32位的ARM指令。这种规定如下图所示。</p><figure name="2976" id="2976" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*x-HXGq16Ivu4RSSFuB_0IA.png" data-width="1394" data-height="730" src="https://cdn-images-1.medium.com/max/800/1*x-HXGq16Ivu4RSSFuB_0IA.png"></figure><figure name="0b38" id="0b38" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*6VFJ1gcV-o_jvHcRAlIFow.png" data-width="1584" data-height="642" src="https://cdn-images-1.medium.com/max/800/1*6VFJ1gcV-o_jvHcRAlIFow.png"><figcaption class="imageCaption">有立即数和无立即数的机器码</figcaption></figure><p name="7923" id="7923" class="graf graf--p graf-after--figure">下面我们将看一些具体的例子。</p><p name="c4e9" id="c4e9" class="graf graf--p graf-after--p">（1）add r0, r1, r2转换为机器码</p><figure name="fd8b" id="fd8b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*UBGg751g3tK-JJdSVOVlsw.png" data-width="1454" data-height="488" src="https://cdn-images-1.medium.com/max/800/1*UBGg751g3tK-JJdSVOVlsw.png"></figure><p name="fa66" id="fa66" class="graf graf--p graf-after--figure">（2）add r0, r1, #1转换为机器码</p><figure name="5c38" id="5c38" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0KLe-TQx7Oc-Lxh_62qSbg.png" data-width="1454" data-height="488" src="https://cdn-images-1.medium.com/max/800/1*0KLe-TQx7Oc-Lxh_62qSbg.png"></figure><p name="05af" id="05af" class="graf graf--p graf-after--figure">（3）add r0, r1, #0x10000转换为机器码</p><figure name="8ddd" id="8ddd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zDDFTJJeYXNSK60taBIsEw.png" data-width="1454" data-height="488" src="https://cdn-images-1.medium.com/max/800/1*zDDFTJJeYXNSK60taBIsEw.png"></figure><p name="72b1" id="72b1" class="graf graf--p graf-after--figure">（4）sub r7, r5, #0x300转换为机器码</p><figure name="9c6a" id="9c6a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dqUC8-KjNUOqllOZwWqOrw.png" data-width="1454" data-height="488" src="https://cdn-images-1.medium.com/max/800/1*dqUC8-KjNUOqllOZwWqOrw.png"></figure><p name="7805" id="7805" class="graf graf--p graf-after--figure">三、桶式移位器Barrel shifter</p><p name="c87a" id="c87a" class="graf graf--p graf-after--p">桶式移位器是一种数字电路，它不依靠逻辑，只依靠单纯的数字电路性质对数位进行移位。使用桶式移位器能够让我们节省40%的代码空间。可以参考：<a href="https://alisdair.mcdiarmid.org/arm-immediate-value-encoding/#play-with-it" data-href="https://alisdair.mcdiarmid.org/arm-immediate-value-encoding/#play-with-it" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ARM即时值编码交互式演示</a>，它让我们通过一种更加直观的方式来理解移位器！</p><figure name="8ecd" id="8ecd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*oDLshCNDtcA_Rx2e9qXQzg.png" data-width="1592" data-height="716" src="https://cdn-images-1.medium.com/max/800/1*oDLshCNDtcA_Rx2e9qXQzg.png"></figure><p name="a835" id="a835" class="graf graf--p graf-after--figure">四、直接使用地址</p><p name="97f3" id="97f3" class="graf graf--p graf-after--p">在调用ldr指令和str指令的时候，有的时候我们想要直接给定地址，而不是先将地址保存到寄存器中。这种做法是可以实现的，有下面两种方法可以实现它：</p><pre name="a908" id="a908" class="graf graf--pre graf-after--p">ldr r0, =0x20200008</pre><p name="d6b9" id="d6b9" class="graf graf--p graf-after--pre">或者</p><pre name="b8db" id="b8db" class="graf graf--pre graf-after--p">ldr r0, GPFSEL2</pre><pre name="b86d" id="b86d" class="graf graf--pre graf-after--pre">GPFSEL2: .word 0x20200008</pre><p name="7d5c" id="7d5c" class="graf graf--p graf-after--pre">五、流水线Pipeline</p><p name="c0f5" id="c0f5" class="graf graf--p graf-after--p">为了运行一个指令，我们要经过Fetch，Decode，以及Execute三个阶段。同样地，如果我们要执行三个指令，那么我们就要进行九个阶段。如果我们等待上一个阶段执行完毕再执行下一个阶段，我们将会消耗大量的时间。实际上，三个阶段的处理过程在CPU的内部是分离的，这意味着我们可以同时进行这三个阶段——这就像工厂中的流水线一样。</p><figure name="ea0c" id="ea0c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6IxgqASFJHlLz5riprznaA.png" data-width="1242" data-height="208" src="https://cdn-images-1.medium.com/max/800/1*6IxgqASFJHlLz5riprznaA.png"></figure><p name="84d2" id="84d2" class="graf graf--p graf-after--figure">通过这一情况我们就可以知道，我们在fetch过程得到的并不是当前执行的指令的地址，而是当前PC之后的两个指令（地址为：PC+8）。</p><p name="28b3" id="28b3" class="graf graf--p graf-after--p">六、SUBS指令</p><p name="408e" id="408e" class="graf graf--p graf-after--p">和SUB指令类似的是，SUBS指令也是计算两个数的算数差值，区别是SUBS指令改变了NZCV标志位的数值。</p><p name="078f" id="078f" class="graf graf--p graf-after--p">七、设置常数</p><p name="d641" id="d641" class="graf graf--p graf-after--p">汇编语言中的常数需要在一开始的时候就规定好。例如对于关系DELAY = 0x3f0000来说，汇编语句定义如下：</p><pre name="4681" id="4681" class="graf graf--pre graf-after--p">.equ DELAY, 0x3F0000</pre><p name="44b5" id="44b5" class="graf graf--p graf-after--pre">八、跳转指令</p><p name="6611" id="6611" class="graf graf--p graf-after--p">跳转指令分为有条件的跳转和无条件的跳转，其中有条件的跳转（指令为：b+尾缀）参考的是NZCV标志位的情况，再决定是否要进行指令的跳转。无条件的跳转（指令为：b）指的是在任何条件下都会发生的跳转。跳转指令的尾缀，二进制码，判断的标志位和用途的对应关系如下表所示：</p><figure name="275d" id="275d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fdt2mXltyhcipc-CPG285Q.png" data-width="1448" data-height="578" src="https://cdn-images-1.medium.com/max/800/1*fdt2mXltyhcipc-CPG285Q.png"></figure><p name="8229" id="8229" class="graf graf--p graf-after--figure">九、对大端big-endian和对小端little-endian规则</p><p name="ecbc" id="ecbc" class="graf graf--p graf-after--p">对大端和对小端指的是在Memory上指令的两种不同的存储顺序，这个存储顺序的区别引发了旷世已久的论战，以至于人们用《格列佛游记》中从大端打开鸡蛋还是从小端来打开鸡蛋这件事情来讽刺这场无意义的论战。关于这场论战，可以参考Danny Cohen’s article <a href="http://cs107e.github.io/readings/holywars.pdf" data-href="http://cs107e.github.io/readings/holywars.pdf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Holy Wars and a Plea for Peace</a>。</p><p name="ed36" id="ed36" class="graf graf--p graf-after--p">ARM使用的是对小端规则。</p><figure name="98ed" id="98ed" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*rKFRfLradMcpgDHrftiMoQ.png" data-width="1526" data-height="768" src="https://cdn-images-1.medium.com/max/800/1*rKFRfLradMcpgDHrftiMoQ.png"></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/1edd6dd4715c"><time class="dt-published" datetime="2020-05-04T13:19:17.406Z">May 4, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B57-arm%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E5%92%8C%E6%9C%BA%E5%99%A8%E7%A0%81-1edd6dd4715c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>