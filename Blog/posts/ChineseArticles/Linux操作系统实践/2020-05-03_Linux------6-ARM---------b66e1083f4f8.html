<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Linux操作系统实践6 ARM处理器和储存结构</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Linux操作系统实践6 ARM处理器和储存结构</h1>
</header>
<section data-field="subtitle" class="p-summary">
系列：Linux操作系统实践
</section>
<section data-field="body" class="e-content">
<section name="0a17" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="68de" id="68de" class="graf graf--h3 graf--leading graf--title">Linux操作系统实践6 ARM处理器和储存结构</h3><figure name="6a05" id="6a05" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*beSHA3cQNnPOOKl4ypDgfw.jpeg" data-width="2689" data-height="1513" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*beSHA3cQNnPOOKl4ypDgfw.jpeg"></figure><p name="81ab" id="81ab" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">一、指令周期</strong></p><p name="c57d" id="c57d" class="graf graf--p graf-after--p">一个指令周期包括三个阶段，分别是提取阶段fetch instruction，解码阶段decode instruction，和执行阶段executive instruction。</p><ul class="postList"><li name="c27b" id="c27b" class="graf graf--li graf-after--p">Program Counter：程序地址寄存器，用来储存当前程序的地址，每次程序执行之后，地址寄存器的值加一</li><li name="a3b7" id="a3b7" class="graf graf--li graf-after--li">Fetch instruction：当前程序执行后，根据Program Counter中储存的储存的地址在内存中找到下一句指令，并且将其存入指令寄存器中</li><li name="d210" id="d210" class="graf graf--li graf-after--li">Decode instruction：在这一阶段中，指令寄存器中被编码的指令根据给定的规则进行解码</li><li name="478a" id="478a" class="graf graf--li graf-after--li">Executive instruction：CPU的控制单元将被解码的信息作为一系列控制信号传输给相关的CPU作用单元实现指令规定的功能。</li></ul><p name="b7ef" id="b7ef" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">二、Clock时钟</strong></p><p name="3b94" id="3b94" class="graf graf--p graf-after--p">时钟的作用是同步所有元件的状态。这句话可能比较复杂，让我们来假设我们传递1001到一个初始值为0000的四位寄存器上。我们通过下面的图来理解这个过程：</p><figure name="c02a" id="c02a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BYaI-gsi6TY8n3bKfpehyw.png" data-width="1558" data-height="856" src="https://cdn-images-1.medium.com/max/800/1*BYaI-gsi6TY8n3bKfpehyw.png"><figcaption class="imageCaption">*假设在左边的导线上，信号传输的速度是有差别的，长度越长传输越慢</figcaption></figure><p name="8116" id="8116" class="graf graf--p graf-after--figure">根据上面这张图，我们可以看出，如果我们在0～0.04s之内截取信号，我们都将会得到错误的值。同样，如果我们在0.04s之后的任何时间截取信号，我们都会得到同样的正确的值，因此我们需要花费至少0.04s的时间等待所有信号的同步。</p><p name="6bbd" id="6bbd" class="graf graf--p graf-after--p">同样地，当我们传输两个信号Signal1：1001和Signal2：0111时，我们也需要确定什么时候我们需要得到输出。在这个例子中，我们可以参考下面的图1。在我们的例子中，信号的输入是连续的，也就是说，信号不会等待确认之后再输入下一个。根据下面的图，我们发现，在0.04s和0.08s两个位置输出，我们就可以得到确定的值。那么我们就可以通过一个震荡的信号（以.04s为周期，如下图2）来告诉电路什么时候输出。</p><figure name="ba22" id="ba22" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rV_1y3TNTs15MoxL2i98Mg.png" data-width="1558" data-height="856" src="https://cdn-images-1.medium.com/max/800/1*rV_1y3TNTs15MoxL2i98Mg.png"><figcaption class="imageCaption">图1</figcaption></figure><figure name="371e" id="371e" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*iSys3KBkGIlhtuvXnM99-g.png" data-width="1590" data-height="352" src="https://cdn-images-1.medium.com/max/800/1*iSys3KBkGIlhtuvXnM99-g.png"><figcaption class="imageCaption">图2</figcaption></figure><p name="0b2c" id="0b2c" class="graf graf--p graf-after--figure">上面的例子是一种虚假的情况，在实际的电路中，（1）我们的信号传输速度会更快，这意味着我们进行计算的过程有着更大的频率。并且，我们只需要保证半个周期之内（时钟震荡信号为0的时间），所有原件能够完全传输一次信号（或者最多改变一次状态）即可；（2）我们的信号不是连续输入的。这意味着我们在时钟震荡信号为1时，我们等待传输的信号是被挂起的，不进行输入。只有在时钟震荡信号为0时，我们的信号才能传输；（3）从实际的角度看，找到非50%震荡的物理元件是有困难的，不如50%震荡周期的物理元件来的方便，因此我们通常选择50%的振荡信号源。该信号源在计算机科学领域被称为时钟Clock。下面的图展示了一种常见的时钟。</p><figure name="0fd0" id="0fd0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*UiFBUNH7m5wRl6wwnUKj1w.png" data-width="1590" data-height="890" src="https://cdn-images-1.medium.com/max/800/1*UiFBUNH7m5wRl6wwnUKj1w.png"></figure><p name="16f7" id="16f7" class="graf graf--p graf-after--figure">我们再来看第一节中说到的指令周期和上面的时钟周期之间的关系：二者之间有如下图所示的关系。因此，一个指令消耗的时钟周期（机器周期）是大于1的，原因是我们要执行一个指令是需要完成三个过程。</p><figure name="ff1a" id="ff1a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*xB724puFaaNqcQ1ZhDEhYQ.png" data-width="1590" data-height="890" src="https://cdn-images-1.medium.com/max/800/1*xB724puFaaNqcQ1ZhDEhYQ.png"></figure><p name="0f16" id="0f16" class="graf graf--p graf-after--figure">三、ARM架构</p><p name="e60a" id="e60a" class="graf graf--p graf-after--p">我们先来看下面这样一张图，这张图里面我们暂时还不知道它各部分是什么意思，不过我们可以大体上对信息如何在ARM中传递有一个基本的了解。我们使用下面的两张图进行对比。</p><figure name="a638" id="a638" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kvqeW6ULh_z3UrPZJyeIug.png" data-width="1530" data-height="898" src="https://cdn-images-1.medium.com/max/800/1*kvqeW6ULh_z3UrPZJyeIug.png"><figcaption class="imageCaption">在内存和处理器中实际发生的过程</figcaption></figure><figure name="e10b" id="e10b" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*fd3bXN9aRZIBf-NBQHxKzQ.png" data-width="1616" data-height="812" src="https://cdn-images-1.medium.com/max/800/1*fd3bXN9aRZIBf-NBQHxKzQ.png"><figcaption class="imageCaption">这一过程发生的实际位置</figcaption></figure><p name="55d9" id="55d9" class="graf graf--p graf-after--figure">我们可能会感到困惑。因为通常来说，我们应该看到在PCB板上有一部分是处理器（CPU），另一部分是内存（Memory）。但是非常明显的是，我们在Pi上面只看到了一个黑色的方块（上面写着SAMSUNG）。这个黑色的模块是三星公司的Samsung 4Gb (gigabit) S<a href="https://www.samsung.com/semiconductor/dram/" data-href="https://www.samsung.com/semiconductor/dram/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">DRAM模块</a>，它的DRAM功能实际上相当于Memory。</p><p name="8386" id="8386" class="graf graf--p graf-after--p">那么，CPU在什么位置呢？答案是 —— CPU的位置在Samsung DRAM的下面。我们的Pi使用的处理器是Broadcom公司的2865 ARM处理器。为了降低成本，通过将存储芯片堆叠在处理器芯片上方，可以节省PCB上的空间。</p><figure name="622c" id="622c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*1NpJ5S50QZE7uyDXQ-cewA.png" data-width="1598" data-height="528" src="https://cdn-images-1.medium.com/max/800/1*1NpJ5S50QZE7uyDXQ-cewA.png"></figure><ol class="postList"><li name="9092" id="9092" class="graf graf--li graf-after--figure">内存Memory</li></ol><p name="0717" id="0717" class="graf graf--p graf-after--li">内存在Pi中被用于存储指令（instructions）和数据（Data），最大可存储的内存容量为4Gb（2的32次方 = 16的8次方），并且地址总线是32位的。地址的范围是0x0000 0000～0x1000 0000。内存中每一个内存单元的大小是8位（8bit）。</p><p name="fb52" id="fb52" class="graf graf--p graf-after--p">这里要注意区分的是，虽然内存中每一个内存单元的大小只有8位（1字节），但是在处理器中寄存器的一个单元大小是32位（4字节）的。</p><figure name="d4c2" id="d4c2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MBfn3lVcd7ezsiHxQyi9-A.png" data-width="1580" data-height="898" src="https://cdn-images-1.medium.com/max/800/1*MBfn3lVcd7ezsiHxQyi9-A.png"><figcaption class="imageCaption">ARM的总线：ARM采用哈佛结构，数据总线和指令总线是分开的</figcaption></figure><p name="a02a" id="a02a" class="graf graf--p graf-after--figure">我们在Kit中购买的Pi的有效内存是256M的版本（当然，你可能也能买到512M的版本）。非常明显的是，Samsung为我们提供的储存范围是4GB而我们能够实际使用的大小只有256MB，这是因为我们在Samsung上的其他位置被用作了其他用途，不能当作内存来使用，因此，我们的DRAM和实际的内存关系是：</p><figure name="bdba" id="bdba" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*1HXVXDiahU1zmz5AztXHzQ.png" data-width="1494" data-height="1156" src="https://cdn-images-1.medium.com/max/800/1*1HXVXDiahU1zmz5AztXHzQ.png"></figure><p name="63ed" id="63ed" class="graf graf--p graf-after--figure">我们在后面会介绍储存器上其他部分的用途。</p><p name="bcf1" id="bcf1" class="graf graf--p graf-after--p">2. 算数逻辑单元ALU</p><p name="3f20" id="3f20" class="graf graf--p graf-after--p">ALU是负责将两个数进行算数逻辑运算的元件。具体远离在这里不会详细赘述，在电气工程系列的部分我们会在后面仔细介绍。可以将ALU抽象理解为对数字进行逻辑或者非逻辑（数学或者非数学）运算的集成元件。</p><figure name="2f18" id="2f18" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*2uSS207kBFRUSvWc_6XpfA.png" data-width="922" data-height="394" src="https://cdn-images-1.medium.com/max/800/1*2uSS207kBFRUSvWc_6XpfA.png"><figcaption class="imageCaption">Author: Lambtron</figcaption></figure><p name="01d4" id="01d4" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">三、指令提取阶段 </strong>Fetch instruction</p><p name="8d98" id="8d98" class="graf graf--p graf-after--p">程序地址寄存器Program Counter同 CPU内部的第15号寄存器相连。第15号寄存器记作r15（r表示的是register），这也是CPU内部最后一个寄存器（一共有16个寄存器，标号为r0～r15）。这个寄存器储存的是当前运行的程序的地址。</p><ol class="postList"><li name="e6b9" id="e6b9" class="graf graf--li graf-after--p">r15将当前地址推入Program Counter</li></ol><figure name="6c51" id="6c51" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*ivCUqk_lDcO8ODmz5lg4yQ.png" data-width="1232" data-height="596" src="https://cdn-images-1.medium.com/max/800/1*ivCUqk_lDcO8ODmz5lg4yQ.png"><figcaption class="imageCaption">PC = r15</figcaption></figure><p name="4a76" id="4a76" class="graf graf--p graf-after--figure">2. PC将其内容推入地址寄存器（ADDR），内存根据地址寄存器中的地址查找对应地址的内容，之后将找到的内容填入INST寄存器中。</p><figure name="a97c" id="a97c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*4IpWJxcDBXKBDluS3nt5zQ.png" data-width="1414" data-height="718" src="https://cdn-images-1.medium.com/max/800/1*4IpWJxcDBXKBDluS3nt5zQ.png"><figcaption class="imageCaption">ADDR = PC; INST = Memory[ADDR]</figcaption></figure><p name="2584" id="2584" class="graf graf--p graf-after--figure">3. 将PC中的内容「+4」后存入r15寄存器中。「+4」的含义指的是下一个地址的起始地址，原因是内存中一个单元的大小是8bits，但是一个地址的大小是32bits，所以每四个内存单元储存一个地址。因此，我们读取一个地址之后，查找下一个地址要在原来的地址基础上「+4」。</p><figure name="5b31" id="5b31" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*RVXQyvRvy388BEayR0GknA.png" data-width="1354" data-height="628" src="https://cdn-images-1.medium.com/max/800/1*RVXQyvRvy388BEayR0GknA.png"><figcaption class="imageCaption">r15 = PC + 4</figcaption></figure><p name="6c53" id="6c53" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">四、指令解码阶段</strong></p><p name="63d0" id="63d0" class="graf graf--p graf-after--p">通常来说，对于一个指令来说，我们有三种方式表达它：</p><ol class="postList"><li name="94f4" id="94f4" class="graf graf--li graf-after--p">高级语言形式</li></ol><pre name="9470" id="9470" class="graf graf--pre graf-after--li">r0 = r1 + r2</pre><p name="9749" id="9749" class="graf graf--p graf-after--pre">2. 汇编语言形式</p><pre name="6694" id="6694" class="graf graf--pre graf-after--p">add r0, r1, r2</pre><p name="89cd" id="89cd" class="graf graf--p graf-after--pre">3. 机器码形式（二进制 | 十六进制）</p><pre name="db74" id="db74" class="graf graf--pre graf-after--p">1110 0000 1000 0001 0000 0000 0000 0010 | E0 81 00 02 </pre><p name="8029" id="8029" class="graf graf--p graf-after--pre">五、指令执行阶段</p><ol class="postList"><li name="402d" id="402d" class="graf graf--li graf-after--p">立即数赋值到寄存器</li></ol><figure name="31a4" id="31a4" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*92_5n2sQtBmayinNggvIcQ.png" data-width="1372" data-height="680" src="https://cdn-images-1.medium.com/max/800/1*92_5n2sQtBmayinNggvIcQ.png"><figcaption class="imageCaption">mov r0, #1</figcaption></figure><p name="8930" id="8930" class="graf graf--p graf-after--figure">2. 两个寄存器内的数相加</p><figure name="10d3" id="10d3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Xs5-j_0_kHTfoRMY94t7qA.png" data-width="1462" data-height="646" src="https://cdn-images-1.medium.com/max/800/1*Xs5-j_0_kHTfoRMY94t7qA.png"><figcaption class="imageCaption">add r0, r1, r2</figcaption></figure><p name="4aaf" id="4aaf" class="graf graf--p graf-after--figure">3. 寄存器内的数值和立即数相加</p><figure name="d86d" id="d86d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*HylAJ1mSN9oCR5SL5bC4pA.png" data-width="1396" data-height="684" src="https://cdn-images-1.medium.com/max/800/1*HylAJ1mSN9oCR5SL5bC4pA.png"><figcaption class="imageCaption">add r0, r1, #1</figcaption></figure><p name="d564" id="d564" class="graf graf--p graf-after--figure">4. 根据地址找到内存中的数据存到寄存器中</p><figure name="75b7" id="75b7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*p9nB2TqjNJiO3BqwPpi-Ew.png" data-width="1516" data-height="64" src="https://cdn-images-1.medium.com/max/800/1*p9nB2TqjNJiO3BqwPpi-Ew.png"></figure><figure name="c9cd" id="c9cd" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*XlkeuOOoo-ovME9YBV4PZw.png" data-width="1378" data-height="648" src="https://cdn-images-1.medium.com/max/800/1*XlkeuOOoo-ovME9YBV4PZw.png"><figcaption class="imageCaption">Step 1: ADDR = r1, DATA = Memory[ADDR]</figcaption></figure><figure name="6a74" id="6a74" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*jhDEDQJbAg28D83_CYgOlw.png" data-width="1490" data-height="654" src="https://cdn-images-1.medium.com/max/800/1*jhDEDQJbAg28D83_CYgOlw.png"><figcaption class="imageCaption">Step 2: r0 = DATA</figcaption></figure><p name="6a02" id="6a02" class="graf graf--p graf-after--figure">5. 将寄存器中的数据储存到内存中</p><figure name="bb54" id="bb54" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ieO9w9TpobGJXgzHm1-xHQ.png" data-width="1516" data-height="64" src="https://cdn-images-1.medium.com/max/800/1*ieO9w9TpobGJXgzHm1-xHQ.png"></figure><figure name="f563" id="f563" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*5Pp1Zp0r0hfJA6hzi0Tapw.png" data-width="1408" data-height="654" src="https://cdn-images-1.medium.com/max/800/1*5Pp1Zp0r0hfJA6hzi0Tapw.png"><figcaption class="imageCaption">Step1: DATA = r0</figcaption></figure><figure name="05aa" id="05aa" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*KP2GA3fIbtXWUczGX3eWGg.png" data-width="1514" data-height="656" src="https://cdn-images-1.medium.com/max/800/1*KP2GA3fIbtXWUczGX3eWGg.png"><figcaption class="imageCaption">Step2: ADDR = r1, Memory[r1] = DATA</figcaption></figure><p name="9384" id="9384" class="graf graf--p graf-after--figure">六、可视化的ARM模拟</p><p name="496c" id="496c" class="graf graf--p graf-after--p">为了更直观地看出ARM内部寄存器的工作情况，我们可以采用VisUAL软件对其进行模拟。我们可以在下面的链接中找到Windows，MacOSX和Ubuntu版本的安装包：<a href="https://salmanarif.bitbucket.io/visual/downloads.html" data-href="https://salmanarif.bitbucket.io/visual/downloads.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">点击这里</a>。</p><p name="7344" id="7344" class="graf graf--p graf-after--p">首先，我们先来模拟第一个程序：</p><pre name="b753" id="b753" class="graf graf--pre graf-after--p">mov  r0, #1<br>mov  r1, #2<br>add  r2, r0, r1</pre><p name="31de" id="31de" class="graf graf--p graf-after--pre">得到的寄存器结果为：</p><figure name="981b" id="981b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fZxG-QK1J-TbVpdVIW41GQ.png" data-width="2758" data-height="1344" src="https://cdn-images-1.medium.com/max/800/1*fZxG-QK1J-TbVpdVIW41GQ.png"></figure><p name="da00" id="da00" class="graf graf--p graf-after--figure">之后我们再来模拟第二个程序：</p><pre name="991b" id="991b" class="graf graf--pre graf-after--p">ldr r0, =0x100<br>mov r1, #0xff<br>str r1, [r0]<br>ldr r2, [r0]</pre><p name="c38f" id="c38f" class="graf graf--p graf-after--pre">得到的寄存器结果为：</p><figure name="d28a" id="d28a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6t-ULvN3Avf1qlX5fOW07w.png" data-width="2758" data-height="1344" src="https://cdn-images-1.medium.com/max/800/1*6t-ULvN3Avf1qlX5fOW07w.png"></figure><p name="8318" id="8318" class="graf graf--p graf-after--figure">七、Raspberry Pi的GPIO引脚</p><ol class="postList"><li name="7241" id="7241" class="graf graf--li graf-after--p">GPIO引脚用途SELECT寄存器</li></ol><p name="9115" id="9115" class="graf graf--p graf-after--li">GPIO引脚的全称为General Purposed Input / Output Pins，指的是通用I/O引脚。CPU BCM2835一共开放了54个GPIO引脚，但是在Pi上我们可以使用的GPIO引脚的数量为26个。</p><figure name="927e" id="927e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OPLNpAWAreUdgtwPS9ZEvQ.png" data-width="1494" data-height="956" src="https://cdn-images-1.medium.com/max/800/1*OPLNpAWAreUdgtwPS9ZEvQ.png"></figure><p name="c067" id="c067" class="graf graf--p graf-after--figure">GPIO引脚是一种外围设备（Peripherals），也就是说，他们不是由CPU控制的，而是由内存上的特殊内存区域控制的。这个特殊的位于内存上的区域我们称为外围寄存器（Peripheral Registers）。</p><p name="d7b2" id="d7b2" class="graf graf--p graf-after--p">每个GPIO引脚有多种用途，在使用这个引脚之前，我们往往要预先指明GPIO引脚的具体作用。GPIO引脚的作用分为INPUT，OUTPUT，以及ALT0～5八种用途。很明显的计算是，我们可以用3bits来区分这八种状态（在实际的操作中我们也是这样做的）。这3bits的值和状态的对应关系为：</p><figure name="c9f6" id="c9f6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*AYWL7kc2NTTxqo_kOpheHg.png" data-width="1574" data-height="486" src="https://cdn-images-1.medium.com/max/800/1*AYWL7kc2NTTxqo_kOpheHg.png"></figure><p name="1c30" id="1c30" class="graf graf--p graf-after--figure">为了能够控制引脚实现不同的功能，我们在刚刚提到的外围寄存器（Peripheral Registers）中划分了一块区域，这块区域是在实际物理内存之上的一块区域，它被称为GPIO引脚用途选择寄存器（GPIO Function Select Register）。注意：不论是256M的版本还是512M的版本，这个寄存器始终都是从地址0x2020 0000开始的。【注：这里我还不知道是为什么，因为教程里面用的是512M的Pi（从0x2020 0000开始），而我用的是256M的Pi（也是从0x2020 0000开始的，从0x1020 0000开始并不能对GPIO引脚的作用进行控制）。这里可能要找了解的人问一下？】</p><figure name="a2c2" id="a2c2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*P4i4iT8uyveqtg3i3VKrfQ.png" data-width="1606" data-height="730" src="https://cdn-images-1.medium.com/max/800/1*P4i4iT8uyveqtg3i3VKrfQ.png"></figure><p name="383c" id="383c" class="graf graf--p graf-after--figure">对于这个寄存器来说，它每控制10个GPIO引脚需要3个bit，那么它控制每10个pin就要30bits，我们废弃两个bits的空间，得到一个4字节的32位寄存器。因为一共有54个GPIO，所以我们需要54/10 =5.4~6个4字节的32位寄存器作为GPIO引脚用途选择寄存器（GPIO Function Select Register）。</p><figure name="dffa" id="dffa" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*d8Qs_13DUfFgAwje1_9rxA.png" data-width="1574" data-height="178" src="https://cdn-images-1.medium.com/max/800/1*d8Qs_13DUfFgAwje1_9rxA.png"><figcaption class="imageCaption">GPIO Function Select Register （10GPIO）</figcaption></figure><p name="b35c" id="b35c" class="graf graf--p graf-after--figure">我们还可以通过下面的链接（<a href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" data-href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Click这里</a>）找到Broadcom公司BCM2835处理器的进一步信息。我们可以在该文档中搜索Register View来查看GPIO引脚控制信息。通过这里，我们可以看到实际上有41个外围寄存器被用于控制GPIO引脚（包括了其他的功能）。</p><figure name="a6c7" id="a6c7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*KkdA3Tk7m0RQISVsPTeAKA.png" data-width="1260" data-height="676" src="https://cdn-images-1.medium.com/max/800/1*KkdA3Tk7m0RQISVsPTeAKA.png"></figure><p name="0afb" id="0afb" class="graf graf--p graf-after--figure">实际的信息按照上面的文档给出的为准，要注意下面几个问题：</p><ul class="postList"><li name="f583" id="f583" class="graf graf--li graf-after--p">文档中控制GPIO引脚的地址是以0x7E开头的，实际中引脚的地址是以0x20开头的。</li><li name="498d" id="498d" class="graf graf--li graf-after--li">一个GPIO引脚用途选择寄存器在文档中的名称为GPFSEL，其中GPFSEL0～5（共6个寄存器）就是我们在上面提到的。具体的计算方法刚刚已经说过了。</li></ul><p name="f4c5" id="f4c5" class="graf graf--p graf-after--li">下面我们来通过VisUAL模拟一段代码，这段代码的用途是更改GPIO20引脚的用途为OUTPUT。</p><pre name="db80" id="db80" class="graf graf--pre graf-after--p">  mov  r0, #0x20<br>  <br>  lsl  r1, r0, #24<br>  lsl  r2, r0, #16<br>  <br>  orr  r1, r1, r2<br>  orr  r0, r1, #0x08<br>  <br>  mov  r1, #1<br>  str  r1, [r0]</pre><figure name="0271" id="0271" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*EWY_z8l9QI6HgCpzInutcA.png" data-width="2766" data-height="1350" src="https://cdn-images-1.medium.com/max/800/1*EWY_z8l9QI6HgCpzInutcA.png"></figure><p name="3e53" id="3e53" class="graf graf--p graf-after--figure">我们下面来分析这一段代码。</p><p name="958e" id="958e" class="graf graf--p graf-after--p">第1行代码将寄存器r0的值赋值为0x20，就相当于r0中的值变为 0x0000 0020。</p><p name="c150" id="c150" class="graf graf--p graf-after--p">第3行和第4行中的lsl指令（指的是Logic Shift Left）是逻辑左移指令，指的是将r0中的数值向左移动「立即数」（这个立即数就是#后面的数值）位，低位用0占位。通过这两步，我们将寄存器r1中的值变为0x 2000 0000，将寄存器r2中的值变为0x 0020 0000。</p><p name="5246" id="5246" class="graf graf--p graf-after--p">第6行通过将r1和r2之中的值做OR运算，得到GPIO引脚用途选择寄存器的GPFSEL0的初始地址。orr指令指的是做OR运算。这一步也可以用add指令来实现。</p><p name="6894" id="6894" class="graf graf--p graf-after--p">由于我们想要更改的引脚为GPIO20，而CPIO20的作用是GPFSEL2（第三个GPFSEL寄存器）中的最低3bits决定的。所以，我们只需要改变GPFSEL2中的值为0x 0000 0001即可（001表示OUTPUT）。并且，GPFSEL2的起始地址为0x 2020 0008，所以我们要构造这个地址。</p><p name="c552" id="c552" class="graf graf--p graf-after--p">第7行通过r1和立即数0x08之间做OR运算，得到GPIO引脚用途选择寄存器的GPFSEL2的初始地址0x 2020 0008，并且将这一地址存入r0中。这一步也可以用add指令来实现。</p><p name="c2f0" id="c2f0" class="graf graf--p graf-after--p">第9行我们将r1寄存器的值赋值为立即数1，也就是0x 0000 0001，我们下一步就可以将这个值输出到GPFSEL2寄存器中。</p><p name="8c24" id="8c24" class="graf graf--p graf-after--p">第10行我们通过str指令，根据r0中储存的地址，将r1寄存器中的值输出到GPFSEL2寄存器，从而使GPFSEL2寄存器内的值被更改为0x 0000 0001，GPIO20引脚的作用被设置为OUTPUT，我们可以通过GPIO20来输出脉冲了。（同时，GPIO21～29被设置为了INPUT）</p><p name="d083" id="d083" class="graf graf--p graf-after--p">2. GPIO引脚SET寄存器</p><p name="dd01" id="dd01" class="graf graf--p graf-after--p">跟在6个GPFSEL寄存器之后是一个保留的地址，之后是GPSET寄存器（GPIO引脚SET寄存器，GPIO SET Register）。GPSET寄存器的每一位表示的是一个GPIO引脚的状态（1表示高电平HIGH，0表示低电平LOW）。因此，54个GPIO引脚需要的GPSET寄存器数量为54/32 = 1.69~2个，GPSET1寄存器中多余的位是被废弃的。</p><figure name="d6e4" id="d6e4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*hgLD8j-QA0WD8JiS2hNU1w.png" data-width="1202" data-height="208" src="https://cdn-images-1.medium.com/max/800/1*hgLD8j-QA0WD8JiS2hNU1w.png"></figure><figure name="85c7" id="85c7" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*ZzRrkiLCTI48Ak936w5Wjw.png" data-width="1576" data-height="236" src="https://cdn-images-1.medium.com/max/800/1*ZzRrkiLCTI48Ak936w5Wjw.png"><figcaption class="imageCaption">GPSET0寄存器（上）、GPSET1寄存器（下）</figcaption></figure><p name="7d5c" id="7d5c" class="graf graf--p graf-after--figure">下面我们来通过VisUAL模拟一段代码，这段代码的用途是更改GPIO20引脚的状态为高电平HIGH。</p><pre name="c1ac" id="c1ac" class="graf graf--pre graf-after--p">   mov r0, #0x20     <br><br>   lsl r1, r0, #24   <br>   lsl r2, r0, #16   </pre><pre name="0825" id="0825" class="graf graf--pre graf-after--pre">   orr r1, r1, r2    <br>   orr r0, r1, #0x1c <br><br>   mov r1, #1<br>   lsl r1, r1, #20   <br>   str r1, [r0]      <br><br>loop  <br>   b loop</pre><figure name="e9ba" id="e9ba" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*OXyrOKqPYaHlMVWj_NrSCQ.png" data-width="2768" data-height="1346" src="https://cdn-images-1.medium.com/max/800/1*OXyrOKqPYaHlMVWj_NrSCQ.png"></figure><p name="4fb6" id="4fb6" class="graf graf--p graf-after--figure">执行这一段代码可能会得到一个死循环的警告，不过不用担心，最后的循环的目的是始终将GPIO20的值设置为HIGH。下面我们来逐行分析段代码。</p><p name="19d9" id="19d9" class="graf graf--p graf-after--p">第1行：r0 = 0x 0000 0020</p><p name="27ab" id="27ab" class="graf graf--p graf-after--p">第3行：r1 = 0x 2000 0000</p><p name="9e57" id="9e57" class="graf graf--p graf-after--p">第4行：r2 = 0x 0020 0000</p><p name="6e7e" id="6e7e" class="graf graf--p graf-after--p">第6行：r1 = 0x 2020 0000</p><p name="ba96" id="ba96" class="graf graf--p graf-after--p">第7行：r0 = 0x 2020 001c</p><p name="0375" id="0375" class="graf graf--p graf-after--p">第9行：r1 = 0x 0000 0001</p><p name="0f31" id="0f31" class="graf graf--p graf-after--p">第10行：r1 = 0x 0010 0000</p><p name="cd87" id="cd87" class="graf graf--p graf-after--p">第11行：将r1的值存储到GPSET0（起始地址为0x 2020 001c）</p><p name="f0dc" id="f0dc" class="graf graf--p graf-after--p">第13行：规定跳转的目标LABEL loop的位置</p><p name="20fc" id="20fc" class="graf graf--p graf-after--p graf--trailing">第14行：b指令为无判断的跳转指令，它指的是跳转到给定的LABEL的位置。第14行的目的是保持程序的运行，从而将GPIO20的状态保持为HIGH。</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/b66e1083f4f8"><time class="dt-published" datetime="2020-05-03T10:26:23.367Z">May 3, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B56-arm%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84-b66e1083f4f8" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>