<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>密码导论2 对称密码</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">密码导论2 对称密码</h1>
</header>
<section data-field="subtitle" class="p-summary">
系列：密码导论
</section>
<section data-field="body" class="e-content">
<section name="ba8b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="06d9" id="06d9" class="graf graf--h3 graf--leading graf--title">密码导论2 对称密码</h3><figure name="03a8" id="03a8" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*EMMJWRwbE-Ua0JxrAZskPA.jpeg" data-width="2250" data-height="1500" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*EMMJWRwbE-Ua0JxrAZskPA.jpeg"></figure><ol class="postList"><li name="39f6" id="39f6" class="graf graf--li graf-after--figure">流密码 Stream cipher</li></ol><p name="ab29" id="ab29" class="graf graf--p graf-after--li">流密码的主要特征是逐字节或者逐比特地处理信息。首先，流密码的密钥和流密码的明文长度上是相同的，但是由于每次改变密钥的操作过于复杂，所以实际密钥都是派生于一个较短的密钥，通过某种伪随机数生成算法生成一个稍微长一些的密钥。</p><p name="b76e" id="b76e" class="graf graf--p graf-after--p">一般来说，明文和密钥之间会做<strong class="markup--strong markup--p-strong">异或</strong>运算（需要先转换为ASCII码），从而生成密文。因此，流密码的关键就在于基本密钥和实际密钥的生成算法的不可预测性。</p><p name="63ba" id="63ba" class="graf graf--p graf-after--p">（1）反馈移位寄存器 feedback shift register</p><p name="39a7" id="39a7" class="graf graf--p graf-after--p">反馈移位寄存器是一种伪随机数生成方法，下面的图片展示了这种方法的基本内容。在下面的图中，如果生成函数 <em class="markup--em markup--p-em">F(x_i) </em>是线性的，那么我们将这种算法称为线性反馈移位寄存器（Linear feedback shift register，LFSR）。类似地，如果生成函数 <em class="markup--em markup--p-em">F(x_i) </em>是非线性的，那么我们将这种算法称为非线性反馈移位寄存器（Non-linear feedback shift register，NFSR）。</p><figure name="d80e" id="d80e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3saig7NSoRADM8y2Xv20rw.png" data-width="1216" data-height="294" src="https://cdn-images-1.medium.com/max/800/1*3saig7NSoRADM8y2Xv20rw.png"></figure><p name="3751" id="3751" class="graf graf--p graf-after--figure">对于一个反馈移位寄存器来说，它内部可以存储的数位是给定的。一般来说，如果我们希望反馈移位寄存器可以表示一个字符（ASCII码的字母最高位和第二高位总是01，所以是6bit），那么我们可以指定该反馈移位寄存器中存在7个数位。</p><p name="5195" id="5195" class="graf graf--p graf-after--p">假设我们的初始密钥（也称为种子Seed）为字母A（ASCII：65，0100 0001），那么我们就可以得到如下所示的反馈移位寄存器的初始状态，如下图所示：</p><figure name="dfc3" id="dfc3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*bYk_glNNwJq13ydUg-TZMg.png" data-width="1306" data-height="232" src="https://cdn-images-1.medium.com/max/800/1*bYk_glNNwJq13ydUg-TZMg.png"></figure><p name="0be3" id="0be3" class="graf graf--p graf-after--figure">假设我们采用的生成算法是异或，并且我们人为规定是出队列的数和4号位（此位置也称为抽头 tap = 4）置的数进行异或（这是一种LFSR），由于每次是高位出队列，所以我们有下图所示的生成：</p><figure name="50ba" id="50ba" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6J4uOh2U-caDjLFI4aBMMw.png" data-width="1446" data-height="560" src="https://cdn-images-1.medium.com/max/800/1*6J4uOh2U-caDjLFI4aBMMw.png"></figure><p name="2296" id="2296" class="graf graf--p graf-after--figure">假设我们的明文是Rabbit，我们的Seed是A，那么根据上面的操作，我们需要从Seed生成一个6字符的密钥。在生成算法中，我们指明tap为4，由此可以得到下面的图。根据下面的图中内容所示，我们得到的随机生成密钥为：ABDHQb。</p><figure name="b6cf" id="b6cf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*oIPAqe8BFTpDxtQL4h3qAw.png" data-width="1446" data-height="772" src="https://cdn-images-1.medium.com/max/800/1*oIPAqe8BFTpDxtQL4h3qAw.png"></figure><p name="b772" id="b772" class="graf graf--p graf-after--figure">接下来我们再对此后六位（原因为了尽量输出字母）逐位进行异或操作。由此，我们可以得到密文为：ScfjxV。综上所述，有如下内容：</p><pre name="2155" id="2155" class="graf graf--pre graf-after--p">明文：Rabbit<br>加密方法：6位LFSR异或，tap=4<br>Seed：A<br>生成密钥：ABDHQb<br>密文：ScfjxV</pre><p name="b77c" id="b77c" class="graf graf--p graf-after--pre">在实际的应用中，可能我们需要多个位置作为tap，那么此步骤可以通过设置mask掩码来实现。</p><pre name="a168" id="a168" class="graf graf--pre graf-after--p">output = (Seed &lt;&lt; 1) &amp; 0xffffffff  # Seed删除最高位，最低位填充0<br>i = (Seed &amp; mask) &amp; 0xffffffff     # 得到所有mask中指定位置的值<br>lastbit = 0<br>while i!=0:                        # 对mask中全部指定的值做异或运算<br>     lastbit ^= (i &amp; 1)<br>     i = i &gt;&gt; 1<br>output ^= lastbit                  # 将得到的最低位数值赋给结果的最低位</pre><p name="db9e" id="db9e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. 分组密码 Block cipher</strong></p><p name="c8fd" id="c8fd" class="graf graf--p graf-after--p">分组密码的基本策略主要有两种，一种是混淆，另一种是扩散。</p><p name="ebab" id="ebab" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">混淆</strong>指的是将密文与密钥之间的统计关系变得尽可能复杂，使得即使攻击者查获了一些密文的统计特性，也无法推测密钥。常见的混淆方法一般指的是复杂的非线性变换例如S盒（用于DES加密）和乘法。</p><p name="52c6" id="52c6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">扩散</strong>指的是微小的明文变化会引起大量的密文变化。这里用到的方法主要是线性变换、置换、以及移位。</p><p name="6018" id="6018" class="graf graf--p graf-after--p">一般来说，分组密码都会涉及<strong class="markup--strong markup--p-strong">迭代</strong>过程。在分组密码的加密结构中最常见的就是迭代结构。迭代结构一般涉及密钥置换，轮加密函数，以及轮解密函数。轮函数又分为Feistel Network（常用于DES加密算法）以及Substitution-Permutation Network（简称SPN）（常用于AES加密算法）。</p><p name="f539" id="f539" class="graf graf--p graf-after--p">（1）Data Encryption Standard（DES加密算法）</p><p name="d6cf" id="d6cf" class="graf graf--p graf-after--p">明文的输入和密文的输出都是64位，输入的密钥也是64位，但是只使用其中的56位，其他8位要么丢弃，要么作为奇偶校验位。DES算法使用的迭代结构是Feistel Network，其中迭代的次数为16次。DES的加密和解密使用的是同一套逻辑方法，并且密钥的顺序恰好相反（根据给定的64位密钥生成的16组密钥顺序相反，而不是64位密钥本身相反）。</p><figure name="e055" id="e055" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ODnsvnMd01RyTfnyQ0P7Vw.png" data-width="1318" data-height="688" src="https://cdn-images-1.medium.com/max/800/1*ODnsvnMd01RyTfnyQ0P7Vw.png"></figure><p name="99a3" id="99a3" class="graf graf--p graf-after--figure">下面我们来仔细了解这种算法：</p><p name="1a4a" id="1a4a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">A. 明文的处理</strong></p><p name="4eda" id="4eda" class="graf graf--p graf-after--p">假设我们的明文为 Hello World! ，首先第一步，我们要将明文转化为二进制（规则为ASCII）：</p><pre name="9a5d" id="9a5d" class="graf graf--pre graf-after--p">----H----|----e----|----l----|----l----|----o----|---- ----<br>0100 1000 0110 0101 0110 1100 0110 1100 0110 1111 0010 0000<br>----W----|----o----|----r----|----l----|----d----|----!----<br>0101 0111 0110 1111 0111 0010 0110 1100 0110 0100 0010 0001</pre><p name="8be6" id="8be6" class="graf graf--p graf-after--pre">之后，我们将明文的二进制划分为64bit的分组（例如第一组为）：</p><pre name="e409" id="e409" class="graf graf--pre graf-after--p">block1 =[<br>0100 1000<br>0110 0101<br>0110 1100<br>0110 1100<br>0110 1111<br>0010 0000<br>0101 0111<br>0110 1111<br>]</pre><p name="de8b" id="de8b" class="graf graf--p graf-after--pre">首先，我们根据已经人为规定好的数组IP对此block1进行重排，IP被人为规定为：</p><pre name="42d0" id="42d0" class="graf graf--pre graf-after--p">58,50,42,34,26,18,10,2,<br>60,52,44,36,28,20,12,4, <br>62,54,46,38,30,22,14,6, <br>64,56,48,40,32,24,16,8, <br>57,49,41,33,25,17, 9,1, <br>59,51,43,35,27,19,11,3, <br>61,53,45,37,29,21,13,5, <br>63,55,47,39,31,23,15,7,</pre><p name="f55d" id="f55d" class="graf graf--p graf-after--pre">对于IP来说，它每一位上的数字i表示的是取出block1中的第i个数字，填充到该位置上。经过重排，我们可以得到新的block：</p><pre name="eb64" id="eb64" class="graf graf--pre graf-after--p">1,1,0,1,1,1,1,1<br>0,1,0,0,0,0,0,0<br>1,1,0,1,1,1,1,0<br>1,1,0,1,0,0,1,0<br>0,0,0,0,0,0,0,0<br>1,0,1,1,1,1,1,0<br>1,0,0,1,1,1,0,1<br>1,1,0,1,0,0,0,0</pre><p name="c055" id="c055" class="graf graf--p graf-after--pre">对于上表，我们从中间将其分成两部分，其中第二个部分我们通过Selection Table进行重排，得到一个48位的表。Selection Table如下所示：</p><pre name="13c7" id="13c7" class="graf graf--pre graf-after--p">32, 1, 2, 3, 4, 5,<br> 4, 5, 6, 7, 8, 9,<br> 8, 9,10,11,12,13,<br>12,13,14,15,16,17,<br>16,17,18,19,20,21,<br>20,21,22,23,24,25,<br>24,25,26,27,28,29,<br>28,29,30,31,32, 1</pre><p name="ce0e" id="ce0e" class="graf graf--p graf-after--pre">第二部分如下所示：</p><pre name="437d" id="437d" class="graf graf--pre graf-after--p">0,0,0,0,0,0,0,0<br>1,0,1,1,1,1,1,0<br>1,0,0,1,1,1,0,1<br>1,1,0,1,0,0,0,0</pre><p name="0bd1" id="0bd1" class="graf graf--p graf-after--pre">生成的结果为：</p><pre name="7540" id="7540" class="graf graf--pre graf-after--p">0 0 0 0 0 0<br>0 0 0 0 0 1<br>0 1 0 1 1 1<br>1 1 1 1 0 1 <br>0 1 0 0 1 1<br>1 1 1 0 1 1 <br>1 1 1 0 1 0<br>1 0 0 0 0 0</pre><p name="bba9" id="bba9" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">B. 密钥生成步骤</strong></p><p name="353a" id="353a" class="graf graf--p graf-after--p">在密钥的生成过程中，我们实际上会得到不止一组密钥。由于我们进行了16次的迭代，这将导致我们生成了16组密钥。</p><p name="97d2" id="97d2" class="graf graf--p graf-after--p">假设我们给定64位密钥如下：</p><pre name="5eb1" id="5eb1" class="graf graf--pre graf-after--p">0 0 1 1 0 1 0 0<br>0 0 1 0 1 1 0 1<br>1 0 1 1 0 1 0 1<br>1 0 1 0 1 0 0 0<br>0 0 0 1 1 1 0 1<br>1 1 0 1 1 0 1 1<br>1 0 0 1 0 0 0 0<br>0 0 0 0 0 1 0 0</pre><p name="8430" id="8430" class="graf graf--p graf-after--pre">同样地，对于密钥来说，我们也不是随机删除8位，而是根据一个给定的表PC-1进行重排。这个给定的表可以从中间分为两部分，每部分是4行 x 7列的表格。因此，整个表有56位。此表的数值如下：</p><pre name="9861" id="9861" class="graf graf--pre graf-after--p">57,49,41,33,25,17, 9,<br> 1,58,50,42,34,26,18,<br>10, 2,59,51,43,35,27,<br>19,11, 3,60,52,44,36,</pre><pre name="f0e7" id="f0e7" class="graf graf--pre graf-after--pre">63,55,47,39,31,23,15,<br> 7,62,54,46,38,30,22,<br>14, 6,61,53,45,37,29,<br>21,13, 5,28,20,12, 4,</pre><p name="89f8" id="89f8" class="graf graf--p graf-after--pre">根据该表和密钥，我们同样可以得到：</p><pre name="7381" id="7381" class="graf graf--pre graf-after--p">0 1 1 0 1 1 0<br>0 0 0 1 0 0 0<br>0 0 0 0 0 0 1<br>1 1 1 0 1 1 1</pre><pre name="10c7" id="10c7" class="graf graf--pre graf-after--pre">0 0 1 0 0 0 0<br>0 1 0 0 1 0 1 <br>1 1 0 0 1 1 1<br>0 1 0 0 1 0 1</pre><p name="2c80" id="2c80" class="graf graf--p graf-after--pre">接下来我们将两个表的第一位分别挪到末尾。此步骤移动的数量根据迭代的次数的不同而不同，具体要求参考下面的表格：</p><figure name="c74b" id="c74b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*lJgd-rMOC8hYWp4cThX52w.png" data-width="1492" data-height="264" src="https://cdn-images-1.medium.com/max/800/1*lJgd-rMOC8hYWp4cThX52w.png"></figure><p name="568b" id="568b" class="graf graf--p graf-after--figure">移动其他各位，结果如下所示：</p><pre name="d7db" id="d7db" class="graf graf--pre graf-after--p">1 1 0 1 1 0 0<br>0 0 1 0 0 0 0<br>0 0 0 0 0 1 1<br>1 1 0 1 1 1 0</pre><pre name="8e6d" id="8e6d" class="graf graf--pre graf-after--pre">0 1 0 0 0 0 0 <br>1 0 0 1 0 1 1<br>1 0 0 1 1 1 0<br>1 0 0 1 0 1 0</pre><p name="25ca" id="25ca" class="graf graf--p graf-after--pre">然后，我们再将两个表拼成一个表。</p><pre name="abb6" id="abb6" class="graf graf--pre graf-after--p">1 1 0 1 1 0 0<br>0 0 1 0 0 0 0<br>0 0 0 0 0 1 1<br>1 1 0 1 1 1 0<br>0 1 0 0 0 0 0 <br>1 0 0 1 0 1 1<br>1 0 0 1 1 1 0<br>1 0 0 1 0 1 0</pre><p name="8ef8" id="8ef8" class="graf graf--p graf-after--pre">接下来我们根据人为规定的PC-2表再对上面的表格进行重排。PC-2表共有48位，这将导致我们最终得到48位的密钥。PC-2的具体数值如下所示：</p><pre name="0e8d" id="0e8d" class="graf graf--pre graf-after--p">14,17,11,24, 1, 5,<br> 3,28,15, 6,21,10,<br>23,19,12, 4,26, 8,<br>16, 7,27,20,13, 2,<br>41,52,31,37,47,55,<br>30,40,51,45,33,48,<br>44,49,39,56,34,53,<br>46,42,50,36,29,32,</pre><p name="2695" id="2695" class="graf graf--p graf-after--pre">变换后的结果为（48位）：</p><pre name="6d39" id="6d39" class="graf graf--pre graf-after--p">0 0 0 0 1 1 <br>0 0 0 0 1 1 <br>1 0 0 1 1 0<br>0 0 1 1 0 1 <br>1 0 0 0 1 1 <br>1 0 0 0 0 1 <br>0 0 1 0 0 1<br>1 1 1 1 0 0 </pre><p name="38e0" id="38e0" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">C. 明文和密钥的异或运算</strong></p><pre name="1e94" id="1e94" class="graf graf--pre graf-after--p">0 0 0 0 0 0            0 0 0 0 1 1<br>0 0 0 0 0 1            0 0 0 0 1 1<br>0 1 0 1 1 1            1 0 0 1 1 0<br>1 1 1 1 0 1            0 0 1 1 0 1<br>0 1 0 0 1 1     ^      1 0 0 0 1 1<br>1 1 1 0 1 1            1 0 0 0 0 1<br>1 1 1 0 1 0            0 0 1 0 0 1<br>1 0 0 0 0 0            1 1 1 1 0 0</pre><p name="2e4b" id="2e4b" class="graf graf--p graf-after--pre">由上面的运算，得到表格：</p><pre name="da11" id="da11" class="graf graf--pre graf-after--p">0 0 0 0 1 1 <br>0 0 0 0 1 0<br>1 1 0 0 0 1 <br>1 1 0 0 0 0<br>1 1 0 0 0 0<br>0 1 1 0 1 0<br>1 1 0 0 1 1 <br>0 1 1 1 0 0 </pre><p name="5d4b" id="5d4b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">D. S盒运算</strong></p><p name="3b4e" id="3b4e" class="graf graf--p graf-after--p">S盒总体包括S1～S8，每一个S盒（64位）内的数字都不同。每一个S盒可以处理一个6位的输入（相当于一行），并且得到4位的输出。8个S盒中的数字分别为：</p><pre name="0d67" id="0d67" class="graf graf--pre graf-after--p">S1 = <br>14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,<br>0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,<br>4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,<br>15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,</pre><pre name="5e5c" id="5e5c" class="graf graf--pre graf-after--pre">S2 = <br>15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,<br>3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,<br>0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,<br>13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9,</pre><pre name="f41f" id="f41f" class="graf graf--pre graf-after--pre">S3 = <br>10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,<br>13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,<br>13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,<br>1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,</pre><pre name="4533" id="4533" class="graf graf--pre graf-after--pre">S4 = <br>7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,<br>13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,<br>10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,<br>3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,</pre><pre name="98bb" id="98bb" class="graf graf--pre graf-after--pre">S5 = <br>2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,<br>14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,<br>4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,<br>11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3,</pre><pre name="f9d2" id="f9d2" class="graf graf--pre graf-after--pre">S6 = <br>12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,<br>10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,<br>9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,<br>4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,</pre><pre name="8386" id="8386" class="graf graf--pre graf-after--pre">S7 = <br>4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,<br>13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,<br>1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,<br>6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,</pre><pre name="050f" id="050f" class="graf graf--pre graf-after--pre">S8 = <br>13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,<br>1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,<br>7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,<br>2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11,</pre><p name="bd3d" id="bd3d" class="graf graf--p graf-after--pre">首先，对于C中计算出的表格的的每一行（一共8行）取第 <em class="markup--em markup--p-em">i</em> 行的第一个数和最后一个数组成一个二位二进制数表示行数，然后取中间的四位二进制数表示列数，在S<em class="markup--em markup--p-em">i</em>盒中找到所需要的数值。例如，下面的表格展示了S1盒的求值。</p><figure name="b25f" id="b25f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rPCp1_aMeteUxIxFYRjYAw.png" data-width="1272" data-height="248" src="https://cdn-images-1.medium.com/max/800/1*rPCp1_aMeteUxIxFYRjYAw.png"></figure><p name="4fa6" id="4fa6" class="graf graf--p graf-after--figure">S盒的结构可以表示为：</p><figure name="573c" id="573c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*FerRsS4bKk-RjuUeIOkVYA.png" data-width="1410" data-height="346" src="https://cdn-images-1.medium.com/max/800/1*FerRsS4bKk-RjuUeIOkVYA.png"></figure><p name="e6e7" id="e6e7" class="graf graf--p graf-after--figure">经过S盒的计算，得到的最终结果是：</p><pre name="ed4d" id="ed4d" class="graf graf--pre graf-after--p">1 1 1 1<br>0 0 0 1 <br>0 1 0 0 <br>1 1 1 1 <br>1 1 1 1 <br>0 1 1 1 <br>0 1 0 1 <br>1 1 0 0</pre><p name="6767" id="6767" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">E. P置换</strong></p><p name="2dac" id="2dac" class="graf graf--p graf-after--p">经过了S盒之后，我们需要再对S盒计算的结果进行P盒置换。P盒的数值如下：</p><pre name="6b78" id="6b78" class="graf graf--pre graf-after--p">16, 7,20,21,<br>29,12,28,17,<br> 1,15,23,26,<br> 5,18,31,10,<br> 2, 8,24,14,<br>32,27, 3, 9,<br>19,13,30, 6,<br>22,11, 4,25,</pre><p name="012c" id="012c" class="graf graf--p graf-after--pre">由此得到：</p><pre name="ca25" id="ca25" class="graf graf--pre graf-after--p">1 0 1 0<br>1 0 1 1<br>1 1 1 1 <br>0 1 0 1<br>1 1 1 1 <br>0 0 1 0<br>1 1 1 0<br>1 0 1 0</pre><p name="9a24" id="9a24" class="graf graf--p graf-after--pre">为了后续计算，我们将此表顺时针旋转90度：</p><pre name="d9f5" id="d9f5" class="graf graf--pre graf-after--p">1 1 0 1 0 1 1 1<br>0 1 0 1 1 1 0 0 <br>1 1 1 1 0 1 1 1<br>0 0 0 1 1 1 1 0</pre><p name="e436" id="e436" class="graf graf--p graf-after--pre">F. 明文第一部分和上表取异或</p><pre name="32df" id="32df" class="graf graf--pre graf-after--p">1,1,0,1,1,1,1,1           1 1 0 1 0 1 1 1<br>0,1,0,0,0,0,0,0           0 1 0 1 1 1 0 0<br>1,1,0,1,1,1,1,0     ^     1 1 1 1 0 1 1 1<br>1,1,0,1,0,0,1,0           0 0 0 1 1 1 1 0</pre><p name="2259" id="2259" class="graf graf--p graf-after--pre">得到：</p><pre name="0fa1" id="0fa1" class="graf graf--pre graf-after--p">0 0 0 0 1 0 0 0<br>0 0 0 1 1 1 0 0 <br>0 0 1 0 1 0 0 1 <br>1 1 0 0 1 1 0 0</pre><p name="0506" id="0506" class="graf graf--p graf-after--pre">G. 根据表格流程重复计算</p><figure name="9770" id="9770" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NLKvb0tWKJ7iQ1BjurqO_g.png" data-width="1762" data-height="1334" src="https://cdn-images-1.medium.com/max/800/1*NLKvb0tWKJ7iQ1BjurqO_g.png"></figure><p name="9ac4" id="9ac4" class="graf graf--p graf-after--figure">上面的内容最终加密的结果为：</p><figure name="5b95" id="5b95" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zuN-8juXd1-yr0Wi4zom8A.png" data-width="938" data-height="338" src="https://cdn-images-1.medium.com/max/800/1*zuN-8juXd1-yr0Wi4zom8A.png"></figure><p name="068e" id="068e" class="graf graf--p graf-after--figure">详细的16轮加密过程可以参考此<a href="https://kathrynneugent.com/wp-content/uploads/2020/04/DESwalkthrough.pdf" data-href="https://kathrynneugent.com/wp-content/uploads/2020/04/DESwalkthrough.pdf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">文档</a>。</p><p name="807d" id="807d" class="graf graf--p graf-after--p">也可以参考此图来进一步理解DES的加密过程。</p><figure name="09fb" id="09fb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kjNyevybDB3ATpjCE_-2VQ.png" data-width="1640" data-height="1342" src="https://cdn-images-1.medium.com/max/800/1*kjNyevybDB3ATpjCE_-2VQ.png"></figure><p name="19fd" id="19fd" class="graf graf--p graf-after--figure">（2）Advanced Encryption Standard（AES加密算法）</p><p name="c31c" id="c31c" class="graf graf--p graf-after--p">AES加密算法最初被设计的目的用来取代DES算法，它使用的不是Feistel结构而是SPN迭代结构。AES加密有三种不同的密钥长度和轮数：</p><ul class="postList"><li name="4543" id="4543" class="graf graf--li graf-after--p">AES-128：128bit密钥，10轮迭代</li><li name="9d2c" id="9d2c" class="graf graf--li graf-after--li">AES-192：192bit密钥，12轮迭代</li><li name="5f83" id="5f83" class="graf graf--li graf-after--li">AES-256：256bit密钥，14轮迭代</li></ul><p name="a5bc" id="a5bc" class="graf graf--p graf-after--li">AES明文和密文的长度是固定的，都是16字节（128bit，是DES的一倍）。此外，AES比DES的安全性更高。AES的原理在这里不去介绍。</p><p name="d1e2" id="d1e2" class="graf graf--p graf-after--p">2. 填充规则</p><p name="31fc" id="31fc" class="graf graf--p graf-after--p">在实际的分组加密中，我们经常会遇到明文不满一组的情况。这时候我们就需要对明文进行填充。</p><p name="1eae" id="1eae" class="graf graf--p graf-after--p">（1）PKCS5 Padding</p><p name="60ed" id="60ed" class="graf graf--p graf-after--p">指的是对不满的字节数填充字节数的二进制。例如，在DES加密中，某组只有三个字节，还差5个字节。那么，对于剩下的字节来说，需要全部填充0x05，也就是0000 0101。PKCS5 Padding是最常见的填充方式。</p><p name="3c66" id="3c66" class="graf graf--p graf-after--p">（2）Padding with 0x80 followed by zero bytes</p><p name="f312" id="f312" class="graf graf--p graf-after--p">待填充的第一个字节填充0x80，之后全部填0。常用于md5和sha1的哈希算法中。</p><p name="10a7" id="10a7" class="graf graf--p graf-after--p">（3）Padding with zero bytes except the last byte equals to the number of paddings</p><p name="0854" id="0854" class="graf graf--p graf-after--p">之后一律填0，除了最后一个填充缺失的数量。</p><p name="226e" id="226e" class="graf graf--p graf-after--p">（4）全部填充0</p><p name="ca9b" id="ca9b" class="graf graf--p graf-after--p">一般来说比较少见，容易出现问题。</p><p name="ffb1" id="ffb1" class="graf graf--p graf-after--p">3. ECB和CBC</p><p name="bfe7" id="bfe7" class="graf graf--p graf-after--p">（1）电子密码本 Electronic Codebook</p><p name="cef3" id="cef3" class="graf graf--p graf-after--p">将分组加密的密文直接按照顺序连在一起，形成的密码本就是ECB，解密是通过对ECB进行分组来实现的。在组的内容一致时，密文的内容中相关部分会完全一致，可能造成信息泄露。因此，ECB常用于单组明文密码。</p><p name="9906" id="9906" class="graf graf--p graf-after--p">（2）密码组链 Cipher-block Chaining</p><p name="f8a9" id="f8a9" class="graf graf--p graf-after--p">CBC的每一组加密都需要密钥和上一组密文（除了第一组，第一组需要初始向量Initialization Vector）的同时参与。CBC的加密方式如下：</p><figure name="a4fd" id="a4fd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Tn4goPXhUCKK4V0_vHbqJw.png" data-width="1290" data-height="516" src="https://cdn-images-1.medium.com/max/800/1*Tn4goPXhUCKK4V0_vHbqJw.png"></figure><p name="008e" id="008e" class="graf graf--p graf-after--figure">CBC的解密方式相当于加密方式的逆运算，要求如下：</p><figure name="ce73" id="ce73" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*7kPvP3NCm1uctMZf9LPNuw.png" data-width="1400" data-height="516" src="https://cdn-images-1.medium.com/max/800/1*7kPvP3NCm1uctMZf9LPNuw.png"></figure><p name="96da" id="96da" class="graf graf--p graf-after--figure graf--trailing">CBC的加密处理不能并行处理，所以CBC比ECB的加密效率低很多。</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/42be3642ac15"><time class="dt-published" datetime="2020-08-03T08:08:34.332Z">August 3, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/%E5%AF%86%E7%A0%81%E5%AF%BC%E8%AE%BA2-%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-42be3642ac15" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>