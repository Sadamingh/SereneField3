<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Java Programming 3 | Array, Coupon Collector Problem, and Self Avoiding Random Walks</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Java Programming 3 | Array, Coupon Collector Problem, and Self Avoiding Random Walks</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Java Programming
</section>
<section data-field="body" class="e-content">
<section name="fec2" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ff3c" id="ff3c" class="graf graf--h3 graf--leading graf--title">Java Programming 3 | Array, <strong class="markup--strong markup--h3-strong">Coupon Collector Problem, and Self Avoiding Random Walks</strong></h3><figure name="6ade" id="6ade" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*o4ZeWGPKLrI1NUAfwERYtg.png" data-width="1576" data-height="862" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*o4ZeWGPKLrI1NUAfwERYtg.png"></figure><ol class="postList"><li name="7665" id="7665" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Array</strong></li></ol><p name="52bc" id="52bc" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Data Structure</strong></p><p name="7dca" id="7dca" class="graf graf--p graf-after--p">A data structure is an arrangement of data that enables efficient processing by a program.</p><p name="d504" id="d504" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Array</strong></p><p name="674c" id="674c" class="graf graf--p graf-after--p">An array is an indexed sequence of values of the same type. The main purpose of an array is to facilitate <strong class="markup--strong markup--p-strong">storage</strong> and <strong class="markup--strong markup--p-strong">manipulation </strong>of data.</p><ul class="postList"><li name="707f" id="707f" class="graf graf--li graf-after--p">Indices start at 0</li><li name="ca85" id="ca85" class="graf graf--li graf-after--li">Given i, the operation of accessing the value a[i] is extremely efficient</li><li name="9390" id="9390" class="graf graf--li graf-after--li">The assignment b = a makes the names b and a reference to the same array</li></ul><p name="6eac" id="6eac" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Initialization Options</strong></p><ul class="postList"><li name="1275" id="1275" class="graf graf--li graf-after--p">Default initialization to 0 for numeric types, for example,</li></ul><pre name="cf6e" id="cf6e" class="graf graf--pre graf-after--li">a = new double[1000];</pre><ul class="postList"><li name="da2a" id="da2a" class="graf graf--li graf-after--pre">Declare, create and initialize in one statement</li></ul><pre name="0b89" id="0b89" class="graf graf--pre graf-after--li">double[] a = new double[1000];</pre><ul class="postList"><li name="cb7f" id="cb7f" class="graf graf--li graf-after--pre">Initialize to literal values</li></ul><pre name="e41c" id="e41c" class="graf graf--pre graf-after--li">double[] x = { 0.3, 0.6, 0.1 };</pre><p name="d107" id="d107" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(4) Basic Supports For Array</strong></p><ul class="postList"><li name="a52a" id="a52a" class="graf graf--li graf-after--p">Declare an array</li></ul><pre name="848e" id="848e" class="graf graf--pre graf-after--li">double[] a;</pre><ul class="postList"><li name="40c4" id="40c4" class="graf graf--li graf-after--pre">Create an array of a given length</li></ul><pre name="aed4" id="aed4" class="graf graf--pre graf-after--li">a = new double[1000];</pre><ul class="postList"><li name="d127" id="d127" class="graf graf--li graf-after--pre">Refer to an array entry by index</li></ul><pre name="42b0" id="42b0" class="graf graf--pre graf-after--li">a[i] = b[j] + c[k];</pre><ul class="postList"><li name="b0ea" id="b0ea" class="graf graf--li graf-after--pre">Refer to the length of an array</li></ul><pre name="c3c7" id="c3c7" class="graf graf--pre graf-after--li">a.length;</pre><p name="f917" id="f917" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(5) Copying an Array</strong></p><p name="bebd" id="bebd" class="graf graf--p graf-after--p">The code b = a does not copy an array (it makes b and a reference to the same array). To copy an array, create a new array, then copy all the values. So we have to assign the element one by one,</p><pre name="9461" id="9461" class="graf graf--pre graf-after--p">double[] b = new double[a.length]; <br>for (int i = 0; i &lt; a.length; i++)  b[i] = a[i];</pre><p name="b192" id="b192" class="graf graf--p graf-after--pre">If we use b = a, then we can get the same array,</p><figure name="ee98" id="ee98" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/09956c0d982c58ed3775c809573d6195.js"></script></figure><pre name="5874" id="5874" class="graf graf--pre graf-after--figure">0 1 2 3 4 5<br>0 1 2 3 4 5</pre><p name="e0aa" id="e0aa" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Array: Examples</strong></p><p name="9e4b" id="9e4b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Create a Deck of Cards</strong></p><p name="23d1" id="23d1" class="graf graf--p graf-after--p">Use nested for loops to put all the cards in the deck.</p><figure name="153e" id="153e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/3e3c2a7d9c12b9ada54f51be21d67a9c.js"></script></figure><p name="8b35" id="8b35" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(2) Take a Card, Any Card</strong></p><p name="5eaa" id="5eaa" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Algorithm:</strong> Take N from the command line and do the following N times</p><ul class="postList"><li name="1599" id="1599" class="graf graf--li graf-after--p">Calculate a random index r between 0 and 51</li><li name="3f3d" id="3f3d" class="graf graf--li graf-after--li">Print deck[r]</li></ul><figure name="d42c" id="d42c" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*FxNdzpuK4qPcWnC-l4xGbg.png" data-width="804" data-height="242" src="https://cdn-images-1.medium.com/max/800/1*FxNdzpuK4qPcWnC-l4xGbg.png"></figure><figure name="6512" id="6512" class="graf graf--figure graf--iframe graf-after--figure"><script src="https://gist.github.com/Sadamingh/6031d5ad5d100a93713036a55b5eaf6f.js"></script></figure><p name="04f0" id="04f0" class="graf graf--p graf-after--figure">Note that the sample is with replacement (the same card can appear multiple times).</p><p name="3c4d" id="3c4d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Shuffle and Deal</strong></p><p name="7c2d" id="7c2d" class="graf graf--p graf-after--p">Suppose we want to shuffle the desk first and then deal with the desk in order. The algorithm should be,</p><ul class="postList"><li name="9f39" id="9f39" class="graf graf--li graf-after--p">Consider each card index<em class="markup--em markup--li-em"> i</em> from 0 to 51</li><li name="2f79" id="2f79" class="graf graf--li graf-after--li">Calculate a random index <em class="markup--em markup--li-em">r</em> between <em class="markup--em markup--li-em">i</em> and 51</li><li name="b096" id="b096" class="graf graf--li graf-after--li">Exchange deck[<em class="markup--em markup--li-em">i</em>] with deck[<em class="markup--em markup--li-em">r</em>]</li><li name="1b26" id="1b26" class="graf graf--li graf-after--li">Print the first N cards in the deck</li></ul><figure name="881b" id="881b" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/Sadamingh/d9c79dce52214f989f68395567a2b6fd.js"></script></figure><p name="9c9a" id="9c9a" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Coupon Collector Problem</strong></p><p name="d666" id="d666" class="graf graf--p graf-after--p">Suppose that we want to have a collection of the coupon and this must be composed by M different coupons in the deck (2 to A). We can conduct this experiment for N times and then calculate the average times we need to get a collection of M coupons.</p><p name="7c2a" id="7c2a" class="graf graf--p graf-after--p">In practice, this question is equivalent to the question that, suppose we want to collect a series of cards as a coupon of a kind of product, and by opening one bag of the product, we can get 1 card per bag. Suppose that there are in total M different cards and we want to collect them all. And the probability of each card in the bag is equal. So how many trials we can have to attempt to get a whole selection of the cards?</p><p name="d209" id="d209" class="graf graf--p graf-after--p">We are not going to go too detailed for this example. What are we going to do is to give us the solution to this problem directly. Based on the <a href="https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant" data-href="https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Euler–Mascheroni constant</a>, we can then have the conclusion the expectation of the attempts should be,</p><figure name="d379" id="d379" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*SThO_mbbrVwntNLQtNrNfA.png" data-width="1608" data-height="124" src="https://cdn-images-1.medium.com/max/800/1*SThO_mbbrVwntNLQtNrNfA.png"></figure><p name="8e53" id="8e53" class="graf graf--p graf-after--figure">In our code, we are going to have two parameters, the first one is the numbers of the coupons M, the second one is trials of the experiment N. We are going to print three results, real mean attempts for M coupons after N trials, the estimated expectation attempts by Euler–Mascheroni constant, and finally the error between these two values.</p><figure name="6188" id="6188" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/6129817193eb7b7111efedba3834282a.js"></script></figure><p name="771f" id="771f" class="graf graf--p graf-after--figure">We can test the result for M = 4, 13, 100, and more (with 100 trials) …</p><ul class="postList"><li name="e0e4" id="e0e4" class="graf graf--li graf-after--p">M = 4</li></ul><pre name="e6ec" id="e6ec" class="graf graf--pre graf-after--li">4 coupons for mean attempts = 7<br>Estimated result based on Euler–Mascheroni constant = 7.367807297884452<br>Error Value = 0.3678072978844522</pre><ul class="postList"><li name="5704" id="5704" class="graf graf--li graf-after--pre">M = 13</li></ul><pre name="1877" id="1877" class="graf graf--pre graf-after--li">13 coupons for mean attempts = 39<br>Estimated result based on Euler–Mascheroni constant = 39.267888670565874<br>Error Value = 0.26788867056587407</pre><ul class="postList"><li name="c239" id="c239" class="graf graf--li graf-after--pre">M = 100</li></ul><pre name="1f47" id="1f47" class="graf graf--pre graf-after--li">100 coupons for mean attempts = 505<br>Estimated result based on Euler–Mascheroni constant = 506.08276493393134<br>Error Value = 1.0827649339313439</pre><p name="81e5" id="81e5" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. Two-Dimension Array</strong></p><p name="1039" id="1039" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of A Two-Dimension Array</strong></p><p name="9826" id="9826" class="graf graf--p graf-after--p">A two-dimensional array is a doubly-indexed sequence of values of the same type. The main purpose of the two-dimension array is to facilitate the storage and manipulate data. Java language support for two-dimensional arrays.</p><p name="8b66" id="8b66" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Initialization Options</strong></p><ul class="postList"><li name="4a27" id="4a27" class="graf graf--li graf-after--p">Default initialization to 0 for numeric types</li></ul><pre name="036f" id="036f" class="graf graf--pre graf-after--li">a = new double[1000][1000];</pre><ul class="postList"><li name="34e8" id="34e8" class="graf graf--li graf-after--pre">Declare, create and initialize in a single statement</li></ul><pre name="4cfc" id="4cfc" class="graf graf--pre graf-after--li">double[][] a = new double[1000][1000];</pre><ul class="postList"><li name="00e9" id="00e9" class="graf graf--li graf-after--pre">Initialize to literal values</li></ul><pre name="871c" id="871c" class="graf graf--pre graf-after--li">double[][] p =<br>            {<br>                    { .92, .02, .02, .02, .02 },<br>                    { .02, .92, .32, .32, .32 },<br>                    { .02, .02, .02, .92, .02 },<br>                    { .92, .02, .02, .02, .02 },<br>                    { .47, .02, .47, .02, .02 },<br>            };</pre><p name="806b" id="806b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Basic Operations</strong></p><ul class="postList"><li name="7ec1" id="7ec1" class="graf graf--li graf-after--p">Declare a two-dimensional array</li></ul><pre name="fb11" id="fb11" class="graf graf--pre graf-after--li">double[][] a;</pre><ul class="postList"><li name="a168" id="a168" class="graf graf--li graf-after--pre">Create a two-dimensional array of a given length</li></ul><pre name="032c" id="032c" class="graf graf--pre graf-after--li">a = new double[1000][1000];</pre><ul class="postList"><li name="2384" id="2384" class="graf graf--li graf-after--pre">Refer to an array entry by index</li></ul><pre name="b4ce" id="b4ce" class="graf graf--pre graf-after--li">a[i][j] = b[i][j] * c[j][k];</pre><ul class="postList"><li name="6d5d" id="6d5d" class="graf graf--li graf-after--pre">Refer to the number of rows</li></ul><pre name="75b5" id="75b5" class="graf graf--pre graf-after--li">a.length;</pre><ul class="postList"><li name="ff2c" id="ff2c" class="graf graf--li graf-after--pre">Refer to the number of columns</li></ul><pre name="af2a" id="af2a" class="graf graf--pre graf-after--li">a[i].length;</pre><ul class="postList"><li name="9dc7" id="9dc7" class="graf graf--li graf-after--pre">Refer to row <em class="markup--em markup--li-em">i</em></li></ul><pre name="b839" id="b839" class="graf graf--pre graf-after--li">a[i]</pre><p name="7f50" id="7f50" class="graf graf--p graf-after--pre">Note that there’s no way to refer directly to column <em class="markup--em markup--p-em">j</em>.</p><p name="2cc3" id="2cc3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Vector and Matrix Calculations</strong></p><ul class="postList"><li name="d05a" id="d05a" class="graf graf--li graf-after--p">Vector Addition</li></ul><pre name="1058" id="1058" class="graf graf--pre graf-after--li">double[] c = new double[N]; <br>for (int i = 0; i &lt; N; i++)<br>    c[i] = a[i] + b[i];</pre><ul class="postList"><li name="3a49" id="3a49" class="graf graf--li graf-after--pre">Matrix Addition</li></ul><pre name="917b" id="917b" class="graf graf--pre graf-after--li">double[][] c = new double[N][N]; <br>for (int i = 0; i &lt; N; i++)<br>    for (int j = 0; j &lt; N; j++)<br>        c[i][j] = a[i][j] + b[i][j];</pre><ul class="postList"><li name="484b" id="484b" class="graf graf--li graf-after--pre">Vector Dot Product</li></ul><pre name="a825" id="a825" class="graf graf--pre graf-after--li">double sum = 0.0;<br>for (int i = 0; i &lt; N; i++)<br>    sum += a[i]*b[i];</pre><ul class="postList"><li name="9776" id="9776" class="graf graf--li graf-after--pre">Matrix Multiplication</li></ul><pre name="839e" id="839e" class="graf graf--pre graf-after--li">double[][] c = new double[N][N];<br>for (int i = 0; i &lt; N; i++)<br>    for (int j = 0; j &lt; N; j++)<br>        for (int k = 0; k &lt; N; k++)<br>            c[i][j] += a[i][k] * b[k][j];</pre><p name="dedb" id="dedb" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(5) Two-Dimension Array: Self Avoiding Random Walks</strong></p><p name="2711" id="2711" class="graf graf--p graf-after--p">So our model here is a random process in an N-by-N lattice followed by the steps:</p><ul class="postList"><li name="50ba" id="50ba" class="graf graf--li graf-after--p">start in the middle</li><li name="36b1" id="36b1" class="graf graf--li graf-after--li">move to a random neighboring intersection but do not revisit any intersection</li><li name="64f8" id="64f8" class="graf graf--li graf-after--li">Escape: reach edge of the lattice</li><li name="cdfe" id="cdfe" class="graf graf--li graf-after--li">Dead end: No unvisited neighbors</li></ul><figure name="3520" id="3520" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/Sadamingh/518c56691e0e8cbefaabff3dcc1f18b3.js"></script></figure><p name="3f18" id="3f18" class="graf graf--p graf-after--figure">To try this code, we can then have the result as,</p><pre name="737b" id="737b" class="graf graf--pre graf-after--p">10 by 10 lattice with 5% dead ends for 1000000 trials.<br>20 by 20 lattice with 32% dead ends for 1000000 trials.<br>30 by 30 lattice with 59% dead ends for 1000000 trials.<br>40 by 40 lattice with 77% dead ends for 1000000 trials.<br>50 by 50 lattice with 87% dead ends for 1000000 trials.<br>60 by 60 lattice with 93% dead ends for 1000000 trials.<br>70 by 70 lattice with 96% dead ends for 1000000 trials.<br>80 by 80 lattice with 98% dead ends for 1000000 trials.<br>90 by 90 lattice with 99% dead ends for 1000000 trials.<br>100 by 100 lattice with 99% dead ends for 1000000 trials.</pre><p name="f2ef" id="f2ef" class="graf graf--p graf-after--pre graf--trailing">This result has many physical applications (solvents, polymers, magnetic materials, etc.) and the probability of reaching a dead hasn’t been solved by the mathematicians and the physics researchers despite decades of study. But we can clearly see from our program that when N &gt; 100, the probability of dead ends is greater than 99%.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/5af3af86bc63"><time class="dt-published" datetime="2020-09-17T07:09:42.280Z">September 17, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/java-programming-3-array-coupon-collector-problem-and-self-avoiding-random-walks-5af3af86bc63" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>