<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Java Programming 6 | Functions and Libraries</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Java Programming 6 | Functions and Libraries</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Java Programming
</section>
<section data-field="body" class="e-content">
<section name="12f5" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4c04" id="4c04" class="graf graf--h3 graf--leading graf--title">Java Programming 6 | Functions and Libraries</h3><figure name="2d2e" id="2d2e" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*D-GxAy97o2fapYWM.png" data-width="1400" data-height="765" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*D-GxAy97o2fapYWM.png"></figure><ol class="postList"><li name="c379" id="c379" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Modular Programming</strong></li></ol><p name="b7fa" id="b7fa" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Libraries</strong></p><p name="52ff" id="52ff" class="graf graf--p graf-after--p">A library is a set of functions.</p><p name="c614" id="c614" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Java Modules</strong></p><p name="bbbb" id="bbbb" class="graf graf--p graf-after--p">A java module is a <code class="markup--code markup--p-code">.java</code> file. Because a java module contains sets of functions, libraries and modules are basically the same thing.</p><p name="4091" id="4091" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of Java Functions</strong></p><p name="be2c" id="be2c" class="graf graf--p graf-after--p">The java functions, which are also called the <strong class="markup--strong markup--p-strong">static methods</strong>, take zero or more arguments and return zero or more output values. Because Java functions are more general than mathematical functions, they may cause some side effects like bugs, exceptions, or other calls.</p><p name="7bc4" id="7bc4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">main</strong></code><strong class="markup--strong markup--p-strong"> Function</strong></p><p name="b0c9" id="b0c9" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">main</code> function is the entrance where we start when we execute a program. Therefore, we can only have one <code class="markup--code markup--p-code">main</code> functions in one program and the name of this function must be <code class="markup--code markup--p-code">main</code>.</p><p name="0be2" id="0be2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) The Definition of Scope</strong></p><p name="a1d8" id="a1d8" class="graf graf--p graf-after--p">The scope of a variable i the code that can refer to it by name. In a Java library, a variable’s scope is the code following its declaration, in the same block.</p><p name="95bc" id="95bc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Flow of Control</strong></p><p name="601e" id="601e" class="graf graf--p graf-after--p">In Java, OS first calls <code class="markup--code markup--p-code">main()</code> on java command. Then the control transfers to the function code. Then argument variables are declared and initialized with the given values and the function code is executed. Finally, control transfers back to the calling code with the return value assigned in place of the function name in the calling code.</p><p name="ae00" id="ae00" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Case Study of Functions: Digital Audio</strong></p><p name="d80e" id="d80e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Sound</strong></p><p name="f76f" id="f76f" class="graf graf--p graf-after--p">Sound is the perception of the vibration of molecules.</p><p name="e403" id="e403" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Musical Tone</strong></p><p name="4e58" id="4e58" class="graf graf--p graf-after--p">A musical tone is a steady periodic sound.</p><p name="e7c5" id="e7c5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of Pure Tone</strong></p><p name="8bc2" id="8bc2" class="graf graf--p graf-after--p">A pure tone is a sinusoidal waveform.</p><p name="97e9" id="97e9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) The Definition of Samples</strong></p><p name="0f40" id="0f40" class="graf graf--p graf-after--p">Similar to drawing a function, the representation of a sound wave is also discrete, and it is decided by how many samples per second. This concept is called samples because it is firstly the samples we take for recording sounds. A Sony standard CD has 44,100 samples per second.</p><p name="a208" id="a208" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">StdAudio</strong></code><strong class="markup--strong markup--p-strong"> Library</strong></p><ul class="postList"><li name="423c" id="423c" class="graf graf--li graf-after--p">play a <code class="markup--code markup--li-code">wav</code> file</li></ul><pre name="41ef" id="41ef" class="graf graf--pre graf-after--li">void play(String filename)</pre><ul class="postList"><li name="d564" id="d564" class="graf graf--li graf-after--pre">play the given sound wave <code class="markup--code markup--li-code">a</code></li></ul><pre name="c48e" id="c48e" class="graf graf--pre graf-after--li">void play(double[] a)</pre><ul class="postList"><li name="3d9c" id="3d9c" class="graf graf--li graf-after--pre">save the soundtrack to a <code class="markup--code markup--li-code">wav</code> file</li></ul><pre name="9213" id="9213" class="graf graf--pre graf-after--li">void save(String file, double[] a)</pre><ul class="postList"><li name="2f33" id="2f33" class="graf graf--li graf-after--pre">read from a <code class="markup--code markup--li-code">wav</code> file</li></ul><pre name="955a" id="955a" class="graf graf--pre graf-after--li">double[] read(String file)</pre><p name="d1d7" id="d1d7" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(6) Example 1: Play A Note</strong></p><p name="17c5" id="17c5" class="graf graf--p graf-after--p">Let’s now see the simplest example for the <code class="markup--code markup--p-code">StdAudio</code> Library. We would like to use this library for playing a note with given seconds. We will take in two arguments, <code class="markup--code markup--p-code">hz</code> means the frequency of the sound, and we can have a quick reference with the following table (e.g. A = 440 Hz),</p><figure name="3024" id="3024" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*asZpZy57OqVxlvy_RdzOIw.png" data-width="1520" data-height="544" src="https://cdn-images-1.medium.com/max/800/1*asZpZy57OqVxlvy_RdzOIw.png"></figure><p name="8ac6" id="8ac6" class="graf graf--p graf-after--figure"><code class="markup--code markup--p-code">duration</code> means how long the note lasts (a duration = 1 means 1 second). The standard we use is to have 44,100 samples per second, so we need to calculate 44,100 pieces of data per second. We need to calculate the array <code class="markup--code markup--p-code">a</code> based on the following formula,</p><figure name="b09b" id="b09b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cQBf1uljbDIVxJoTWVCdjg.png" data-width="1254" data-height="94" src="https://cdn-images-1.medium.com/max/800/1*cQBf1uljbDIVxJoTWVCdjg.png"></figure><p name="ac3d" id="ac3d" class="graf graf--p graf-after--figure">Therefore, the program should be,</p><pre name="5d69" id="5d69" class="graf graf--pre graf-after--p">public class PlayNote {<br>   public static void main(String[] args) {<br>        double hz = Double.parseDouble(args[0]);<br>        double duration = Double.parseDouble(args[1]);<br>        int N = (int) (44100 * duration);<br>        double[] a = new double [N+1];<br>        for (int i = 0; i &lt; N; i++) {<br>         a[i] = Math.sin(2 * Math.PI * i * hz / 44100);<br>        }<br>        StdAudio.play(a);<br> }<br>}</pre><p name="ee00" id="ee00" class="graf graf--p graf-after--pre">We can test this program by,</p><pre name="df31" id="df31" class="graf graf--pre graf-after--p">$ java PlayNote 440 1</pre><p name="cb42" id="cb42" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(7) Example 2: Modulized Play A Note</strong></p><p name="92a7" id="92a7" class="graf graf--p graf-after--p">In the last example, our code is not modulized. To modulize the code above, we are going to create a function <code class="markup--code markup--p-code">tone</code>. This function takes in two arguments <code class="markup--code markup--p-code">hz</code> and <code class="markup--code markup--p-code">duration</code>, and then it outputs the sound wave sequence <code class="markup--code markup--p-code">a</code>. In the <code class="markup--code markup--p-code">main</code> function, we don’t need to realize the details about the <code class="markup--code markup--p-code">tune</code> function anymore, what we can do now is to focus only on the inputs and the outputs. This will bring us some benefits that we are going to talk about in the future. The program should be,</p><pre name="94c8" id="94c8" class="graf graf--pre graf-after--p">public class PlayThatNote<br>{<br>    public static double[] tone(double hz, double duration)<br>    {<br>        int N = (int) (44100 * duration);<br>        double[] a = new double[N+1];<br>        for (int i = 0; i &lt;= N; i++)<br>            a[i] = Math.sin(2 * Math.PI * i * hz / 44100);<br>        return a;<br>    }<br>    public static void main(String[] args)<br>    {<br>        double hz = Double.parseDouble(args[0]);<br>        double duration = Double.parseDouble(args[1]);<br>        double[] a = tone(hz, duration);<br>        StdAudio.play(a);<br>    }<br>}</pre><p name="b2fc" id="b2fc" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(8) Example 3: Modulized Play Für Elise</strong></p><p name="e4f8" id="e4f8" class="graf graf--p graf-after--p">Before we start to write the next program, how about listening to the one piece of music,</p><figure name="ad0a" id="ad0a" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://www.youtube.com/embed/wfF0zHeU3Zs?feature=oembed" width="700" height="393" frameborder="0" scrolling="no"></iframe></figure><p name="6b5c" id="6b5c" class="graf graf--p graf-after--figure">Would you like to play this music with your program? Let’s have a try. In this example, we will use the <code class="markup--code markup--p-code">PlayThatNote.tone</code> method we have created. You can find out that one benefit of modulize the program is that we can easily reuse some functions.</p><p name="718b" id="718b" class="graf graf--p graf-after--p">The data of this music can be found at <a href="https://introcs.cs.princeton.edu/java/21function/elise.txt" data-href="https://introcs.cs.princeton.edu/java/21function/elise.txt" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this link</a>. And based on this data, we have to change the code a little bit. We can find out in this data file <code class="markup--code markup--p-code">elise.txt</code> , the notes are represented by the numbers from 0 to 12. The formula to transfer these numbers to frequencies is as follows,</p><figure name="0b1d" id="0b1d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-1ylE_NYS_uFIZ1DjFoFdQ.png" data-width="1254" data-height="68" src="https://cdn-images-1.medium.com/max/800/1*-1ylE_NYS_uFIZ1DjFoFdQ.png"></figure><p name="0fb7" id="0fb7" class="graf graf--p graf-after--figure">The program should be,</p><pre name="b98d" id="b98d" class="graf graf--pre graf-after--p">public class PlayThatTune<br>{<br>    public static void main(String[] args)<br>    {<br>        double tempo = Double.parseDouble(args[0]);<br>        while (!StdIn.isEmpty())<br>        {<br>            int pitch = StdIn.readInt();<br>            double duration = StdIn.readDouble() * tempo;<br>            double hz = 440 * Math.pow(2, pitch / 12.0);<br>            double[] a = PlayThatNote.tone(hz, duration);<br>            StdAudio.play(a);<br>        }<br>        StdAudio.close();<br>    }<br>}</pre><p name="633f" id="633f" class="graf graf--p graf-after--pre">We can test this code by,</p><pre name="db1d" id="db1d" class="graf graf--pre graf-after--p">$ curl <a href="https://introcs.cs.princeton.edu/java/21function/elise.txt" data-href="https://introcs.cs.princeton.edu/java/21function/elise.txt" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://introcs.cs.princeton.edu/java/21function/elise.txt</a> | java PlayThatTune 1</pre><p name="6f08" id="6f08" class="graf graf--p graf-after--pre">Aha, it sounds awful, right? Let’s find some ways to improve this.</p><p name="fc1a" id="fc1a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Example 4: Play the Chords</strong></p><p name="0a19" id="0a19" class="graf graf--p graf-after--p">If we can implement chords, our music must sound better. But what is the theory of chords? Well, in conclusion producing chords means averaging waveforms. Let’s see an example. Suppose we have two sound waves <code class="markup--code markup--p-code">a[]</code> and <code class="markup--code markup--p-code">b[]</code> , then their chord will simply be the average of them <code class="markup--code markup--p-code">c[] = a[] / 2 + b[] / 2</code> . Based on this theory, we can create a program that can play chords of two notes (remember that using <code class="markup--code markup--p-code">PlayThatNote.tone</code> saves our time),</p><pre name="dd5e" id="dd5e" class="graf graf--pre graf-after--p">public class PlayThatChord<br>{<br>    public static double[] avg(double[] a, double[] b)<br>    {<br>        double[] c = new double[a.length];<br>        for (int i = 0; i &lt; a.length; i++)<br>            c[i] = a[i]/2.0 + b[i]/2.0;<br>        return c;<br>    }<br>    public static double[] chord(int pitch1, int pitch2, double d)<br>    {<br>        double hz1 = 440.0 * Math.pow(2, pitch1 / 12.0);<br>        double hz2 = 440.0 * Math.pow(2, pitch2 / 12.0);<br>        double[] a = PlayThatNote.tone(hz1, d);<br>        double[] b = PlayThatNote.tone(hz2, d);<br>        return avg(a, b);<br>    }<br>    public static void main(String[] args)<br>    {<br>        int pitch1 = Integer.parseInt(args[0]);<br>        int pitch2 = Integer.parseInt(args[1]);<br>        double duration = Double.parseDouble(args[2]);<br>        double[] a = chord(pitch1, pitch2, duration);<br>        StdAudio.play(a);<br>    }<br>}</pre><p name="9f4c" id="9f4c" class="graf graf--p graf-after--pre">And we can test it by,</p><pre name="3167" id="3167" class="graf graf--pre graf-after--p">% java PlayThatChord 0 3 1.0<br>% java PlayThatChord 0 12 1.0</pre><p name="2f5c" id="2f5c" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(10) Example 5: Play Für Elise with Harmonics</strong></p><p name="aef7" id="aef7" class="graf graf--p graf-after--p">By adding harmonics to <code class="markup--code markup--p-code">PlayThatTune</code> , we can produce a more realistic sound. The algorithm that we are going to use is firstly averaging the half frequency <code class="markup--code markup--p-code">lo</code> and the double frequency <code class="markup--code markup--p-code">hi</code> for the current pitch, and what we generate is so-called both harmonics. Then we will average these harmonics with the pure pitch <code class="markup--code markup--p-code">a</code>, which will create our final result. The algorithm method is called <code class="markup--code markup--p-code">note</code> and it will be as follows,</p><pre name="48e4" id="48e4" class="graf graf--pre graf-after--p">public static double[] note(int pitch, double duration) {<br>    double hz = 440.0 * Math.pow(2, pitch / 12.0);<br>    double[] a  = PlayThatNote.tone(hz, duration);<br>    double[] hi = PlayThatNote.tone(2*hz, duration);<br>    double[] lo = PlayThatNote.tone(hz/2, duration);<br>    double[] h  = sum(hi, lo, 0.5, 0.5);<br>    return sum(a, h, 0.5, 0.5);<br>}</pre><p name="2bee" id="2bee" class="graf graf--p graf-after--pre">What’s more, we also need to work out a function for averaging the pitches. This function should be called <code class="markup--code markup--p-code">sum</code> and it takes 4 arguments. Of course, two of them are the arraies of these two pitches. We also have two other arguments, <code class="markup--code markup--p-code">awt</code> and <code class="markup--code markup--p-code">bwt</code> , which simply means the weight of pitch <code class="markup--code markup--p-code">a</code> and pitch <code class="markup--code markup--p-code">b</code>. These values should be subject to the rule of <code class="markup--code markup--p-code">awt + bwt = 1</code>.</p><figure name="8de1" id="8de1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5WBVY1euT87i39iP8v3hww.png" data-width="1374" data-height="548" src="https://cdn-images-1.medium.com/max/800/1*5WBVY1euT87i39iP8v3hww.png"></figure><p name="49e4" id="49e4" class="graf graf--p graf-after--figure">The function <code class="markup--code markup--p-code">sum</code> should be,</p><pre name="1c7c" id="1c7c" class="graf graf--pre graf-after--p">public static double[] sum(double[] a, double[] b, double awt, double bwt) {<br>    assert a.length == b.length;<br>    double[] c = new double[a.length];<br>    for (int i = 0; i &lt; a.length; i++) {<br>        c[i] = a[i]*awt + b[i]*bwt;<br>    }<br>    return c;<br>}</pre><p name="e008" id="e008" class="graf graf--p graf-after--pre">So in general, the program that we can play a tune with harmonics is,</p><pre name="41fd" id="41fd" class="graf graf--pre graf-after--p">public class PlayThatTuneDeluxe {<br>    public static double[] sum(double[] a, double[] b, double awt, double bwt) {<br>        assert a.length == b.length;<br>        double[] c = new double[a.length];<br>        for (int i = 0; i &lt; a.length; i++) {<br>            c[i] = a[i]*awt + b[i]*bwt;<br>        }<br>        return c;<br>    }<br>    public static double[] note(int pitch, double duration) {<br>        double hz = 440.0 * Math.pow(2, pitch / 12.0);<br>        double[] a  = PlayThatNote.tone(hz, duration);<br>        double[] hi = PlayThatNote.tone(2*hz, duration);<br>        double[] lo = PlayThatNote.tone(hz/2, duration);<br>        double[] h  = sum(hi, lo, 0.5, 0.5);<br>        return sum(a, h, 0.5, 0.5);<br>    }<br>    public static void main(String[] args) {<br>        while (!StdIn.isEmpty()) {<br>            int pitch = StdIn.readInt();<br>            double duration = StdIn.readDouble();<br>            double[] a = note(pitch, duration);<br>            StdAudio.play(a);<br>        }<br>    }<br>}</pre><p name="8f36" id="8f36" class="graf graf--p graf-after--pre">We can retry the music and see if it sounds better this time,</p><pre name="656d" id="656d" class="graf graf--pre graf-after--p">$ curl <a href="https://introcs.cs.princeton.edu/java/21function/elise.txt" data-href="https://introcs.cs.princeton.edu/java/21function/elise.txt" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://introcs.cs.princeton.edu/java/21function/elise.txt</a> | java PlayThatTuneDeluxe 1.5</pre><p name="2719" id="2719" class="graf graf--p graf-after--pre">Or we can also try something new,</p><pre name="340e" id="340e" class="graf graf--pre graf-after--p">$ curl <a href="https://introcs.cs.princeton.edu/java/21function/entertainer.txt" data-href="https://introcs.cs.princeton.edu/java/21function/entertainer.txt" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://introcs.cs.princeton.edu/java/21function/entertainer.txt</a> | java PlayThatTuneDeluxe 1.5</pre><p name="0390" id="0390" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. Application of Functions: Gaussian Distribution</strong></p><p name="9254" id="9254" class="graf graf--p graf-after--p">In this part, we will write a bunch of functions that can be used for Gaussian distribution. As what we have talked about in the other series, the Gaussian distribution is a mathematical model that has been used successfully for centuries. It gives useful conclusions for engineering and experimenting.</p><p name="5b1f" id="5b1f" class="graf graf--p graf-after--p">The standard Gaussian distribution should be,</p><figure name="7fad" id="7fad" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kP3Zk6tgj7ARUHrElOZsng.png" data-width="1154" data-height="96" src="https://cdn-images-1.medium.com/max/800/1*kP3Zk6tgj7ARUHrElOZsng.png"></figure><p name="c0b2" id="c0b2" class="graf graf--p graf-after--figure">And a more general form with the standard deviation σ and the mean value μ is,</p><figure name="d4a8" id="d4a8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*AD10NKVIvbH13h-sSpHtrg.png" data-width="1154" data-height="96" src="https://cdn-images-1.medium.com/max/800/1*AD10NKVIvbH13h-sSpHtrg.png"></figure><p name="45b8" id="45b8" class="graf graf--p graf-after--figure">Now let’s write our first function, the standard PDF for Gaussian distribution in the <code class="markup--code markup--p-code">Gaussian</code> class,</p><pre name="5f86" id="5f86" class="graf graf--pre graf-after--p">public class Gaussian<br>{<br>    public static double pdf(double x)<br>    {<br>        return Math.exp(-x*x / 2) / Math.sqrt(2 * Math.PI);<br>    }<br>}</pre><p name="c2d3" id="c2d3" class="graf graf--p graf-after--pre">Now, if we want to add a more general PDF with μ and σ, what can we do? Can we use the same function name <code class="markup--code markup--p-code">pdf</code>? The answer to this question is yes. Functions and libraries provide an easy way for any user to extend the Java system. Java functions with different arguments are different even if their names match. So the general function is,</p><pre name="2391" id="2391" class="graf graf--pre graf-after--p">public class Gaussian<br>{<br>    public static double pdf(double x)<br>    {<br>        return Math.exp(-x*x / 2) / Math.sqrt(2 * Math.PI);<br>    }<br>    public static double pdf(double x, double mu, double sigma)<br>    {<br>        return pdf((x - mu) / sigma) / sigma;<br>    }<br>}</pre><p name="92ba" id="92ba" class="graf graf--p graf-after--pre">Another function we have to implement is the Gaussian cumulative distribution function. It is actually the integration of the Gaussian PDF. However, due to the limitations of mathematics, we can not work out the precise result of this integration. For example, the standard form of its standard CDF should be,</p><figure name="c00d" id="c00d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*gW_GMYOI40WV-ZoRP3uouw.png" data-width="1304" data-height="110" src="https://cdn-images-1.medium.com/max/800/1*gW_GMYOI40WV-ZoRP3uouw.png"></figure><p name="1990" id="1990" class="graf graf--p graf-after--figure">Typically, we get the result of this integration by referring to a table. However, another way to get the result by hand easily is to use the Taylor series. The formula of the Taylor series for the Gaussian CDF is,</p><figure name="082e" id="082e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mxjmZBa1rVdJZvCOA3AMXQ.png" data-width="1304" data-height="110" src="https://cdn-images-1.medium.com/max/800/1*mxjmZBa1rVdJZvCOA3AMXQ.png"></figure><p name="8248" id="8248" class="graf graf--p graf-after--figure">When z is in the scope of (-8, 8), the sum of terms in this series is convergence. However, when <code class="markup--code markup--p-code">z &gt; 8</code> or <code class="markup--code markup--p-code">z &lt; -8</code>, the result of this series will be 1 and 0, respectively. When this sequence converges, based on the feature of a double value, we can finally find a time when <code class="markup--code markup--p-code">sum + term == sum</code>. And we are going to use a loop to get the value for some of the terms at this time. The program should be,</p><pre name="95c2" id="95c2" class="graf graf--pre graf-after--p">public static double cdf(double z)<br>{<br>    if (z &lt; -8.0) return 0.0;<br>    if (z &gt; 8.0) return 1.0;<br>    double sum = 0.0, term = z;<br>    for (int i = 3; sum + term != sum; i += 2)<br>    {<br>        sum = sum + term;<br>        term = term * z * z / i;<br>    }<br>    return 0.5 + sum * pdf(z);<br>}<br>public static double cdf(double z, double mu, double sigma)<br>{ return cdf((z - mu) / sigma); }</pre><p name="b5e1" id="b5e1" class="graf graf--p graf-after--pre">So finally, let’s write the <code class="markup--code markup--p-code">main</code> function. The main function takes in three arguments <code class="markup--code markup--p-code">z</code> , <code class="markup--code markup--p-code">mu</code> , and <code class="markup--code markup--p-code">sigma</code> . And it will print the value of the Gaussian CDF. Therefore, the code of the main function should be,</p><pre name="6c37" id="6c37" class="graf graf--pre graf-after--p">public static void main(String[] args)<br>{<br>    double z = Double.parseDouble(args[0]);<br>    double mu = Double.parseDouble(args[1]);<br>    double sigma = Double.parseDouble(args[2]);<br>    StdOut.println(cdf(z, mu, sigma));<br>}</pre><p name="c0ed" id="c0ed" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4. Modular Programming</strong></p><p name="4d5e" id="4d5e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Signatures</strong></p><p name="ad13" id="ad13" class="graf graf--p graf-after--p">The signature of a function in Java includes,</p><ul class="postList"><li name="39db" id="39db" class="graf graf--li graf-after--p">parameters and their data types</li><li name="962a" id="962a" class="graf graf--li graf-after--li">a return value and its data type</li><li name="2ac9" id="2ac9" class="graf graf--li graf-after--li">exceptions that might be thrown or passed back</li><li name="4e1a" id="4e1a" class="graf graf--li graf-after--li">information about the availability of the method in an object-oriented program (such as the keywords <code class="markup--code markup--li-code">public</code>, <code class="markup--code markup--li-code">static</code>, or <code class="markup--code markup--li-code">prototype</code>).</li></ul><p name="d1ab" id="d1ab" class="graf graf--p graf-after--li">Functions with different signatures will be treated as different functions even though their function names match.</p><p name="dda1" id="dda1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Application Programming Interface (API)</strong></p><p name="4b19" id="4b19" class="graf graf--p graf-after--p">The API is a list that defines the function signatures and describes methods. For example, the API for <code class="markup--code markup--p-code">Gaussian</code> class is,</p><pre name="fbea" id="fbea" class="graf graf--pre graf-after--p">public static double pdf(double x)<br>public static double pdf(double x, double mu, double sigma)<br>public static double cdf(double z)<br>public static double cdf(double z, double mu, double sigma)</pre><p name="b397" id="b397" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">StdRandom</strong></code><strong class="markup--strong markup--p-strong"> Library APIs</strong></p><p name="ef85" id="ef85" class="graf graf--p graf-after--p">The standard random library <code class="markup--code markup--p-code">StdRandom</code> is base on the <code class="markup--code markup--p-code">Math.random()</code> function. It can be used for generating random values based on various distributions.</p><ul class="postList"><li name="579b" id="579b" class="graf graf--li graf-after--p">generate random integers between <code class="markup--code markup--li-code">0</code> to <code class="markup--code markup--li-code">N-1</code></li></ul><pre name="80f4" id="80f4" class="graf graf--pre graf-after--li">int uniform(int N)</pre><ul class="postList"><li name="6129" id="6129" class="graf graf--li graf-after--pre">generate random reals between <code class="markup--code markup--li-code">lo</code> and <code class="markup--code markup--li-code">hi</code></li></ul><pre name="2736" id="2736" class="graf graf--pre graf-after--li">double uniform(double lo, double hi)</pre><ul class="postList"><li name="b19b" id="b19b" class="graf graf--li graf-after--pre">generate boolean values based on the Bernoulli distribution</li></ul><pre name="29cf" id="29cf" class="graf graf--pre graf-after--li">boolean bernoulli(double p)</pre><ul class="postList"><li name="a4c5" id="a4c5" class="graf graf--li graf-after--pre">generate random reals based on standard Gaussian distribution</li></ul><pre name="3b25" id="3b25" class="graf graf--pre graf-after--li">double gaussian()</pre><ul class="postList"><li name="f524" id="f524" class="graf graf--li graf-after--pre">generate random reals based on Gaussian distribution with mean <code class="markup--code markup--li-code">m</code> and standard deviation <code class="markup--code markup--li-code">s</code></li></ul><pre name="3d62" id="3d62" class="graf graf--pre graf-after--li">double gaussian(double m, double s)</pre><p name="a709" id="a709" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(4) Example 1: 2D Gaussian Distribution</strong></p><p name="e4f3" id="e4f3" class="graf graf--p graf-after--p">Now, let’s see an application. Suppose we have an X-Y coordinate plane and the points we are going to draw in this plane follows the Gaussian Distribution both on the X-axis and the Y-axis. Then, the program should be as follows,</p><pre name="922e" id="922e" class="graf graf--pre graf-after--p">public class RandomPoints<br>{<br>    public static void main(String[] args)<br>    {<br>        int N = Integer.parseInt(args[0]);<br>        for (int i = 0; i &lt; N; i++)<br>        {<br>            double x = StdRandom.gaussian(0.5, 0.2);<br>            double y = StdRandom.gaussian(0.5, 0.2);<br>            StdDraw.point(x, y);<br>        }<br>    }<br>}</pre><figure name="7b96" id="7b96" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*EwIVxVpPhaVMIxI8DF2nJA.png" data-width="1424" data-height="388" src="https://cdn-images-1.medium.com/max/800/1*EwIVxVpPhaVMIxI8DF2nJA.png"></figure><p name="1a60" id="1a60" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">StdStats</strong></code><strong class="markup--strong markup--p-strong"> Library APIs</strong></p><p name="f20b" id="f20b" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">StdStats</code> library is implemented for computing statistics on arrays of real numbers. Common methods are,</p><ul class="postList"><li name="b66a" id="b66a" class="graf graf--li graf-after--p">get the largest value</li></ul><pre name="71e9" id="71e9" class="graf graf--pre graf-after--li">double max(double[] a)</pre><ul class="postList"><li name="deac" id="deac" class="graf graf--li graf-after--pre">get the smallest value</li></ul><pre name="0138" id="0138" class="graf graf--pre graf-after--li">double min(double[] a)</pre><ul class="postList"><li name="8547" id="8547" class="graf graf--li graf-after--pre">get the mean value</li></ul><pre name="c329" id="c329" class="graf graf--pre graf-after--li">double mean(double[] a)</pre><ul class="postList"><li name="a884" id="a884" class="graf graf--li graf-after--pre">get the sample variance</li></ul><pre name="0be9" id="0be9" class="graf graf--pre graf-after--li">double var(double[] a)</pre><ul class="postList"><li name="2850" id="2850" class="graf graf--li graf-after--pre">get the standard deviation</li></ul><pre name="aa00" id="aa00" class="graf graf--pre graf-after--li">double stddev(double[] a)</pre><ul class="postList"><li name="2067" id="2067" class="graf graf--li graf-after--pre">get the median value</li></ul><pre name="187a" id="187a" class="graf graf--pre graf-after--li">double median(double[] a)</pre><ul class="postList"><li name="022d" id="022d" class="graf graf--li graf-after--pre">plot all the points at (i, a[i])</li></ul><pre name="617f" id="617f" class="graf graf--pre graf-after--li">void plotPoints(double[] a)</pre><ul class="postList"><li name="23ff" id="23ff" class="graf graf--li graf-after--pre">plot lines connecting points at (i, a[i])</li></ul><pre name="535a" id="535a" class="graf graf--pre graf-after--li">void plotLines(double[] a)</pre><ul class="postList"><li name="2bb2" id="2bb2" class="graf graf--li graf-after--pre">plot bars to points at (i, a[i])</li></ul><pre name="9539" id="9539" class="graf graf--pre graf-after--li">void plotBars(double[] a)</pre><p name="b8b2" id="b8b2" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(6) Example 2: Bernoulli Trials and Central limit theorem</strong></p><p name="def2" id="def2" class="graf graf--p graf-after--p">Now, let’s see an example of the Bernoulli trials, and let’s see if the result of this experiment follows the Gaussian distribution. The question is as follows, suppose we have a coin and we would like to flip it for <code class="markup--code markup--p-code">N</code> times and see how many heads we have. We are going to repeat this trial for <code class="markup--code markup--p-code">trials</code> times, and finally draw a bar plot of experimental result. We are also going to draw the theoretical curve of the Gaussian distribution and see if these two results match. The program should be,</p><pre name="12f6" id="12f6" class="graf graf--pre graf-after--p">public class Bernoulli<br>{<br>    public static int binomial(int N)<br>    {<br>        int heads = 0;<br>        for (int j = 0; j &lt; N; j++)<br>            if (StdRandom.bernoulli(0.5))<br>                heads++;<br>        return heads;<br>    }<br>    public static void main(String[] args)<br>    {<br>        int N = Integer.parseInt(args[0]);<br>        int trials = Integer.parseInt(args[1]);<br>        int[] freq = new int[N+1];<br>        for (int t = 0; t &lt; trials; t++)<br>            freq[binomial(N)]++;<br>        double[] normalized = new double[N+1];<br>        for (int i = 0; i &lt;= N; i++)<br>            normalized[i] = (double) freq[i] / trials;<br>        StdStats.plotBars(normalized);<br>        double mean = N / 2.0;<br>        double stddev = Math.sqrt(N) / 2.0;<br>        double[] phi = new double[N+1];<br>        for (int i = 0; i &lt;= N; i++)<br>            phi[i] = Gaussian.pdf(i, mean, stddev);<br>        StdStats.plotLines(phi);<br>    }<br>}</pre><p name="7b6d" id="7b6d" class="graf graf--p graf-after--pre">And the output should be,</p><pre name="9f48" id="9f48" class="graf graf--pre graf-after--p">$ java Bernoulli 20 10000</pre><figure name="6e2a" id="6e2a" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*GHcHXMVV9Yrs5oK0qB0xxg.png" data-width="1284" data-height="132" src="https://cdn-images-1.medium.com/max/800/1*GHcHXMVV9Yrs5oK0qB0xxg.png"></figure><p name="f8d2" id="f8d2" class="graf graf--p graf-after--figure graf--trailing">This is one special case of the central limit theorem (or CLT), and it states the fact that, in many situations, when independent random variables are added, their properly normalized sum tends toward a normal distribution even if the original variables themselves are not normally distributed.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/c0658741cd78"><time class="dt-published" datetime="2021-08-19T04:12:12.609Z">August 19, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/java-programming-6-functions-and-libraries-c0658741cd78" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>