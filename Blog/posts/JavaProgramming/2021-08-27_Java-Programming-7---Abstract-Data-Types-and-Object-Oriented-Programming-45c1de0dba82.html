<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Java Programming 7 | Abstract Data Types and Object-Oriented Programming</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Java Programming 7 | Abstract Data Types and Object-Oriented Programming</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Java Programming
</section>
<section data-field="body" class="e-content">
<section name="7f0a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b19a" id="b19a" class="graf graf--h3 graf--leading graf--title">Java Programming 7 | Abstract Data Types and <strong class="markup--strong markup--h3-strong">Object-Oriented Programming</strong></h3><figure name="0f89" id="0f89" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*8NuV8Zt6fPIsGBlk.png" data-width="1400" data-height="765" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*8NuV8Zt6fPIsGBlk.png"></figure><ol class="postList"><li name="a960" id="a960" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Abstract Data Types</strong></li></ol><p name="afe6" id="afe6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Data Types</strong></p><p name="084c" id="084c" class="graf graf--p graf-after--p">A data type is a set of values and a set of operations on those values.</p><p name="0f0b" id="0f0b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Primitive Data Types</strong></p><p name="b697" id="b697" class="graf graf--p graf-after--p">The primitive data types in Java are those types whose values immediately map to machine representations. What’s more, the operations of these data types also immediately map to machine instructions. Basically, there are 8 primitive data types in Java as follows,</p><figure name="65cf" id="65cf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*bgVksqbGtrrX-W_JPOAhgw.png" data-width="832" data-height="227" src="https://cdn-images-1.medium.com/max/800/1*bgVksqbGtrrX-W_JPOAhgw.png"><figcaption class="imageCaption"><a href="https://www.theserverside.com/tutorial/Why-the-8-Java-primitive-data-types-are-not-objects" data-href="https://www.theserverside.com/tutorial/Why-the-8-Java-primitive-data-types-are-not-objects" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Resource Link</a></figcaption></figure><p name="4658" id="4658" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) The Definition of Abstract Data Type (ADT)</strong></p><p name="3bec" id="3bec" class="graf graf--p graf-after--p">Although we have many in-built primitive data types in Java, we also want to write programs that process other types of data. For example, we may want colors, pictures, strings, vectors, matrices, etc. An <strong class="markup--strong markup--p-strong">abstract data type</strong> is a data type whose representation is hidden from the client.</p><p name="db81" id="db81" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) The Definition of Object-Oriented Programming (OOP)</strong></p><p name="7b2a" id="7b2a" class="graf graf--p graf-after--p">OOP means basically two things. One is that you are able to create your own data types. The other is that you can use them in your programs by manipulating objects. So the main point is that the abstraction of an ADT is hidden from the client and we can use abstract data types without knowing implementation details.</p><p name="45d6" id="45d6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Example 1: String ADT</strong></p><p name="d90f" id="d90f" class="graf graf--p graf-after--p">Guess what! We have already been using ADTs. In Java, we can find out that the string is not a primitive data type and it is actually a sequence of Unicode characters. Java’s String ADT allows us to write Java programs that manipulate strings when the exact representation of this ADT is hidden. The common APIs for the String ADT are,</p><ul class="postList"><li name="eeb8" id="eeb8" class="graf graf--li graf-after--p">create a string by some value,</li></ul><pre name="9927" id="9927" class="graf graf--pre graf-after--li">String()</pre><ul class="postList"><li name="0f33" id="0f33" class="graf graf--li graf-after--pre">get the string length</li></ul><pre name="389e" id="389e" class="graf graf--pre graf-after--li">String.length()</pre><ul class="postList"><li name="8693" id="8693" class="graf graf--li graf-after--pre">get the i-th character in the string</li></ul><pre name="2ac9" id="2ac9" class="graf graf--pre graf-after--li">String.charAt(int i)</pre><ul class="postList"><li name="7788" id="7788" class="graf graf--li graf-after--pre">get the substring from the i-th character to the j-th character</li></ul><pre name="e1bf" id="e1bf" class="graf graf--pre graf-after--li">String.substring(int i, int j)</pre><ul class="postList"><li name="e121" id="e121" class="graf graf--li graf-after--pre">check if a string contains a substring <code class="markup--code markup--li-code">sub</code></li></ul><pre name="4b7a" id="4b7a" class="graf graf--pre graf-after--li">String.contains(String sub)</pre><p name="f3f8" id="f3f8" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(6) How to Use a Data Type?</strong></p><p name="3c18" id="3c18" class="graf graf--p graf-after--p">First, we should know the name of this data type. In Java, the name of an ADT should be capitalized. Second, we should know how to construct new objects according to the API. And finally, we need to find out how to apply applications to this given object.</p><p name="ccb4" id="ccb4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) How to Construct a New Data Type?</strong></p><p name="2b30" id="2b30" class="graf graf--p graf-after--p">Basically, we have two steps to construct a new object,</p><ul class="postList"><li name="b4d4" id="b4d4" class="graf graf--li graf-after--p">use the data type name to specify the type of an object</li><li name="7614" id="7614" class="graf graf--li graf-after--li">use the keyword <code class="markup--code markup--li-code">new</code> to invoke a constructor</li></ul><p name="e09e" id="e09e" class="graf graf--p graf-after--li">We have to use the keyword <code class="markup--code markup--p-code">new</code> because we have to allocate the memory on the heap before we assign the values of an instance.</p><p name="09c4" id="09c4" class="graf graf--p graf-after--p">However, because strings are originally an object, we can initialize a string without using the keyword new. For example, we can use</p><pre name="ce0f" id="ce0f" class="graf graf--pre graf-after--p">String a = new String(&quot;Hi&quot;);</pre><p name="83a2" id="83a2" class="graf graf--p graf-after--pre">Or,</p><pre name="20b5" id="20b5" class="graf graf--pre graf-after--p">String b = &quot;Hi&quot;;</pre><p name="8fe3" id="8fe3" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(8) How to Apply an Operation?</strong></p><p name="9099" id="9099" class="graf graf--p graf-after--p">First, we have to use the <strong class="markup--strong markup--p-strong">object name</strong> to specify which object. Then, we need to use the<strong class="markup--strong markup--p-strong"> dot operator</strong> to indicate that an operation is to be applied. Finally, a method name should be used to specify which operation we would like to call. For example,</p><pre name="43b8" id="43b8" class="graf graf--pre graf-after--p"> obj   method<br>+----+ +-----+<br>StdOut.println(&quot;Hi&quot;);<br>      | <br>   Dot Operator</pre><p name="44a9" id="44a9" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Case Study: Color ADT</strong></p><p name="82c9" id="82c9" class="graf graf--p graf-after--p">Before we talk about how to build our own ADT, let’s first see a case study about the Color ADT, which is an ADT allows us to write Java programs that manipulate color.</p><p name="080f" id="080f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) APIs for Color ADT</strong></p><p name="1129" id="1129" class="graf graf--p graf-after--p">Here are some APIs for the Color ADT,</p><ul class="postList"><li name="8c69" id="8c69" class="graf graf--li graf-after--p">construct a Color object</li></ul><pre name="87ca" id="87ca" class="graf graf--pre graf-after--li">Color(int r, int g, int b);</pre><ul class="postList"><li name="3eff" id="3eff" class="graf graf--li graf-after--pre">get red intensity</li></ul><pre name="83d7" id="83d7" class="graf graf--pre graf-after--li">int getRed()</pre><ul class="postList"><li name="b62c" id="b62c" class="graf graf--li graf-after--pre">get green intensity</li></ul><pre name="8b17" id="8b17" class="graf graf--pre graf-after--li">int getGreen()</pre><ul class="postList"><li name="7efe" id="7efe" class="graf graf--li graf-after--pre">get blue intensity</li></ul><pre name="30d1" id="30d1" class="graf graf--pre graf-after--li">int getBlue()</pre><ul class="postList"><li name="b35f" id="b35f" class="graf graf--li graf-after--pre">get a brighter version of this color</li></ul><pre name="8f6b" id="8f6b" class="graf graf--pre graf-after--li">Color brighter()</pre><ul class="postList"><li name="e5ab" id="e5ab" class="graf graf--li graf-after--pre">get a darker version of this color</li></ul><pre name="c23a" id="c23a" class="graf graf--pre graf-after--li">Color darker()</pre><ul class="postList"><li name="404a" id="404a" class="graf graf--li graf-after--pre">get a String representations of this color</li></ul><pre name="4e72" id="4e72" class="graf graf--pre graf-after--li">String toString()</pre><ul class="postList"><li name="1baf" id="1baf" class="graf graf--li graf-after--pre">is this color the same as color <code class="markup--code markup--li-code">c</code></li></ul><pre name="5a81" id="5a81" class="graf graf--pre graf-after--li">boolean equals(Color c)</pre><p name="6107" id="6107" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(2) Josef Albers’ Albers squares</strong></p><p name="2b40" id="2b40" class="graf graf--p graf-after--p">Josef Albers was a German-born artist and headed Yale University’s department of design. He is considered one of the most influential teachers of the visual arts of the twentieth century. One of the most famous works of Josef Albers is the Albers squares, and they are made from 1933, when Nazis forced the school to close.</p><figure name="5ce0" id="5ce0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*trZZY13UM29ztbDcunjLXw.png" data-width="832" data-height="227" src="https://cdn-images-1.medium.com/max/800/1*trZZY13UM29ztbDcunjLXw.png"></figure><p name="11e1" id="11e1" class="graf graf--p graf-after--figure">Now, let’s write a Java program to generate Albers squares. The position of the squares should be,</p><figure name="84cb" id="84cb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Pt6yh3iogtCUX529Z_s_hw.png" data-width="661" data-height="215" src="https://cdn-images-1.medium.com/max/800/1*Pt6yh3iogtCUX529Z_s_hw.png"></figure><p name="0030" id="0030" class="graf graf--p graf-after--figure">And the Java program should be as follows. Remember if we want to use the <code class="markup--code markup--p-code">Color</code> class, we have to import it by <code class="markup--code markup--p-code">import java.awt.Color;</code></p><pre name="7114" id="7114" class="graf graf--pre graf-after--p">import java.awt.Color;</pre><pre name="2b1a" id="2b1a" class="graf graf--pre graf-after--pre">public class AlbersSquares<br>{<br>    public static void main(String[] args)<br>    {<br>        int r1 = Integer.parseInt(args[0]);<br>        int g1 = Integer.parseInt(args[1]);<br>        int b1 = Integer.parseInt(args[2]);<br>        Color c1 = new Color(r1, g1, b1);<br>        int r2 = Integer.parseInt(args[3]);<br>        int g2 = Integer.parseInt(args[4]);<br>        int b2 = Integer.parseInt(args[5]);<br>        Color c2 = new Color(r2, g2, b2);<br>        StdDraw.setPenColor(c1);<br>        StdDraw.filledSquare(.25, .5, .2);<br>        StdDraw.setPenColor(c2);<br>        StdDraw.filledSquare(.25, .45, .1);<br>        StdDraw.setPenColor(c2);<br>        StdDraw.filledSquare(.75, .5, .2);<br>        StdDraw.setPenColor(c1);<br>        StdDraw.filledSquare(.75, .45, .1);<br>    }<br>}</pre><p name="e33a" id="e33a" class="graf graf--p graf-after--pre">To test this code, we can run,</p><pre name="debd" id="debd" class="graf graf--pre graf-after--p">$ java AlbersSquares 0 64 128 105 105 105<br>$ java AlbersSquares 251 112 34 177 153 71<br>$ java AlbersSquares 28 183 122 15 117 123</pre><p name="8628" id="8628" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. Object-Oriented Programming (OOP)</strong></p><p name="bc47" id="bc47" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Implementing a Data Type</strong></p><p name="f207" id="f207" class="graf graf--p graf-after--p">To create a data type, you need to provide the code that,</p><ul class="postList"><li name="7aee" id="7aee" class="graf graf--li graf-after--p">defines the set of values or so-called <strong class="markup--strong markup--li-strong">instance variables</strong></li><li name="7e5a" id="7e5a" class="graf graf--li graf-after--li">implements operations on those values (methods or static methods)</li><li name="9c4d" id="9c4d" class="graf graf--li graf-after--li">creates and initialize new objects (constructors)</li></ul><p name="b9ba" id="b9ba" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) The Definition of Class</strong></p><p name="f778" id="f778" class="graf graf--p graf-after--p">In Java, a data-type implementation is known as a class. A typical class structure is as follows,</p><figure name="bbee" id="bbee" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*QtVw-pbVtfw7-VsHH4DpDw.png" data-width="674" data-height="262" src="https://cdn-images-1.medium.com/max/800/1*QtVw-pbVtfw7-VsHH4DpDw.png"></figure><p name="9546" id="9546" class="graf graf--p graf-after--figure">For example, an example <code class="markup--code markup--p-code">Charge</code> class can be,</p><figure name="0f40" id="0f40" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Jd_ARheT1-9PRjDomhtaDQ.png" data-width="720" data-height="381" src="https://cdn-images-1.medium.com/max/800/1*Jd_ARheT1-9PRjDomhtaDQ.png"></figure><p name="94e1" id="94e1" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) The Definition of Java Constructors</strong></p><p name="1e28" id="1e28" class="graf graf--p graf-after--p">A constructor in Java is a special method that is used to initialize objects. The constructor is called when an object of a class is created. The name of a constructor should be the same as the class name. Note that because the constructor returns no value, it is actually NOT a method.</p><pre name="ccd9" id="ccd9" class="graf graf--pre graf-after--p">public class CreateClass {<br>    public CreateClass() {<br>        StdOut.println(&quot;An object is created.&quot;);<br>    }<br>    public static void main(String[] args) {<br>        CreateClass object = new CreateClass();<br>    }<br>}</pre><p name="7138" id="7138" class="graf graf--p graf-after--pre">Similar to the principle that methods with different assignments will be treated as different methods, constructors with different assignments will also be reckoned as different constructors. For example,</p><pre name="e163" id="e163" class="graf graf--pre graf-after--p">public class CreateClass {<br>    public CreateClass() {<br>        StdOut.println(&quot;An object1 is created.&quot;);<br>    }<br>    public CreateClass(int a) {<br>        StdOut.println(&quot;An object2 is created with integer &quot; + a + &quot;.&quot;);<br>    }<br>    public static void main(String[] args) {<br>        CreateClass object1 = new CreateClass();<br>        CreateClass object2 = new CreateClass(5);<br>    }<br>}</pre><p name="296c" id="296c" class="graf graf--p graf-after--pre">And we can test this program by,</p><pre name="aca6" id="aca6" class="graf graf--pre graf-after--p">$ java CreateClass<br>An object1 is created.<br>An object2 is created with integer 5.</pre><p name="7adb" id="7adb" class="graf graf--p graf-after--pre">A common mistake for constructors is that someone may add a <code class="markup--code markup--p-code">void</code> before the constructor assignment because no value should be returned for a constructor. However, this is now correct because if we write <code class="markup--code markup--p-code">void</code> , the compiler will treat the current constructor as a normal static method. So, for a constructor, we have to use,</p><pre name="b871" id="b871" class="graf graf--pre graf-after--p"> public CreateClass()</pre><p name="fbd2" id="fbd2" class="graf graf--p graf-after--pre">Instead of,</p><pre name="2462" id="2462" class="graf graf--pre graf-after--p">public void CreateClass()</pre><p name="0494" id="0494" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(4) The Definition of Attributes</strong></p><p name="8004" id="8004" class="graf graf--p graf-after--p">Attributes are the variables owned by the classes. Let’s see the easiest case with an attribute <code class="markup--code markup--p-code">ID</code> of value 0. The program should be as follows,</p><pre name="8b8f" id="8b8f" class="graf graf--pre graf-after--p">public class MyAttributes {<br>    int ID = 0;<br>    public MyAttributes() {};<br>    public static void main(String[] args) {<br>        MyAttributes object = new MyAttributes();<br>        StdOut.println(object.ID);<br>    }<br>}</pre><p name="a936" id="a936" class="graf graf--p graf-after--pre">if we want to create a MyAttributes object and then assign its ID to 5, we can use the following way,</p><pre name="697c" id="697c" class="graf graf--pre graf-after--p">public class MyAttributes {<br>    int ID = 0;<br>    public MyAttributes() {};<br>    public static void main(String[] args) {<br>        MyAttributes object = new MyAttributes();<br>        object.ID = 5;<br>        StdOut.println(object.ID);<br>    }<br>}</pre><p name="e54a" id="e54a" class="graf graf--p graf-after--pre">While in many cases, it is more convenient if we assign the value of the attributes when we create an object. For example, ID can be written to 5 if we write a new constructor with one parameter <code class="markup--code markup--p-code">a</code> ,</p><pre name="0cd7" id="0cd7" class="graf graf--pre graf-after--p">public class MyAttributes {<br>    int ID = 0;<br>    public MyAttributes() {};<br>    public MyAttributes(int a) {<br>        ID = a;<br>    };<br>    public static void main(String[] args) {<br>        MyAttributes object = new MyAttributes(5);<br>        StdOut.println(object.ID);<br>    }<br>}</pre><p name="9ed2" id="9ed2" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(5) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">final</strong></code><strong class="markup--strong markup--p-strong"> Modifier for Attributes</strong></p><p name="1d6b" id="1d6b" class="graf graf--p graf-after--p">In addition, we may need some read-only attributes, and it may not be safe if everyone can override these attributes. For example, we would like to have a <code class="markup--code markup--p-code">password</code> attribute, and no matter what is ID number of an object is, it should have the same password <code class="markup--code markup--p-code">274133</code> . To solve this problem, the <code class="markup--code markup--p-code">final</code> modifier is used in front of the attribute’s data type for declaring this attribute is read-only. If we run the following code, we will generate <code class="markup--code markup--p-code">error: cannot assign a value to a final variable</code> ,</p><pre name="3157" id="3157" class="graf graf--pre graf-after--p">public class MyAttributes {<br>    int ID = 0;<br>    final int password = 274133;<br>    public MyAttributes() {};<br>    public MyAttributes(int a) {<br>        ID = a;<br>    };<br>    public static void main(String[] args) {<br>        MyAttributes object = new MyAttributes(5);<br>        object.password = 123456;<br>    }<br>}</pre><p name="430f" id="430f" class="graf graf--p graf-after--pre">If we delete the testing client, the present program can be compiled into a class. The program is,</p><pre name="2afb" id="2afb" class="graf graf--pre graf-after--p">public class MyAttributes {<br>    int ID = 0;<br>    final int password = 274133;<br>    public MyAttributes() {};<br>    public MyAttributes(int a) {<br>        ID = a;<br>    };<br>}</pre><p name="e1a3" id="e1a3" class="graf graf--p graf-after--pre">And we should compile it by,</p><pre name="f0f8" id="f0f8" class="graf graf--pre graf-after--p">$ javac MyAttributes.java</pre><p name="78e4" id="78e4" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(6) Get The Password in a Dangerous Way</strong></p><p name="7966" id="7966" class="graf graf--p graf-after--p">Now, let’s suppose we have a client program called <code class="markup--code markup--p-code">GetPassword.java</code> and it is used to retrieve the password from a MyAttributes object. The program should easily be,</p><pre name="30a8" id="30a8" class="graf graf--pre graf-after--p">public class GetPassword {<br>    public static void main(String[] args) {<br>        MyAttributes object = new MyAttributes();<br>        System.out.println(object.password);<br>    }<br>}</pre><p name="89c2" id="89c2" class="graf graf--p graf-after--pre">Well, we can find in this case that any client can easily get the password and <code class="markup--code markup--p-code">MyAttributes</code> class provides no protection of its data. This is quite dangerous and we don’t want anyone to get our password in such a dangerous way.</p><p name="9b9e" id="9b9e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Java Encapsulation: </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">private</strong></code><strong class="markup--strong markup--p-strong"> Keyword</strong></p><p name="b83d" id="b83d" class="graf graf--p graf-after--p">Encapsulation means that we should make sure that sensitive data is hidden from users. In order to protect the password, we can use the <code class="markup--code markup--p-code">private</code> modifier for the variable <code class="markup--code markup--p-code">password</code> by,</p><pre name="6b7e" id="6b7e" class="graf graf--pre graf-after--p">private final int password = 274133;</pre><p name="08e4" id="08e4" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">private</code> modifier means that the current variable can only be called by the methods in the same class. The modified member is only visible within the class, not from any other classes. To test this feature, then we need to recompile the program <code class="markup--code markup--p-code">MyAttributes.java</code>,</p><pre name="9324" id="9324" class="graf graf--pre graf-after--p">$ javac MyAttributes.java</pre><p name="9e45" id="9e45" class="graf graf--p graf-after--pre">If we use the same program <code class="markup--code markup--p-code">GetPassword</code> to get the password, an exception of <code class="markup--code markup--p-code">Error: variable has private access in class</code>.</p><p name="7d7a" id="7d7a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) The Definition of Methods</strong></p><p name="29c6" id="29c6" class="graf graf--p graf-after--p">We have already seen some APIs and now it’s time to create our own API for <code class="markup--code markup--p-code">MyAttributes</code>. Because someone can have an access to the password, we need a method <code class="markup--code markup--p-code">GetPWD()</code> in the class for getting the password.</p><pre name="5237" id="5237" class="graf graf--pre graf-after--p">public class MyAttributes {<br>    int ID = 0;<br>    private final int password = 274133;<br>    public MyAttributes() {};<br>    public MyAttributes(int a) {<br>        ID = a;<br>    };<br>    public int getPWD() {<br>        return password;<br>    };</pre><pre name="ab33" id="ab33" class="graf graf--pre graf-after--pre">}</pre><p name="732c" id="732c" class="graf graf--p graf-after--pre">And when we have the following program, we can retrieve the password from the object because the API of <code class="markup--code markup--p-code">MyAttributes</code> allows this operation.</p><pre name="1ba0" id="1ba0" class="graf graf--pre graf-after--p">public class GetPassword {<br>    public static void main(String[] args) {<br>        MyAttributes object = new MyAttributes();<br>        System.out.println(object.getPWD());<br>    }<br>}</pre><p name="4def" id="4def" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(9) Checking the Permission By ID</strong></p><p name="d5f4" id="d5f4" class="graf graf--p graf-after--p">Whereas, we can make the program better if we check to see whether the current ID has permission to the password. Suppose ID <code class="markup--code markup--p-code">71035</code> has permission to the password, and we have a checking method <code class="markup--code markup--p-code">isAdmin()</code> for checking if the current ID has permission to the password. Then the program should be,</p><pre name="6525" id="6525" class="graf graf--pre graf-after--p">public class MyAttributes {<br>    int ID = 0;<br>    private final int password = 274133;<br>    public MyAttributes() {};<br>    public MyAttributes(int a) {<br>        ID = a;<br>    };<br>    public boolean isAdmin() {<br>        if (ID == 71035) return true;<br>        return false;<br>    }<br>    public int getPWD() {<br>        if (isAdmin()) return password;<br>        return 0;<br>    };<br>}</pre><p name="f53e" id="f53e" class="graf graf--p graf-after--pre">Then after we create an <code class="markup--code markup--p-code">object</code> by <code class="markup--code markup--p-code">new</code> , we can retrieve the password if we enter the <code class="markup--code markup--p-code">ID = 71035</code>,</p><pre name="0f16" id="0f16" class="graf graf--pre graf-after--p">public class GetPassword {<br>    public static void main(String[] args) {<br>        MyAttributes object = new MyAttributes(Integer.parseInt(args[0]));<br>        System.out.println(object.isAdmin());<br>        System.out.println(object.getPWD());<br>    }<br>}</pre><p name="c1f5" id="c1f5" class="graf graf--p graf-after--pre">To test this code, we can use,</p><pre name="f6b6" id="f6b6" class="graf graf--pre graf-after--p">$ java GetPassword.java 71035<br>true<br>274133</pre><p name="f8aa" id="f8aa" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(10) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">static</strong></code><strong class="markup--strong markup--p-strong"> Keyword</strong></p><p name="f327" id="f327" class="graf graf--p graf-after--p">In the example above, the method <code class="markup--code markup--p-code">isAdmin()</code> can only be used when we already have an <code class="markup--code markup--p-code">object</code> created by,</p><pre name="68f2" id="68f2" class="graf graf--pre graf-after--p">MyAttributes object = new MyAttributes(Integer.parseInt(args[0]));</pre><p name="2885" id="2885" class="graf graf--p graf-after--pre">However, sometimes we would like to call a method without creating an object. The keyword <code class="markup--code markup--p-code">static</code> means the current method or value can also be called or used even if there is no instance of its class. For example, based on one ID, we want to check if it is an Admin account without creating an object of it. We have to construct a new method <code class="markup--code markup--p-code">public static boolean isAdmin()</code> . The program should be as follows,</p><pre name="a802" id="a802" class="graf graf--pre graf-after--p">public class MyAttributes {<br>    int ID = 0;<br>    private final int password = 274133;<br>    public MyAttributes() {};<br>    public MyAttributes(int a) {<br>        ID = a;<br>    };<br>    public boolean isAdmin() {<br>        if (ID == 71035) return true;<br>        return false;<br>    }<br>    public static boolean isAdmin(int a) {<br>        if (a == 71035) return true;<br>        return false;<br>    }<br>    public int getPWD() {<br>        if (isAdmin()) return password;<br>        return 0;<br>    };<br>}</pre><p name="b82f" id="b82f" class="graf graf--p graf-after--pre">In the client program, statement</p><pre name="c7b4" id="c7b4" class="graf graf--pre graf-after--p">System.out.println(MyAttributes.isAdmin(Integer.parseInt(args[0])));</pre><p name="4725" id="4725" class="graf graf--p graf-after--pre">And</p><pre name="f82f" id="f82f" class="graf graf--pre graf-after--p">MyAttributes object = new MyAttributes(Integer.parseInt(args[0]));<br>System.out.println(object.isAdmin());</pre><p name="23cc" id="23cc" class="graf graf--p graf-after--pre">basically mean the same thing. We can easily find out the first code segment checks the admin permission without any newly created objects.</p><p name="a38e" id="a38e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) The Definition of Inheritance</strong></p><p name="b09b" id="b09b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Inheritance</strong> can be defined as the process where one class acquires the properties of another. The class that inherits from another class is called a <strong class="markup--strong markup--p-strong">subclass</strong> (or child class), and the class being inherited from is called a <strong class="markup--strong markup--p-strong">superclass</strong> (or parent class). In Java, we use keyword <code class="markup--code markup--p-code">extends</code> to declare a inheritance.</p><p name="7b51" id="7b51" class="graf graf--p graf-after--p">The main benefit of inheritance is that the inheritance improves code reusability. We can reuse attributes and methods of an existing class when we create a new class.</p><p name="49ad" id="49ad" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(12) Example: Animal Sound</strong></p><p name="0453" id="0453" class="graf graf--p graf-after--p">Let’s now see a relatively simple program called <code class="markup--code markup--p-code">Animal.java</code> . The program only has one method called <code class="markup--code markup--p-code">sound</code> , and it is only used for output the String <code class="markup--code markup--p-code">The animal make a sound.</code> ,</p><pre name="39c6" id="39c6" class="graf graf--pre graf-after--p">public class Animal {<br>    public void sound() {<br>        StdOut.println(&quot;The animal makes a sound.&quot;);<br>    }<br>    public static void main(String[] args) {<br>        Animal object = new Animal();<br>        object.sound();<br>    }<br>}</pre><p name="58ea" id="58ea" class="graf graf--p graf-after--pre">We can test this program by,</p><pre name="fa4c" id="fa4c" class="graf graf--pre graf-after--p">$ javac Animal.java<br>$ java Animal.java<br>The animal makes a sound.</pre><p name="1895" id="1895" class="graf graf--p graf-after--pre">Now we want another class called <code class="markup--code markup--p-code">Cat</code> , which, of course, is a kind of animal (means that it has some relationships to the <code class="markup--code markup--p-code">Animal</code> class). We have an attribute <code class="markup--code markup--p-code">name</code> equals <code class="markup--code markup--p-code">Cat</code> in this class. It should also contain the method <code class="markup--code markup--p-code">sound</code> and a new method called <code class="markup--code markup--p-code">makeSound</code> . When <code class="markup--code markup--p-code">makeSound()</code> is called, the program will first call the <code class="markup--code markup--p-code">sound()</code> method, and then it will print <code class="markup--code markup--p-code">Cat: Meow</code> . Even though we can write the <code class="markup--code markup--p-code">sound</code> method inside the <code class="markup--code markup--p-code">Cat</code> class again, we will choose to inherit the <code class="markup--code markup--p-code">Animal</code> class at this time. In order to do so, we have to use keyword <code class="markup--code markup--p-code">extends</code> . The program <code class="markup--code markup--p-code">Cat.java</code> should be,</p><pre name="8762" id="8762" class="graf graf--pre graf-after--p">public class Cat extends Animal {<br>    final String name = &quot;Cat&quot;;<br>    public void makeSound() {<br>        sound();<br>        StdOut.println(name + &quot;: Meow&quot;);<br>    }<br>    public static void main(String[] args) {<br>        Cat kitty = new Cat();<br>        kitty.makeSound();<br>    }<br>}</pre><p name="0bbe" id="0bbe" class="graf graf--p graf-after--pre">The program can be tested by,</p><pre name="0641" id="0641" class="graf graf--pre graf-after--p">$ java Cat.java<br>The animal makes a sound.<br>Cat: Meow</pre><p name="8044" id="8044" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(13) Java Polymorphism</strong></p><p name="a70b" id="a70b" class="graf graf--p graf-after--p">Polymorphism means many forms in Java, which occurs when we have many classes that are related to each other by inheritance. Polymorphism uses the those methods to perform different tasks and it is actually to override the pre-existing methods in the subclass.</p><p name="8b55" id="8b55" class="graf graf--p graf-after--p">Let’s now see an example. The <code class="markup--code markup--p-code">Admin.java</code> has the ID and a private password that can not be overwrite. It also has a method <code class="markup--code markup--p-code">getPWD</code> that can be used to get the password.</p><pre name="a26b" id="a26b" class="graf graf--pre graf-after--p">public class Admin {<br>    private int ID = 71035;<br>    private final static int password = 274133;<br>    public int getPWD() {<br>        return password;<br>    };<br>}</pre><p name="6a7b" id="6a7b" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">Staff</code> class inherit class <code class="markup--code markup--p-code">Admin</code> , but it can not inherit the <code class="markup--code markup--p-code">private</code> attributes <code class="markup--code markup--p-code">ID</code> and <code class="markup--code markup--p-code">password</code> in the <code class="markup--code markup--p-code">Admin</code> class. The default ID of an <code class="markup--code markup--p-code">Staff</code> object is 0, and we can assign this ID when we construct a new object of it. It also has a method called <code class="markup--code markup--p-code">getPWD</code> but it will check whether the current ID has the permission to the password. The present method <code class="markup--code markup--p-code">getPWD</code> will override the method with the same name in the superclass <code class="markup--code markup--p-code">Admin</code> , and this is called polymorphism. However, because we still need to call the method <code class="markup--code markup--p-code">getPWD</code> in the superclass to get the password, we have to use the <code class="markup--code markup--p-code">super</code> keyword. Therefore, the program should be,</p><pre name="4449" id="4449" class="graf graf--pre graf-after--p">public class Staff extends Admin {<br>    int ID = 0;<br>    public Staff(int a) {<br>        ID = a;<br>    };<br>    public int getPWD() {<br>        if (ID == 71035) {<br>            StdOut.println(&quot;Permission Allowed&quot;);<br>            return super.getPWD();<br>        } else {<br>            StdOut.println(&quot;Permission Denied&quot;);<br>            return 0;<br>        }<br>    };<br>    public static void main(String[] args) {<br>        Staff object = new Staff(Integer.parseInt(args[0]));<br>        StdOut.println(object.getPWD());<br>    }<br>}</pre><p name="698f" id="698f" class="graf graf--p graf-after--pre">And we can test it by,</p><pre name="29bc" id="29bc" class="graf graf--pre graf-after--p">$ java Staff.java 71035<br>Permission Allowed<br>274133<br>$ java Staff.java 710<br>Permission Denied<br>0</pre><p name="c45b" id="c45b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4. Common Java Modifiers</strong></p><p name="ccfa" id="ccfa" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Defintion of Modifiers</strong></p><p name="5e24" id="5e24" class="graf graf--p graf-after--p">In the sections above, we have talked about many modifiers. For example,</p><ul class="postList"><li name="d938" id="d938" class="graf graf--li graf-after--p">public</li><li name="054a" id="054a" class="graf graf--li graf-after--li">static</li><li name="56da" id="56da" class="graf graf--li graf-after--li">private</li><li name="062b" id="062b" class="graf graf--li graf-after--li">final</li></ul><p name="4ecb" id="4ecb" class="graf graf--p graf-after--li">Now let’s see some more detailed descriptions.</p><p name="1531" id="1531" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Defintion of Properties</strong></p><p name="fdfe" id="fdfe" class="graf graf--p graf-after--p">A modifier can be used for properties means that it can be used for attributes and methods.</p><p name="b96f" id="b96f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Defintion of Access Modifier</strong></p><p name="0595" id="0595" class="graf graf--p graf-after--p">Access modifiers (or access specifiers) are keywords in Java that set the accessibility of classes, methods, constructors, and other members. Commonly, there are four access modifiers,</p><ul class="postList"><li name="a1f9" id="a1f9" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">public</code>: means the current class, attribute, method, or constructor is accessible for <strong class="markup--strong markup--li-strong">all classes</strong>.</li><li name="2526" id="2526" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">private</code>: means the current attribute, method, or constructor is only accessible within the <strong class="markup--strong markup--li-strong">declared class</strong>. What’s more, they can not be inherited in the subclass.</li><li name="6d05" id="6d05" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">protected</code>: means the current attribute, method, or constructor is only accessible within the <strong class="markup--strong markup--li-strong">declared class and its subclasses</strong>.</li><li name="1e8b" id="1e8b" class="graf graf--li graf-after--li">default (means no modifier): means the current class, attribute, method, or constructor is only accessible by <strong class="markup--strong markup--li-strong">classes in the same package</strong>.</li></ul><p name="2f86" id="2f86" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Non-Access Modifiers</strong></p><p name="f27b" id="f27b" class="graf graf--p graf-after--p">There are also many non-access modifiers. For example,</p><ul class="postList"><li name="fd6c" id="fd6c" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">final</code>: For classes, it means the current class can not be inherited by other classes. For properties, it means the current attribute or method can not be overridden or modified.</li><li name="912d" id="912d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">static</code>: means that the current properties can be called without an object of the current class.</li><li name="43d1" id="43d1" class="graf graf--li graf-after--li graf--trailing"><code class="markup--code markup--li-code">abstract</code>: For classes, it means that the current class can not be used to create object. To access an abstract class, it must be inherited from another class. This modifier can also be used to the methods in an abstract class, which means the method does not have a body.</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/45c1de0dba82"><time class="dt-published" datetime="2021-08-27T06:04:45.882Z">August 27, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/java-programming-7-abstract-data-types-and-object-oriented-programming-45c1de0dba82" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>