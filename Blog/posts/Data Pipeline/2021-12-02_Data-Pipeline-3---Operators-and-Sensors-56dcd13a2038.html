<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Data Pipeline 3 | Operators and Sensors</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Data Pipeline 3 | Operators and Sensors</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Data Pipeline
</section>
<section data-field="body" class="e-content">
<section name="df2d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4cbb" id="4cbb" class="graf graf--h3 graf--leading graf--title">Data Pipeline 3 | Operators and Sensors</h3><figure name="8b98" id="8b98" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*8LQeLl_vlLMewHue.png" data-width="1352" data-height="622" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*8LQeLl_vlLMewHue.png"></figure><ol class="postList"><li name="c196" id="c196" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Operators</strong></li></ol><p name="1e94" id="1e94" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) DummyOperator</strong></p><p name="8a6f" id="8a6f" class="graf graf--p graf-after--p">Before we create our own operators, let’s first introduce some basic operators, and the first we are going to introduce here is the <code class="markup--code markup--p-code">DummyOperator</code>. As we have discussed, dummy typically has two functions.</p><ul class="postList"><li name="1e98" id="1e98" class="graf graf--li graf-after--p">It can be used to group tasks</li><li name="1439" id="1439" class="graf graf--li graf-after--li">It can be used to combine tasks</li></ul><p name="0a59" id="0a59" class="graf graf--p graf-after--li">Now, let’s see an example script <code class="markup--code markup--p-code">example_dummy.py</code>,</p><figure name="3391" id="3391" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/682eeb63eaa2bc0826caf878193fba37.js"></script></figure><p name="456c" id="456c" class="graf graf--p graf-after--figure">In this example, the dummy operator <code class="markup--code markup--p-code">group_task_1</code> is used to group <code class="markup--code markup--p-code">echo_task0</code> to <code class="markup--code markup--p-code">echo_task4</code> , and <code class="markup--code markup--p-code">group_task_2</code> is used to group <code class="markup--code markup--p-code">echo_task5</code> to <code class="markup--code markup--p-code">echo_task7</code>. The dummy operator <code class="markup--code markup--p-code">last_to_run</code> is used to group all the <code class="markup--code markup--p-code">echo_task</code> after running, and then they will be directed to the task <code class="markup--code markup--p-code">echo_complete</code>.</p><figure name="03c4" id="03c4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zZz0AeiZ3j3QYhS92EtTRQ.png" data-width="970" data-height="412" src="https://cdn-images-1.medium.com/max/800/1*zZz0AeiZ3j3QYhS92EtTRQ.png"></figure><p name="043b" id="043b" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(2) BashOperator</strong></p><p name="4a22" id="4a22" class="graf graf--p graf-after--p">Then, we can continue to see how we can use the BashOperator. Again, you can add the following DAG to your DAG folder.</p><figure name="524f" id="524f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/2f933c4102838a9ebb5fe88cd7884cbb.js"></script></figure><p name="f881" id="f881" class="graf graf--p graf-after--figure"><code class="markup--code markup--p-code">bash_1</code> is a basic <code class="markup--code markup--p-code">BashOpeartion</code> task that is used to show that we can assign bash commands to parameter <code class="markup--code markup--p-code">bash_command</code>.</p><p name="252b" id="252b" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">bash_2</code> is showing that we can use Jinja templates for bash commands. You can refer this <a href="https://airflow.apache.org/docs/apache-airflow/stable/templates-ref.html" data-href="https://airflow.apache.org/docs/apache-airflow/stable/templates-ref.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">link</a> to know how it works. Some common templates we can use are,</p><ul class="postList"><li name="37d1" id="37d1" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">{{ ds }}</code> : The DAG run’s logical date as <code class="markup--code markup--li-code">YYYY-MM-DD</code>.</li><li name="7e15" id="7e15" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">{{ ts }}</code> : The DAG run’s logical time like <code class="markup--code markup--li-code">2018-01-01T00:00:00+00:00</code>.</li><li name="4f61" id="4f61" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">{{ execution_date }}</code> : The execution date, same as logical date.</li><li name="64e7" id="64e7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">{{ run_id }}</code> : The <code class="markup--code markup--li-code">run_id</code> of the current DAG run.</li><li name="49ef" id="49ef" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">{{ dag_run }}</code> : A reference to the DagRun object.</li><li name="12a1" id="12a1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">{{ task_instance_key_str }}</code> : A unique, human-readable key to the task instance formatted <code class="markup--code markup--li-code">{dag_id}__{task_id}__{ds_nodash}</code>.</li><li name="8c89" id="8c89" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">{{ macros.datetime }}</code> : The standard lib’s <code class="markup--code markup--li-code">datetime.datetime</code></li></ul><p name="739e" id="739e" class="graf graf--p graf-after--li">We can also define some personally cumstomed parameters by assigning the <code class="markup--code markup--p-code">params</code> variable. So the output of this <code class="markup--code markup--p-code">bash_2</code> is supposed to be something like, (you can find this in the log)</p><pre name="f9d7" id="f9d7" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">Logical Date: 2021-12-01<br>Logical Time: 2021-12-01T20:54:09.152458+00:00<br>Execution Date: 2021-12-01T20:54:09.152458+00:00<br>Run ID: manual__2021-12-01T20:54:09.152458+00:00<br>DAG Run Reference: &lt;DagRun example_bash @ 2021-12-01 20:54:09.152458+00:00: manual__2021-12-01T20:54:09.152458+00:00, externally triggered: True&gt;<br>Readable Task Key: example_bash__bash_2__20211201<br>Customed Paramerter: This is a customed param<br>Standlib Datatime: &lt;class &#39;datetime.datetime&#39;&gt;<br>Command exited with return code 0</code></pre><p name="efe6" id="efe6" class="graf graf--p graf-after--pre">In general, a non-zero exit code produces an <code class="markup--code markup--p-code">AirflowException</code> and thus a task failure. In cases where it is desirable to instead have the task end in a <code class="markup--code markup--p-code">skipped</code> state, you can exit with code <code class="markup--code markup--p-code">99</code> (or with another exit code if you pass <code class="markup--code markup--p-code">skip_exit_code</code>). So bash_3 is using <code class="markup--code markup--p-code">exit 99;</code> in its command and we are expected to see that this task instance is in the <code class="markup--code markup--p-code">skipped</code> state after running.</p><figure name="925b" id="925b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*N2syhJHC6K3tGT5N40WWlA.png" data-width="1828" data-height="122" src="https://cdn-images-1.medium.com/max/800/1*N2syhJHC6K3tGT5N40WWlA.png"></figure><p name="3173" id="3173" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) PythonOperator</strong></p><p name="6728" id="6728" class="graf graf--p graf-after--p">The PythonOperator can be used to execute Python callables.</p><ul class="postList"><li name="3233" id="3233" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">op_args</code>: used as list for passing the function arguments</li><li name="d99c" id="d99c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">op_kwargs</code> : used as a dictionary used for passing the function arguments</li><li name="23ab" id="23ab" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">templates_dict</code> : used as a dictionary for passing Jinja templates</li></ul><p name="045e" id="045e" class="graf graf--p graf-after--li">Now, let’s see the following script,</p><figure name="8301" id="8301" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/a2cf3e9cab4c3af628257cf4f82c18ea.js"></script></figure><p name="14d1" id="14d1" class="graf graf--p graf-after--figure"><code class="markup--code markup--p-code">run_start</code> task will execute the <code class="markup--code markup--p-code">running_func</code> function and returns <code class="markup--code markup--p-code">Start running ...</code>. In Airflow, whatever you return gets printed in the logs.</p><p name="2ad4" id="2ad4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">run_sleep</code> task execute the <code class="markup--code markup--p-code">sleep_func</code> , which takes an argument <code class="markup--code markup--p-code">sleep_time</code> from <code class="markup--code markup--p-code">op_kwargs</code>.</p><p name="d252" id="d252" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">run_complete</code> task execute the <code class="markup--code markup--p-code">complete_func</code> , which takes a Jinja template value <code class="markup--code markup--p-code">task_instance_key_str</code> from <code class="markup--code markup--p-code">templates_dict</code>. Note that the <code class="markup--code markup--p-code">templates_dict</code> argument is templated, so each value in the dictionary is evaluated as a Jinja template. Therefore, the output of this task is something like,</p><pre name="7969" id="7969" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">Done. Returned value was: Complete running example_python__run_complete__20211201</code></pre><p name="9f23" id="9f23" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(4) Custom Operator</strong></p><p name="a1e9" id="a1e9" class="graf graf--p graf-after--p">Airflow allows creating new operators to suit the requirements by extending the <code class="markup--code markup--p-code">BaseOperator</code>. Let’s see an example on the official document.</p><p name="d618" id="d618" class="graf graf--p graf-after--p">First, let’s put the following script in a new directory <code class="markup--code markup--p-code">custom_operator</code> in our DAG folder. This script defines the class <code class="markup--code markup--p-code">HelloOperator</code> inherited from <code class="markup--code markup--p-code">BaseOperator</code>. Then it modifies the operations in the <code class="markup--code markup--p-code">__init__</code> method with a <code class="markup--code markup--p-code">self.name</code> attribute. It also modifies the <code class="markup--code markup--p-code">execute</code> method and make it print a formatted string <code class="markup--code markup--p-code">Hello {self.name}</code> to the standard output.</p><figure name="2a3f" id="2a3f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/bfdfc70db893950ee8f417dae897e2f0.js"></script></figure><p name="10fc" id="10fc" class="graf graf--p graf-after--figure">After that, we can use the following script for using this customized <code class="markup--code markup--p-code">HelloOperator</code>.</p><figure name="fa32" id="fa32" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/b0ffa9eef9cf15812af8c4494dbb5205.js"></script></figure><p name="5294" id="5294" class="graf graf--p graf-after--figure">The log should show our result,</p><pre name="bd3a" id="bd3a" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">Hello foo_bar</code></pre><p name="b764" id="b764" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Sensors</strong></p><p name="6ad0" id="6ad0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) TimeDeltaSensorAsync</strong></p><p name="b46c" id="b46c" class="graf graf--p graf-after--p">This is a drop-in replacement for <code class="markup--code markup--p-code">TimeDeltaSensor</code> that defers itself to avoid taking up a worker slot while it is waiting. We can use this to wait for a certain time period. We already have <code class="markup--code markup--p-code">example_time_delta_sensor_async</code> script in our example DAG folder and we can test it out. The script should be as follows,</p><pre name="28c1" id="28c1" class="graf graf--pre graf-after--p">with DAG(<br>    dag_id=&quot;example_time_delta_sensor_async&quot;,<br>    schedule_interval=None,<br>    start_date=datetime(2021, 1, 1),<br>    catchup=False,<br>    tags=[&quot;example&quot;],<br>) as dag:<br>    wait = TimeDeltaSensorAsync(task_id=&quot;wait&quot;, delta=timedelta(seconds=10))<br>    finish = DummyOperator(task_id=&quot;finish&quot;)<br>    wait &gt;&gt; finish</pre><p name="156d" id="156d" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">wait</code> task is a sensor used to wait a time period of 10 seconds. Then the <code class="markup--code markup--p-code">finish</code> task of DummyOperator is called for finishing.</p><p name="f6e0" id="f6e0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) BashSensor</strong></p><p name="8fdc" id="8fdc" class="graf graf--p graf-after--p">Next up, let’s see an example of the BashSensor. Suppose we have the following bash script that will randomly exit with <code class="markup--code markup--p-code">0</code> or <code class="markup--code markup--p-code">1</code>,</p><pre name="fd2c" id="fd2c" class="graf graf--pre graf-after--p">if (($RANDOM % 2))<br>then <br>    echo &quot;Success, exit with 0.&quot;<br>    exit 0;<br>else<br>    echo &quot;Hang and retry after 60 seconds, exit with 1.&quot;<br>    exit 1;<br>fi</pre><p name="c94a" id="c94a" class="graf graf--p graf-after--pre">Then the script should be as follows,</p><figure name="2196" id="2196" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/967dc489b65762f70c16cfcb9ccbdd63.js"></script></figure><p name="286b" id="286b" class="graf graf--p graf-after--figure">After triggering this DAG, we have a 50% chance to exit with 0 and another 50% chance to exit with 1. Let’s suppose we get an even <code class="markup--code markup--p-code">$RANDOM</code> value in the first trial, then we will output <code class="markup--code markup--p-code">Hang and retry after 60 seconds, exit with 1.</code> and then retry this command after 60 seconds. This interval is defined by the argument <code class="markup--code markup--p-code">poke_interval</code> and by default it should be 60 seconds. We can also change it to some other values for longer or shorter intervals. We can check this by viewing the logs,</p><pre name="37b9" id="37b9" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">[2021-12-01, 20:30:32 UTC] {bash.py:66} INFO - Running command:<br>...<br>[2021-12-01, 20:30:32 UTC] {bash.py:77} INFO - Output:<br>[2021-12-01, 20:30:32 UTC] {bash.py:80} INFO - </code>Hang and retry after 60 seconds, exit with 1.<br><code class="markup--code markup--pre-code">[2021-12-01, 20:30:32 UTC] {bash.py:82} INFO - Command exited with return code 1<br>...<br>[2021-12-01, 20:31:32 UTC] {bash.py:66} INFO - Running command:<br>...<br>[2021-12-01, 20:31:32 UTC] {bash.py:77} INFO - Output:<br>[2021-12-01, 20:31:32 UTC] {bash.py:80} INFO - Success, exit with 0.<br>[2021-12-01, 20:31:32 UTC] {bash.py:82} INFO - Command exited with return code 0<br>[2021-12-01, 20:31:32 UTC] {base.py:249} INFO - Success criteria met. Exiting.<br>...</code></pre><p name="5cbb" id="5cbb" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Poke Method</strong></p><p name="9be2" id="9be2" class="graf graf--p graf-after--p">Similar to operators, all the sensors are derived from a class named <code class="markup--code markup--p-code">BaseSensorOperator</code> (which also inherit from <code class="markup--code markup--p-code">BaseOperator</code>, so we say the sensor is a specific type of operator). For <code class="markup--code markup--p-code">BaseSensorOperator</code> , it has a parameter named <code class="markup--code markup--p-code">mode</code> , which defines how the sensor operates. Basically, a sensor can choose from the following two modes,</p><ul class="postList"><li name="2981" id="2981" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">poke</code> : the default one. It means to occupy the current worker when working and the current worker will sleep between pokes. This should be used when the cost of context switch on the scheduler is larger than the expected waiting time.</li><li name="92e5" id="92e5" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">reschedule</code> : When set to <code class="markup--code markup--li-code">reschedule</code> the sensor task frees the worker slot when the criteria is not yet met and it’s rescheduled at a later time. Use this mode if the time before the criteria is met is expected to be quite long.</li></ul><p name="68aa" id="68aa" class="graf graf--p graf-after--li">The <code class="markup--code markup--p-code">poke</code> method in <code class="markup--code markup--p-code">BaseSensorOperator</code> is repeatedly invoked every <code class="markup--code markup--p-code">poke_interval</code> seconds until one of the following occurs,</p><ul class="postList"><li name="5220" id="5220" class="graf graf--li graf-after--p">The <code class="markup--code markup--li-code">poke</code> method returns true.</li><li name="a515" id="a515" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">poke</code> method raises an <code class="markup--code markup--li-code">AirflowSkipException</code>, in which case, the sensor task instance’s status will be set to <code class="markup--code markup--li-code">Skipped</code>.</li><li name="4fa6" id="4fa6" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">poke</code> raises another exception, in which case it will be retried until the maximum number of <code class="markup--code markup--li-code">retries</code> have been attempted.</li></ul><p name="94aa" id="94aa" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Custom Sensor</strong></p><p name="d6fb" id="d6fb" class="graf graf--p graf-after--p">Now, let’s make our own customed sensor. We should pass the path to an attribute <code class="markup--code markup--p-code">path_to_check</code> and then check if it exists in every poke by modifying the <code class="markup--code markup--p-code">poke</code> function. Remember to put the customed sensor in a newly created directory named <code class="markup--code markup--p-code">custom_sensor</code> in the DAG folder.</p><figure name="5e42" id="5e42" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/f9434843a80ee9a032f1feeef5313cf5.js"></script></figure><p name="f9bf" id="f9bf" class="graf graf--p graf-after--figure">Then we can create a DAG to use it,</p><figure name="9349" id="9349" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/de8b40736390e94cff0649023cea874e.js"></script></figure><p name="07f9" id="07f9" class="graf graf--p graf-after--figure">If we trigger this DAG, it will poke every 5 seconds for checking if we have that path. For example,</p><pre name="26ed" id="26ed" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">[2021-12-01, 21:32:58 UTC] {logging_mixin.py:109} INFO - Sensor didn&#39;t find path, will try again in a while<br>[2021-12-01, 21:33:03 UTC] {logging_mixin.py:109} INFO - Sensor didn&#39;t find path, will try again in a while<br>[2021-12-01, 21:33:08 UTC] {logging_mixin.py:109} INFO - Sensor didn&#39;t find path, will try again in a while<br>...</code></pre><p name="adb1" id="adb1" class="graf graf--p graf-after--pre">Then we go to the terminal and use the command line to create a folder on that path,</p><pre name="0576" id="0576" class="graf graf--pre graf-after--p">$ mkdir /tmp/testsensor</pre><p name="b96b" id="b96b" class="graf graf--p graf-after--pre">Then finally, we can find out that the task suddenly detect the path,</p><pre name="9d6f" id="9d6f" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">[2021-12-01, 21:33:23 UTC] {logging_mixin.py:109} INFO - Sensor detected path exists<br>[2021-12-01, 21:33:23 UTC] {base.py:249} INFO - Success criteria met. Exiting.</code></pre><p name="d18b" id="d18b" class="graf graf--p graf-after--pre graf--trailing">And then the BashOperator <code class="markup--code markup--p-code">delete_folder</code> will be able to delete this path.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/56dcd13a2038"><time class="dt-published" datetime="2021-12-02T05:46:03.012Z">December 2, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/data-pipeline-3-operators-and-sensors-56dcd13a2038" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>