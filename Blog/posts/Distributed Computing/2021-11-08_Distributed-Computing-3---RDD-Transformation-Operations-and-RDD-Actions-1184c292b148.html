<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Distributed Computing 3 | RDD Transformation Operations and RDD Actions</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Distributed Computing 3 | RDD Transformation Operations and RDD Actions</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Distributed Computing
</section>
<section data-field="body" class="e-content">
<section name="aa93" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="cfeb" id="cfeb" class="graf graf--h3 graf--leading graf--title">Distributed Computing 3 | <strong class="markup--strong markup--h3-strong">RDD Transformation Operations and RDD Actions</strong></h3><figure name="6523" id="6523" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*brKIaMasaMocIZqK.png" data-width="1144" data-height="634" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*brKIaMasaMocIZqK.png"></figure><ol class="postList"><li name="7691" id="7691" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">RDD Transformation Operations</strong></li></ol><p name="c61a" id="c61a" class="graf graf--p graf-after--li">Transformation means to construct a new RDD from an existing RDD. They do not take place until an action is called.</p><p name="e2be" id="e2be" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Narrow Transformation</strong></p><p name="df4d" id="df4d" class="graf graf--p graf-after--p">Narrow transformations transform data without any shuffle involved. These transformations transform the data on a per-partition basis; that is to say, each element of the output RDD can be computed without involving any elements from different partitions. It includes,</p><ul class="postList"><li name="b5d4" id="b5d4" class="graf graf--li graf-after--p">Return a new distributed dataset formed by passing each element of the source through a function <code class="markup--code markup--li-code">func</code>.</li></ul><pre name="e944" id="e944" class="graf graf--pre graf-after--li">rdd.map(func)</pre><ul class="postList"><li name="a6d1" id="a6d1" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">flatMap(func)</code> is similar to <code class="markup--code markup--li-code">map</code>, but each input item can be mapped to 0 or more output items (so <code class="markup--code markup--li-code">func</code> should return a sequence rather than a single item).</li></ul><pre name="9de2" id="9de2" class="graf graf--pre graf-after--li">rdd.flatMap(func)</pre><ul class="postList"><li name="4ea1" id="4ea1" class="graf graf--li graf-after--pre">Return a new dataset formed by selecting those elements of the source on which <code class="markup--code markup--li-code">func</code> returns true.</li></ul><pre name="c65f" id="c65f" class="graf graf--pre graf-after--li">rdd.filter(func)</pre><p name="16bb" id="16bb" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(2) Wide Transformation</strong></p><p name="88ef" id="88ef" class="graf graf--p graf-after--p">Wide transformations involve a shuffle of the data between the partitions. It includes,</p><ul class="postList"><li name="65a7" id="65a7" class="graf graf--li graf-after--p">Return a new dataset that contains the distinct elements of the source dataset.</li></ul><pre name="d3eb" id="d3eb" class="graf graf--pre graf-after--li">rdd.distinct()</pre><ul class="postList"><li name="8a1b" id="8a1b" class="graf graf--li graf-after--pre">Return a new dataset that contains the union of the elements in the sources dataset and the argument.</li></ul><pre name="ae6a" id="ae6a" class="graf graf--pre graf-after--li">rdd.union(otherDataset)</pre><ul class="postList"><li name="9f58" id="9f58" class="graf graf--li graf-after--pre">Return a new RDD that contains the intersection of elements in the source database and the argument</li></ul><pre name="db13" id="db13" class="graf graf--pre graf-after--li">rdd.intersection(otherDataset)</pre><ul class="postList"><li name="de13" id="de13" class="graf graf--li graf-after--pre">Return each value in self that is not contained in <code class="markup--code markup--li-code">otherDataset</code></li></ul><pre name="2f11" id="2f11" class="graf graf--pre graf-after--li">rdd.substract(<code class="markup--code markup--pre-code">otherDataset)</code></pre><ul class="postList"><li name="db75" id="db75" class="graf graf--li graf-after--pre">Return the Cartesian product of the RDD and <code class="markup--code markup--li-code">otherDataset</code></li></ul><pre name="b828" id="b828" class="graf graf--pre graf-after--li">rdd.cartesian(<code class="markup--code markup--pre-code">otherDataset)</code></pre><ul class="postList"><li name="f633" id="f633" class="graf graf--li graf-after--pre">Sorts the present RDD by the given <code class="markup--code markup--li-code">func</code>.</li></ul><pre name="e9d4" id="e9d4" class="graf graf--pre graf-after--li">rdd.sortBy(<code class="markup--code markup--pre-code">func, ascending=True)</code></pre><p name="fadb" id="fadb" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. RDD Actions</strong></p><p name="bc80" id="bc80" class="graf graf--p graf-after--p">The actions are the triggers of the operations, and they are going to return non-RDD datatypes like int, string, list, or else. The actions operate on the data known in the memory and it will be wrapped out if we restart.</p><p name="6026" id="6026" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Simple RDD Actions</strong></p><ul class="postList"><li name="bd8f" id="bd8f" class="graf graf--li graf-after--p">Return all the elements of the dataset as an array at the driver program.</li></ul><pre name="c018" id="c018" class="graf graf--pre graf-after--li">rdd.collect()</pre><ul class="postList"><li name="f905" id="f905" class="graf graf--li graf-after--pre">Return the first element of the dataset (similar to take(1)).</li></ul><pre name="dce2" id="dce2" class="graf graf--pre graf-after--li">rdd.first()</pre><ul class="postList"><li name="b298" id="b298" class="graf graf--li graf-after--pre">Return an array with the first <code class="markup--code markup--li-code">n</code> elements of the dataset.</li></ul><pre name="b49f" id="b49f" class="graf graf--pre graf-after--li">rdd.take(n)</pre><ul class="postList"><li name="2070" id="2070" class="graf graf--li graf-after--pre">Return the top <code class="markup--code markup--li-code">n</code> elements of the RDD by descending order</li></ul><pre name="f6e4" id="f6e4" class="graf graf--pre graf-after--li">rdd.top(n)</pre><ul class="postList"><li name="c166" id="c166" class="graf graf--li graf-after--pre">Return the last <code class="markup--code markup--li-code">n</code> elements of the RDD by descending order</li></ul><pre name="f49b" id="f49b" class="graf graf--pre graf-after--li">rdd.takeOrdered(n)</pre><ul class="postList"><li name="6317" id="6317" class="graf graf--li graf-after--pre">Return the number of elements in the dataset.</li></ul><pre name="aabb" id="aabb" class="graf graf--pre graf-after--li">rdd.count()</pre><ul class="postList"><li name="dfa9" id="dfa9" class="graf graf--li graf-after--pre">Return the number of times occurs in the RDD in a dictionary.</li></ul><pre name="f594" id="f594" class="graf graf--pre graf-after--li">rdd.countByValue()</pre><ul class="postList"><li name="5bb5" id="5bb5" class="graf graf--li graf-after--pre">Return the number of times each element occurs in the RDD in tuples.</li></ul><pre name="8f8a" id="8f8a" class="graf graf--pre graf-after--li">rdd.countByValue().item()</pre><p name="e5e7" id="e5e7" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(2) Math RDD Actions</strong></p><ul class="postList"><li name="0e32" id="0e32" class="graf graf--li graf-after--p">Return the mean of the RDD’s elements.</li></ul><pre name="eefa" id="eefa" class="graf graf--pre graf-after--li">rdd.mean()</pre><ul class="postList"><li name="8795" id="8795" class="graf graf--li graf-after--pre">Add up the elements in the RDD.</li></ul><pre name="5fb9" id="5fb9" class="graf graf--pre graf-after--li">rdd.sum()</pre><ul class="postList"><li name="d618" id="d618" class="graf graf--li graf-after--pre">Return the maximum item in the RDD.</li></ul><pre name="e273" id="e273" class="graf graf--pre graf-after--li">rdd.max()</pre><ul class="postList"><li name="ebe6" id="ebe6" class="graf graf--li graf-after--pre">Return the minimum item in the RDD.</li></ul><pre name="3dc6" id="3dc6" class="graf graf--pre graf-after--li">rdd.min()</pre><ul class="postList"><li name="f226" id="f226" class="graf graf--li graf-after--pre">Return the variance of the RDD’s elements.</li></ul><pre name="ab9a" id="ab9a" class="graf graf--pre graf-after--li">rdd.variance()</pre><ul class="postList"><li name="4a50" id="4a50" class="graf graf--li graf-after--pre">Return the standard deviation of the RDD’s elements.</li></ul><pre name="38c0" id="38c0" class="graf graf--pre graf-after--li">rdd.stdev()</pre><p name="8533" id="8533" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Complicated RDD Actions</strong></p><ul class="postList"><li name="fa86" id="fa86" class="graf graf--li graf-after--p">Combine the elements of the RDD together in parallel by <code class="markup--code markup--li-code">func</code>.</li></ul><pre name="7fd6" id="7fd6" class="graf graf--pre graf-after--li">rdd.reduce(func)</pre><ul class="postList"><li name="a250" id="a250" class="graf graf--li graf-after--pre">Same as <code class="markup--code markup--li-code">reduce()</code>, but with the provided <code class="markup--code markup--li-code">zeroValue</code> (don’t necessarily have to be 0) to start within each partition. This is safer because we won’t have errors if there is no element in a partition.</li></ul><pre name="79c4" id="79c4" class="graf graf--pre graf-after--li">rdd.fold(zeroValue, func)</pre><p name="3ac0" id="3ac0" class="graf graf--p graf-after--pre">For example, if we have a sum function of <code class="markup--code markup--p-code">lambda x, y: x+y</code> , then we are going to have an added value of <code class="markup--code markup--p-code">zeroValue * (numberOfPartition + 1)</code> . Having this <code class="markup--code markup--p-code">numberOfPartition + 1</code> because the program starts with <code class="markup--code markup--p-code">zeroValue</code> in each partition, and after calculating the result of each partition, the program treats all the values in a partition and it will also start from <code class="markup--code markup--p-code">zeroValue</code>.</p><p name="69be" id="69be" class="graf graf--p graf-after--p">Now, let’s see some common examples of <code class="markup--code markup--p-code">reduce</code> and <code class="markup--code markup--p-code">fold</code></p><ul class="postList"><li name="a664" id="a664" class="graf graf--li graf-after--p">Return the sum of all elements in all the partitions with non-empty RDDs</li></ul><pre name="b43b" id="b43b" class="graf graf--pre graf-after--li">rdd.reduce(lambda x, y: x + y)</pre><ul class="postList"><li name="c060" id="c060" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">Safely</strong> return the sum of all elements in all the partitions in an RDD. When the RDD is empty, return 0.</li></ul><pre name="b951" id="b951" class="graf graf--pre graf-after--li">rdd.fold(0, lambda x, y: x + y)</pre><ul class="postList"><li name="66e0" id="66e0" class="graf graf--li graf-after--pre">Return the product of all elements in all the partitions with non-empty RDDs</li></ul><pre name="da8a" id="da8a" class="graf graf--pre graf-after--li">rdd.reduce(lambda x, y: x * y)</pre><ul class="postList"><li name="2020" id="2020" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">Safely</strong> return the product of all elements in all the partitions in an RDD. When the RDD is empty, return 1.</li></ul><pre name="d615" id="d615" class="graf graf--pre graf-after--li">rdd.fold(1, lambda x, y: x * y)</pre><ul class="postList"><li name="6a26" id="6a26" class="graf graf--li graf-after--pre">Return the maximum value in a non-empty RDD by <code class="markup--code markup--li-code">reduce</code></li></ul><pre name="923f" id="923f" class="graf graf--pre graf-after--li">rdd.reduce(lambda x, y: x if x &gt; y else y)</pre><ul class="postList"><li name="5d2f" id="5d2f" class="graf graf--li graf-after--pre">Return the minimum value in a non-empty RDD by <code class="markup--code markup--li-code">reduce</code></li></ul><pre name="e41a" id="e41a" class="graf graf--pre graf-after--li">rdd.reduce(lambda x, y: x if x &lt; y else y)</pre><ul class="postList"><li name="f4bd" id="f4bd" class="graf graf--li graf-after--pre">Return the string combined with all the words in a non-empty RDD separated by <code class="markup--code markup--li-code">&quot; &quot;</code></li></ul><pre name="79b9" id="79b9" class="graf graf--pre graf-after--li">rdd.reduce(lambda x, y: x + &quot; &quot; + y)</pre><p name="dfd7" id="dfd7" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(5) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">reduce</strong></code><strong class="markup--strong markup--p-strong"> and </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">fold</strong></code><strong class="markup--strong markup--p-strong"> Problem: Counting</strong></p><p name="82e8" id="82e8" class="graf graf--p graf-after--p">If we have only <code class="markup--code markup--p-code">reduce</code> and <code class="markup--code markup--p-code">fold</code> , we can only do little things. For example, we are not able to count the elements in the RDD. If we try,</p><pre name="3256" id="3256" class="graf graf--pre graf-after--p">rdd = sc.parallelize([5,2,7,4,3,6,1], 3)<br>rdd.fold(0, lambda x, y: x + 1)</pre><p name="47bf" id="47bf" class="graf graf--p graf-after--pre">The result will probably be,</p><pre name="4ad4" id="4ad4" class="graf graf--pre graf-after--p">3</pre><p name="993f" id="993f" class="graf graf--p graf-after--pre">This is because we will start from the first partition which has elements <code class="markup--code markup--p-code">[5, 2]</code> . Then the lambda function will count the values in this function to 2. It will also be the same for the other two partitions. As a result, the result in each partition will be,</p><pre name="da51" id="da51" class="graf graf--pre graf-after--p">[2, 2, 3]</pre><p name="70a0" id="70a0" class="graf graf--p graf-after--pre">However, when the lambda starts to work on this list, it will again start by 0 and it will give us the number of partitions instead of the number of the elements. So what we want here is to have a different last step.</p><p name="3074" id="3074" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) RDD </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">aggregate</strong></code><strong class="markup--strong markup--p-strong"> Action</strong></p><p name="a905" id="a905" class="graf graf--p graf-after--p">Finally, let’s see the most complicated RDD action called <code class="markup--code markup--p-code">aggregate</code> . This is very useful when we want to have a different step in the end when combining the value in all the partitions.</p><pre name="d9f1" id="d9f1" class="graf graf--pre graf-after--p">rdd.aggregate(zeroValue, SeqOp, CombOp)</pre><p name="e87d" id="e87d" class="graf graf--p graf-after--pre">where,</p><ul class="postList"><li name="a349" id="a349" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">SeqOp</code>: this is the operation inside each partition</li><li name="fc6a" id="fc6a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">CombOp</code>: this is the operation when combining the returned value in all the partitions in the last step</li></ul><p name="c4d6" id="c4d6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) RDD </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">aggregate</strong></code><strong class="markup--strong markup--p-strong"> Action Example 1: Counting</strong></p><p name="3e09" id="3e09" class="graf graf--p graf-after--p">Now, let’s think about counting the array again. In the last step, we definitely don’t want to add 1 to the <code class="markup--code markup--p-code">zeroValue</code> iteratively. Instead, we would like to sum the result returned from all the partitions. Therefore,</p><ul class="postList"><li name="9792" id="9792" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">SeqOp = lambda x, y: x + 1</code> (counting in each partition)</li><li name="4f3f" id="4f3f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">CombOp = lambda x, y: x + y</code> (sum all the results)</li></ul><p name="3ad2" id="3ad2" class="graf graf--p graf-after--li">So the action should be,</p><pre name="318f" id="318f" class="graf graf--pre graf-after--p">rdd.aggregate(0, (<code class="markup--code markup--pre-code">lambda x, y: x + 1</code>), (<code class="markup--code markup--pre-code">lambda x, y: x + y</code>))</pre><p name="879e" id="879e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(8) RDD </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">aggregate</strong></code><strong class="markup--strong markup--p-strong"> Action Example 2: Safely Return String</strong></p><p name="d666" id="d666" class="graf graf--p graf-after--p">We have given an example about how to join a list of words separated by the space character <code class="markup--code markup--p-code">&quot; &quot;</code>. However, this method is not safe, especially when we have an empty RDD. So the safer idea is that we can start from an empty string, and if there’s no word, we can return an empty string <code class="markup--code markup--p-code">&quot;&quot;</code>.</p><ul class="postList"><li name="f3e9" id="f3e9" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">SeqOp = lambda x, y: x + &quot; &quot; + y</code>(joining in each partition)</li><li name="5938" id="5938" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">CombOp = lambda x, y: x + y</code> (join all the results)</li></ul><p name="f2b3" id="f2b3" class="graf graf--p graf-after--li">So the action should be,</p><pre name="acfb" id="acfb" class="graf graf--pre graf-after--p graf--trailing">rdd.aggregate(&quot;&quot;, (<code class="markup--code markup--pre-code">lambda x, y: x + &quot; &quot; + y</code>), (<code class="markup--code markup--pre-code">lambda x, y: x + y</code>))</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/1184c292b148"><time class="dt-published" datetime="2021-11-08T22:08:04.884Z">November 8, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/distributed-computing-3-rdd-transformation-operations-and-rdd-actions-1184c292b148" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>