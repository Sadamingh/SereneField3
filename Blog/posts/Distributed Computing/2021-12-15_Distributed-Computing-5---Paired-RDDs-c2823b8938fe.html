<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Distributed Computing 5 | Paired RDDs</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Distributed Computing 5 | Paired RDDs</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Distributed Computing
</section>
<section data-field="body" class="e-content">
<section name="e5fd" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e30d" id="e30d" class="graf graf--h3 graf--leading graf--title">Distributed Computing 5 | Paired RDDs</h3><figure name="322b" id="322b" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*bL86KlUeWycRQ2HT.png" data-width="1144" data-height="634" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*bL86KlUeWycRQ2HT.png"></figure><ol class="postList"><li name="5834" id="5834" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Paired RDDs</strong></li></ol><p name="817d" id="817d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Definition</strong></p><p name="09d9" id="09d9" class="graf graf--p graf-after--p">Pair RDDs are key-value pairs that are commonly used for many operations including aggregations or ETL in Spark.</p><ul class="postList"><li name="4eec" id="4eec" class="graf graf--li graf-after--p">Key: can be any type (hashable or unhashable)</li><li name="6326" id="6326" class="graf graf--li graf-after--li">Value: can be any type (hashable or unhashable)</li></ul><p name="0230" id="0230" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Paired RDD Transformations</strong></p><ul class="postList"><li name="e408" id="e408" class="graf graf--li graf-after--p">Return an RDD of just the keys.</li></ul><pre name="978a" id="978a" class="graf graf--pre graf-after--li">rdd.keys()</pre><ul class="postList"><li name="be8e" id="be8e" class="graf graf--li graf-after--pre">Return an RDD of just the values.</li></ul><pre name="860c" id="860c" class="graf graf--pre graf-after--li">rdd.values()</pre><ul class="postList"><li name="6be2" id="6be2" class="graf graf--li graf-after--pre">Return an RDD sorted by the key.</li></ul><pre name="4aa1" id="4aa1" class="graf graf--pre graf-after--li">rdd.sortByKey()</pre><ul class="postList"><li name="3345" id="3345" class="graf graf--li graf-after--pre">Group values with the same key.</li></ul><pre name="ce75" id="ce75" class="graf graf--pre graf-after--li">rdd.groupByKey()</pre><ul class="postList"><li name="ef8e" id="ef8e" class="graf graf--li graf-after--pre">Apply a function to each value of a pair RDD without changing the key.</li></ul><pre name="8b4c" id="8b4c" class="graf graf--pre graf-after--li">rdd.mapValues(func)</pre><ul class="postList"><li name="67b2" id="67b2" class="graf graf--li graf-after--pre">Pass each value in the key-value pair RDD through a flatMap function without changing the keys.</li></ul><pre name="2969" id="2969" class="graf graf--pre graf-after--li">rdd.flatMapValues(func)</pre><ul class="postList"><li name="9d36" id="9d36" class="graf graf--li graf-after--pre">Combine values with the same key.</li></ul><pre name="0170" id="0170" class="graf graf--pre graf-after--li">rdd.reduceByKey(func)</pre><ul class="postList"><li name="d6df" id="d6df" class="graf graf--li graf-after--pre">Remove elements with a key that existed in the other RDD.</li></ul><pre name="b696" id="b696" class="graf graf--pre graf-after--li">rdd.subtractByKey(otherDataset)</pre><ul class="postList"><li name="5e9f" id="5e9f" class="graf graf--li graf-after--pre">Perform an inner join between two RDDs.</li></ul><pre name="df32" id="df32" class="graf graf--pre graf-after--li">rdd.join(otherDataset)</pre><ul class="postList"><li name="b859" id="b859" class="graf graf--li graf-after--pre">Perform a join between two RDDs where the key must be present in the first RDD.</li></ul><pre name="0f2b" id="0f2b" class="graf graf--pre graf-after--li">rdd.leftOuterJoin(otherDataset)</pre><ul class="postList"><li name="3efb" id="3efb" class="graf graf--li graf-after--pre">Perform a join between two RDDs where the key must be present in the other RDD.</li></ul><pre name="36cc" id="36cc" class="graf graf--pre graf-after--li">rdd.rightOuterJoin(otherDataset)</pre><p name="280e" id="280e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Paired RDD Actions</strong></p><ul class="postList"><li name="c3f7" id="c3f7" class="graf graf--li graf-after--p">Only available on pair RDDs. Returns (Key, Int) pairs with the count of each key.</li></ul><pre name="2271" id="2271" class="graf graf--pre graf-after--li">rdd.countByKey()</pre><ul class="postList"><li name="40f4" id="40f4" class="graf graf--li graf-after--pre">Return all values associated with the provided key.</li></ul><pre name="c236" id="c236" class="graf graf--pre graf-after--li">rdd.lookup(key)</pre><p name="52d4" id="52d4" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Self Testing Questions</strong></p><p name="ef75" id="ef75" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Suppose we have the following RDD.</strong></p><pre name="2a52" id="2a52" class="graf graf--pre graf-after--p">rdd = sc.parallelize([[5,2],[7,4],[3,6],[1,4],[9,7]],3)</pre><ul class="postList"><li name="97c5" id="97c5" class="graf graf--li graf-after--pre">What is the result of the following code?</li></ul><pre name="1ae7" id="1ae7" class="graf graf--pre graf-after--li">rdd_pair = rdd.map(lambda x: ([x[0]], x[1]))<br>rdd_pair.take(1)</pre><p name="ffee" id="ffee" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">[([5], 2)]</code> because the paired key can be a list</p><ul class="postList"><li name="8b2f" id="8b2f" class="graf graf--li graf-after--p">What is the result of the following code?</li></ul><pre name="154d" id="154d" class="graf graf--pre graf-after--li">rdd_pair = rdd.map(lambda x: ({x[0]:1}, x[1]))<br>rdd_pair.take(1)</pre><p name="628d" id="628d" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">[({5: 1}, 2)]</code> because the paired key can be a list</p><ul class="postList"><li name="5331" id="5331" class="graf graf--li graf-after--p">What is the result of the following code?</li></ul><pre name="1d87" id="1d87" class="graf graf--pre graf-after--li">rdd_pair = rdd.map(lambda x: (x[0], {x[1]:1}))<br>rdd_pair.distinct().count()</pre><p name="a8cf" id="a8cf" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">ERROR</code> because <code class="markup--code markup--p-code">distinct()</code> requires keys and values in paired RDDs to be hashable.</p><ul class="postList"><li name="5386" id="5386" class="graf graf--li graf-after--p">What is the result of the following code?</li></ul><pre name="021e" id="021e" class="graf graf--pre graf-after--li">rdd_pair = rdd.map(lambda x: (x[0], str(x[1])))<br>rdd_pair.distinct().count()</pre><p name="dabf" id="dabf" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">5</code></p><p name="3f14" id="3f14" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Suppose we have the following paired RDD.</strong></p><pre name="8bb6" id="8bb6" class="graf graf--pre graf-after--p">rdd = sc.parallelize([[7,2],[7,4],[3,6],[1,4],[3,7]],3)<br>rdd = rdd.map(lambda x: (x[0], x[1]))</pre><ul class="postList"><li name="2b83" id="2b83" class="graf graf--li graf-after--pre">What is the result of the following code?</li></ul><pre name="535c" id="535c" class="graf graf--pre graf-after--li">rdd.flatMap(lambda x: x).collect()</pre><p name="8312" id="8312" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">[7, 2, 7, 4, 3, 6, 1, 4, 3, 7]</code> the answer has no pairs</p><ul class="postList"><li name="5b0f" id="5b0f" class="graf graf--li graf-after--p">What is the result of the following code?</li></ul><pre name="2697" id="2697" class="graf graf--pre graf-after--li">rdd.flatMapValues(lambda x: x).collect()</pre><p name="decd" id="decd" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">ERROR</code> because the value for each pair is not iterable.</p><ul class="postList"><li name="59ef" id="59ef" class="graf graf--li graf-after--p">What is the result of the following code?</li></ul><pre name="e3df" id="e3df" class="graf graf--pre graf-after--li">rdd.sortByKey().groupByKey().take(1)[0][1] == [6, 7]</pre><p name="4218" id="4218" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">False</code> because <code class="markup--code markup--p-code">groupByKey()</code> returns <code class="markup--code markup--p-code">ResultIterable</code> type object as its value. The following code should return <code class="markup--code markup--p-code">True</code> ,</p><pre name="f5c4" id="f5c4" class="graf graf--pre graf-after--p">rdd.sortByKey().groupByKey().mapValues(list).take(1)[0][1] == [6, 7]</pre><ul class="postList"><li name="5111" id="5111" class="graf graf--li graf-after--pre">What is the result of the following code?</li></ul><pre name="4a07" id="4a07" class="graf graf--pre graf-after--li">rdd.groupByKey().mapValues(list).flatMapValues(lambda x: x).collect() == rdd.collect()</pre><p name="0299" id="0299" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">False</code> although two results have the same elements, their order can be different. The following code should return <code class="markup--code markup--p-code">True</code>.</p><pre name="2429" id="2429" class="graf graf--pre graf-after--p">set(rdd.groupByKey().mapValues(list).flatMapValues(lambda x: x).collect()) == set(rdd.collect())</pre><ul class="postList"><li name="d5cd" id="d5cd" class="graf graf--li graf-after--pre">What’s the result of the following code?</li></ul><pre name="fcbb" id="fcbb" class="graf graf--pre graf-after--li">rdd.groupByKey().mapValues(list).reduceByKey(lambda x, y: x + y).take(1)</pre><p name="57f9" id="57f9" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">[(3, [6, 7])]</code> the method <code class="markup--code markup--p-code">reduceByKey</code> is not useful because we have unique keys. Directly use <code class="markup--code markup--p-code">reduceByKey</code> if you want to sum them up.</p><pre name="8a04" id="8a04" class="graf graf--pre graf-after--p">rdd.reduceByKey(lambda x, y: x + y).take(1)</pre><ul class="postList"><li name="4bdc" id="4bdc" class="graf graf--li graf-after--pre">What’s the result of the following code?</li></ul><pre name="3997" id="3997" class="graf graf--pre graf-after--li">rdd.lookup(3)</pre><p name="e1dc" id="e1dc" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">[6, 7]</code> , should return a list.</p><ul class="postList"><li name="20e0" id="20e0" class="graf graf--li graf-after--p">What’s the result of the following code?</li></ul><pre name="f962" id="f962" class="graf graf--pre graf-after--li">rdd.countByKey()[3]</pre><p name="578b" id="578b" class="graf graf--p graf-after--pre">Ans: <code class="markup--code markup--p-code">2</code>, returns a dictionary with keys and the number of its values.</p><p name="bac4" id="bac4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Which of the following transformations don’t require data shuffle?</strong></p><ul class="postList"><li name="2890" id="2890" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">keys()</code></li><li name="c18c" id="c18c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">values()</code></li><li name="c23e" id="c23e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sortByKey()</code></li><li name="4dc9" id="4dc9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">groupByKey()</code></li><li name="7561" id="7561" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">mapValues(func)</code></li><li name="04d6" id="04d6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">flatMapValues(func)</code></li><li name="d42c" id="d42c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">reduceByKey(func)</code></li></ul><p name="6b32" id="6b32" class="graf graf--p graf-after--li">Ans: <code class="markup--code markup--p-code">keys(), values(), mapValues(func), flatMapValues(func)</code></p><p name="210b" id="210b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Which of the following code performs better?</strong></p><pre name="6430" id="6430" class="graf graf--pre graf-after--p">Code 1: rdd.groupByKey().mapValues(sum).collect()<br>Code 2: rdd.reduceByKey(lambda x, y: x + y).collect()</pre><p name="0437" id="0437" class="graf graf--p graf-after--pre graf--trailing">Ans: <code class="markup--code markup--p-code">Code 2</code> because <code class="markup--code markup--p-code">groupByKey</code> requires shuffle and aggregate.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/c2823b8938fe"><time class="dt-published" datetime="2021-12-15T18:07:10.153Z">December 15, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/distributed-computing-5-paired-rdds-c2823b8938fe" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>