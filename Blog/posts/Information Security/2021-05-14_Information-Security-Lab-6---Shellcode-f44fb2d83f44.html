<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Information Security Lab 6 | Shellcode</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Information Security Lab 6 | Shellcode</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Information Security Lab
</section>
<section data-field="body" class="e-content">
<section name="545f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0ed8" id="0ed8" class="graf graf--h3 graf--leading graf--title">Information Security Lab 6 | Shellcode</h3><figure name="464e" id="464e" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*jMx8me39pTKGbPLr.png" data-width="1738" data-height="952" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*jMx8me39pTKGbPLr.png"></figure><p name="07e2" id="07e2" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">1. Linux Shells</strong></p><p name="ae8f" id="ae8f" class="graf graf--p graf-after--p">Let’s discuss today’s main topic about writing the shellcode. Shellcode often means a generic payload for the exploitation, so its goal is to launch an interactive shell as a result. First, we have to direct to the <code class="markup--code markup--p-code">tut02-shellcode</code> directory by,</p><pre name="1605" id="1605" class="graf graf--pre graf-after--p">$ seclab tut02<br>$ cd ~/tuts/lab02/tut02-shellcode/<br>$ ls -al<br>total 44<br>drwxrwxr-x 2 vagrant vagrant  4096 May 10 09:57 .<br>drwxrwxr-x 3 vagrant vagrant  4096 May  6 03:25 ..<br>-rw-r--r-- 1 vagrant vagrant   535 May  9 21:54 Makefile<br>-rw-r--r-- 1 vagrant vagrant 11253 May  9 21:54 README<br>-rw-r--r-- 1 vagrant vagrant  1090 May  9 21:54 shellcode.S<br>-rwxr-xr-x 1 vagrant vagrant  9820 May  9 21:54 target<br>-rw-r--r-- 1 vagrant vagrant   482 May  9 21:54 target.c</pre><p name="0142" id="0142" class="graf graf--p graf-after--pre">Before we see how we can build a shellcode, we will first see some shells we can use in Linux. If we want to check the current shell we are using, we can check it by (in the VM, we are using <code class="markup--code markup--p-code">bash</code> by default),</p><pre name="9238" id="9238" class="graf graf--pre graf-after--p">$ echo $0<br>/bin/bash</pre><p name="7b5c" id="7b5c" class="graf graf--p graf-after--pre">Our system support many other shells like <code class="markup--code markup--p-code">dash</code> or <code class="markup--code markup--p-code">zsh</code>. We can check all the shells we support by,</p><pre name="203f" id="203f" class="graf graf--pre graf-after--p">$ cat /etc/shells<br># /etc/shells: valid login shells<br>/bin/sh<br>/bin/bash<br>/bin/rbash<br>/bin/dash<br>/usr/bin/tmux<br>/usr/bin/screen<br>/bin/zsh<br>/usr/bin/zsh</pre><p name="b764" id="b764" class="graf graf--p graf-after--pre">Or we can try,</p><pre name="42c9" id="42c9" class="graf graf--pre graf-after--p">$ ls /bin | grep sh<br>bash<br>dash<br>rbash<br>rzsh<br>sh<br>sh.distrib<br>static-sh<br>zsh<br>zsh5</pre><p name="7e7c" id="7e7c" class="graf graf--p graf-after--pre">In this result, we can find out that we are able to change to some other shells. For example, we can change to <code class="markup--code markup--p-code">dash</code> by,</p><pre name="f7ba" id="f7ba" class="graf graf--pre graf-after--p">$ /bin/dash<br>$</pre><p name="3a44" id="3a44" class="graf graf--p graf-after--pre">To quit the current shell, we can use the <code class="markup--code markup--p-code">exit</code> command,</p><pre name="25ea" id="25ea" class="graf graf--pre graf-after--p">$ exit</pre><p name="d000" id="d000" class="graf graf--p graf-after--pre">Or we can change to <code class="markup--code markup--p-code">sh</code> by,</p><pre name="fc1b" id="fc1b" class="graf graf--pre graf-after--p">$ /bin/sh<br>$ echo $0<br>/bin/sh<br>$ exit</pre><p name="a669" id="a669" class="graf graf--p graf-after--pre">Or we can also use <code class="markup--code markup--p-code">zsh</code>,</p><pre name="b4a7" id="b4a7" class="graf graf--pre graf-after--p">$ /bin/zsh<br>This is the Z Shell configuration function for new users,<br>zsh-newuser-install.<br>...<br>--- Type one of the keys in parentheses ---<br>Aborting.<br>The function will be run again next time.  To prevent this, execute:<br>  touch ~/.zshrc</pre><pre name="1ed8" id="1ed8" class="graf graf--pre graf-after--pre">ubuntu-bionic% echo $0<br>/bin/zsh<br>ubuntu-bionic% exit</pre><p name="4b89" id="4b89" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Introduction to Shellcode</strong></p><p name="5d10" id="5d10" class="graf graf--p graf-after--p">Let’s first see an example of the shellcode. Suppose we have the following C program, and what it does is to execute the command <code class="markup--code markup--p-code">/bin/sh</code>. The system call we should use in this example is called <code class="markup--code markup--p-code">execve</code> and the program <code class="markup--code markup--p-code">shellcode.c</code> should be as follows,</p><pre name="6107" id="6107" class="graf graf--pre graf-after--p">#include &lt;stdio.h&gt;<br>#include &lt;unistd.h&gt;</pre><pre name="2195" id="2195" class="graf graf--pre graf-after--pre">int main() {<br> char *sh = &quot;/bin/sh&quot;;<br> char *argv[] = {sh, NULL};<br> char *envp[] = {NULL};<br> execve(sh, argv, envp);<br> return 0;<br>}</pre><p name="d383" id="d383" class="graf graf--p graf-after--pre">The string <code class="markup--code markup--p-code">sh</code> is the shell we would like to use, and the <code class="markup--code markup--p-code">execve</code> call accepts another two arguments,</p><ul class="postList"><li name="da86" id="da86" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">argv</code> to indicate the arguments</li><li name="047e" id="047e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">envp</code> to indicate the environment pointers (find more from <a href="https://www.gnu.org/software/libc/manual/html_node/Program-Arguments.html" data-href="https://www.gnu.org/software/libc/manual/html_node/Program-Arguments.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">here</a>)</li></ul><blockquote name="85f2" id="85f2" class="graf graf--blockquote graf-after--li"><code class="markup--code markup--blockquote-code">execve()</code> executes the program referred to by pathname. This causes the program that is currently being run by the calling process to be replaced with a new program, with newly initialized stack, heap, and (initialized and uninitialized) data segments.</blockquote><p name="1585" id="1585" class="graf graf--p graf-after--blockquote">The function <code class="markup--code markup--p-code">execve</code> belongs to the <code class="markup--code markup--p-code">exec</code> function family and if you are not familiar with this concept, the following article may help.</p><div name="1a63" id="1a63" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/adamedelwiess/operating-system-3-process-and-process-management-process-control-block-process-lifecycle-66bbf73ee3f6" data-href="https://medium.com/adamedelwiess/operating-system-3-process-and-process-management-process-control-block-process-lifecycle-66bbf73ee3f6" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/adamedelwiess/operating-system-3-process-and-process-management-process-control-block-process-lifecycle-66bbf73ee3f6"><strong class="markup--strong markup--mixtapeEmbed-strong">Operating System 3 | Process and Process Management, Process Control Block, Process Lifecycle…</strong><br><em class="markup--em markup--mixtapeEmbed-em">Series: Operating System</em>medium.com</a><a href="https://medium.com/adamedelwiess/operating-system-3-process-and-process-management-process-control-block-process-lifecycle-66bbf73ee3f6" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="b67b1fd8d280b5a016150067416c944f" data-thumbnail-img-id="0*pvX403KYxMklPqIF.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*pvX403KYxMklPqIF.png);"></a></div><p name="1168" id="1168" class="graf graf--p graf-after--mixtapeEmbed">In fact, the <code class="markup--code markup--p-code">/bin/sh</code> is not the only command we can execute. Actually, we can execute some other commands like, for example, the simplest one is to create a program for <code class="markup--code markup--p-code">echo</code> command.</p><figure name="2f8d" id="2f8d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/686389d98223cbdddecfee6d58e0e8e6.js"></script></figure><p name="56ce" id="56ce" class="graf graf--p graf-after--figure">We can use the following command to compile this code,</p><pre name="932d" id="932d" class="graf graf--pre graf-after--p">$ gcc echocode.c -o echocode</pre><p name="5cbd" id="5cbd" class="graf graf--p graf-after--pre">Then we can execute this program by,</p><pre name="7c2d" id="7c2d" class="graf graf--pre graf-after--p">$ ./echocode hello<br>hello</pre><p name="bddf" id="bddf" class="graf graf--p graf-after--pre">Now, let’s look back to the shellcode. In the lab, we have provided the assembly code <code class="markup--code markup--p-code">shellcode.S</code> for <code class="markup--code markup--p-code">shellcode.c</code>. Note that different compilers will compile the C script in different ways, and what we are going to discuss is the assembly code we have provided. You can find the assembly code <code class="markup--code markup--p-code">shellcode.S</code> by,</p><pre name="58b5" id="58b5" class="graf graf--pre graf-after--p">[vm] $ cd ~/tuts/lab02/tut02-shellcode/<br>[vm] $ cat shellcode.S</pre><figure name="51e1" id="51e1" class="graf graf--figure graf--iframe graf-after--pre"><script src="https://gist.github.com/Sadamingh/57cd7f27efd465d689c36352b0f31bd8.js"></script></figure><p name="8a3c" id="8a3c" class="graf graf--p graf-after--figure">This assembly code seems more complicated than the C script, and we have to explain it for a little bit. First, in this code, we will find some defined constants like <code class="markup--code markup--p-code">STRING</code> , <code class="markup--code markup--p-code">STRLEN</code> , <code class="markup--code markup--p-code">ARGV</code> , and <code class="markup--code markup--p-code">ENVP</code>. The <code class="markup--code markup--p-code">STRLEN</code> is exactly the length of the <code class="markup--code markup--p-code">STRING</code> (value = 7), and <code class="markup--code markup--p-code">ARGV</code> (value = 8) and <code class="markup--code markup--p-code">ENVP</code> (value = 12) is the offset for <code class="markup--code markup--p-code">argv</code> and the environment pointer.</p><figure name="795e" id="795e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0znTyMlJAZSB-D38e1xKTg.png" data-width="1770" data-height="1056" src="https://cdn-images-1.medium.com/max/800/1*0znTyMlJAZSB-D38e1xKTg.png"></figure><p name="9760" id="9760" class="graf graf--p graf-after--figure">In the main function, the very first instruction in this shellcode is a jump instruction. When this instruction is executed, our instruction pointer <code class="markup--code markup--p-code">eip</code> will now point to <code class="markup--code markup--p-code">calladdr</code> , which will have a call instruction.</p><figure name="3a14" id="3a14" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*bLkztxpJ_PiTn2NbZXaWVA.png" data-width="1770" data-height="1056" src="https://cdn-images-1.medium.com/max/800/1*bLkztxpJ_PiTn2NbZXaWVA.png"></figure><p name="41d7" id="41d7" class="graf graf--p graf-after--figure">One thing to notice here is that the <code class="markup--code markup--p-code">/bin/sh</code> string will be written after the call instruction. So after we call <code class="markup--code markup--p-code">popladdr</code> , we will have this string on the top of the stack.</p><figure name="444a" id="444a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*7HlPe4tin2CNHqZn41jMbw.png" data-width="1770" data-height="1056" src="https://cdn-images-1.medium.com/max/800/1*7HlPe4tin2CNHqZn41jMbw.png"></figure><p name="b847" id="b847" class="graf graf--p graf-after--figure">After executing <code class="markup--code markup--p-code">pop esi</code> , the <code class="markup--code markup--p-code">esi</code> register will contain the particular pointer <code class="markup--code markup--p-code">sh</code>.</p><figure name="d946" id="d946" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fZClz7tCTxld34OXoexePg.png" data-width="1770" data-height="1056" src="https://cdn-images-1.medium.com/max/800/1*fZClz7tCTxld34OXoexePg.png"></figure><p name="5b54" id="5b54" class="graf graf--p graf-after--figure">Using <code class="markup--code markup--p-code">esi</code> as a reference, we will prepare the arguments for the <code class="markup--code markup--p-code">execve</code> system call now. First, we put the pointer as our first argument to <code class="markup--code markup--p-code">argv</code> by,</p><pre name="56fe" id="56fe" class="graf graf--pre graf-after--p">mov [ARGV + esi], esi</pre><figure name="18f1" id="18f1" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*XzLGkIIpnd5eLkVi0lsgtg.png" data-width="1770" data-height="1154" src="https://cdn-images-1.medium.com/max/800/1*XzLGkIIpnd5eLkVi0lsgtg.png"></figure><p name="1fa1" id="1fa1" class="graf graf--p graf-after--figure">Second, we zero out the <code class="markup--code markup--p-code">eax</code> register by (see why <a href="https://stackoverflow.com/questions/1396527/what-is-the-purpose-of-xoring-a-register-with-itself" data-href="https://stackoverflow.com/questions/1396527/what-is-the-purpose-of-xoring-a-register-with-itself" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>),</p><pre name="92b6" id="92b6" class="graf graf--pre graf-after--p">xor eax, eax</pre><p name="06a3" id="06a3" class="graf graf--p graf-after--pre">Then we put a NULL character <code class="markup--code markup--p-code">\0</code> at the end of <code class="markup--code markup--p-code">\bin\sh</code> string.</p><figure name="2422" id="2422" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*1lT4y0pEJYZ11o-HRbRSyw.png" data-width="1770" data-height="1154" src="https://cdn-images-1.medium.com/max/800/1*1lT4y0pEJYZ11o-HRbRSyw.png"></figure><p name="6a4c" id="6a4c" class="graf graf--p graf-after--figure">By using the <code class="markup--code markup--p-code">eax</code> register, we also put the NULL pointer as a first element of the environment pointer <code class="markup--code markup--p-code">envp</code>. Now, because the second element of <code class="markup--code markup--p-code">argv</code> is now sharing with the <code class="markup--code markup--p-code">envp</code>, we do not need to use another NULL variable.</p><figure name="c224" id="c224" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*pXtIx4ZlGy5XfC0Uri5Hiw.png" data-width="1770" data-height="1154" src="https://cdn-images-1.medium.com/max/800/1*pXtIx4ZlGy5XfC0Uri5Hiw.png"></figure><p name="2e80" id="2e80" class="graf graf--p graf-after--figure">Then, the system call number <code class="markup--code markup--p-code">SYS_execve</code> will be moved to the <code class="markup--code markup--p-code">eax</code> register.</p><figure name="79b9" id="79b9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qSXOWuJ1qtICNDVkwygR0g.png" data-width="1770" data-height="1154" src="https://cdn-images-1.medium.com/max/800/1*qSXOWuJ1qtICNDVkwygR0g.png"></figure><p name="9043" id="9043" class="graf graf--p graf-after--figure">And finally, we put the corresponding addresses to register <code class="markup--code markup--p-code">ebx</code> , <code class="markup--code markup--p-code">ecx</code> , and <code class="markup--code markup--p-code">edx</code> registers respectively.</p><figure name="c487" id="c487" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tlgjAOL401P_m7C9N58THg.png" data-width="1770" data-height="1154" src="https://cdn-images-1.medium.com/max/800/1*tlgjAOL401P_m7C9N58THg.png"></figure><p name="2d32" id="2d32" class="graf graf--p graf-after--figure">Finally, we will invoke this system call by executing an interrupt instruction,</p><pre name="5345" id="5345" class="graf graf--pre graf-after--p">int 0x80</pre><p name="1a13" id="1a13" class="graf graf--p graf-after--pre">In Linux, <code class="markup--code markup--p-code">0x80</code> interrupt handler is the kernel, and is used to make system calls to the kernel by other programs.</p><p name="cb91" id="cb91" class="graf graf--p graf-after--p">Now, let’s compile the code in the current directory.</p><pre name="6d6a" id="6d6a" class="graf graf--pre graf-after--p">$ cd ~/tuts/lab02/tut02-shellcode<br>$ cat Makefile<br>$ make clean<br>$ make</pre><p name="4fdd" id="4fdd" class="graf graf--p graf-after--pre">When compiling the file, we will have the following commands. The first one is to compile the assembly code <code class="markup--code markup--p-code">shellcode.S</code> to the object file <code class="markup--code markup--p-code">shellcode.o</code> by <code class="markup--code markup--p-code">cc</code>,</p><pre name="c516" id="c516" class="graf graf--pre graf-after--p">cc -m32 -c -o shellcode.o shellcode.S</pre><p name="9d05" id="9d05" class="graf graf--p graf-after--pre">Then, the <code class="markup--code markup--p-code">shellcode.o</code> file is compiled to a payload binary called <code class="markup--code markup--p-code">shellcode.bin</code>,</p><pre name="934d" id="934d" class="graf graf--pre graf-after--p">objcopy -S -O binary -j .text shellcode.o shellcode.bin</pre><p name="d25f" id="d25f" class="graf graf--p graf-after--pre">After this, we explicitly set the target as <code class="markup--code markup--p-code">execstack</code> to the linker, so that the <code class="markup--code markup--p-code">target</code> process actually contains the executable stack.</p><pre name="24d8" id="24d8" class="graf graf--pre graf-after--p">cc -m32 -std=gnu99 -g -O0 -fno-stack-protector -fno-PIE -fno-pie -z execstack -o target target.c</pre><p name="488e" id="488e" class="graf graf--p graf-after--pre">Finally, we will delete the medium object file,</p><pre name="4868" id="4868" class="graf graf--pre graf-after--p">rm shellcode.o</pre><p name="01d5" id="01d5" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. Shellcode Execution</strong></p><p name="f622" id="f622" class="graf graf--p graf-after--p">After we compile the <code class="markup--code markup--p-code">shellcode.S</code> file, we get the binary we want called <code class="markup--code markup--p-code">shellcode.bin</code>. But if we try to run this program by,</p><pre name="31c3" id="31c3" class="graf graf--pre graf-after--p">$ ./shellcode.bin</pre><p name="9374" id="9374" class="graf graf--p graf-after--pre">We will get a permission problem as follows,</p><pre name="225e" id="225e" class="graf graf--pre graf-after--p">-bash: ./shellcode.bin: Permission denied</pre><p name="af87" id="af87" class="graf graf--p graf-after--pre">This is because the permission of file <code class="markup--code markup--p-code">shellcode.bin</code> is <code class="markup--code markup--p-code">-rw-rw-r--</code> and only the target file can be executed now. So the simplest idea is to change the permission of this <code class="markup--code markup--p-code">shellcode.bin</code> file by <code class="markup--code markup--p-code">chmod</code>,</p><pre name="eab4" id="eab4" class="graf graf--pre graf-after--p">$ chmod 777 shellcode.bin</pre><p name="6c3f" id="6c3f" class="graf graf--p graf-after--pre">However, even after we change the permission of this file, we can not execute it,</p><pre name="6a3b" id="6a3b" class="graf graf--pre graf-after--p">$ ./shellcode.bin<br>-bash: ./shellcode.bin: cannot execute binary file: Exec format error</pre><p name="6bce" id="6bce" class="graf graf--p graf-after--pre">To execute this binary, we have to execute it from the <code class="markup--code markup--p-code">target</code> binary by,</p><pre name="58f7" id="58f7" class="graf graf--pre graf-after--p">$ (cat shellcode.bin; echo; cat) | ./target</pre><p name="6dd7" id="6dd7" class="graf graf--p graf-after--pre">This command will invoke <code class="markup--code markup--p-code">execve(&quot;/bin/cat&quot;...</code> and we can check this by the <code class="markup--code markup--p-code">strace</code> function,</p><pre name="10c5" id="10c5" class="graf graf--pre graf-after--p">$ (cat shellcode.bin; echo; cat) | strace ./target<br>...<br>execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], 0x56581073 /* 0 vars */) = 0<br>...</pre><p name="abfa" id="abfa" class="graf graf--p graf-after--pre">We can make the output much clearer by pointing out that we only want to see <code class="markup--code markup--p-code">execve</code> system call with <code class="markup--code markup--p-code">-e</code> option,</p><pre name="2295" id="2295" class="graf graf--pre graf-after--p">$ (cat shellcode.bin; echo; cat) | strace -e execve ./target<br>execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], 0x56581073 /* 0 vars */) = 0<br>...</pre><p name="4394" id="4394" class="graf graf--p graf-after--pre">Also, we can view the disassembled binary of <code class="markup--code markup--p-code">shellcode.bin</code> simply by running,</p><pre name="d210" id="d210" class="graf graf--pre graf-after--p">$ cat shellcode.bin | disasm -c i386</pre><p name="cb81" id="cb81" class="graf graf--p graf-after--pre">This is what <code class="markup--code markup--p-code">$ make test</code> do. First, it will show the disassembled binary <code class="markup--code markup--p-code">shellcode.bin</code>. And then, we will execute this binary with the help of the pre-compiled <code class="markup--code markup--p-code">target</code> file,</p><pre name="61c6" id="61c6" class="graf graf--pre graf-after--p">$ make test<br>cat shellcode.bin | disasm -c i386<br>...<br>bash -c &#39;(cat shellcode.bin; echo; cat) | strace -e execve ./target&#39;<br>...</pre><p name="c3f9" id="c3f9" class="graf graf--p graf-after--pre">Now, let’s modify the <code class="markup--code markup--p-code">shellcode.S</code> so that it will <code class="markup--code markup--p-code">execve</code> file <code class="markup--code markup--p-code">/bin/cat</code> instead of <code class="markup--code markup--p-code">/bin/sh</code>. To change the program we would like to run, we have to modify the following lines in <code class="markup--code markup--p-code">shellcode.S</code>,</p><pre name="9951" id="9951" class="graf graf--pre graf-after--p">#define STRING  &quot;/bin/sh&quot; <br>#define STRLEN  7</pre><p name="1a1f" id="1a1f" class="graf graf--p graf-after--pre">to,</p><pre name="1791" id="1791" class="graf graf--pre graf-after--p">#define STRING  &quot;/bin/cat&quot;<br>#define STRLEN  8</pre><p name="4ff1" id="4ff1" class="graf graf--p graf-after--pre">After that, we will compile the <code class="markup--code markup--p-code">shellcode.S</code> and then execute it again by,</p><pre name="9e5c" id="9e5c" class="graf graf--pre graf-after--p">$ make<br>$ make test<br>...<br>execve(&quot;/bin/cat&quot;, [&quot;/bin/cat&quot;], 0x5659a073 /* 0 vars */) = 0<br>strace: [ Process PID=3221 runs in 64 bit mode. ]<br><br></pre><p name="63d5" id="63d5" class="graf graf--p graf-after--pre">If we see the <code class="markup--code markup--p-code">strace</code>, we can then type in <code class="markup--code markup--p-code">hello</code>. If all the things are correct, we are expected to see an echoed <code class="markup--code markup--p-code">hello</code> as follows,</p><figure name="2944" id="2944" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*FvkQeJEbQ4O4aX9se2uZdg.png" data-width="1762" data-height="1068" src="https://cdn-images-1.medium.com/max/800/1*FvkQeJEbQ4O4aX9se2uZdg.png"></figure><p name="6bf7" id="6bf7" class="graf graf--p graf-after--figure">We can press <code class="markup--code markup--p-code">ctrl+c</code> to quit this program.</p><p name="c600" id="c600" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. Get the Flag</strong></p><p name="f36b" id="f36b" class="graf graf--p graf-after--p">In the previous discussion, we have modified the shellcode so that we can execute <code class="markup--code markup--p-code">/bin/cat</code> instead of <code class="markup--code markup--p-code">/bin/sh</code>. Now, we would like to provide an argument to the shellcode so that it can output the content of the file <code class="markup--code markup--p-code">/proc/flag</code> , which is the flag we want to get. Note that our current payload is as follows (i.e. <code class="markup--code markup--p-code">/bin/cat</code>),</p><pre name="0e03" id="0e03" class="graf graf--pre graf-after--p">+-------------+<br>v             |<br>[/bin/cat][0][ptr ][NULL]<br>             ^     ^     <br>             |     +-- envp<br>             +-- argv</pre><p name="6187" id="6187" class="graf graf--p graf-after--pre">And our plan is to make the payload as follows (i.e. <code class="markup--code markup--p-code">/bin/cat /proc/flag</code>),</p><pre name="0c75" id="0c75" class="graf graf--pre graf-after--p">+----------------------------+<br>|             +--------------=-----+<br>v             v              |     |<br>[/bin/cat][0][/proc/flag][0][ptr1][ptr2][NULL]<br>                            ^           ^<br>                            |           +-- envp<br>                            +-- argv</pre><p name="3644" id="3644" class="graf graf--p graf-after--pre">We can use a letter <code class="markup--code markup--p-code">N</code> (means NULL character, as a placeholder) to split <code class="markup--code markup--p-code">/bin/cat</code> and <code class="markup--code markup--p-code">/proc/flag</code> , and we are going to overwrite this letter with a <code class="markup--code markup--p-code">NULL</code> byte. So the string we are going to have will be,</p><pre name="554f" id="554f" class="graf graf--pre graf-after--p">#define STRING <code class="markup--code markup--pre-code">&quot;/bin/catN/proc/flag&quot;</code></pre><p name="a39c" id="a39c" class="graf graf--p graf-after--pre">And now, only one <code class="markup--code markup--p-code">STRLEN</code> will not be enough for us. We have to indicate the string <code class="markup--code markup--p-code">/bin/cat</code> by one <code class="markup--code markup--p-code">STRLEN1</code> and we will represent the full length of the string with another <code class="markup--code markup--p-code">STRLEN2</code>. These are as follows,</p><pre name="e17e" id="e17e" class="graf graf--pre graf-after--p">#define STRLEN1 8 <br>#define STRLEN2 19</pre><p name="1a45" id="1a45" class="graf graf--p graf-after--pre">Then, the next thing we are going to do is to place lace a <code class="markup--code markup--p-code">NULL</code> after <code class="markup--code markup--p-code">/bin/cat</code> and <code class="markup--code markup--p-code">/proc/flag</code>. Recall we have discussed that we can zero out <code class="markup--code markup--p-code">eax</code> by <code class="markup--code markup--p-code">xor eax,eax</code>, then if we want to place a NULL character after <code class="markup--code markup--p-code">/bin/cat</code> , we have to add,</p><pre name="dffe" id="dffe" class="graf graf--pre graf-after--p">mov    [STRLEN1 + esi],al</pre><p name="c0ad" id="c0ad" class="graf graf--p graf-after--pre">Meanwhile, if we want to place a NULL character after <code class="markup--code markup--p-code">/proc/flag</code> , we have to add,</p><pre name="b3c2" id="b3c2" class="graf graf--pre graf-after--p">mov    [STRLEN2 + esi],al</pre><p name="7f91" id="7f91" class="graf graf--p graf-after--pre">The offset <code class="markup--code markup--p-code">ARGV</code> and <code class="markup--code markup--p-code">ENVP</code> should also be changed and we can refer to the following diagram in the memory.</p><pre name="9b08" id="9b08" class="graf graf--pre graf-after--p">+---------------------------------------------+   &lt;- esi<br>|  / b i n / c a t \0 / p r o c / f l a g \0  |<br>+---------------------------------------------+   &lt;- esi+ARGV<br>|             argv[0] == cat                  |<br>+---------------------------------------------+   &lt;- esi+ARGV+4<br>|                 argv[1]                     |<br>+---------------------------------------------+   &lt;- esi+ENVP<br>|                  NULL                       |<br>+---------------------------------------------+</pre><p name="abe2" id="abe2" class="graf graf--p graf-after--pre">Because we have,</p><pre name="cebe" id="cebe" class="graf graf--pre graf-after--p">STRLEN1 == 8<br>STRLEN2 == 19</pre><p name="f7a8" id="f7a8" class="graf graf--p graf-after--pre">Then, the <code class="markup--code markup--p-code">ARGV</code> offset should be the full length of the <code class="markup--code markup--p-code">STRING</code> plus the size of the NULL character, which should be <code class="markup--code markup--p-code">20</code>,</p><pre name="5566" id="5566" class="graf graf--pre graf-after--p">ARGV == STRLEN2 + 1</pre><p name="bbf0" id="bbf0" class="graf graf--p graf-after--pre">Based on the diagram, now we have 2 pointers (i.e. 2 addresses) in the <code class="markup--code markup--p-code">ARGV</code> argument. Because 1 pointer takes 4 bytes, the offset between the <code class="markup--code markup--p-code">ARGV</code> and <code class="markup--code markup--p-code">ENVP</code> will be 8 bytes (i.e. <code class="markup--code markup--p-code">2*4 = 8 bytes</code>). Therefore, the <code class="markup--code markup--p-code">ENVP</code> should be</p><pre name="e93f" id="e93f" class="graf graf--pre graf-after--p">ENVP == ARGV + 8</pre><p name="3d1f" id="3d1f" class="graf graf--p graf-after--pre">We can define them in <code class="markup--code markup--p-code">shellcode.S</code> by,</p><pre name="5432" id="5432" class="graf graf--pre graf-after--p">#define ARGV    (STRLEN2+1)<br>#define ENVP    (ARGV+8)</pre><p name="deb9" id="deb9" class="graf graf--p graf-after--pre">Finally, we initially set up <code class="markup--code markup--p-code">argv[0]</code> pointer to pathname <code class="markup--code markup--p-code">/bin/cat</code>, we should also set the <code class="markup--code markup--p-code">argv[1]</code> pointer our argument <code class="markup--code markup--p-code">/proc/flag</code>. This requires us to get the address of the string <code class="markup--code markup--p-code">/proc/flag</code> and then assign the address to <code class="markup--code markup--p-code">argv[1]</code>. As we have discussed, the <code class="markup--code markup--p-code">argv[1]</code> starts at <code class="markup--code markup--p-code">esi+ARGV+4</code> , so we can achieve it by,</p><pre name="ced0" id="ced0" class="graf graf--pre graf-after--p">[e<code class="markup--code markup--pre-code">si+ARGV+0x4</code>]</pre><p name="6eab" id="6eab" class="graf graf--p graf-after--pre">Also, the starting address of string <code class="markup--code markup--p-code">/proc/flag</code> will be <code class="markup--code markup--p-code">esi+9</code> because the length of <code class="markup--code markup--p-code">/bin/cat</code> is 8, and we have to add one more byte for the null character. So the simplest logic will be,</p><pre name="48e8" id="48e8" class="graf graf--pre graf-after--p">mov    [????],????</pre><p name="b813" id="b813" class="graf graf--p graf-after--pre">However, this instruction will not work. Even though we can find the address by <code class="markup--code markup--p-code">[ARGV+esi+0x4]</code> , we can not directly use <code class="markup--code markup--p-code">esi+0x9</code> in a <code class="markup--code markup--p-code">mov</code> instruction. Here, we have an <code class="markup--code markup--p-code">add</code> logic and we can only have one logic per instruction. To conduct this add logic without changing the value of <code class="markup--code markup--p-code">esi</code>, we can use the following instructions,</p><pre name="c9dd" id="c9dd" class="graf graf--pre graf-after--p">????<br>????</pre><p name="ee98" id="ee98" class="graf graf--p graf-after--pre">After that, the value in <code class="markup--code markup--p-code">eax</code> will be exactly the same as <code class="markup--code markup--p-code">esi+????</code>,</p><pre name="93d0" id="93d0" class="graf graf--pre graf-after--p">eax == esi+????</pre><p name="52ef" id="52ef" class="graf graf--p graf-after--pre">Finally, we can run the following instruction to assign the pointer for <code class="markup--code markup--p-code">/proc/flag</code>,</p><pre name="1ae2" id="1ae2" class="graf graf--pre graf-after--p">????</pre><p name="0211" id="0211" class="graf graf--p graf-after--pre">After modifying the <code class="markup--code markup--p-code">shellcode.S</code>, we need to recompile the code and execute it again by,</p><pre name="74a0" id="74a0" class="graf graf--pre graf-after--p">$ make<br>$ make test</pre><p name="4833" id="4833" class="graf graf--p graf-after--pre">Or we can directly run,</p><pre name="4cb9" id="4cb9" class="graf graf--pre graf-after--p">$ make<br>$ cat shellcode.bin | ~/tuts/lab02/tut02-shellcode/target</pre><p name="a57e" id="a57e" class="graf graf--p graf-after--pre graf--trailing">If everything has been okay so far, we are expected to get the flag!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/f44fb2d83f44"><time class="dt-published" datetime="2021-05-14T16:46:04.109Z">May 14, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/information-security-lab-6-shellcode-f44fb2d83f44" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>