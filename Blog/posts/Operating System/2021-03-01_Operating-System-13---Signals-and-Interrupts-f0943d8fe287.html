<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 13 | Signals and Interrupts</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 13 | Signals and Interrupts</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="6658" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0095" id="0095" class="graf graf--h3 graf--leading graf--title">Operating System 13 | Signals and Interrupts</h3><figure name="3d2c" id="3d2c" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*MYnsp9QQ1bPd8rdt.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*MYnsp9QQ1bPd8rdt.png"></figure><ol class="postList"><li name="b2eb" id="b2eb" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Introduction to the Signal and Interrupts</strong></li></ol><p name="5333" id="5333" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of the Interrupts</strong></p><p name="7180" id="7180" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Interrupts </strong>are events that are<strong class="markup--strong markup--p-strong"> generated externally to the CPU</strong> by components that are other than the CPU where the interrupt is delivered (i.e. I/O devices (i.e. network packet arrivals), timers (i.e. for time out), other CPUs (i.e. for context switch), etc.).</p><p name="0c4f" id="0c4f" class="graf graf--p graf-after--p">Particular interrupts can occur on a given <strong class="markup--strong markup--p-strong">platform</strong> depends on the specific configuration of the platform. So the <strong class="markup--strong markup--p-strong">hardware architecture</strong> and the type of devices can determine the signals.</p><p name="2572" id="2572" class="graf graf--p graf-after--p">Another important characteristic about interrupts is they appear <strong class="markup--strong markup--p-strong">asynchronously</strong>. That’s to say that they’re <strong class="markup--strong markup--p-strong">not in direct response</strong> to some specific action that is taking place on the CPU.</p><p name="1cc5" id="1cc5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of the Signals</strong></p><p name="83da" id="83da" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Signals</strong> are events that are triggered basically by the <strong class="markup--strong markup--p-strong">software</strong> that’s running on the CPU. The signals are either <strong class="markup--strong markup--p-strong">generated by software</strong>, sort of like software interrupt, or the<strong class="markup--strong markup--p-strong"> CPU hardware itself triggers</strong> certain events that are basically interpreted as signals.</p><p name="817d" id="817d" class="graf graf--p graf-after--p">Signals that can occur on a given platform depend very much on the <strong class="markup--strong markup--p-strong">operating system</strong> of this platform. So two identical platforms will have the same interrupts, but if they are running different operating systems they will have different signals.</p><p name="97c3" id="97c3" class="graf graf--p graf-after--p">Unlike hardware interrupts, signals can appear<strong class="markup--strong markup--p-strong"> both synchronously and asynchronously</strong>. By synchronous here we mean that they occur in response to a specific action that took place on the CPU, and in response to that action, a synchronous signal is generated. For instance, if a process is trying to touch a memory that has not been allocated to it, then this will result in a synchronous signal.</p><p name="8008" id="8008" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Similarities between Interrupts and Signals</strong></p><p name="bc0c" id="bc0c" class="graf graf--p graf-after--p">There are some aspects of interrupts and signals that are similar,</p><ul class="postList"><li name="5337" id="5337" class="graf graf--li graf-after--p">both of them have a <strong class="markup--strong markup--li-strong">unique ID</strong> depending on hardware or OS</li><li name="2bd4" id="2bd4" class="graf graf--li graf-after--li">both of them can be <strong class="markup--strong markup--li-strong">masked</strong>. We use either a per-CPU mask for the interrupts or a per-process mask for the signals. The interrupt mask is associated with a <strong class="markup--strong markup--li-strong">CPU</strong> because interrupts are delivered to the CPU as a whole. Whereas, the signal mask is associated with a <strong class="markup--strong markup--li-strong">process</strong> because signals are delivered to individual processes.</li><li name="94fe" id="94fe" class="graf graf--li graf-after--li">If the mask indicates that the signal or the interrupt is enabled, then that will result in invoking the <strong class="markup--strong markup--li-strong">corresponding handler</strong>. Interrupt handlers are specified <strong class="markup--strong markup--li-strong">for the entire system </strong>by the OS, but signal handlers are specified <strong class="markup--strong markup--li-strong">per process </strong>by the process.</li></ul><p name="57db" id="57db" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Interrupts and Signals Metaphor</strong></p><p name="d402" id="d402" class="graf graf--p graf-after--p">Now, suppose we receive two warnings on our mobile phone. The first one is a <strong class="markup--strong markup--p-strong">snowstorm</strong> warning, and the second is a <strong class="markup--strong markup--p-strong">low-battery</strong> warning. Because the snowstorm is external to the mobile phone (processor) and it depends on the location (hardware architecture), it can be seen as an <strong class="markup--strong markup--p-strong">interrupt</strong>. And because the low battery warning is raised by the operating system of the mobile phone, it can be seen as a <strong class="markup--strong markup--p-strong">signal</strong>.</p><figure name="8911" id="8911" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Rtwfv3yq6ycfmplSO4pHGw.png" data-width="1276" data-height="698" src="https://cdn-images-1.medium.com/max/800/1*Rtwfv3yq6ycfmplSO4pHGw.png"></figure><p name="d249" id="d249" class="graf graf--p graf-after--figure">First, each of these types of warnings needs to be handled in specific ways, which is correspond to the concepts of <strong class="markup--strong markup--p-strong">interrupt handlers</strong> and <strong class="markup--strong markup--p-strong">signal handlers.</strong> Second, both of them can be ignored, and this matches the concept of the <strong class="markup--strong markup--p-strong">interrupt mask</strong> and the <strong class="markup--strong markup--p-strong">signal mask</strong>. And last, we can think about both of them as being expected (<strong class="markup--strong markup--p-strong">synchronously</strong>) or unexpected (<strong class="markup--strong markup--p-strong">asynchronously</strong>).</p><p name="bddb" id="bddb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Interrupt and Signal Handling</strong></p><p name="9852" id="9852" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Interrupt Handling</strong></p><p name="1886" id="1886" class="graf graf--p graf-after--p">The device interrupts the CPU via the wires that connect it with a unique message with the <strong class="markup--strong markup--p-strong">interrupt ID</strong> INT-# (i.e. like INT-1, INT-2, …) (INT means interrupt), and this message is called the <strong class="markup--strong markup--p-strong">message signal interrupter (MSI</strong>).</p><p name="5d70" id="5d70" class="graf graf--p graf-after--p">The MSI is then looked up in a table called <strong class="markup--strong markup--p-strong">interrupt handler table (IHT)</strong> and the corresponding handler is called. The PC is moved to that address of the handler code and the handler routine is then executed.</p><figure name="a3ab" id="a3ab" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ncef_-HlWLcPOtCtkHBlIA.png" data-width="1494" data-height="552" src="https://cdn-images-1.medium.com/max/800/1*ncef_-HlWLcPOtCtkHBlIA.png"></figure><p name="a94a" id="a94a" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(2) Signal Handling</strong></p><p name="4d54" id="4d54" class="graf graf--p graf-after--p">For handling a signal, the OS defines the possible signals, e.g. SIGNAL-11, instead of the hardware. Similarly, a <strong class="markup--strong markup--p-strong">signal handler table (SHT)</strong> is used to map the OS defines the possible signals to the hander’s starter address.</p><figure name="1029" id="1029" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*gIYqTbp5Wtygb8w6tliu8Q.png" data-width="1494" data-height="658" src="https://cdn-images-1.medium.com/max/800/1*gIYqTbp5Wtygb8w6tliu8Q.png"></figure><p name="b820" id="b820" class="graf graf--p graf-after--figure">There are default actions defined by the <strong class="markup--strong markup--p-strong">OS</strong> in response to these signals including,</p><ul class="postList"><li name="46bd" id="46bd" class="graf graf--li graf-after--p">terminate: terminate the process</li><li name="9c9a" id="9c9a" class="graf graf--li graf-after--li">ignore: ignore the signal</li><li name="4c44" id="4c44" class="graf graf--li graf-after--li">terminate and core dump: so that one can inspect the core dump</li><li name="15db" id="15db" class="graf graf--li graf-after--li">stop or continue</li></ul><p name="c7cc" id="c7cc" class="graf graf--p graf-after--li">for most of the common OS, each <strong class="markup--strong markup--p-strong">process</strong> can have its own customed signal handlers which respond in a user-defined way in response to the OS signal by the <code class="markup--code markup--p-code">signal()</code> call and the <code class="markup--code markup--p-code">sigaction()</code> call. However, there are also some signals that can not be “caught” by the process (i.e. some signals will always kill the process).</p><p name="3050" id="3050" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Examples of Synchronous Signals and Asynchronous Signals</strong></p><p name="87b5" id="87b5" class="graf graf--p graf-after--p">a. Synchronous Signals</p><ul class="postList"><li name="d203" id="d203" class="graf graf--li graf-after--p">SIGSEGV: attempt to access the illegal/protected memory</li><li name="e86c" id="e86c" class="graf graf--li graf-after--li">SIGFPE: divide by zero</li><li name="0e99" id="0e99" class="graf graf--li graf-after--li">SIGKILL(kill, id): direct to another thread</li></ul><p name="e1c5" id="e1c5" class="graf graf--p graf-after--li">b. Asynchronous Signals</p><ul class="postList"><li name="b55c" id="b55c" class="graf graf--li graf-after--p">SIGKILL(kill): cause a process to terminate</li><li name="c7d3" id="c7d3" class="graf graf--li graf-after--li">SIGALARM: timer expiring (timeout) issue</li></ul><p name="5160" id="5160" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">3. Interrupt and Signal Masks</strong></p><p name="9c0b" id="9c0b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Interrupt/Signal Deadlock Issue</strong></p><p name="4c64" id="4c64" class="graf graf--p graf-after--p">If the interrupted thread has a locked mutex, and the handler also needs to acquire the same mutex, then a <strong class="markup--strong markup--p-strong">deadlock</strong> will occur. This issue is caused because of the interrupts and signals executed in the context of the thread that was interrupted.</p><p name="df54" id="df54" class="graf graf--p graf-after--p">This can be remedied by the thread first disabling the ability to be interrupted before it acquires the mutex. Likewise, it enables the ability to be interrupted after it releases the mutex.</p><p name="2b58" id="2b58" class="graf graf--p graf-after--p">One possible way to deal with this issue is to <strong class="markup--strong markup--p-strong">keep the handler code simple</strong> by removing its lock for the mutex. If there’s no possibility for the handler code to block some mutex operations, then the deadlock will not occur. The problem with this method is that it can be <strong class="markup--strong markup--p-strong">too restrictive</strong>. Thus, we will use masks to ignore the interrupts/signals.</p><p name="d4c8" id="d4c8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Masks</strong></p><p name="cbab" id="cbab" class="graf graf--p graf-after--p">The masks allow us to dynamically enable or disable based on whether the handling code can interrupt the executing mutex. These masks are called <strong class="markup--strong markup--p-strong">interrupt masks </strong>or <strong class="markup--strong markup--p-strong">signal masks</strong>.</p><p name="f9d6" id="f9d6" class="graf graf--p graf-after--p">The mask is a sequence of bits where each bit corresponds to a specific interrupt or signal in the value of 0 (means disable) or 1 (means enable) that indicates whether the specific interrupt will be disabled or enabled.</p><p name="2ea9" id="2ea9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Disable Interrupts and Signals by Masks</strong></p><p name="da01" id="da01" class="graf graf--p graf-after--p">Now, let’s see an example of how the masks work. At some point of the execution, an interrupt occurs. As a result, the PC will change and it will start to point to the first instruction in the handler. The stack pointer will remain the same. And this can be <strong class="markup--strong markup--p-strong">nested</strong> if there are multiple singles/interrupts.</p><p name="c8aa" id="c8aa" class="graf graf--p graf-after--p">In a nested fashion, they will keep executing on the stack of the thread which was interrupted. The handling routine needs to access some state perhaps some other thread is accessing, so we need to use the mutex. However, if the thread that was interrupted already has the mutex that was needed by the handler routine, we have a <strong class="markup--strong markup--p-strong">deadlock </strong>situation.</p><p name="785f" id="785f" class="graf graf--p graf-after--p">When an event occurs, first the mask is checked. If the event is enabled, then we proceed with the handler procedure. If the event is disabled, then the interrupt/signal will remain suspended until a later time when the mask value changes.</p><p name="ba0a" id="ba0a" class="graf graf--p graf-after--p">To solve the deadlock situation, the thread before acquiring a mutex disables the interrupt. So even when the interrupt occurs, it will be disabled and not interrupt the execution of the critical section. If the mask indicates the interruption is disabled, then it will remain <strong class="markup--strong markup--p-strong">pending</strong> until a later time.</p><p name="4e20" id="4e20" class="graf graf--p graf-after--p">After the mutex is unlocked, the mask value is <strong class="markup--strong markup--p-strong">reset to its proper value</strong>. As a result, the interrupt will become enabled. The operation will allow the execution of the handler code. Now at this time, it is ok to execute this code since we are no longer holding the mutex. The deadlock is avoided.</p><p name="778a" id="778a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Basis for Interrupts and Signals</strong></p><p name="f531" id="f531" class="graf graf--p graf-after--p">Interrupt masks are maintained on a <strong class="markup--strong markup--p-strong">per CPU basis</strong>. What this means is that if the interrupt mask disables a particular interrupt, the hardware support for routing interrupt will just <strong class="markup--strong markup--p-strong">not deliver that interrupt to the CPU</strong>.</p><p name="6dfd" id="6dfd" class="graf graf--p graf-after--p">The signal masks are <strong class="markup--strong markup--p-strong">per execution context</strong>. If a signal mask is disabled, the kernel sees that, and in that case, it will not interrupt the corresponding thread. It will <strong class="markup--strong markup--p-strong">not interrupt the execution context</strong>.</p><p name="af77" id="af77" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. More Topics About Interrupts and Signals</strong></p><p name="aa99" id="aa99" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Interrupts and Performance for Multiple CPUs</strong></p><p name="7839" id="7839" class="graf graf--p graf-after--p">We can specify that <strong class="markup--strong markup--p-strong">only one </strong>of the CPUs/cores is designated for handling interrupts. That will be the only CPU that has interrupts enabled, so we will be able to avoid any of the overheads or perturbations related to interrupt handling from any of the other cores. The result will be improved performance. Therefore, the conclusion is that <strong class="markup--strong markup--p-strong">instead of all CPUs receiving an interrupt, let only one CPU receive it</strong>.</p><p name="38db" id="38db" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Types of Signals</strong></p><p name="b598" id="b598" class="graf graf--p graf-after--p">Generally, there are <strong class="markup--strong markup--p-strong">two types of signals</strong>.</p><ul class="postList"><li name="1f57" id="1f57" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">One-shot signal (overwrite behavior)</strong></li></ul><p name="53d8" id="53d8" class="graf graf--p graf-after--li">If there are multiple instances of the same signal that occur, they will be handled <strong class="markup--strong markup--p-strong">at least once</strong>. So the situation with N same signals pending is equivalent to the situation with only one of that signal pending.</p><p name="d933" id="d933" class="graf graf--p graf-after--p">The other thing about one-shot signals is that the handling routine must be <strong class="markup--strong markup--p-strong">re-enabled every single time</strong>. So if the process wants to install some custom handler for that signal, then invoking the operation will mean once when the signal occurs, the process handler for that signal will be <strong class="markup--strong markup--p-strong">invoked</strong>. However, any future instances of that signal will be handled by the default operating system action. Or if the operating system decides to ignore that set of signals, then they will be lost.</p><p name="adea" id="adea" class="graf graf--p graf-after--p">Thus, if a one-shot signal is not re-enabled, the next time the particular signal comes, it will be handled by the default OS handler or ignore the signal instead of the specific handler for that process.</p><ul class="postList"><li name="532b" id="532b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Real-Time Signals (queue behavior)</strong></li></ul><p name="63ce" id="63ce" class="graf graf--p graf-after--li">Real-time signals that are supported in an OS like Linux. And their behavior is that if a signal is called <em class="markup--em markup--p-em">n </em>times, then the handler is guaranteed to be called <em class="markup--em markup--p-em">n</em> times as well. So, they have sort of a <strong class="markup--strong markup--p-strong">queueing behavior</strong> as opposed to an <strong class="markup--strong markup--p-strong">overwriting behavior</strong>, as is the case with the one-shot signals.</p><p name="05f4" id="05f4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) POSIX Standard Signal Names Example</strong></p><p name="37e3" id="37e3" class="graf graf--p graf-after--p">We have talked about the signals and now let’s look at the POSIX standard (POSIX.1-2008) for the signal names of different events. The POSIX standard library documentation can be found <a href="https://pubs.opengroup.org/onlinepubs/9699919799/" data-href="https://pubs.opengroup.org/onlinepubs/9699919799/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>, and you need to search for the <code class="markup--code markup--p-code">signal.h</code> file which controls the signals.</p><p name="0d2a" id="0d2a" class="graf graf--p graf-after--p">From the page of <code class="markup--code markup--p-code">signal.h</code> , we can find a list of signal names are provided with their descriptions.</p><figure name="4e43" id="4e43" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*H5e3Rj0YaomJ_3fJV70G7A.png" data-width="1333" data-height="726" src="https://cdn-images-1.medium.com/max/800/1*H5e3Rj0YaomJ_3fJV70G7A.png"></figure><p name="acb3" id="acb3" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">5. Interrupts and Threads</strong></p><p name="247a" id="247a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Handling Interrupts as Threads</strong></p><p name="ef5b" id="ef5b" class="graf graf--p graf-after--p">Now let’s look at the relationship between interrupts and threads. In the previous example, when an interrupt/signal occurs there is a possibility of deadlock.</p><figure name="b9e8" id="b9e8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*UnkvvBIssZRqJJIT-VX75w.png" data-width="1584" data-height="486" src="https://cdn-images-1.medium.com/max/800/1*UnkvvBIssZRqJJIT-VX75w.png"></figure><p name="b2b3" id="b2b3" class="graf graf--p graf-after--figure">One way as illustrated in the <strong class="markup--strong markup--p-strong">Sun OS paper </strong>is to allow interrupts to become <strong class="markup--strong markup--p-strong">full-fledged threads</strong> (aka. complete threads), and this should happen every time it is performing blocking operations. In this case, the interrupt handler is blocked at this point. It has its own context, stack, thus it can remain blocked.</p><figure name="9a21" id="9a21" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*4gpwd7iNWfIZPFRyS6OLNw.png" data-width="1740" data-height="674" src="https://cdn-images-1.medium.com/max/800/1*4gpwd7iNWfIZPFRyS6OLNw.png"></figure><p name="a15d" id="a15d" class="graf graf--p graf-after--figure">However, there is a problem with this operation because creating dynamic thread creation is quite <strong class="markup--strong markup--p-strong">expensive</strong>. So we can not simply turn interrupts to threads all the time with respect to the performance. The rule of whether or not creating a dynamic thread described in Sun OS paper is that,</p><ul class="postList"><li name="2c6f" id="2c6f" class="graf graf--li graf-after--p">if the <strong class="markup--strong markup--li-strong">handler does not include a lock</strong>, then <strong class="markup--strong markup--li-strong">no dynamic thread</strong> will be created</li><li name="28fe" id="28fe" class="graf graf--li graf-after--li">if there is a possibility for the thread to be blocked, then we turn it into a real thread</li></ul><p name="f81f" id="f81f" class="graf graf--p graf-after--li">To limit the need to dynamically create a thread whenever there is a potential to block the thread, the kernel can <strong class="markup--strong markup--p-strong">pre-create and pre-initialize</strong> a number of threads (i.e. 2 threads) for the variable interrupt routine. As a result, the creation of a thread from the fast path of the interrupt processing and we don’t pay the cost when the interrupt occurs.</p><p name="64fa" id="64fa" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Top Half &amp; Bottom Half Technique</strong></p><p name="258e" id="258e" class="graf graf--p graf-after--p">We intentionally chose the words <strong class="markup--strong markup--p-strong">top</strong> and <strong class="markup--strong markup--p-strong">bottom</strong> to describe what’s happening for a situation with handling interrupts as threads because this is exactly the description of how Solaris uses threads to handle interrupts. If we use the top&amp;bottom-half technique, we don’t have to worry about the deadlocks anymore because the interrupt is executed in a separate thread.</p><p name="ba5a" id="ba5a" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">top half</strong> will,</p><ul class="postList"><li name="b3a4" id="b3a4" class="graf graf--li graf-after--p">handle a <strong class="markup--strong markup--li-strong">minimum amount of processing</strong></li><li name="272b" id="272b" class="graf graf--li graf-after--li">be required to be <strong class="markup--strong markup--li-strong">non-blocking</strong></li><li name="ed27" id="ed27" class="graf graf--li graf-after--li">execute <strong class="markup--strong markup--li-strong">immediately</strong> when the interrupt occurs</li></ul><p name="b0af" id="b0af" class="graf graf--p graf-after--li">The <strong class="markup--strong markup--p-strong">bottom half</strong> is allowed to,</p><ul class="postList"><li name="5b8b" id="5b8b" class="graf graf--li graf-after--p">have any <strong class="markup--strong markup--li-strong">arbitrary/complex processing</strong></li><li name="dabd" id="dabd" class="graf graf--li graf-after--li">like any other thread, be <strong class="markup--strong markup--li-strong">scheduled for a later time</strong></li><li name="ad16" id="ad16" class="graf graf--li graf-after--li">be <strong class="markup--strong markup--li-strong">blocked</strong></li></ul><figure name="a5c7" id="a5c7" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*QosHHehb1Qa88pG0hc4Dgg.png" data-width="1694" data-height="878" src="https://cdn-images-1.medium.com/max/800/1*QosHHehb1Qa88pG0hc4Dgg.png"></figure><p name="262d" id="262d" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) Performance of Handling Interrupts as Threads</strong></p><p name="3a20" id="3a20" class="graf graf--p graf-after--p">The behavior of using threads to handle interrupts is really motivated by performance. It is best to handle interrupts by using threads instead of doing the mask/unmask/check mutex/etc.</p><p name="5d40" id="5d40" class="graf graf--p graf-after--p">The operations that are necessary to perform the appropriate checks of whether to use a thread for handling an interrupt add about 40 SPARC instructions per interrupt. Without changing the interrupt masks whenever a mutex is locked and then switch it back again, we can save about 12 instructions per mutex.</p><p name="d049" id="d049" class="graf graf--p graf-after--p">Because the number of the mutex lock/unlock operations is much more than the number of the interrupts, <strong class="markup--strong markup--p-strong">we can expect that we end up saving much more instructions on the mutex than the cost on interrupts</strong>. This brings to an important conclusion in the system design: optimize for the common case.</p><p name="889d" id="889d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Different UL and KL Masks Issue</strong></p><p name="d082" id="d082" class="graf graf--p graf-after--p">Signal masks are associated with the ULT and the KLT (or attached LWP). When ULT wants to disable an interrupt/signal, it changes the bit in the ULT mask to 0. However, the ULT mask is not visible to the kernel (and vice versa), so that the kernel mask will remain the same. If the kernel visible signal mask is enabled (bit set to 1), it wants to respond to the signal.</p><figure name="dae7" id="dae7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*DBqKRtuuNG3PYn18KQrEPg.png" data-width="1694" data-height="570" src="https://cdn-images-1.medium.com/max/800/1*DBqKRtuuNG3PYn18KQrEPg.png"></figure><p name="45c1" id="45c1" class="graf graf--p graf-after--figure">So either we need a <strong class="markup--strong markup--p-strong">method</strong> to cross the user/kernel barrier and set the kernel mask in this case to 0 (since UL mask is 0), or we need to have a <strong class="markup--strong markup--p-strong">policy</strong> that deals with the situation where the user level and KL masks are different.<strong class="markup--strong markup--p-strong"> </strong>In fact, the SunOS paper describes the <strong class="markup--strong markup--p-strong">lightweight user-level threading library (LWULTlib)</strong> that proposes a solution to how to handle this situation.</p><p name="4499" id="4499" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Different UL and KL Masks Case1: 2 ULTs with 1 KLT</strong></p><p name="c71a" id="c71a" class="graf graf--p graf-after--p">Suppose we have two ULTs, ULT1 and ULT2, and the ULT1 is currently running on the single KLT. The ULT2 is runnable but it is currently pending in the run queue. Because the KLT has a mask of 1, it will then see that the process overall knows how to handle the signal/interrupt. However, the ULT1 has a mask of 0 and this means a signal/interrupt disabled for this ULT. We should figure out a way on how to get to the LWULTlib because it knows that the ULT2 would be able to handle a signal/interrupt.</p><figure name="2718" id="2718" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*nJDUZBDeNpavZgAOWnpcqg.png" data-width="1694" data-height="570" src="https://cdn-images-1.medium.com/max/800/1*nJDUZBDeNpavZgAOWnpcqg.png"></figure><p name="2e05" id="2e05" class="graf graf--p graf-after--figure">There exists a library handling routine that serves as a wrapper class for the signal handlers. When a signal occurs, the KLT runs the wrapper routine. The wrapper routine has access to all the threads running in the process so it will see that ULT2 has the mask enabled and will then switch ULT2 to be running on KLT.</p><p name="1e3e" id="1e3e" class="graf graf--p graf-after--p">Recall the way signals are handled. When the signal interrupts the process or a thread that is running in the process, the corresponding <strong class="markup--strong markup--p-strong">handling routine </strong>(aka. the handling code segment) needs to be executed is specified in the <strong class="markup--strong markup--p-strong">signal handler table (SHT)</strong> by the starter addresses of these routines.</p><p name="8994" id="8994" class="graf graf--p graf-after--p">Thus, for all the signals in the system, we can have a special library routine that will wrap the <strong class="markup--strong markup--p-strong">signal handling routine</strong>. So when the signal occurs, we start to execute the handler provided by ULTlib which can see all the masks of the ULTs. Then the LWULTlib will be able to detect the situation that the currently ULT can not handle the schedule, but there’s another runnable user-level thread that can handle the signal. The library handling routine will then call the library scheduler and it can now make the ULT2 running on the KLT so that the signals can be handled.</p><figure name="a979" id="a979" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3IcAJeMmRv1ZaqaMWUGrJw.png" data-width="1722" data-height="570" src="https://cdn-images-1.medium.com/max/800/1*3IcAJeMmRv1ZaqaMWUGrJw.png"></figure><p name="bf7d" id="bf7d" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) Different UL and KL Masks Case 2: 2 ULTs with 2 KLTs (with enabled)</strong></p><p name="180a" id="180a" class="graf graf--p graf-after--p">Here, in this case, we have 2 ULTS, ULT1 and ULT2. The ULT1 is currently running on the KLT1 pinned to the CPU1, and the ULT2 is currently running on the KLT2 pinned to the CPU2. Let’s suppose that the mask for the ULT1 is set to 0 at the beginning and this means that it has <strong class="markup--strong markup--p-strong">signal disabled</strong>. However, the masks for the other threads (including ULT2, KLT1, KLT2) are all set to bit 1, and this means the signal is enabled.</p><p name="9bc5" id="9bc5" class="graf graf--p graf-after--p">So when the signal is delivered in the context of the KLT1, the library handling routine will kick in and it knows that there is a ULT2 that can handle this particular signal, but this ULT is associated with another KLT (KLT2). Then the library will generate a directed signal to the KLT2 where the ULT2 is currently executing.</p><p name="bd0a" id="bd0a" class="graf graf--p graf-after--p">After the OS sends this signal to the KLT2, it will again call the library handling routine and handle the signal because ULT2 is enabled for signals.</p><figure name="54e9" id="54e9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5vwRs6xNZgSVj6MxnfWvvg.png" data-width="1722" data-height="570" src="https://cdn-images-1.medium.com/max/800/1*5vwRs6xNZgSVj6MxnfWvvg.png"></figure><p name="9465" id="9465" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(7) Different UL and KL Masks Case 3: 2 ULTs with 2 KLTs (all ULTs disabled)</strong></p><p name="ec1a" id="ec1a" class="graf graf--p graf-after--p">We have one case left for us, and you may be curious about what will happen if we have all the ULTs disabled with their masks all set to 0s. However, the KLT masks are still the bit 1, and they still think that the process can handle this particular signal.</p><p name="0626" id="0626" class="graf graf--p graf-after--p">So when a single is sent to KLT1, it goes up and calls the library handling routine as normal because it thinks that we can handle this signal. Whereas the library handling routine then sees all the particular threads have the mask 0, so it doesn’t have any ULTs to handle the signal.</p><p name="5f2a" id="5f2a" class="graf graf--p graf-after--p">Then the library will call a system call and set the mask of the KLT1 (the KLT that receives the signal) to 0.</p><figure name="52de" id="52de" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*AC9jCb0q9mmpuJ9h4yFKPQ.png" data-width="1722" data-height="608" src="https://cdn-images-1.medium.com/max/800/1*AC9jCb0q9mmpuJ9h4yFKPQ.png"></figure><p name="c4d4" id="c4d4" class="graf graf--p graf-after--figure">The library does not stop at this point. Instead, it will continue updating all the masks of the KLTs until all of them become 0s so that all the KLTs will know that they can neglect the future signals. Thus, the library will <strong class="markup--strong markup--p-strong">re-issue the signal</strong> for the other processes and then they will execute the same process and thus all the masks will be updated to 0s.</p><figure name="ed62" id="ed62" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kHEFgsB5XSgW6y3cfM5hGg.png" data-width="1722" data-height="578" src="https://cdn-images-1.medium.com/max/800/1*kHEFgsB5XSgW6y3cfM5hGg.png"></figure><p name="8d13" id="8d13" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(8) Different UL and KL Masks Case 4: 2 ULTs with 2 KLTs (all KLTs disabled)</strong></p><p name="a65a" id="a65a" class="graf graf--p graf-after--p">Let’s continue with the last case. Let’s say that in the last example, we have a final state that all the masks are set to 0, and all the threads are signal disabled. At this moment, there is a possibility that one of the ULTs (let’s say ULT2) finishes whatever they were doing and enables the signal by setting its mask to bit 1 again.</p><figure name="9d7f" id="9d7f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*xnFhAI7sOljSMSRyEoERig.png" data-width="1722" data-height="578" src="https://cdn-images-1.medium.com/max/800/1*xnFhAI7sOljSMSRyEoERig.png"></figure><p name="886e" id="886e" class="graf graf--p graf-after--figure">Because the threading library knows that it has already disabled all of the KL signal masks, it will at that time performs a system call to update one of the signal masks. So that the mask of the KLT2 can now properly reflects the state of the ULT and now it can start to handle the signals.</p><figure name="7698" id="7698" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IiSpD0Z-cwvzVJkJ3O93HA.png" data-width="1722" data-height="578" src="https://cdn-images-1.medium.com/max/800/1*IiSpD0Z-cwvzVJkJ3O93HA.png"></figure><p name="ca92" id="ca92" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(9) Performance of Handling UL and KL Masks</strong></p><p name="2b56" id="2b56" class="graf graf--p graf-after--p">The actual signals can be rare to happen compares to the need of updating the signal masks. So the updates for signal masks are the common case for performance improvement. This is because whenever we would have a certain critical portion of the code, we would first disable the signal and then enable the signal. However, in most of these cases, the signal doesn&#39;t really occur.</p><p name="c5c1" id="c5c1" class="graf graf--p graf-after--p">In order to make the common case cheap, we just apply the updates of the signal mask for the UL signal masks, and actually, the system call for updating the KL signal masks tends to be avoided. With respect to that, we have to make the actual signal handling a little bit more complex than what we have discussed.</p><p name="91ff" id="91ff" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">6. Linux Supporting For Multithreading</strong></p><p name="2157" id="2157" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Task</strong></p><p name="197d" id="197d" class="graf graf--p graf-after--p">Like all OSes, Linux has an abstraction to represent the processes. And the main abstraction it uses to abstract the main execution context is called the task. And this abstraction is represented via a structure called <code class="markup--code markup--p-code">task_struct</code>. A task is exactly the <strong class="markup--strong markup--p-strong">execution context of a KLT</strong>. It is also direct to know that a single-threaded process has only 1 task, while a multi-threaded process can have many tasks.</p><p name="0950" id="0950" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Source Code of </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">task_struct</strong></code></p><p name="1e1f" id="1e1f" class="graf graf--p graf-after--p">Our following discussion is based on the Linux kernel v3.17 and you can find the <code class="markup--code markup--p-code">task_struct</code> source code from the file <code class="markup--code markup--p-code">sched.h</code> at <a href="https://elixir.bootlin.com/linux/v3.7/source/include/linux/sched.h#L1190" data-href="https://elixir.bootlin.com/linux/v3.7/source/include/linux/sched.h#L1190" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a> (from line 1190 to line 1551). A brief version of this structure is as follows,</p><pre name="ebbe" id="ebbe" class="graf graf--pre graf-after--p">struct task_struct {<br>    /* some codes ... */<br>    pid_t pid;<br>    pid_t tgid;<br>    int prio;<br>    volatile long;<br>    struct mm_struct *mm;<br>    struct files_struct *files;<br>    struct list_head tasks;<br>    int on_cpu;<br>    cpumask_t cpus_allowed;<br>    /* some other codes ... */<br>}</pre><p name="443f" id="443f" class="graf graf--p graf-after--pre">Each task is identified by a task identifier called <code class="markup--code markup--p-code">pid</code> (or process ID, because of historic reasons although it can be misleading). If we have a single-threaded process, then <code class="markup--code markup--p-code">pid</code> and the actual process ID will be the same. Whereas, if we have a multi-threaded process, then we will have several <code class="markup--code markup--p-code">pid</code>s for this process for these tasks. The <code class="markup--code markup--p-code">tgid</code> (group ID) is actually the very first <code class="markup--code markup--p-code">pid</code> that we have created for this process and it is the same as the actual process ID.</p><p name="a461" id="a461" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">task_struct</code> also contains a data structure of listed tasks by <code class="markup--code markup--p-code">tasks</code> , so that we can easily refer to all the tasks of the process.</p><p name="c907" id="c907" class="graf graf--p graf-after--p">Unlike the SunOS, Linux doesn’t have one continuous PCB. Instead, the process state is always represented by references of to data structures like the memory management data structure <code class="markup--code markup--p-code">mm_struct</code> and file management data structure <code class="markup--code markup--p-code">files_struct</code>. This design makes it easy for tasks to share some portions of the address space.</p><p name="edae" id="edae" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Task Creation</strong></p><p name="746e" id="746e" class="graf graf--p graf-after--p">The Linux uses the <code class="markup--code markup--p-code">clone</code> function to create a task and the manual of this function can be found <a href="https://man7.org/linux/man-pages/man2/clone.2.html" data-href="https://man7.org/linux/man-pages/man2/clone.2.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>. An arbitrary synopsis is,</p><pre name="f96c" id="f96c" class="graf graf--pre graf-after--p">clone(function, stack_ptr, <code class="markup--code markup--pre-code">sharing_flags, args</code>)</pre><p name="bf0f" id="bf0f" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">sharing_flags</code> is the most important portion of this function and the flag parameter is used to specify which portion of the state of a task will be shared between a parent and a child task. It has to do with the sharing of parent <code class="markup--code markup--p-code">task_struct</code> info with the child.</p><p name="ee4a" id="ee4a" class="graf graf--p graf-after--p">If flags are <strong class="markup--strong markup--p-strong">set</strong>, then it is like creating a new thread since a new thread <strong class="markup--strong markup--p-strong">shares</strong> the parent’s address space and only has its own stack and registers. When the flags are <strong class="markup--strong markup--p-strong">cleared</strong>, it is like creating a new process since a new process doesn’t share the parent’s information, it <strong class="markup--strong markup--p-strong">copies</strong> them.</p><figure name="e200" id="e200" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ddgX1YQP2iaVtWKczH9ugA.png" data-width="1216" data-height="350" src="https://cdn-images-1.medium.com/max/800/1*ddgX1YQP2iaVtWKczH9ugA.png"></figure><p name="d198" id="d198" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Process Forking in Multi-Threaded Process</strong></p><p name="df76" id="df76" class="graf graf--p graf-after--p">Moreover, for forking a new process in a single threaded process, we actually copy with <strong class="markup--strong markup--p-strong">same address space</strong>. However, if we fork a new process in a multi-threaded process, then the new process will only contain a <strong class="markup--strong markup--p-strong">portion</strong> of the parent’s address space.</p><p name="f70c" id="f70c" class="graf graf--p graf-after--p">This also has lots of discussions, but it is beyond the scope of the present series.</p><p name="50e0" id="50e0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Linux Threading Model</strong></p><p name="59d4" id="59d4" class="graf graf--p graf-after--p">The current implementation of a Linux threading is called <strong class="markup--strong markup--p-strong">Native POSIX Threads Library (NPTL)</strong>. This is a one-to-one (1:1) model, so there will be a KL task for each of the ULTs. Because the NPTL is a 1:1 model, the kernel can see the information of each ULT. So the kernel traps become cheaper (the user to kernel level crossing can be much faster) but we pay a cost more resources. Because modern architectures have more resources to use, so it would not be a problem anymore.</p><p name="a07f" id="a07f" class="graf graf--p graf-after--p graf--trailing">The NPTL implementation actually replace an earlier threading mode called <strong class="markup--strong markup--p-strong">LinuxThreads</strong>, which is a many-to-many model. This design is quite similar to the one that is described in Solaris papers.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/f0943d8fe287"><time class="dt-published" datetime="2021-03-01T10:30:08.824Z">March 1, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-13-signals-and-interrupts-f0943d8fe287" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>