<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 1 | Introduction to Operating System, User/Kernel Protection Boundary</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 1 | Introduction to Operating System, User/Kernel Protection Boundary</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="d7f6" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1d67" id="1d67" class="graf graf--h3 graf--leading graf--title">Operating System 1 | <strong class="markup--strong markup--h3-strong">Introduction to Operating System, User/Kernel Protection Boundary, and Different Types for Operating Systems</strong></h3><figure name="ee3d" id="ee3d" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*Cifa_i0ZavMA_gY8jmVN8w.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Cifa_i0ZavMA_gY8jmVN8w.png"></figure><ol class="postList"><li name="887f" id="887f" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Introduction to Operating System</strong></li></ol><p name="a201" id="a201" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Operating System</strong></p><p name="451d" id="451d" class="graf graf--p graf-after--p">In simplest terms, an operating system is a piece of software <strong class="markup--strong markup--p-strong">abstract</strong> and <strong class="markup--strong markup--p-strong">arbitrates</strong> the underlying hardware system. In this context, <strong class="markup--strong markup--p-strong">abstract</strong> means to simplify what the hardware actually looks like, and <strong class="markup--strong markup--p-strong">arbitrates</strong> means to manage and oversee the controlling of the hardware.</p><p name="f921" id="f921" class="graf graf--p graf-after--p">Note that the <strong class="markup--strong markup--p-strong">cache memory</strong> is not managed by the operating system. Instead, it is managed by the hardware.</p><p name="2232" id="2232" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Three Functions of Operating System</strong></p><ul class="postList"><li name="060d" id="060d" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Direct operational resources</strong>: means to control the use of CPU, memory, peripheral devices and allocate resources to different applications</li><li name="82ce" id="82ce" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Enforces working policies</strong>: means to have fair resource access, and impose certain limits to allocate the maximum amount of a certain resource that a particular application or process can use. For example, the limits like the number of opening files that can be opened per process or some thresholds that need to be passed in order for some memory management daemons to kick in.</li><li name="7f50" id="7f50" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Mitigates difficulty of complex tasks</strong>: it simplifies and abstracts the view of the underlying hardware that’s observed by the applications that are running on that particular platform. In reality, the applications ask for system calls and the OS takes care of how to manage them properly.</li></ul><p name="b31a" id="b31a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Goals for Operating Systems</strong></p><ul class="postList"><li name="bf58" id="bf58" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Privileged Access</strong>: the operating system is a layer of system software that can directly have privileged access to the underlying hardware.</li><li name="6308" id="6308" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Hide hardware complexity</strong>: the operating system hides the complexity of the underlying hardware from the applications and the developers. For example, we don’t have to worry about memory or disk storage when we are using an application. Also, the OS hides the various types of storage devices. So hard disks like SSDs or USB flashes are managed to be abstracted as <strong class="markup--strong markup--li-strong">files</strong> and we can R/W to the files. Meanwhile, for a web server application, when we are responding to the requests, we don’t want to think about the bits and the packages that we need to compose when performing that application. The operating system abstracts the networking resources and these resources are abstracted as <strong class="markup--strong markup--li-strong">sockets </strong>and we can send or receive these sockets.</li><li name="f806" id="f806" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Resource Management</strong>: for example, the OS decides how many and which one of these resources will the application use. For instance, the operating system allocates the memories for these applications, and also it is one that schedules these applications onto the CPU.</li><li name="73e2" id="73e2" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Provide Isolation &amp; Protection</strong>: The operating system must ensure that each application can make adequate progress and they don’t hurt each other. Thus, it will provide isolation and protection. For instance, the operating system will allocate different parts of the physical memories to different applications. It also ensures that each application doesn’t access each other’s memory.</li></ul><p name="ef27" id="ef27" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Operating System Examples</strong></p><p name="0361" id="0361" class="graf graf--p graf-after--p">Now, let’s see some of the operating system examples. We will choose the operating systems for the desktops and the embedded systems because they are quite common nowadays,</p><ul class="postList"><li name="a7ee" id="a7ee" class="graf graf--li graf-after--p">Microsoft Windows</li><li name="13fb" id="13fb" class="graf graf--li graf-after--li">Unix-Based: Mac OSX (BSD), Linux, …</li><li name="5b11" id="5b11" class="graf graf--li graf-after--li">Android</li><li name="9e8d" id="9e8d" class="graf graf--li graf-after--li">iOS</li><li name="d774" id="d774" class="graf graf--li graf-after--li">Symbian</li><li name="68e1" id="68e1" class="graf graf--li graf-after--li">…</li></ul><p name="47ce" id="47ce" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Operating System Elements</strong></p><p name="807a" id="807a" class="graf graf--p graf-after--p">To achieve its goals, the operating system supports a number of higher-level abstractions and a number of key mechanisms that operate on top of these abstractions. The <strong class="markup--strong markup--p-strong">abstractions</strong> include,</p><ul class="postList"><li name="fe6f" id="fe6f" class="graf graf--li graf-after--p">Process</li><li name="7eba" id="7eba" class="graf graf--li graf-after--li">Thread</li><li name="6e23" id="6e23" class="graf graf--li graf-after--li">File</li><li name="64a3" id="64a3" class="graf graf--li graf-after--li">Socket</li><li name="34fd" id="34fd" class="graf graf--li graf-after--li">Memory page</li></ul><p name="7299" id="7299" class="graf graf--p graf-after--li">The <strong class="markup--strong markup--p-strong">mechanisms</strong> include,</p><ul class="postList"><li name="6750" id="6750" class="graf graf--li graf-after--p">Create</li><li name="0bc7" id="0bc7" class="graf graf--li graf-after--li">Schedule</li><li name="1ffb" id="1ffb" class="graf graf--li graf-after--li">Open</li><li name="3814" id="3814" class="graf graf--li graf-after--li">Write</li><li name="92d1" id="92d1" class="graf graf--li graf-after--li">Allocate</li></ul><p name="0b4b" id="0b4b" class="graf graf--p graf-after--li">Operating systems may also integrate specific <strong class="markup--strong markup--p-strong">policies</strong> that determine exactly how these mechanisms will be used to manage standalone hardware. For instance, the policies can control what is the maximum number of sockets that a process can actually have access to. They may also control which data will be removed from physical memory based on some algorithm like the <strong class="markup--strong markup--p-strong">least recently used</strong> (LRU) or <strong class="markup--strong markup--p-strong">earliest deadline first</strong> (EDF).</p><p name="03df" id="03df" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Principles for Designing Operating System</strong></p><p name="3bde" id="3bde" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Principle #1: The separation between mechanisms and policies</strong></p><p name="49fd" id="49fd" class="graf graf--p graf-after--p">This means that we want to incorporate into the operating system a number of flexible mechanisms that can support a range of policies. For memory management, some useful policies include LRU (least recently used), LFU (least frequently used), or completely random. That means that we have to find some mechanisms that are used to track the frequency or the time when the memory locations have been accessed.</p><p name="c5d6" id="c5d6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Principle #2: Optimizing for the common case</strong></p><p name="90f3" id="90f3" class="graf graf--p graf-after--p">Optimizing for the common case means that we need to understand a number of questions like,</p><ul class="postList"><li name="fbd0" id="fbd0" class="graf graf--li graf-after--p">How the operating system will be used?</li><li name="2b4f" id="2b4f" class="graf graf--li graf-after--li">What it will need to provide in order to understand what the common case is?</li><li name="789a" id="789a" class="graf graf--li graf-after--li">Where the operating system will be used?</li><li name="bf82" id="bf82" class="graf graf--li graf-after--li">What kind of machine it will run?</li><li name="3d74" id="3d74" class="graf graf--li graf-after--li">How many processing elements does the machine have?</li><li name="a612" id="a612" class="graf graf--li graf-after--li">How many CPUs?</li><li name="0277" id="0277" class="graf graf--li graf-after--li">What kinds of devices?</li><li name="a621" id="a621" class="graf graf--li graf-after--li">How much memory?</li><li name="ffee" id="ffee" class="graf graf--li graf-after--li">What are the commands the end-user will use on that machine?</li><li name="bc71" id="bc71" class="graf graf--li graf-after--li">What will be the applications being executed on the machine?</li><li name="0487" id="0487" class="graf graf--li graf-after--li">What are the requirements of that workload?</li><li name="631c" id="631c" class="graf graf--li graf-after--li">How does that workload behave?</li><li name="551d" id="551d" class="graf graf--li graf-after--li">etc.</li></ul><p name="6afd" id="6afd" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Operating System Servies</strong></p><p name="1e1e" id="1e1e" class="graf graf--p graf-after--p">The operating system provides many services that can be used to interact with the hardware,</p><ul class="postList"><li name="959c" id="959c" class="graf graf--li graf-after--p">Scheduler: for controlling the access to the CPU</li><li name="aec3" id="aec3" class="graf graf--li graf-after--li">Memory Manager: for allocating the underlying physical memory</li><li name="5b6b" id="5b6b" class="graf graf--li graf-after--li">Block Device Drive: for a block device like a disk</li></ul><p name="33a8" id="33a8" class="graf graf--p graf-after--li">There are also some higher-level services that are linked with higher-level abstractions. For instance,</p><ul class="postList"><li name="ca07" id="ca07" class="graf graf--li graf-after--p">File System</li></ul><p name="d388" id="d388" class="graf graf--p graf-after--li">Some other services are provided to the applications or developers with a number of useful types of functionality. This includes,</p><ul class="postList"><li name="05c9" id="05c9" class="graf graf--li graf-after--p">Process Management</li><li name="244b" id="244b" class="graf graf--li graf-after--li">File Management</li><li name="f910" id="f910" class="graf graf--li graf-after--li">Device Management</li></ul><p name="c2f8" id="c2f8" class="graf graf--p graf-after--li">These services are verified through <strong class="markup--strong markup--p-strong">system calls</strong>.</p><p name="e342" id="e342" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. User/Kernel Protection Boundary</strong></p><p name="6b44" id="6b44" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) User Mode and Kernel Mode</strong></p><p name="3b74" id="3b74" class="graf graf--p graf-after--p">As the definition of the operating system pointed out, the operating system must have the privileges to have direct access to the hardware. Computer hardware distinguished into two modes. The privileged one is called the <strong class="markup--strong markup--p-strong">kernel mode</strong> and the unprivileged one is called the <strong class="markup--strong markup--p-strong">user mode</strong>.</p><p name="bc2c" id="bc2c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) User-kernel Switch</strong></p><p name="c116" id="c116" class="graf graf--p graf-after--p">In order to have direct access to the hardware, the operating system must run in the privileged kernel-level mode. However, the applications should be running on the user mode because of the isolation issues. In practice, most of the modern computers can conduct the <strong class="markup--strong markup--p-strong">user-kernel switch</strong> by the supports from the hardware.</p><p name="8ba4" id="8ba4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) User-kernel Switch Example: Instruction Trap</strong></p><p name="727b" id="727b" class="graf graf--p graf-after--p">A specific example of the user-kernel switch is the instruction trap (and we will talk more about it later). When there’s an attempt from the user mode to perform privileged operations, it’s probable that there will be an <strong class="markup--strong markup--p-strong">instruction trap</strong>. A trap, also known as an exception or a fault, is typically a type of synchronous interrupt caused by an exceptional condition. Then, the applications will be interrupted and then the hardware will switch the control to the operating system at some location. And then the operating system will verify if it should run that access or it should terminate the process to prevent something illegal.</p><p name="7025" id="7025" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) User-kernel Switch Example: System Call Interface</strong></p><p name="c5a8" id="c5a8" class="graf graf--p graf-after--p">In addition to this trap method, the interaction between the applications and the operating system can be conducted via the <strong class="markup--strong markup--p-strong">system call interface</strong>. The operating system exports a system call interface so the application can also call the hardware through the operating system. The most common system calls include <code class="markup--code markup--p-code">open</code> for files, <code class="markup--code markup--p-code">send</code> for sockets, and <code class="markup--code markup--p-code">mmap</code> for memory. Here’s a summary of the commonest system calls for Windows and UNIX,</p><figure name="7d7f" id="7d7f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ijjMeyhmGrXHj26RtlmPEA.png" data-width="1740" data-height="810" src="https://cdn-images-1.medium.com/max/800/1*ijjMeyhmGrXHj26RtlmPEA.png"></figure><p name="01fa" id="01fa" class="graf graf--p graf-after--figure">To understand the process of a system call, let’s see an abstracted <strong class="markup--strong markup--p-strong">workflow</strong> of it,</p><ul class="postList"><li name="c9c5" id="c9c5" class="graf graf--li graf-after--p">Step 1: Let’s start with the user mode (mode code = 1). Because the user application/process needs some hardware access, it then makes a system call.</li><li name="8cc2" id="8cc2" class="graf graf--li graf-after--li">Step 2: To interact with the hardware, we have to now change to the privileged mode (mode code = 0) and then the operating system will perform the operation, and then it will return the result to the process. This process involves changing the execution context from the user to the kernel and also passing arguments whatever necessary for the operating system.</li><li name="619f" id="619f" class="graf graf--li graf-after--li">Step 3: While the system call completes, it will return the result and the control back to the calling process. And this again will involve changing the execution context from the kernel mode (mode code = 0) back to the user mode (mode code = 1), passing any arguments back into the user space, and jumping to exactly the same location where the system call was made from.</li></ul><p name="df55" id="df55" class="graf graf--p graf-after--li">Note that there is also a <strong class="markup--strong markup--p-strong">synchronous mode</strong> that the user process that will wait until the system call completes and we are going to talk about this later.</p><p name="f3bf" id="f3bf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) User-kernel Switch Example: Signals</strong></p><p name="f27c" id="f27c" class="graf graf--p graf-after--p">An operating system also supports <strong class="markup--strong markup--p-strong">signals</strong>, which is a mechanism for the operating system to pass notifications to the applications. We will talk about it later.</p><p name="1684" id="1684" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Cost of User-Kernel Transitions</strong></p><p name="3f55" id="3f55" class="graf graf--p graf-after--p">From the system call workflow above, we can see that the user-kernel transitions are necessary steps during an application execution because applications must have to perform access to certain types of hardware. In fact, these user-kernel transitions are <strong class="markup--strong markup--p-strong">not cheap</strong>.</p><p name="b521" id="b521" class="graf graf--p graf-after--p">Firstly, the hardware should support these transitions. We have talked about the instruction trap made by the hardware to control the illegal instructions or memory accesses.</p><p name="9c08" id="9c08" class="graf graf--p graf-after--p">Secondly, to perform the traps, there also needs to be a number of instructions. And of course, it takes time for the machine to perform all these operations.</p><p name="453a" id="453a" class="graf graf--p graf-after--p">Thirdly, these transitions can affect the cache usage of the hardware. Because context switches will swap the data/addresses currently in the <strong class="markup--strong markup--p-strong">cache</strong>, the performance of applications can benefit or suffer based on how a context switch changes what is in cache at the time they are accessing it. A cache would be considered <strong class="markup--strong markup--p-strong">hot</strong> if an application is accessing the cache when it contains the data/addresses it needs. Likewise, a cache would be considered <strong class="markup--strong markup--p-strong">cold</strong> if an application is accessing the cache when it does not contain the data/addresses it needs — forcing it to retrieve data/addresses from the main memory.</p><p name="9d26" id="9d26" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) System Call Examples</strong></p><p name="a677" id="a677" class="graf graf--p graf-after--p">Let’s now see some examples of the system calls for a 64-bit Unix machine. You can find all the system calls from this <a href="https://thevivekpandey.github.io/posts/2017-09-25-linux-system-calls.html" data-href="https://thevivekpandey.github.io/posts/2017-09-25-linux-system-calls.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">site</a> and answer the following questions.</p><p name="538f" id="538f" class="graf graf--p graf-after--p">Which system call is used to send a signal to a process?</p><pre name="51fa" id="51fa" class="graf graf--pre graf-after--p">kill</pre><p name="ef72" id="ef72" class="graf graf--p graf-after--pre">Which system call is used to set the group identity of a process?</p><pre name="7e26" id="7e26" class="graf graf--pre graf-after--p">setgid</pre><p name="c7c5" id="c7c5" class="graf graf--p graf-after--pre">Which system call is used to mount a file system?</p><pre name="e0cc" id="e0cc" class="graf graf--pre graf-after--p">mount</pre><p name="2f01" id="2f01" class="graf graf--p graf-after--pre">Which system call is used to read/write system parameters?</p><pre name="f009" id="f009" class="graf graf--pre graf-after--p">sysctl</pre><p name="0126" id="0126" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. Different Types for Operating Systems</strong></p><p name="b93e" id="b93e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Monolithic OS</strong></p><p name="3114" id="3114" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">monolithic operating system</strong> is a very basic operating system in which file management, memory management, device management, and process management are directly controlled within the kernel. Historically, an operating system has a monolithic design. For instance, the monolithic operating system may include several possible file systems, and one is specialized for sequential workloads while the other is for random I/O (common with database).</p><p name="856f" id="856f" class="graf graf--p graf-after--p">So the main point of the monolithic OS is that <strong class="markup--strong markup--p-strong">everything is included</strong> in the kernel of the operating system and everything is packaged at the same time. However, the monolithic OS has too many states, and too many codes that are hard to maintain and debug.</p><p name="9f6c" id="9f6c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Modular OS</strong></p><p name="66a8" id="66a8" class="graf graf--p graf-after--p">A more common approach today is the modular OS as the Linux operating system. This kind of operating system has already had some basic services and some of the APIs as some parts of it. More importantly, <strong class="markup--strong markup--p-strong">everything can be added</strong> as a module.</p><p name="4096" id="4096" class="graf graf--p graf-after--p">Depending on the workload, we can install a module that implements this interface in a way that makes sense for this workload. The advantages of this OS are that is easier for us to maintain and upgrade, and it also has a smaller codebase with fewer resources intensive (this leaves more memory for the applications). However, because we have to pass through the module, the interfaces can reduce some opportunities for optimizations (not very significant). Some of the modules can come from self developers and may contain a lot of bugs, so the maintenance of the modules is still a big issue.</p><p name="78af" id="78af" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Microkernel</strong></p><p name="3d4d" id="3d4d" class="graf graf--p graf-after--p">The microkernel is a kernel that requires only the <strong class="markup--strong markup--p-strong">most basic primitives</strong> at the operating system level, for instance, at the OS level, the microkernel can support some basic services like to represent an executed application (the address space and the context threads). All the other components (i.e. database) as well as software (i.e. file system and disk drivers) that we typically thinks as a part of the operating system will run out side the kernel at the user level.</p><p name="0d19" id="0d19" class="graf graf--p graf-after--p graf--trailing">The benefit of a microkernel is that it is very small and verifiability that can be used for some embedded systems or some sorts of the control systems. The down sides of the microkernel design are that although it is small, it’s portability questionable because it’s typically very customized to the underlying hardware and this also leads to the software complexity.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/a408ebe9f463"><time class="dt-published" datetime="2021-01-17T05:49:44.339Z">January 17, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-1-introduction-to-operating-system-user-kernel-protection-boundary-a408ebe9f463" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>