<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 4 | Socket Programming Experiment</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 4 | Socket Programming Experiment</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="8889" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1e79" id="1e79" class="graf graf--h3 graf--leading graf--title">Operating System 4 | Socket Programming Experiment</h3><figure name="7c6d" id="7c6d" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*2KGklTRLYrmDgRw0.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*2KGklTRLYrmDgRw0.png"></figure><p name="66a3" id="66a3" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">0. Clone the Code</strong></p><p name="0057" id="0057" class="graf graf--p graf-after--p">Before we start this experiment, we have to download or clone the code <code class="markup--code markup--p-code">server.c</code> and <code class="markup--code markup--p-code">client.c</code> from this <a href="https://github.com/zx1986/xSinppet/tree/master/unix-socket-practice" data-href="https://github.com/zx1986/xSinppet/tree/master/unix-socket-practice" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">repo</a>. You may also need the following <code class="markup--code markup--p-code">Makefile</code> file to compile these codes,</p><figure name="c713" id="c713" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/f351c7817fd2c7feeeaf6fe9bf06182f.js"></script></figure><p name="72d2" id="72d2" class="graf graf--p graf-after--figure">We can use <code class="markup--code markup--p-code">make</code> to compile these codes. After compilation, we are going to have two files named <code class="markup--code markup--p-code">server</code> and <code class="markup--code markup--p-code">client</code>. There may be some warnings when we compile the C programs and you can ignore these warnings.</p><pre name="b482" id="b482" class="graf graf--pre graf-after--p">client.c:32:15: warning: implicit declaration of function &#39;atoi&#39; is invalid in C99 [-Wimplicit-function-declaration]<br>server.c:30:15: warning: implicit declaration of function &#39;atoi&#39; is invalid in C99 [-Wimplicit-function-declaration]</pre><p name="cd89" id="cd89" class="graf graf--p graf-after--pre">After compiling, we can test the code by (as the server),</p><pre name="9881" id="9881" class="graf graf--pre graf-after--p">$ ./server 12322</pre><p name="932c" id="932c" class="graf graf--p graf-after--pre">Then in another terminal (as the client),</p><pre name="a290" id="a290" class="graf graf--pre graf-after--p">$ ./client localhost 12322</pre><ol class="postList"><li name="76a2" id="76a2" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">Header Files</strong></li></ol><p name="5b24" id="5b24" class="graf graf--p graf-after--li">Let’s now see how the server and client work. The header files that we are going to use are,</p><ul class="postList"><li name="812f" id="812f" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">stdio.h</code> : standard I/O header, contains declarations used in most input and output and is typically included in all C programs.</li><li name="ec61" id="ec61" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sys/types.h</code> : data type header, definitions of a number of data types used in system calls. These types are used in the next two include files.</li><li name="2c96" id="2c96" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sys/socket.h</code> : socket header, includes a number of definitions of structures needed for sockets.</li><li name="30d3" id="30d3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">netinet/in.h</code> : internet header, contains constants and structures needed for internet domain addresses.</li><li name="1299" id="1299" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">unistd.h</code> : UNIX standard functions header, contains functions like <code class="markup--code markup--li-code">read</code> , <code class="markup--code markup--li-code">write</code> , <code class="markup--code markup--li-code">getpid</code> , etc.</li><li name="01a9" id="01a9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">string.h</code> : string functions header, contains useful functions for strings</li><li name="a185" id="a185" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">netdb.h</code> : network database operations header, contains functions for setting or getting the domain, like <code class="markup--code markup--li-code">gethostbyname</code></li></ul><p name="dcba" id="dcba" class="graf graf--p graf-after--li">There are some other headers that we have to know because they can be useful in the future,</p><ul class="postList"><li name="026d" id="026d" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">errno.h</code> : error number header, used to retrieve error conditions using the symbol <code class="markup--code markup--li-code">errno</code>.</li><li name="4c59" id="4c59" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">stdlib.h</code>: standard library header, provide various types and general functions in the standard library, like the ASCII to integer <code class="markup--code markup--li-code">atoi</code> function</li><li name="9a68" id="9a68" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">getopt.h</code> : for <code class="markup--code markup--li-code">getopt</code> function, see the <a href="https://www.gnu.org/software/gnulib/manual/html_node/getopt_002eh.html" data-href="https://www.gnu.org/software/gnulib/manual/html_node/getopt_002eh.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">documentation</a></li></ul><p name="21d3" id="21d3" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">2. Socket Establishing Procedures</strong></p><p name="c218" id="c218" class="graf graf--p graf-after--p">For a <strong class="markup--strong markup--p-strong">client</strong>, a socket can be created by,</p><ul class="postList"><li name="46b1" id="46b1" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Step 1</strong>. created with the <code class="markup--code markup--li-code">socket()</code> system call</li><li name="9ab4" id="9ab4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 2</strong>. connected to the address of the server by <code class="markup--code markup--li-code">connect()</code> system call</li><li name="18d2" id="18d2" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 3</strong>. send and receive data by the <code class="markup--code markup--li-code">read()</code> and <code class="markup--code markup--li-code">write()</code> system call</li><li name="b60f" id="b60f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 4</strong>. close the socket by the <code class="markup--code markup--li-code">close()</code> system call</li></ul><p name="a243" id="a243" class="graf graf--p graf-after--li">For a <strong class="markup--strong markup--p-strong">server</strong>, a socket can be created by,</p><ul class="postList"><li name="b929" id="b929" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Step 1</strong>. created with the <code class="markup--code markup--li-code">socket()</code> system call</li><li name="02f7" id="02f7" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 2</strong>. bind the socket to an address using the <code class="markup--code markup--li-code">bind()</code> system call</li><li name="ab06" id="ab06" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 3</strong>. listen for connections with <code class="markup--code markup--li-code">listen()</code> system call</li><li name="3d14" id="3d14" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 4</strong>. accept a connection with <code class="markup--code markup--li-code">accept()</code> system call</li><li name="2dfa" id="2dfa" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 5</strong>. send and receive data by the <code class="markup--code markup--li-code">read()</code> and <code class="markup--code markup--li-code">write()</code> system call</li><li name="151c" id="151c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 6</strong>. close the socket by the <code class="markup--code markup--li-code">close()</code> system call</li></ul><p name="4c3e" id="4c3e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">3. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">socket()</strong></code><strong class="markup--strong markup--p-strong"> Function</strong></p><p name="2d30" id="2d30" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">socket</code> function has three parameters, <code class="markup--code markup--p-code">domain</code> , <code class="markup--code markup--p-code">type</code> , and <code class="markup--code markup--p-code">protocol</code> ,</p><pre name="718b" id="718b" class="graf graf--pre graf-after--p">#include &lt;sys/types.h&gt;          <br>#include &lt;sys/socket.h&gt;<br><br>int socket(int <em class="markup--em markup--pre-em">domain</em>, int <em class="markup--em markup--pre-em">type</em>, int <em class="markup--em markup--pre-em">protocol</em>);</pre><p name="afc1" id="afc1" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">domain</code> argument specifies a communication domain, this selects the protocol family which will be used for communication.</p><ul class="postList"><li name="fde2" id="fde2" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">AF_INET</code> , for IPv4 Internet protocols</li><li name="f69c" id="f69c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">AF_INET6</code> , for IPv6 Internet protocols</li></ul><p name="7b53" id="7b53" class="graf graf--p graf-after--li">The socket has the indicated <code class="markup--code markup--p-code">type</code>, which specifies the communication semantics.</p><ul class="postList"><li name="ff8b" id="ff8b" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">SOCK_STREAM</code> : Sequenced, reliable, two-way, connection-based byte streams. Supports TCP.</li><li name="8a73" id="8a73" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">SOCK_DGRAM</code>: Connectionless, unreliable messages of a fixed maximum length. Supports UDP.</li></ul><p name="d40a" id="d40a" class="graf graf--p graf-after--li">The <code class="markup--code markup--p-code">protocol</code> specifies a particular protocol to be used with the socket.</p><ul class="postList"><li name="36c4" id="36c4" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">IPPROTO_TCP</code>: we can specify this argument to the TCP protocol, or because TCP exists to support a particular socket type within the given protocol family <code class="markup--code markup--li-code">SOCKET_STREAM</code> , in which case protocol can be specified as <code class="markup--code markup--li-code">0</code>.</li></ul><p name="162c" id="162c" class="graf graf--p graf-after--li">On success, a <code class="markup--code markup--p-code">file descriptor</code> for the new socket is returned. On error, <code class="markup--code markup--p-code">-1</code> is returned, and <code class="markup--code markup--p-code">errno</code> is set appropriately. To print an <code class="markup--code markup--p-code">errno</code>, we can use,</p><pre name="1d00" id="1d00" class="graf graf--pre graf-after--p">#include &lt;errno.h&gt;</pre><pre name="4b19" id="4b19" class="graf graf--pre graf-after--pre">if (errno != 0) {<br>     perror(&quot;ERROR&quot;);<br>     exit(1);<br>}</pre><p name="d987" id="d987" class="graf graf--p graf-after--pre">And we can also refer to the <a href="https://man7.org/linux/man-pages/man3/errno.3.html" data-href="https://man7.org/linux/man-pages/man3/errno.3.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">manual</a> of errno for more information.</p><p name="47c3" id="47c3" class="graf graf--p graf-after--p">Thus, for TCP socket, we can make it by,</p><pre name="e3c9" id="e3c9" class="graf graf--pre graf-after--p">tcp_socket = socket(AF_INET, SOCK_STREAM, 0); </pre><p name="ae86" id="ae86" class="graf graf--p graf-after--pre">For UDP socket, we can make it by,</p><pre name="7f4a" id="7f4a" class="graf graf--pre graf-after--p">udp_socket = socket(AF_INET, SOCK_DGRAM, 0);</pre><p name="d177" id="d177" class="graf graf--p graf-after--pre">However, in our case, we are going to use the TCP protocol.</p><p name="b8c5" id="b8c5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">sockaddr_in</strong></code><strong class="markup--strong markup--p-strong"> Structure</strong></p><p name="aa3c" id="aa3c" class="graf graf--p graf-after--p">The sockaddr_in structure is used to handle the information for the internet addresses. Now we have already made a socket, but we also need to specify the partner we would like to communicate with. The prototype of the <code class="markup--code markup--p-code">sockaddr_in</code> is as follows,</p><pre name="5861" id="5861" class="graf graf--pre graf-after--p">#include &lt;netinet/in.h&gt;<br><br>struct sockaddr_in {<br>    short            sin_family;   // e.g. AF_INET<br>    unsigned short   sin_port;     // e.g. htons(3490)<br>    struct in_addr   sin_addr;     // see struct in_addr, below<br>    char             sin_zero[8];  // zero this if you want to<br>};<br><br>struct in_addr {<br>    unsigned long s_addr;  // load with inet_aton()<br>};</pre><p name="0e97" id="0e97" class="graf graf--p graf-after--pre">We can build an instance of this structure by,</p><pre name="4285" id="4285" class="graf graf--pre graf-after--p">struct sockaddr_in Address;</pre><ul class="postList"><li name="8cda" id="8cda" class="graf graf--li graf-after--pre">The <code class="markup--code markup--li-code">sin_family</code> should be selected from <code class="markup--code markup--li-code">AF_INET</code> or <code class="markup--code markup--li-code">AF_INET6</code> ,</li></ul><pre name="61e1" id="61e1" class="graf graf--pre graf-after--li">Address.sin_family = AF_INET;</pre><p name="84fe" id="84fe" class="graf graf--p graf-after--pre">Or,</p><pre name="c9ec" id="c9ec" class="graf graf--pre graf-after--p">Address.sin_family = AF_INET6;</pre><ul class="postList"><li name="a34d" id="a34d" class="graf graf--li graf-after--pre">The <code class="markup--code markup--li-code">sin_port</code> is the port that the server will <strong class="markup--strong markup--li-strong">listen to</strong>. Normally, we can not directly assign the port value to this parameter because the integer values are different from the host and network byte order values.</li></ul><p name="730c" id="730c" class="graf graf--p graf-after--li">To convert our integers to the network byte order values, we have to use the <code class="markup--code markup--p-code">htons()</code> function, which is quite common for socket programming. The <code class="markup--code markup--p-code">htons()</code> function converts the unsigned short integer host short from host byte order to network byte order.</p><pre name="9288" id="9288" class="graf graf--pre graf-after--p">Address.sin_port = htons(nHostPort);  // nHostPort is 1025 ~ 65535</pre><ul class="postList"><li name="5342" id="5342" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">in_addr</code> is a nested structure with an unsigned long element <code class="markup--code markup--li-code">s_addr</code>. It is used to specify which IP address can be seen as our client.</li></ul><p name="e6be" id="e6be" class="graf graf--p graf-after--li">If we don’t want to specify the inbound address, we can write <code class="markup--code markup--p-code">INADDR_ANY</code> for all the addresses (which is equivalent to <code class="markup--code markup--p-code">0</code>),</p><pre name="5e27" id="5e27" class="graf graf--pre graf-after--p">Address.sin_addr.s_addr = INADDR_ANY;</pre><p name="81b4" id="81b4" class="graf graf--p graf-after--pre">However, if we want to specify some inbound address like <code class="markup--code markup--p-code">63.161.169.137</code> , then we have to use the <code class="markup--code markup--p-code">inet_aton</code> function to assign this value.</p><pre name="97ed" id="97ed" class="graf graf--pre graf-after--p">inet_aton(&quot;63.161.169.137&quot;, &amp;myaddr.sin_addr.s_addr);</pre><p name="f134" id="f134" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">5. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">bind()</strong></code><strong class="markup--strong markup--p-strong"> Function [Server]</strong></p><p name="ec19" id="ec19" class="graf graf--p graf-after--p">The bind is used to bind a name to a socket. We have to bind the <code class="markup--code markup--p-code">Address</code> structure that we have built to this socket. You can find more about why we do this <code class="markup--code markup--p-code">bind</code> function from the <a href="https://stackoverflow.com/questions/7556811/why-bind-a-socket-to-an-address" data-href="https://stackoverflow.com/questions/7556811/why-bind-a-socket-to-an-address" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">link here</a>.</p><p name="72fb" id="72fb" class="graf graf--p graf-after--p">When a socket is created with <code class="markup--code markup--p-code">socket</code>, it exists in a namespace (address family) but has no address assigned to it. <code class="markup--code markup--p-code">bind()</code> assigns the address specified by <code class="markup--code markup--p-code">addr</code> to the socket referred to by the file descriptor <code class="markup--code markup--p-code">sockfd</code>. The synopsis of this <code class="markup--code markup--p-code">bind</code> function is,</p><pre name="6d3a" id="6d3a" class="graf graf--pre graf-after--p">#include &lt;sys/types.h&gt;       <br>#include &lt;sys/socket.h&gt;</pre><pre name="c34a" id="c34a" class="graf graf--pre graf-after--pre">int bind(int sockfd,const struct sockaddr *addr,socklen_t addrlen);</pre><ul class="postList"><li name="7f51" id="7f51" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">sockfd</code> is the socket file descriptor (return value) that we have generated through the <code class="markup--code markup--li-code">socket</code> function</li><li name="e686" id="e686" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">addr</code> is the socket address structure that we have built above. Because this is a pointer argument, we have to get the address of the <code class="markup--code markup--li-code">Address</code> structure that we have constructed and then convert it to a pointer,</li></ul><pre name="bbb7" id="bbb7" class="graf graf--pre graf-after--li">(struct sockaddr*) &amp;Address</pre><ul class="postList"><li name="172c" id="172c" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">addrlen</code> is the size of the socket address structure, we can directly retrieve this value by,</li></ul><pre name="928f" id="928f" class="graf graf--pre graf-after--li">sizeof(Address)</pre><p name="4b07" id="4b07" class="graf graf--p graf-after--pre">On success, <code class="markup--code markup--p-code">0</code> is returned. On error, <code class="markup--code markup--p-code">-1</code> is returned, and errno is set appropriately. If we get an <code class="markup--code markup--p-code">-1</code> as our returned value, this means that we can not connect to the host.</p><p name="bcdd" id="bcdd" class="graf graf--p graf-after--p">We can also test our connection with the <code class="markup--code markup--p-code">getsockname</code> function. For example,</p><pre name="2eb6" id="2eb6" class="graf graf--pre graf-after--p">getsockname(hServerSocket, (struct sockaddr *) &amp;Address,(socklen_t *)&amp;nAddressSize);</pre><p name="b407" id="b407" class="graf graf--p graf-after--pre">See more information about this function, you can refer to <a href="https://pubs.opengroup.org/onlinepubs/007904875/functions/getsockname.html" data-href="https://pubs.opengroup.org/onlinepubs/007904875/functions/getsockname.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this link</a>.</p><p name="c85a" id="c85a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">6. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">listen()</strong></code><strong class="markup--strong markup--p-strong"> Function [Server]</strong></p><p name="b530" id="b530" class="graf graf--p graf-after--p">After binding, we have to listen for connections on a socket. The synopsis of the listen is quite easy with only two arguments,</p><pre name="d857" id="d857" class="graf graf--pre graf-after--p">#include &lt;sys/types.h&gt;<br>#include &lt;sys/socket.h&gt; </pre><pre name="e514" id="e514" class="graf graf--pre graf-after--pre">int listen(int sockfd, int backlog);</pre><ul class="postList"><li name="4cde" id="4cde" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">sockfd</code> is the socket file descriptor (return value) that we have generated through the <code class="markup--code markup--li-code">socket</code> function</li><li name="b549" id="b549" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">backlog</code> is a little bit tricky. In simple words, the <code class="markup--code markup--li-code">backlog</code> parameter specifies the number of pending connections the queue will hold. When multiple clients connect to the server, the server then holds the incoming requests in a queue. The clients are arranged in the queue, and the server processes their requests <strong class="markup--strong markup--li-strong">one by one</strong> as and when queue-member proceeds. The value of the <code class="markup--code markup--li-code">backlog</code> is actually the queue size of the pending clients. In our case, it will be assigned to <code class="markup--code markup--li-code">5</code>.</li></ul><pre name="d13b" id="d13b" class="graf graf--pre graf-after--li"># define QUEUE_SIZE = 5<br>listen(hServerSocket, QUEUE_SIZE)</pre><p name="502c" id="502c" class="graf graf--p graf-after--pre">Note that on success, <code class="markup--code markup--p-code">0</code> is returned. On error, <code class="markup--code markup--p-code">-1</code> is returned, and <code class="markup--code markup--p-code">errno</code> is set appropriately.</p><p name="f09c" id="f09c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">7. Resolve the Hostname [Client]</strong></p><p name="4ac8" id="4ac8" class="graf graf--p graf-after--p">For our client, we have to resolve the hostname before connection. The first argument provides the hostname in our case, and we can store it in the <code class="markup--code markup--p-code">strHostName</code> variable. The <code class="markup--code markup--p-code">strcpy</code> function is used to copy a string to another variable. The <code class="markup--code markup--p-code">pHostInfo</code> is a pointer pointing to the <code class="markup--code markup--p-code">hostent</code> structure which can be used to store host information,</p><pre name="e2b7" id="e2b7" class="graf graf--pre graf-after--p">struct hostent* pHostInfo;<br>char strHostName[HOST_NAME_SIZE];</pre><pre name="585a" id="585a" class="graf graf--pre graf-after--pre">strcpy(strHostName,argv[1]);<br>pHostInfo=gethostbyname(strHostName);</pre><p name="6a8d" id="6a8d" class="graf graf--p graf-after--pre">After this, we can copy the address of this host to a long integer by <code class="markup--code markup--p-code">memcpy</code> ,</p><pre name="c5cb" id="c5cb" class="graf graf--pre graf-after--p">long nHostAddress;<br>memcpy(&amp;nHostAddress,pHostInfo-&gt;h_addr,pHostInfo-&gt;h_length);</pre><p name="b001" id="b001" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">8. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">accept()</strong></code><strong class="markup--strong markup--p-strong"> Function [Server]</strong></p><p name="ec7b" id="ec7b" class="graf graf--p graf-after--p">The server should use the <code class="markup--code markup--p-code">accept</code> function to wait for the connection request from a client. The <code class="markup--code markup--p-code">accept</code> is a system call for accepting a connection on a socket.</p><pre name="edfc" id="edfc" class="graf graf--pre graf-after--p">#include &lt;sys/types.h&gt;   <br>#include &lt;sys/socket.h&gt;<br><br>int accept(int <em class="markup--em markup--pre-em">sockfd</em>, struct sockaddr *<em class="markup--em markup--pre-em">addr</em>, socklen_t *<em class="markup--em markup--pre-em">addrlen</em>);</pre><ul class="postList"><li name="8d66" id="8d66" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">sockfd</code> is the socket file descriptor (return value) that we have generated through the <code class="markup--code markup--li-code">socket</code> function</li><li name="ac3d" id="ac3d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">addr</code> is the socket address structure that we have built above. Because this is a pointer argument, we have to get the address of the <code class="markup--code markup--li-code">Address</code> structure that we have constructed and then convert it to a pointer,</li></ul><pre name="c17e" id="c17e" class="graf graf--pre graf-after--li">(struct sockaddr*) &amp;Address</pre><ul class="postList"><li name="b488" id="b488" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">addrlen</code> is the size of the socket address structure, we can directly retrieve this value by,</li></ul><pre name="c5a7" id="c5a7" class="graf graf--pre graf-after--li">sizeof(Address)</pre><p name="5928" id="5928" class="graf graf--p graf-after--pre">On success, these system calls return a <code class="markup--code markup--p-code">file descriptor</code> for the accepted socket. On error, <code class="markup--code markup--p-code">-1</code> is returned, and errno is set appropriately. Thus,</p><pre name="e934" id="e934" class="graf graf--pre graf-after--p">int hSocket;<br>hSocket=accept(hServerSocket,(struct sockaddr*)&amp;Address,(socklen_t *)&amp;nAddressSize);</pre><p name="74b0" id="74b0" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">9. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">connect()</strong></code><strong class="markup--strong markup--p-strong"> Function [Client]</strong></p><p name="d556" id="d556" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">connect</code> function is quite similar to the <code class="markup--code markup--p-code">bind</code> function with all the same arguments. However, this is not used to bind the addresses but to be used for connecting to the server. The synopsis for <code class="markup--code markup--p-code">connect</code> is,</p><pre name="1025" id="1025" class="graf graf--pre graf-after--p">#include &lt;sys/types.h&gt;<br>#include &lt;sys/socket.h&gt;</pre><pre name="850f" id="850f" class="graf graf--pre graf-after--pre">int connect(int <em class="markup--em markup--pre-em">sockfd</em>, const struct sockaddr *<em class="markup--em markup--pre-em">addr</em>,socklen_t <em class="markup--em markup--pre-em">addrlen</em>);</pre><ul class="postList"><li name="60f5" id="60f5" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">sockfd</code> is the socket file descriptor (return value) that we have generated through the <code class="markup--code markup--li-code">socket</code> function</li><li name="4dd1" id="4dd1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">addr</code> is the socket address structure that we have built above. Because this is a pointer argument, we have to get the address of the <code class="markup--code markup--li-code">Address</code> structure that we have constructed and then convert it to a pointer,</li></ul><pre name="6087" id="6087" class="graf graf--pre graf-after--li">(struct sockaddr*) &amp;Address</pre><ul class="postList"><li name="de9b" id="de9b" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">addrlen</code> is the size of the socket address structure, we can directly retrieve this value by,</li></ul><pre name="bf04" id="bf04" class="graf graf--pre graf-after--li">sizeof(Address)</pre><p name="950c" id="950c" class="graf graf--p graf-after--pre">On success, <code class="markup--code markup--p-code">0</code> is returned. On error, <code class="markup--code markup--p-code">-1</code> is returned, and errno is set appropriately. If we get an <code class="markup--code markup--p-code">-1</code> as our returned value, this means that we can not connect to the server.</p><p name="fc80" id="fc80" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">10. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">write()</strong></code><strong class="markup--strong markup--p-strong"> and </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">read()</strong></code><strong class="markup--strong markup--p-strong"> Functions</strong></p><p name="c2b5" id="c2b5" class="graf graf--p graf-after--p">The write and read functions are used to receive or send data between the server and the client. <code class="markup--code markup--p-code">write()</code> writes up to <code class="markup--code markup--p-code">count</code> bytes from the buffer starting at <code class="markup--code markup--p-code">buf</code> to the file referred to by the file descriptor <code class="markup--code markup--p-code">fd</code>.</p><pre name="18ad" id="18ad" class="graf graf--pre graf-after--p">#include &lt;unistd.h&gt; </pre><pre name="c0ba" id="c0ba" class="graf graf--pre graf-after--pre">ssize_t write(int fd, const void *buf, size_t count);</pre><p name="a34c" id="a34c" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">read()</code> attempts to read up to <code class="markup--code markup--p-code">count</code> bytes from file descriptor <code class="markup--code markup--p-code">fd</code> into the buffer starting at <code class="markup--code markup--p-code">buf</code>.</p><pre name="154c" id="154c" class="graf graf--pre graf-after--p">#include &lt;unistd.h&gt; </pre><pre name="dfb2" id="dfb2" class="graf graf--pre graf-after--pre">ssize_t read(int fd, void *buf, size_t count);</pre><p name="4a56" id="4a56" class="graf graf--p graf-after--pre">On success, the number of bytes read is returned (<code class="markup--code markup--p-code">0</code> indicates the end of the file), and the file position is advanced by this number. On error, <code class="markup--code markup--p-code">-1</code> is returned, and <code class="markup--code markup--p-code">errno</code> is set appropriately.</p><p name="ba1d" id="ba1d" class="graf graf--p graf-after--p">Before we begin our communication, we have to set up a character buffer <code class="markup--code markup--p-code">pBuffer</code> for both the server and the client, by</p><pre name="0f19" id="0f19" class="graf graf--pre graf-after--p">#define BUFFER_SIZE 100<br>char pBuffer[BUFFER_SIZE];</pre><p name="8a7e" id="8a7e" class="graf graf--p graf-after--pre">We can write to the buffer <code class="markup--code markup--p-code">pBuffer</code> by <code class="markup--code markup--p-code">strcpy</code> ,</p><pre name="8b20" id="8b20" class="graf graf--pre graf-after--p">#define MESSAGE &quot;This is the message I&#39;m sending back and forth&quot;<br>strcpy(pBuffer,MESSAGE);</pre><p name="5caf" id="5caf" class="graf graf--p graf-after--pre">Then we can send this message in the buffer to the client by <code class="markup--code markup--p-code">write</code> function,</p><pre name="2218" id="2218" class="graf graf--pre graf-after--p">write(hSocket,pBuffer,strlen(pBuffer)+1);</pre><p name="8ab7" id="8ab7" class="graf graf--p graf-after--pre">Note that we should add <code class="markup--code markup--p-code">1</code> to the count parameter instead of using <code class="markup--code markup--p-code">strlen(pBuffer)</code> in a direct way. Or if we want to send back the information that we have read, we can directly use the returned value of the read function. For example,</p><pre name="7b37" id="7b37" class="graf graf--pre graf-after--p">nReadAmount = read(hSocket,pBuffer,BUFFER_SIZE);</pre><p name="f1af" id="f1af" class="graf graf--p graf-after--pre">Then,</p><pre name="3bb9" id="3bb9" class="graf graf--pre graf-after--p">write(hSocket,pBuffer,nReadAmount);</pre><p name="2f2b" id="2f2b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">11. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">close()</strong></code><strong class="markup--strong markup--p-strong"> Function</strong></p><p name="23f0" id="23f0" class="graf graf--p graf-after--p">In the end, after we finish our communication, we have to close the socket. We can use the <code class="markup--code markup--p-code">close()</code> function to close a file descriptor. The synopsis is,</p><pre name="8531" id="8531" class="graf graf--pre graf-after--p">#include &lt;unistd.h&gt;</pre><pre name="ca4e" id="ca4e" class="graf graf--pre graf-after--pre">int close(int fildes);</pre><p name="143a" id="143a" class="graf graf--p graf-after--pre graf--trailing">If <code class="markup--code markup--p-code">close()</code> is interrupted by a signal that is to be caught, it shall return <code class="markup--code markup--p-code">-1</code> with <code class="markup--code markup--p-code">errno</code> set to <code class="markup--code markup--p-code">[EINTR]</code>, and the state of <code class="markup--code markup--p-code">fildes</code> is unspecified.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/7e78be945ef5"><time class="dt-published" datetime="2021-01-26T06:31:25.682Z">January 26, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-4-socket-programming-experiment-7e78be945ef5" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>