<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 28 | Final Review for Outlines</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 28 | Final Review for Outlines</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="1058" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2b18" id="2b18" class="graf graf--h3 graf--leading graf--title">Operating System 28 | Final Review for Outlines</h3><figure name="5f67" id="5f67" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*6HGOw64KFxJhCoFJ.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*6HGOw64KFxJhCoFJ.png"></figure><ol class="postList"><li name="7672" id="7672" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">OS Scheduling</strong></li></ol><p name="9d25" id="9d25" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Metrics for OS Scheduling</strong></p><ul class="postList"><li name="285c" id="285c" class="graf graf--li graf-after--p">throughput: task per second</li><li name="cd0e" id="cd0e" class="graf graf--li graf-after--li">the average time it took for tasks to complete</li><li name="fac1" id="fac1" class="graf graf--li graf-after--li">the average time that tasks spent waiting before they were scheduled</li><li name="2f12" id="2f12" class="graf graf--li graf-after--li">the overall CPU utilization</li></ul><figure name="d042" id="d042" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*8xjUcs5p0aQrKwwq.png" data-width="1458" data-height="100" src="https://cdn-images-1.medium.com/max/800/0*8xjUcs5p0aQrKwwq.png"></figure><p name="aac6" id="aac6" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(2) Run-to-Completion Scheduling</strong></p><p name="7dbd" id="7dbd" class="graf graf--p graf-after--p">As soon as a task is assigned to a CPU, it will run until it finishes or until it completes.</p><ul class="postList"><li name="a9de" id="a9de" class="graf graf--li graf-after--p">First-Come, First-Serve (FCFS)</li><li name="8217" id="8217" class="graf graf--li graf-after--li">Shortest-Job First (SJF)</li><li name="fe09" id="fe09" class="graf graf--li graf-after--li">Complex First</li></ul><p name="57e6" id="57e6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Preemptive Scheduling</strong></p><p name="23cb" id="23cb" class="graf graf--p graf-after--p">Tasks don’t hog (means exclusively occupy) the CPU until they’re completed. We will use the following policy,</p><ul class="postList"><li name="7e45" id="7e45" class="graf graf--li graf-after--p">Priority Scheduling: first execute the highest priority</li></ul><p name="b26a" id="b26a" class="graf graf--p graf-after--li">But there can be some problems,</p><ul class="postList"><li name="426a" id="426a" class="graf graf--li graf-after--p">Starvation: stuck low priority task. The solution is priority aging</li><li name="d3f5" id="d3f5" class="graf graf--li graf-after--li">Priority Inverse</li></ul><p name="481e" id="481e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Round-Robin Scheduling (RRS)</strong></p><p name="002e" id="002e" class="graf graf--p graf-after--p">Round-robin scheduling means that we will looply access all the tasks until they’re completed. There can be two types of RRS,</p><ul class="postList"><li name="66f2" id="66f2" class="graf graf--li graf-after--p">Time Slicing</li><li name="90e0" id="90e0" class="graf graf--li graf-after--li">Without Time Slicing</li></ul><p name="6144" id="6144" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Run Queue</strong></p><p name="af42" id="af42" class="graf graf--p graf-after--p">Active processes are placed in an array called a run queue. We can have different types of run queues,</p><ul class="postList"><li name="a0ef" id="a0ef" class="graf graf--li graf-after--p">Single runqueue: same run queue for I/O (slow) and CPU (fast) -bound tasks</li><li name="7df8" id="7df8" class="graf graf--li graf-after--li">Multi-runqueue: different run queues for I/O and CPU-bound tasks in the same layer. I/O-bound tasks will have short time slices and CPU-bound tasks have long time slices. This method needs classifications by history-based heuristics.</li></ul><figure name="a86c" id="a86c" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*WYB6N3XVfc4Sndxw.png" data-width="1298" data-height="270" src="https://cdn-images-1.medium.com/max/800/0*WYB6N3XVfc4Sndxw.png"></figure><ul class="postList"><li name="dbfb" id="dbfb" class="graf graf--li graf-after--figure">Multi-Level Feedback Queue (MLFQ): different run queues for I/O and CPU-bound tasks in different layers. We don’t have to do any classification.</li></ul><figure name="769d" id="769d" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*Lc_c5qNS1VXnp33I.png" data-width="1664" data-height="174" src="https://cdn-images-1.medium.com/max/800/0*Lc_c5qNS1VXnp33I.png"></figure><p name="4dac" id="4dac" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) Linux Schedulers</strong></p><ul class="postList"><li name="6a9c" id="6a9c" class="graf graf--li graf-after--p">Kernel 2.5: O(1) scheduler, not suitable for interactive tasks</li><li name="40c0" id="40c0" class="graf graf--li graf-after--li">Kernel 2.6.23 and later: CFS scheduler</li></ul><p name="4a99" id="4a99" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) I/O-bound Tasks Vs. CPU-Bound Tasks</strong></p><ul class="postList"><li name="ad25" id="ad25" class="graf graf--li graf-after--p">I/O-bound Tasks (Memory-bound Tasks): high CPI, low IPC</li><li name="a4bc" id="a4bc" class="graf graf--li graf-after--li">CPU-bound Tasks (Compute-bound Tasks): low CPI, high IPC</li></ul><p name="d126" id="d126" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) Conclusion of Fedorova’s Paper</strong></p><p name="2cd1" id="2cd1" class="graf graf--p graf-after--p">Mixed IPC workloads on each core results in a better performance.</p><p name="cf9c" id="cf9c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 1-1. Run-to-Completion Scheduling and RR Scheduling</strong></p><p name="6308" id="6308" class="graf graf--p graf-after--p">Suppose we have three tasks T1, T2, and T3 arrive in the order <code class="markup--code markup--p-code">T1 -&gt; T2 -&gt; T3</code>, which have the following execution time,</p><pre name="4305" id="4305" class="graf graf--pre graf-after--p">T1 =  1 s<br>T2 = 10 s<br>T3 =  1 s</pre><p name="893d" id="893d" class="graf graf--p graf-after--pre">For each of the three algorithms (i.e. FCFS, SJF, complex first) with run-to-completion scheduling or RR scheduling with ts = 1s. Calculate,</p><ul class="postList"><li name="5c9f" id="5c9f" class="graf graf--li graf-after--p">throughput</li><li name="6072" id="6072" class="graf graf--li graf-after--li">average completion time</li><li name="067a" id="067a" class="graf graf--li graf-after--li">average waiting time</li></ul><p name="32bd" id="32bd" class="graf graf--p graf-after--li">Solution:</p><p name="8bb7" id="8bb7" class="graf graf--p graf-after--p">For run-to-completion scheduling with FCFS,</p><pre name="b9fa" id="b9fa" class="graf graf--pre graf-after--p">throughput = 3/12 = 0.25 task/s<br>ACT = (1+11+12)/3 = 8 s<br>AWT = (0+10+11)/3 = 4 s</pre><p name="77d0" id="77d0" class="graf graf--p graf-after--pre">For run-to-completion scheduling with SJF,</p><pre name="03b6" id="03b6" class="graf graf--pre graf-after--p">throughput = 3/12 = 0.25 task/s<br>ACT = (1+2+12)/3 = 5 s<br>AWT = (0+1+11)/3 = 1 s</pre><p name="12b9" id="12b9" class="graf graf--p graf-after--pre">For run-to-completion scheduling with complex first,</p><pre name="a78f" id="a78f" class="graf graf--pre graf-after--p">throughput = 3/12 = 0.25 task/s<br>ACT = (10+11+12)/3 = 11 s<br>AWT = (0+10+11)/3 = 7 s</pre><p name="1baa" id="1baa" class="graf graf--p graf-after--pre">For RR scheduling (ts = 1s) with FCFS,</p><pre name="c830" id="c830" class="graf graf--pre graf-after--p">throughput = 3/12 = 0.25 task/s<br>ACT = (1+12+3)/3 = 5.33 s<br>AWT = (0+1+2)/3 = 1 s</pre><p name="1b20" id="1b20" class="graf graf--p graf-after--pre">For RR scheduling (ts = 1s) with FCFS,</p><pre name="128a" id="128a" class="graf graf--pre graf-after--p">throughput = 3/12 = 0.25 task/s<br>ACT = (1+2+12)/3 = 5 s<br>AWT = (0+1+2)/3 = 1 s</pre><p name="0385" id="0385" class="graf graf--p graf-after--pre">For RR scheduling (ts = 1s) with complex first,</p><pre name="ec5c" id="ec5c" class="graf graf--pre graf-after--p">throughput = 3/12 = 0.25 task/s<br>ACT = (12+2+3)/3 = 5.67 s<br>AWT = (0+1+2)/3 = 1 s</pre><p name="232f" id="232f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Memory Management</strong></p><p name="6958" id="6958" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Memory Management Methods</strong></p><p name="635d" id="635d" class="graf graf--p graf-after--p">There are two ways to manage memory,</p><ul class="postList"><li name="eda7" id="eda7" class="graf graf--li graf-after--p">Page-based: virtual memory is divided into fix-sized pages</li><li name="1d6b" id="1d6b" class="graf graf--li graf-after--li">Segment-based: virtual memory is divided into flexible segments</li></ul><p name="bddf" id="bddf" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Page Tables</strong></p><p name="cfab" id="cfab" class="graf graf--p graf-after--p">OS generates a page table for every process that it runs, which is used for virtual to physical translation. Page table entry contains flags like,</p><ul class="postList"><li name="e10e" id="e10e" class="graf graf--li graf-after--p">Present (P): same as the valid bit</li><li name="7984" id="7984" class="graf graf--li graf-after--li">Dirty (D): if need to write back</li><li name="ac3e" id="ac3e" class="graf graf--li graf-after--li">Access (A): show read or write</li><li name="04ba" id="04ba" class="graf graf--li graf-after--li">Protection (R/W/X): show the permission</li></ul><p name="5ad9" id="5ad9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Memory Management Unit</strong></p><p name="c60a" id="c60a" class="graf graf--p graf-after--p">MMU is the hardware for supporting memory management. It is responsible for,</p><ul class="postList"><li name="1f17" id="1f17" class="graf graf--li graf-after--p">Virtual to physical address translation</li><li name="c653" id="c653" class="graf graf--li graf-after--li">Generate page faults: like the non-existing page (need to read from disk) and protection error</li></ul><p name="6c7d" id="6c7d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Page Table Size</strong></p><figure name="6284" id="6284" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*Dm0gmCUXacBCBmea.png" data-width="1422" data-height="106" src="https://cdn-images-1.medium.com/max/800/0*Dm0gmCUXacBCBmea.png"></figure><p name="e6ac" id="e6ac" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Improving Page Tables</strong></p><p name="71cc" id="71cc" class="graf graf--p graf-after--p">The following ways can be used to improve the page tables. These include,</p><ul class="postList"><li name="2e5c" id="2e5c" class="graf graf--li graf-after--p">Multi-level Page Tables (MLPT): reduce page table cost</li><li name="5942" id="5942" class="graf graf--li graf-after--li">Translation Look-aside Buffer (TLB): faster search to the table</li><li name="76c7" id="76c7" class="graf graf--li graf-after--li">Inverted Page Tables (IPT): another approach, need to do a linear search</li><li name="6a78" id="6a78" class="graf graf--li graf-after--li">Hashing Inverted Page Tables (hashing IPT): improving the linear search with hash tables</li></ul><p name="2170" id="2170" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) Descriptor Table</strong></p><p name="17c7" id="17c7" class="graf graf--p graf-after--p">With segments, the address space is divided into components of arbitrary granularity of arbitrary size. The descriptor table is used to translate the virtual address to the linear address.</p><p name="291f" id="291f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Segmentation Translation Procedure</strong></p><p name="972e" id="972e" class="graf graf--p graf-after--p">Segmentation must be used with paging.</p><figure name="6a72" id="6a72" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*JEj0lxQ1lNF1dg5m.png" data-width="946" data-height="110" src="https://cdn-images-1.medium.com/max/800/0*JEj0lxQ1lNF1dg5m.png"></figure><p name="3375" id="3375" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(8) Memory Allocator</strong></p><p name="ed0b" id="ed0b" class="graf graf--p graf-after--p">The memory allocator is used to allocate memory and it can be implemented at either the user level or the kernel level.</p><ul class="postList"><li name="7f93" id="7f93" class="graf graf--li graf-after--p">Buddy memory allocator: The buddy allocator will continue subdividing consecutive memory region until it finds the smallest chunk that’s with a size of a power of 2ⁿ that can satisfy the request. This is fast but has internal fragmentation.</li></ul><figure name="cdfe" id="cdfe" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*W15vPimqzTe0WVD2.png" data-width="1492" data-height="426" src="https://cdn-images-1.medium.com/max/800/0*W15vPimqzTe0WVD2.png"></figure><ul class="postList"><li name="1006" id="1006" class="graf graf--li graf-after--figure">Slub memory allocator: The slub allocator builds custom object caches on top of slabs, and the slabs themselves represent contiguously allocated physical memory. This avoids internal and external fragmentation.</li></ul><p name="e376" id="e376" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(9) Copy On Write (COW)</strong></p><p name="6925" id="6925" class="graf graf--p graf-after--p">Forked processes continue using the virtual address space of their parent process until we need to perform a write operation.</p><p name="4fa1" id="4fa1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) Demand Paging</strong></p><p name="55e8" id="55e8" class="graf graf--p graf-after--p">Demand paging means that we we store some information on the disk and when we need them, we can load them back from the secondary storage.</p><p name="18bb" id="18bb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) Page Replacement</strong></p><p name="c2ae" id="c2ae" class="graf graf--p graf-after--p">When we memory usage is above the threshold or CPU usage is below the threshold, the pages should be swapped out. We can have some common replacement policies like,</p><ul class="postList"><li name="e48f" id="e48f" class="graf graf--li graf-after--p">LRU</li><li name="f1ed" id="f1ed" class="graf graf--li graf-after--li">Swap dirty bit = 0 because we don’t have to write back</li></ul><p name="0a77" id="0a77" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(12) Failure and Recovery Management</strong></p><p name="1ace" id="1ace" class="graf graf--p graf-after--p">There methods that we can handle the failures and recover from a failure,</p><ul class="postList"><li name="90cc" id="90cc" class="graf graf--li graf-after--p">Checkpointing</li><li name="4c9f" id="4c9f" class="graf graf--li graf-after--li">Rewind Replay: means to restart from an early point</li><li name="a56a" id="a56a" class="graf graf--li graf-after--li">Migration: means to restart</li></ul><p name="7df5" id="7df5" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">3. Inter-Process Communication</strong></p><p name="93d0" id="93d0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Types of Inter-Process Communication (IPC)</strong></p><ul class="postList"><li name="c059" id="c059" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Message-based (message pass) IPC</strong>: pipes, message queues, sockets</li><li name="f10c" id="f10c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Memory-based (shared memory) IPC</strong>: shared memory, memory-mapped files</li></ul><p name="2eeb" id="2eeb" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Pipes</strong></p><p name="568d" id="568d" class="graf graf--p graf-after--p">Pipes are characterized by only two processes can communicate at a time via the data stream.</p><figure name="a09b" id="a09b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*7JMLGDS6cFrhb5BB.png" data-width="1436" data-height="380" src="https://cdn-images-1.medium.com/max/800/0*7JMLGDS6cFrhb5BB.png"></figure><p name="b66e" id="b66e" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) Message Queue</strong></p><p name="b24f" id="b24f" class="graf graf--p graf-after--p">Message queue send and receive well-formatted messages between processes.</p><figure name="7d61" id="7d61" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*-76Y7d6Z8GSDDizw.png" data-width="1436" data-height="382" src="https://cdn-images-1.medium.com/max/800/0*-76Y7d6Z8GSDDizw.png"></figure><p name="c89d" id="c89d" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Sockets</strong></p><p name="9115" id="9115" class="graf graf--p graf-after--p">Socket is a way to communicate through different protocols by sending or receiving messages.</p><figure name="bfd5" id="bfd5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*kAvmFGMpC8IWJIfN.png" data-width="1436" data-height="594" src="https://cdn-images-1.medium.com/max/800/0*kAvmFGMpC8IWJIfN.png"></figure><p name="fc30" id="fc30" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Sys V Shared Memory IPC</strong></p><ul class="postList"><li name="a885" id="a885" class="graf graf--li graf-after--p">generate unique key: <code class="markup--code markup--li-code">ftok(pathname, proj_id)</code></li><li name="94ab" id="94ab" class="graf graf--li graf-after--li">create segments: <code class="markup--code markup--li-code">shmget(shmid, size, flag)</code></li><li name="8b98" id="8b98" class="graf graf--li graf-after--li">attach process: <code class="markup--code markup--li-code">shmaddr = shmat(shmid, addr, flags)</code></li><li name="32d3" id="32d3" class="graf graf--li graf-after--li">detach process: <code class="markup--code markup--li-code">shmdt(shmaddr)</code></li><li name="f8f0" id="f8f0" class="graf graf--li graf-after--li">destroy segments: <code class="markup--code markup--li-code">shmctl(shmid, cmd, buf)</code></li></ul><p name="6a69" id="6a69" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) POSIX Shared Memory IPC</strong></p><ul class="postList"><li name="76e8" id="76e8" class="graf graf--li graf-after--p">create files: <code class="markup--code markup--li-code">shm_open()</code></li><li name="56ca" id="56ca" class="graf graf--li graf-after--li">attach process: <code class="markup--code markup--li-code">mmap()</code></li><li name="42f4" id="42f4" class="graf graf--li graf-after--li">detach process: <code class="markup--code markup--li-code">unmmap()</code></li><li name="528f" id="528f" class="graf graf--li graf-after--li">detech all processes: <code class="markup--code markup--li-code">shm_close()</code></li><li name="199a" id="199a" class="graf graf--li graf-after--li">destroy allocated resources: <code class="markup--code markup--li-code">shm_unlink()</code></li></ul><p name="a79f" id="a79f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">4. Synchronization</strong></p><p name="9ee1" id="9ee1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Spinlocks</strong></p><p name="b867" id="b867" class="graf graf--p graf-after--p">Spinlock will be busy and spinning when locking, so it is different from the mutex.</p><p name="7721" id="7721" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Semaphores</strong></p><p name="91da" id="91da" class="graf graf--p graf-after--p">Semaphore is an integer number that will be block when the value equals 0. There are two operations on the semaphore,</p><ul class="postList"><li name="1066" id="1066" class="graf graf--li graf-after--p">wait: means to reduce 1</li><li name="fc8a" id="fc8a" class="graf graf--li graf-after--li">post: means to add 1</li></ul><p name="8941" id="8941" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Sys V Semaphore</strong></p><ul class="postList"><li name="6bc8" id="6bc8" class="graf graf--li graf-after--p">create semaphore: <code class="markup--code markup--li-code">sem_t sem;</code></li><li name="7080" id="7080" class="graf graf--li graf-after--li">initialize semaphore: <code class="markup--code markup--li-code">sem_init(&amp;sem, pshared, count);</code></li><li name="8d1d" id="8d1d" class="graf graf--li graf-after--li">semaphore wait: <code class="markup--code markup--li-code">sem_wait(&amp;sem);</code></li><li name="a898" id="a898" class="graf graf--li graf-after--li">semaphore post: <code class="markup--code markup--li-code">sem_post(&amp;sem);</code></li></ul><p name="6d63" id="6d63" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Semaphore-Mutex Implementation</strong></p><p name="e465" id="e465" class="graf graf--p graf-after--p">Mutex is a specific kind of semaphore. It is equivalent to,</p><pre name="d8ff" id="d8ff" class="graf graf--pre graf-after--p">sem_t mutex;<br>sem_init(&amp;mutex, 0, 1);</pre><p name="ea42" id="ea42" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(5) Read/Write Lock (RWlock)</strong></p><p name="f795" id="f795" class="graf graf--p graf-after--p">The read/write lock is a specific spinlock only for exclusive writes. This is simpler than using the condition variables.</p><p name="ac16" id="ac16" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Linux RWlock</strong></p><ul class="postList"><li name="9101" id="9101" class="graf graf--li graf-after--p">create rwlock: <code class="markup--code markup--li-code">rwlock_t rwlock;</code></li><li name="2a1b" id="2a1b" class="graf graf--li graf-after--li">read lock: <code class="markup--code markup--li-code">read_lock(&amp;rwlock);</code></li><li name="e558" id="e558" class="graf graf--li graf-after--li">read unlock: <code class="markup--code markup--li-code">read_unlock(&amp;rwlock);</code></li><li name="5a2d" id="5a2d" class="graf graf--li graf-after--li">write lock: <code class="markup--code markup--li-code">write_lock(&amp;rwlock);</code></li><li name="1629" id="1629" class="graf graf--li graf-after--li">write unlock: <code class="markup--code markup--li-code">write_unlock(&amp;rwlock);</code></li></ul><p name="cbae" id="cbae" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Monitors</strong></p><p name="abf7" id="abf7" class="graf graf--p graf-after--p">Monitor is a synchronization explicitly specify,</p><ul class="postList"><li name="0e05" id="0e05" class="graf graf--li graf-after--p">shared resources</li><li name="80d8" id="80d8" class="graf graf--li graf-after--li">entry procedures (read or write)</li><li name="261d" id="261d" class="graf graf--li graf-after--li">mutex locks</li><li name="82da" id="82da" class="graf graf--li graf-after--li">condition variables</li></ul><p name="1af4" id="1af4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) Other Synchronizations</strong></p><ul class="postList"><li name="1eef" id="1eef" class="graf graf--li graf-after--p">serializer: make it easier to define <strong class="markup--strong markup--li-strong">priority</strong>, hide explicit use of condition variable</li><li name="e524" id="e524" class="graf graf--li graf-after--li">path expressions: programmer specify <strong class="markup--strong markup--li-strong">regex</strong> captures the correct synchronization behavior</li><li name="eb83" id="eb83" class="graf graf--li graf-after--li">barriers: a barrier will block threads until it figures all of them reach a certain <strong class="markup--strong markup--li-strong">condition</strong></li><li name="df6a" id="df6a" class="graf graf--li graf-after--li">rendezvous points</li><li name="7460" id="7460" class="graf graf--li graf-after--li">optimistic wait-free synchronization (RCU)</li></ul><p name="a64e" id="a64e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(9) Atomic Instructions</strong></p><p name="1d8d" id="1d8d" class="graf graf--p graf-after--p">Atomic instructions are exclusively executed instructions. There are three types of them,</p><ul class="postList"><li name="72ff" id="72ff" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">test_and_set</code>: if fits the condition, then set the value</li><li name="371e" id="371e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">read_and_increment</code>: get the value, and then increase it</li><li name="ac46" id="ac46" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">compare_and_swap</code>: compare the values, and then swap them</li></ul><p name="c36e" id="c36e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(10) Shared Memory Processors (SMP)</strong></p><p name="27a9" id="27a9" class="graf graf--p graf-after--p">The SMP is a system that all the processors will share 1 or more main memory.</p><p name="cf66" id="cf66" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) Cache Memory Interactions</strong></p><ul class="postList"><li name="f89a" id="f89a" class="graf graf--li graf-after--p">Write allocate: means data writes in cache and memory</li><li name="2f33" id="2f33" class="graf graf--li graf-after--li">Non-write allocate: means data writes only in memory</li><li name="b761" id="b761" class="graf graf--li graf-after--li">Write through: directly write to the memory after write</li><li name="cf63" id="cf63" class="graf graf--li graf-after--li">Write back: delay write to the memory until being kicked out</li></ul><p name="a489" id="a489" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(12) Cache Coherence Policies</strong></p><ul class="postList"><li name="7a4e" id="7a4e" class="graf graf--li graf-after--p">Non-Cache-Coherent (NCC): cache coherence supported by software</li><li name="6c54" id="6c54" class="graf graf--li graf-after--li">Write Invalidate: simply invalidate copies of data after write by hardware</li><li name="94f2" id="94f2" class="graf graf--li graf-after--li">Write Update: update copies of data after write by hardware</li></ul><p name="bc00" id="bc00" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(13) Spinlock Performance</strong></p><ul class="postList"><li name="6358" id="6358" class="graf graf--li graf-after--p">Latency: low latency</li><li name="4f3b" id="4f3b" class="graf graf--li graf-after--li">Delay: low delay time</li><li name="2925" id="2925" class="graf graf--li graf-after--li">Contention: reduce traffic, but this conflict with the other two goals because we have to execute less atomic instructions</li></ul><p name="e7da" id="e7da" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(14) Spinlock Implementation</strong></p><p name="31a6" id="31a6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Method #1.</strong> Test-then-test Implementation</p><pre name="7496" id="7496" class="graf graf--pre graf-after--p">spinlock_lock(lock):<br>    while(test_and_set(lock) == busy);</pre><ul class="postList"><li name="efdd" id="efdd" class="graf graf--li graf-after--pre">low latency and low delay</li><li name="676a" id="676a" class="graf graf--li graf-after--li">high contention (bad)</li></ul><p name="f734" id="f734" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Method #2.</strong> Test-test-set Implementation</p><pre name="076c" id="076c" class="graf graf--pre graf-after--p">spinlock_lock(lock):<br>    while (1) {<br>        if (lock == free)<br>            while(test_and_set(lock) == busy);<br>        else<br>            while(lock == busy);      // wait for lock becomes free<br>    }</pre><ul class="postList"><li name="9c59" id="9c59" class="graf graf--li graf-after--pre">okay latency and delay</li><li name="30a9" id="30a9" class="graf graf--li graf-after--li">low contention for write update</li><li name="4735" id="4735" class="graf graf--li graf-after--li">high contention for write invalidate (bad)</li></ul><p name="add3" id="add3" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Method #3.</strong> Delay Spinlock</p><pre name="b5c4" id="b5c4" class="graf graf--pre graf-after--p">spinlock_lock(lock):<br>    while (1) {<br>        if (lock == free)<br>            while(test_and_set(lock) == busy);<br>        else {<br>            while(lock == busy);      // wait for lock becomes free<br>            delay();<br>        }  <br>    }</pre><p name="e8a9" id="e8a9" class="graf graf--p graf-after--pre">We can use the following two</p><ul class="postList"><li name="0100" id="0100" class="graf graf--li graf-after--p">static delay: delay static value like CPUid</li><li name="ef0d" id="ef0d" class="graf graf--li graf-after--li">dynamic delay: higher contention, large range, randomly choose</li></ul><p name="24b5" id="24b5" class="graf graf--p graf-after--li">The performance will be,</p><ul class="postList"><li name="9125" id="9125" class="graf graf--li graf-after--p">okay latency</li><li name="12a4" id="12a4" class="graf graf--li graf-after--li">static delay: unnecessary delay when low contention (bad)</li><li name="dcf7" id="dcf7" class="graf graf--li graf-after--li">dynamic delay: high contention and high delay when <code class="markup--code markup--li-code">test_and_set</code> fails (bad)</li></ul><p name="d9fe" id="d9fe" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Method #4.</strong> Queuing Spinlock (Anderson’s lock)</p><pre name="38be" id="38be" class="graf graf--pre graf-after--p">init:<br>    flags[0] = has_lock;<br>    flags[1 ... N-1] = must_wait;<br>    queuelast = 0;                    // global</pre><pre name="2039" id="2039" class="graf graf--pre graf-after--pre">lock:<br>    myplace = read_and_increment(queuelast);<br>    // spin<br>    while (flags[myplace%N] == must_wait);   <br>     <br>          // now in critical section    <br>     <br>    // finally reset the entry in the queue for next thread<br>    flags[myplace%N] = must_wait;</pre><pre name="40f3" id="40f3" class="graf graf--pre graf-after--pre">unlock:<br>    flags[myplace%N + 1] = has_lock;</pre><ul class="postList"><li name="4e68" id="4e68" class="graf graf--li graf-after--pre">high latency (bad): because inefficient <code class="markup--code markup--li-code">read_and_increment</code> instructions</li><li name="4160" id="4160" class="graf graf--li graf-after--li">good delay: no wait before next signal</li><li name="e128" id="e128" class="graf graf--li graf-after--li">good contention: <code class="markup--code markup--li-code">read_and_increment</code> is only executed once</li></ul><p name="eb22" id="eb22" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(15) Spinlock Implementations Performance</strong></p><figure name="61ff" id="61ff" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rLNz8TOUnI-vZPbAsteQFw.png" data-width="1454" data-height="540" src="https://cdn-images-1.medium.com/max/800/1*rLNz8TOUnI-vZPbAsteQFw.png"></figure><p name="e4e3" id="e4e3" class="graf graf--p graf-after--figure">Basic settings are,</p><ul class="postList"><li name="936c" id="936c" class="graf graf--li graf-after--p">1~20 processes</li><li name="deff" id="deff" class="graf graf--li graf-after--li">one process per core (1~20 cores)</li><li name="93e3" id="93e3" class="graf graf--li graf-after--li">overheads is compared with the ideal state (less means better)</li><li name="01b4" id="01b4" class="graf graf--li graf-after--li">write invalidate</li></ul><p name="872f" id="872f" class="graf graf--p graf-after--li">For more cores (higher load),</p><ul class="postList"><li name="747b" id="747b" class="graf graf--li graf-after--p">queuing lock is the best because good contention</li><li name="750d" id="750d" class="graf graf--li graf-after--li">test-test-set lock (i.e. spin on read) is the worst because of O(N²) high contention</li><li name="6ffe" id="6ffe" class="graf graf--li graf-after--li">static delay lock (i.e. static release/ref.) better than dynamic delay lock (i.e. backoff release/ref.) because there are less low contentions</li></ul><p name="c2ad" id="c2ad" class="graf graf--p graf-after--li">For less cores (lower load),</p><ul class="postList"><li name="d925" id="d925" class="graf graf--li graf-after--p">test-test-set lock is the best because low latency</li><li name="aed0" id="aed0" class="graf graf--li graf-after--li">queuing lock is the worst because of high latency</li><li name="670b" id="670b" class="graf graf--li graf-after--li">dynamic delay lock is better than static delay lock because of lower delay</li></ul><p name="b4ee" id="b4ee" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">5. I/O Devices</strong></p><p name="b59c" id="b59c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) I/O Devices Components</strong></p><ul class="postList"><li name="3cf5" id="3cf5" class="graf graf--li graf-after--p">control registers: includes status registers , command registers , data transfer registers</li><li name="b121" id="b121" class="graf graf--li graf-after--li">micro-controller</li><li name="1dc4" id="1dc4" class="graf graf--li graf-after--li">on-device memory</li><li name="a9c6" id="a9c6" class="graf graf--li graf-after--li">other logic</li></ul><p name="7e22" id="7e22" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Device to CPU Connnections</strong></p><ul class="postList"><li name="a894" id="a894" class="graf graf--li graf-after--p">Peripheral Component Interconnect Bus (PCI bus)</li><li name="a864" id="a864" class="graf graf--li graf-after--li">Peripheral Component Interconnect Express Bus (PCIe bus)</li><li name="d37e" id="d37e" class="graf graf--li graf-after--li">Peripheral Component Interconnect Extend Bus (PCI-X bus)</li></ul><p name="bf00" id="bf00" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Interconnects</strong></p><p name="377a" id="377a" class="graf graf--p graf-after--p">Interconnects are other connects relay on the PCI (main bus).</p><ul class="postList"><li name="7147" id="7147" class="graf graf--li graf-after--p">SCSI bus: for SCSI disks</li><li name="6346" id="6346" class="graf graf--li graf-after--li">Expansion/Perpherial Bus: keyboards, parallel port, serial port, etc.</li><li name="dcd6" id="dcd6" class="graf graf--li graf-after--li">Bridge Controller: connect different interconnects</li></ul><p name="08b5" id="08b5" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Device Drivers</strong></p><p name="74bc" id="74bc" class="graf graf--p graf-after--p">Device drivers are device-specific software components responsible for,</p><ul class="postList"><li name="e7f7" id="e7f7" class="graf graf--li graf-after--p">device access</li><li name="31f2" id="31f2" class="graf graf--li graf-after--li">device management</li><li name="7548" id="7548" class="graf graf--li graf-after--li">device control</li></ul><p name="12dc" id="12dc" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Types of Devices</strong></p><ul class="postList"><li name="127e" id="127e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Block Devices</strong>: blocked data like disks supports directly access</li><li name="69f5" id="69f5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Character Devices</strong>: get/put character data like keyboard</li><li name="c96b" id="c96b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Network Devices</strong>: stream data with flexible blocks</li></ul><p name="5902" id="5902" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) Device Files</strong></p><p name="580e" id="580e" class="graf graf--p graf-after--p">OS maintain abstractions of devices as device files in the file system. Common device file names are,</p><ul class="postList"><li name="2bda" id="2bda" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">tty</code> : special devices representing terminal stations</li><li name="c28c" id="c28c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sda</code> / <code class="markup--code markup--li-code">hda</code>: disks like hard drives, SSDs, CD-ROMs, etc.</li><li name="7500" id="7500" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">lp</code> : for printers</li><li name="910a" id="910a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">mem</code> : access to the physical memory</li><li name="86a7" id="86a7" class="graf graf--li graf-after--li">etc.</li></ul><p name="aac1" id="aac1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Pseudo Device</strong></p><p name="aa14" id="aa14" class="graf graf--p graf-after--p">Linux also supports what is called pseudo or virtual devices like,</p><ul class="postList"><li name="0c6e" id="0c6e" class="graf graf--li graf-after--p">blackhole: <code class="markup--code markup--li-code">/dev/null</code></li><li name="32d7" id="32d7" class="graf graf--li graf-after--li">random string: <code class="markup--code markup--li-code">/dev/random</code></li></ul><p name="1430" id="1430" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) CPU-to-Device Interactions</strong></p><ul class="postList"><li name="4962" id="4962" class="graf graf--li graf-after--p">Memory Mapped I/O: CPU write to device file and PCI send to file</li><li name="f627" id="f627" class="graf graf--li graf-after--li">I/O Port Model: special instructions for accessing a particular device</li><li name="9dfc" id="9dfc" class="graf graf--li graf-after--li">Programmed I/O: CPU directly write command and data to device registers</li><li name="efb5" id="efb5" class="graf graf--li graf-after--li">Direct Memory Access: CPU directly write command to device registers but data is written from the memory based on the DMA controller. We don’t have to send commands many times</li></ul><p name="fdeb" id="fdeb" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(9) Device-to-CPU Interactions</strong></p><ul class="postList"><li name="9fb1" id="9fb1" class="graf graf--li graf-after--p">Interrupt: generate an interrupt to CPU</li><li name="fbc7" id="fbc7" class="graf graf--li graf-after--li">Poll: send the device register values to CPU</li></ul><p name="3807" id="3807" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(10) Device Access Procedure</strong></p><ul class="postList"><li name="a510" id="a510" class="graf graf--li graf-after--p">perform a system call</li><li name="3f56" id="3f56" class="graf graf--li graf-after--li">run the in-kernel stack</li><li name="d4b9" id="d4b9" class="graf graf--li graf-after--li">invoke the appropriate driver</li><li name="86d2" id="86d2" class="graf graf--li graf-after--li">performs the configuration of the request to the device</li><li name="4166" id="4166" class="graf graf--li graf-after--li">perform the request</li><li name="e5ab" id="e5ab" class="graf graf--li graf-after--li">send back results</li></ul><figure name="fc6b" id="fc6b" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*PwhpPBZLKdwcCMAf.png" data-width="1682" data-height="522" src="https://cdn-images-1.medium.com/max/800/0*PwhpPBZLKdwcCMAf.png"></figure><p name="f135" id="f135" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(11) OS Bypass</strong></p><p name="ca0d" id="ca0d" class="graf graf--p graf-after--p">It’s not necessary to access a device in the kernel mode. Instead, we can used some library supported device accesses, and this is called the OS bypass.</p><figure name="b1ab" id="b1ab" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*hg0POiErqiNye755.png" data-width="1682" data-height="522" src="https://cdn-images-1.medium.com/max/800/0*hg0POiErqiNye755.png"></figure><p name="e998" id="e998" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(12) Synchronous Access and Asynchronous Access</strong></p><ul class="postList"><li name="1b2c" id="1b2c" class="graf graf--li graf-after--p">Synchronous Access: Block the process when accessing a device</li><li name="0f3c" id="0f3c" class="graf graf--li graf-after--li">Asynchronous Access: Not block the process when accessing a device</li></ul><p name="243d" id="243d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(13) Block Device Access Procedure</strong></p><ul class="postList"><li name="97cd" id="97cd" class="graf graf--li graf-after--p">User Process: Files</li><li name="cd80" id="cd80" class="graf graf--li graf-after--li">Kernel: File system</li><li name="f769" id="f769" class="graf graf--li graf-after--li">Driver: Generic block layer that is different types of disks</li><li name="40b3" id="40b3" class="graf graf--li graf-after--li">Device: Different types of disks</li></ul><p name="381d" id="381d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(14) Virtual File System (VFS)</strong></p><p name="6879" id="6879" class="graf graf--p graf-after--p">We use virtual file systems because Linux wants to support different file systems.</p><p name="1bdd" id="1bdd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(15) VFS interface</strong></p><p name="9207" id="9207" class="graf graf--p graf-after--p">All the different file system details will be hidden by a virtual file system interface.</p><figure name="7cea" id="7cea" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*NHsO8GU9B6Lq8NsQ.png" data-width="1452" data-height="518" src="https://cdn-images-1.medium.com/max/800/0*NHsO8GU9B6Lq8NsQ.png"></figure><p name="8a20" id="8a20" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(16) Files</strong></p><p name="de15" id="de15" class="graf graf--p graf-after--p">Files are the basic data elements on which VFS operates and the OS describes files as file descripters.</p><p name="7ae1" id="7ae1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(17) Inode</strong></p><p name="8545" id="8545" class="graf graf--p graf-after--p">Inodes are the true file alias that the Linux OS uses because the machine can not understand file names. Each inode can be mapped to a specific file.</p><p name="5fd1" id="5fd1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(18) Directory</strong></p><p name="4922" id="4922" class="graf graf--p graf-after--p">A directory in Linux is a file with its contents including file path — inode pairs called dentry (directory entry).</p><p name="dd66" id="dd66" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(19) Inode Data Structure</strong></p><p name="49a5" id="49a5" class="graf graf--p graf-after--p">The inode contains some important information like,</p><ul class="postList"><li name="5e84" id="5e84" class="graf graf--li graf-after--p">list of all data blocks</li><li name="53bb" id="53bb" class="graf graf--li graf-after--li">permission</li><li name="111f" id="111f" class="graf graf--li graf-after--li">size of the file</li><li name="6250" id="6250" class="graf graf--li graf-after--li">whether lock or not</li><li name="cab3" id="cab3" class="graf graf--li graf-after--li">etc.</li></ul><p name="6da9" id="6da9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(20) Dentry Cache</strong></p><p name="1b12" id="1b12" class="graf graf--p graf-after--p">This is used to speedup the dentry search.</p><p name="43ec" id="43ec" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(21) EXT2 File System</strong></p><ul class="postList"><li name="165d" id="165d" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Boot Block</strong>: code to boot the computer</li><li name="2746" id="2746" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Block Groups</strong>: the storage is divided into block groups</li><li name="5179" id="5179" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Superblock</strong>: info about the overall block group (# of inodes, # of disk blocks, the start of the free blocks)</li><li name="5b00" id="5b00" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Group Descriptor</strong>: overall block group state (bitmaps, # of free nodes, total #of directories)</li><li name="7799" id="7799" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Bitmaps</strong>: used to quickly find a free block or a free inode</li><li name="5fc1" id="5fc1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Inodes</strong>: each is a 128-byte long data structure that describes exactly 1 file (the owner of the file, accounting information, etc.)</li></ul><figure name="2061" id="2061" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*4D9_VqR1xfC8u8Tj.png" data-width="1413" data-height="194" src="https://cdn-images-1.medium.com/max/800/0*4D9_VqR1xfC8u8Tj.png"></figure><p name="4c3d" id="4c3d" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(22) Inode for Data</strong></p><p name="62a6" id="62a6" class="graf graf--p graf-after--p">Because the inode of a file contains a list of all data blocks of a file, we can read from these blocks to get the file data. However, the file size is limited by the inode list length.</p><figure name="c720" id="c720" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*7FaO_Yug8NfbIwV1.png" data-width="1376" data-height="364" src="https://cdn-images-1.medium.com/max/800/0*7FaO_Yug8NfbIwV1.png"></figure><p name="336a" id="336a" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(23) Inode with Indirect Pointers</strong></p><p name="9459" id="9459" class="graf graf--p graf-after--p">Indirect pointers can be used for inodes to store a file with a much larger size.</p><figure name="4931" id="4931" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*58If489-vNUjLnq3.png" data-width="1514" data-height="640" src="https://cdn-images-1.medium.com/max/800/0*58If489-vNUjLnq3.png"></figure><p name="f110" id="f110" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(24) Disk Access Optimization</strong></p><p name="32eb" id="32eb" class="graf graf--p graf-after--p">FS use several techniques to reduce the disk access and disk overheads,</p><ul class="postList"><li name="d712" id="d712" class="graf graf--li graf-after--p">caching: reduce access</li><li name="d861" id="d861" class="graf graf--li graf-after--li">prefetching: reduce access</li><li name="10fb" id="10fb" class="graf graf--li graf-after--li">journaling: reduce random access</li><li name="8cef" id="8cef" class="graf graf--li graf-after--li">I/O scheduling: reduce disk head movements</li></ul><p name="1609" id="1609" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">6. Virtualization</strong></p><p name="1166" id="1166" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Virtual Machine</strong></p><p name="72aa" id="72aa" class="graf graf--p graf-after--p">Each operating system together with its applications as well as the virtual resources that it pings at us is called a virtual machine.</p><p name="b6a0" id="b6a0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Virtual Machine Monitor (VMM)</strong></p><p name="7dca" id="7dca" class="graf graf--p graf-after--p">The virtual machine is taken to be an efficient, isolated, duplicate of the real machine, which is supported by a virtual machine monitor (VMM). The VMM is actually the layer that enables VMs to exist. It has the following characters,</p><ul class="postList"><li name="b14b" id="b14b" class="graf graf--li graf-after--p">essentially identical to the original machine</li><li name="90f1" id="90f1" class="graf graf--li graf-after--li">minor decrease in program speed</li><li name="970d" id="970d" class="graf graf--li graf-after--li">complete control of the system resources</li></ul><p name="1065" id="1065" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Virtualization Reasons</strong></p><ul class="postList"><li name="9de1" id="9de1" class="graf graf--li graf-after--p">Consolidation</li><li name="ce40" id="ce40" class="graf graf--li graf-after--li">Migration</li><li name="1958" id="1958" class="graf graf--li graf-after--li">Security</li><li name="fc78" id="fc78" class="graf graf--li graf-after--li">Debugging</li><li name="442f" id="442f" class="graf graf--li graf-after--li">Legacy OS</li><li name="41f4" id="41f4" class="graf graf--li graf-after--li">etc.</li></ul><p name="0274" id="0274" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Bare-Metal Virtualization (BMV) Model</strong></p><p name="99c2" id="99c2" class="graf graf--p graf-after--p">If all VMs rely only on the VMM, then it is called a bare-metal virtualization model.</p><figure name="6448" id="6448" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*qFgVAff5B4ND7eVZ.png" data-width="1514" data-height="544" src="https://cdn-images-1.medium.com/max/800/0*qFgVAff5B4ND7eVZ.png"></figure><p name="c2fd" id="c2fd" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Bare-Metal Virtualization (BMV) with Service VM</strong></p><p name="ba0a" id="ba0a" class="graf graf--p graf-after--p">If we have a privilege standard service OS control, manage, and configuring the VMM and other VMs, then it is called a BMV with Service VM. For example, Xen (service VM is <code class="markup--code markup--p-code">dom0</code>), and VMware ESX (service VM are remote APIs).</p><figure name="6d04" id="6d04" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*VUKI9CzodvPLe7Az.png" data-width="1514" data-height="848" src="https://cdn-images-1.medium.com/max/800/0*VUKI9CzodvPLe7Az.png"></figure><p name="d84a" id="d84a" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) Hosted Virtualization Model</strong></p><p name="9167" id="9167" class="graf graf--p graf-after--p">If at the lowest level of the hosted model, there is a full-fledged host OS that manages all of the hardware resources, then this is called a hosted virtualization model. For example, KVM (hardware virtualized by QEMU).</p><figure name="a5ed" id="a5ed" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*MDRTVX6J-20CY30C.png" data-width="1514" data-height="532" src="https://cdn-images-1.medium.com/max/800/0*MDRTVX6J-20CY30C.png"></figure><p name="8a46" id="8a46" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(7) Protection Levels for Virtualization</strong></p><p name="17d8" id="17d8" class="graf graf--p graf-after--p">We have two ways for virtualization protection. We can,</p><ul class="postList"><li name="c604" id="c604" class="graf graf--li graf-after--p">If all in the non-root mode,</li></ul><figure name="06f0" id="06f0" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*Jf_vU13SoPtqgBef.png" data-width="1514" data-height="524" src="https://cdn-images-1.medium.com/max/800/0*Jf_vU13SoPtqgBef.png"></figure><ul class="postList"><li name="2bb0" id="2bb0" class="graf graf--li graf-after--figure">If all in the root mode,</li></ul><figure name="dcc8" id="dcc8" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*reAXPyv6giiB4W8H.png" data-width="1570" data-height="1092" src="https://cdn-images-1.medium.com/max/800/0*reAXPyv6giiB4W8H.png"></figure><p name="ed65" id="ed65" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(8) VMexits and VMentry</strong></p><p name="23ed" id="23ed" class="graf graf--p graf-after--p">Attempts by the guest OS to perform privileged operations are called VMexits. When the hypervisor completes its operation, it passes control back to the virtual machine by performing a VMentry.</p><figure name="d430" id="d430" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*xKZJF4PGpR1wmHYG.png" data-width="1570" data-height="1092" src="https://cdn-images-1.medium.com/max/800/0*xKZJF4PGpR1wmHYG.png"></figure><p name="79c9" id="79c9" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(9) CPU Virtualization</strong></p><ul class="postList"><li name="6dcb" id="6dcb" class="graf graf--li graf-after--p">Trap-and-Emulate Technique: trap to the supervisor, see illegal or legal before emulation. It has a problem because instructions at that time has no trap.</li></ul><figure name="a73f" id="a73f" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*z2RM1W5O0e_y8N9V.png" data-width="1368" data-height="298" src="https://cdn-images-1.medium.com/max/800/0*z2RM1W5O0e_y8N9V.png"></figure><ul class="postList"><li name="58b0" id="58b0" class="graf graf--li graf-after--figure">Binary Translation Technique: use software to detect the instructions that should be trapped</li></ul><figure name="c044" id="c044" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*x69cOTMsAETUJk1W.png" data-width="1368" data-height="452" src="https://cdn-images-1.medium.com/max/800/0*x69cOTMsAETUJk1W.png"></figure><ul class="postList"><li name="3fe2" id="3fe2" class="graf graf--li graf-after--figure">Full Virtualization: VM doesn’t know it’s virtual.</li><li name="8eb7" id="8eb7" class="graf graf--li graf-after--li">Paravirtualization: VM knows it’s virtual so that they can all hypercalls to access the hypervisor. This is popularized by Xen.</li></ul><p name="c812" id="c812" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(10) Memory Virtualization</strong></p><ul class="postList"><li name="de40" id="de40" class="graf graf--li graf-after--p">Direct Translation: Direct translation from VA (VMapplication) to PA(VMOS) to MA (hypervisor). Expensive.</li><li name="0d42" id="0d42" class="graf graf--li graf-after--li">Shadow Page Table: Create shadow page table mapping VA to MA.</li><li name="3d35" id="3d35" class="graf graf--li graf-after--li">Paravirtualization: No need for the ordinary page table, just a shadow page table is okay and it can use hypercalls to update the shadow page table.</li></ul><p name="16d8" id="16d8" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(11) Device Virtualization</strong></p><ul class="postList"><li name="5f7f" id="5f7f" class="graf graf--li graf-after--p">Passthrough Model: get to the device register directly. Exclusive and hard to share</li><li name="4e9e" id="4e9e" class="graf graf--li graf-after--li">Hypervisor-Direct Model: get to device register by VMM. Easy to share but complex and slow</li><li name="542a" id="542a" class="graf graf--li graf-after--li">Split Device Driver Model: get to device register by service VM (not through VMM). Reduce overheads and have better management</li></ul><p name="3df7" id="3df7" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">7. RPC, DFS, DSM, and Cloud Computing</strong></p><p name="05ec" id="05ec" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Remote Procedure Calls (RPC)</strong></p><p name="8471" id="8471" class="graf graf--p graf-after--p">RPC is an IPC mechanism for cross-machine interactions. It has the complexity of sockets by providing high-level procedure call interfaces.</p><p name="483f" id="483f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Client Stub</strong></p><p name="c25c" id="c25c" class="graf graf--p graf-after--p">It seems like an ordinary function in the client but what it does is integrating information in a buffer and send it to the server.</p><p name="5cd8" id="5cd8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Server Stub</strong></p><p name="a573" id="a573" class="graf graf--p graf-after--p">It seems like a function in the server but what it does is unpacking messages from the server, conduct the operation and send the result back.</p><p name="f284" id="f284" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) RPC 9 Steps</strong></p><ul class="postList"><li name="fb0a" id="fb0a" class="graf graf--li graf-after--p">Register: server construct with basic information</li><li name="bde9" id="bde9" class="graf graf--li graf-after--li">Bind: client finds the server by a database called registry</li><li name="0c7f" id="0c7f" class="graf graf--li graf-after--li">Call: client pass information to the client stub</li><li name="9eaf" id="9eaf" class="graf graf--li graf-after--li">Marshal: client stub integrate information into the buffer</li><li name="796d" id="796d" class="graf graf--li graf-after--li">Send: the client sends the message buffer to the server</li><li name="e827" id="e827" class="graf graf--li graf-after--li">Receive: server receives the message</li><li name="c02f" id="c02f" class="graf graf--li graf-after--li">Unmarshal: the server stub unpacks the message into information</li><li name="2fee" id="2fee" class="graf graf--li graf-after--li">Actual call: get arguments from the information and conduct an actual procedure call</li><li name="b528" id="b528" class="graf graf--li graf-after--li">Result: server stub sends the result back in a message</li></ul><p name="7423" id="7423" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Interface Definition Language (IDL)</strong></p><p name="663d" id="663d" class="graf graf--p graf-after--p">IDLs serve as a protocol of how the agreement of client and server will be expressed. This is useful because the client and server may be written by different developers in different languages.</p><ul class="postList"><li name="85b3" id="85b3" class="graf graf--li graf-after--p">Language-agnostic IDL: XDR</li><li name="6281" id="6281" class="graf graf--li graf-after--li">Language-specific IDL: Java RMI</li></ul><p name="c7cc" id="c7cc" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) IDL Content</strong></p><p name="9545" id="9545" class="graf graf--p graf-after--p">IDL is an agreement between the server and client, which should contain information like,</p><ul class="postList"><li name="cc1f" id="cc1f" class="graf graf--li graf-after--p">procedure names</li><li name="8cc7" id="8cc7" class="graf graf--li graf-after--li">argument types</li><li name="0375" id="0375" class="graf graf--li graf-after--li">result types</li><li name="7c79" id="7c79" class="graf graf--li graf-after--li">version number</li></ul><p name="648d" id="648d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) RPC Pointers</strong></p><p name="e37c" id="e37c" class="graf graf--p graf-after--p">Passing merely the pointers in a client is useless for the server, so a proper RPC will also pass the data structure related to that pointer called serializing.</p><p name="96d0" id="96d0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) RPC Failures</strong></p><p name="c19f" id="c19f" class="graf graf--p graf-after--p">Because RPC is unlikely to provide a detailed error, we will use the error notifications without claiming the details.</p><p name="3e11" id="3e11" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Distributed File System</strong></p><p name="4781" id="4781" class="graf graf--p graf-after--p">DFS is remote file systems supported by VFS over the network.</p><p name="ac23" id="ac23" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) 2 Types of DFS Models</strong></p><ul class="postList"><li name="df23" id="df23" class="graf graf--li graf-after--p">Server Model: DFS is on the server, centralized and difficult to scale</li><li name="e03b" id="e03b" class="graf graf--li graf-after--li">Peer Model: DFS is on the other machines, easy to scale by adding machines</li></ul><p name="601b" id="601b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(11) Types of Remote File Services (RFS)</strong></p><ul class="postList"><li name="db28" id="db28" class="graf graf--li graf-after--p">Upload-Download Model (UDM): means download, operate, upload. Quick operations but server loses control</li><li name="90b3" id="90b3" class="graf graf--li graf-after--li">True Remote File Access Model (TRFAM): means RPC, operate, download when necessary. Slow and easily overloaded</li><li name="efab" id="efab" class="graf graf--li graf-after--li">Remote File Service/Access Model (RFAM): a combination of UDM and TRFAM. If the client has data in local memory, operate, broadcast, upload when kicked out. If the client doesn’t have data in local memory, RPC, operate, download when necessary.</li></ul><p name="49fa" id="49fa" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(12) Types of Servers</strong></p><ul class="postList"><li name="9bc7" id="9bc7" class="graf graf--li graf-after--p">Stateless server: server doesn’t contain state information from the client. Need self-described messages from the client</li><li name="8e9b" id="8e9b" class="graf graf--li graf-after--li">Stated server: server contains state information from the client. Need Checkpointing</li></ul><p name="aeb0" id="aeb0" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(13) DFS Cache Coherence</strong></p><p name="c94f" id="c94f" class="graf graf--p graf-after--p">We have to maintain state information of caches on the client and server by file-sharing policies called semantics.</p><ul class="postList"><li name="276f" id="276f" class="graf graf--li graf-after--p">Session Semantics: write back when close, get the latest by open</li><li name="3b09" id="3b09" class="graf graf--li graf-after--li">Periodic Updates: write back periodically, get the latest by open</li><li name="7ab0" id="7ab0" class="graf graf--li graf-after--li">Immutable Files: simply only-read policy</li><li name="5348" id="5348" class="graf graf--li graf-after--li">Transaction: API supported policies</li></ul><p name="aadc" id="aadc" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(14) DFS Replication</strong></p><p name="821a" id="821a" class="graf graf--p graf-after--p">There are two ways for DFS replication because we need some fault tolerance,</p><ul class="postList"><li name="c3f3" id="c3f3" class="graf graf--li graf-after--p">Replication: extra servers for a copy of all the files</li><li name="b5b2" id="b5b2" class="graf graf--li graf-after--li">Partitioning: each server stores only a part of all the files</li></ul><p name="c343" id="c343" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(15) DFS Examples</strong></p><ul class="postList"><li name="35d7" id="35d7" class="graf graf--li graf-after--p">NFSv3: stateless</li><li name="44b4" id="44b4" class="graf graf--li graf-after--li">NFSv4: stated</li><li name="404f" id="404f" class="graf graf--li graf-after--li">Sprit DFS: periodic updates</li></ul><p name="1fd4" id="1fd4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(16) DSM</strong></p><p name="6992" id="6992" class="graf graf--p graf-after--p">DSM is a service that manages the memory across multiple nodes.</p><ul class="postList"><li name="6a34" id="6a34" class="graf graf--li graf-after--p">Hardware Supported DSM: supported NIC</li><li name="5b71" id="5b71" class="graf graf--li graf-after--li">Software Supported DSM</li></ul><p name="dd80" id="dd80" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(17) Memory Sharing Granularity</strong></p><ul class="postList"><li name="4da0" id="4da0" class="graf graf--li graf-after--p">Variables: bad</li><li name="54cd" id="54cd" class="graf graf--li graf-after--li">Pages or Objects: better, but will have false sharing problems.</li></ul><p name="1b74" id="1b74" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(18) Memory Access Algorithms</strong></p><ul class="postList"><li name="72c3" id="72c3" class="graf graf--li graf-after--p">Single reader, single writer (SRSW): simplest but not commonly used</li><li name="7767" id="7767" class="graf graf--li graf-after--li">Multiple readers, single writer (MRSW) or Multiple readers, multiple writers (MRMW): should maintain write order and consistency</li></ul><p name="889d" id="889d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(19) DSM Performance Metrics</strong></p><p name="15e0" id="15e0" class="graf graf--p graf-after--p">The main metric for measuring DSM performance is the latency.</p><p name="0d32" id="0d32" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(20) DSM Optimization</strong></p><ul class="postList"><li name="3a8b" id="3a8b" class="graf graf--li graf-after--p">Migration: if access then move</li><li name="789b" id="789b" class="graf graf--li graf-after--li">Replication: if access then copy</li></ul><p name="7b6f" id="7b6f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(21) DSM Consistency</strong></p><ul class="postList"><li name="a665" id="a665" class="graf graf--li graf-after--p">push invalidations when write</li><li name="a22b" id="a22b" class="graf graf--li graf-after--li">pull periodically on demand</li></ul><p name="5084" id="5084" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(22) Memory Consistency Models</strong></p><ul class="postList"><li name="9917" id="9917" class="graf graf--li graf-after--p">Strict Consistency: all accesses strictly in the give sequence</li><li name="ffb0" id="ffb0" class="graf graf--li graf-after--li">Sequential Consistency: different processes see accesses in the same order</li><li name="eda5" id="eda5" class="graf graf--li graf-after--li">Causal Consistency: one process sees accesses in order</li><li name="c82f" id="c82f" class="graf graf--li graf-after--li">Weak Consistency: no consistency guarantee, need synchronization</li></ul><p name="9c8d" id="9c8d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(23) Types of Internet Services</strong></p><ul class="postList"><li name="ef85" id="ef85" class="graf graf--li graf-after--p">presentations: static</li><li name="7847" id="7847" class="graf graf--li graf-after--li">business logic: dynamic</li><li name="3da9" id="3da9" class="graf graf--li graf-after--li">database tier: data storage and management</li></ul><p name="d76b" id="d76b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(24) Cloud Computing Functions</strong></p><ul class="postList"><li name="ef72" id="ef72" class="graf graf--li graf-after--p">shared resources</li><li name="d7c8" id="d7c8" class="graf graf--li graf-after--li">APIs for different services</li><li name="d10a" id="d10a" class="graf graf--li graf-after--li">billing and accounting</li></ul><p name="4294" id="4294" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(25) Cloud Deployment Models</strong></p><ul class="postList"><li name="18ba" id="18ba" class="graf graf--li graf-after--p">public model</li><li name="c6d5" id="c6d5" class="graf graf--li graf-after--li">private model</li><li name="90be" id="90be" class="graf graf--li graf-after--li">hybrid model</li><li name="8534" id="8534" class="graf graf--li graf-after--li">community model</li></ul><p name="b6e9" id="b6e9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(26) Cloud Service Models</strong></p><ul class="postList"><li name="bc7b" id="bc7b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Infrasture as a service</strong> (aka. <strong class="markup--strong markup--li-strong">IaaS</strong>) Model: Amazon EC2</li><li name="4b53" id="4b53" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Platform as a service</strong> (aka. <strong class="markup--strong markup--li-strong">PaaS</strong>) Model: google APPs</li><li name="61c1" id="61c1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Software as a service</strong> (aka. <strong class="markup--strong markup--li-strong">SaaS</strong>) Model: Gmail</li></ul><p name="2f9f" id="2f9f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(27) Cloud Requirements</strong></p><ul class="postList"><li name="27ce" id="27ce" class="graf graf--li graf-after--p">fungible resources</li><li name="ca2c" id="ca2c" class="graf graf--li graf-after--li">elasticity and flexibility</li><li name="3243" id="3243" class="graf graf--li graf-after--li">scalability</li><li name="f8b1" id="f8b1" class="graf graf--li graf-after--li">failure tolerance and exception handling</li><li name="3fca" id="3fca" class="graf graf--li graf-after--li">isolation for multi-tenancy</li><li name="61a8" id="61a8" class="graf graf--li graf-after--li">security</li></ul><p name="f5cb" id="f5cb" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(30) Cloud Technique Implementations</strong></p><ul class="postList"><li name="418c" id="418c" class="graf graf--li graf-after--p">Virtualization</li><li name="a31f" id="a31f" class="graf graf--li graf-after--li">Resource provisioning</li><li name="8baa" id="8baa" class="graf graf--li graf-after--li">Big Data</li><li name="94d9" id="94d9" class="graf graf--li graf-after--li">Software</li><li name="5f71" id="5f71" class="graf graf--li graf-after--li graf--trailing">Monitoring</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/983a380242ba"><time class="dt-published" datetime="2021-05-03T19:40:24.867Z">May 3, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-28-final-review-for-outlines-983a380242ba" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>