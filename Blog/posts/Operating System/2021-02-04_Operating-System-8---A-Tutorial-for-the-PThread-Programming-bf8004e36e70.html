<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 8 | A Tutorial for the PThread Programming</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 8 | A Tutorial for the PThread Programming</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="bcb2" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="76e2" id="76e2" class="graf graf--h3 graf--leading graf--title">Operating System 8 | A Tutorial for the PThread Programming</h3><figure name="38bf" id="38bf" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*q3b7G95zDTLqCKx1.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*q3b7G95zDTLqCKx1.png"></figure><ol class="postList"><li name="cd17" id="cd17" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">PThreads Basis</strong></li></ol><p name="7cfb" id="7cfb" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of PThreads</strong></p><p name="0f84" id="0f84" class="graf graf--p graf-after--p">Birrel’s paper talked about threads in a general way. However, PThreads is a very concrete multithreading system and it is the default standard in the UNIX system. <strong class="markup--strong markup--p-strong">PThreads</strong> stands for POSIX threads, and <strong class="markup--strong markup--p-strong">POSIX</strong> means <strong class="markup--strong markup--p-strong">Portable Operating System Interface</strong>, which is a kind of interface that the operating system needs to support. Within POSIX, PThreads describes the threading APIs the operating system needs to support.</p><p name="bd74" id="bd74" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) PThread Headers</strong></p><p name="3aa4" id="3aa4" class="graf graf--p graf-after--p">In order to use the PThread interfaces, we have to include the header <code class="markup--code markup--p-code">pthread.h</code> at the beginning of the CPP script,</p><pre name="f40d" id="f40d" class="graf graf--pre graf-after--p">#include &lt;pthread.h&gt;</pre><p name="66dd" id="66dd" class="graf graf--p graf-after--pre">What’s more, we can also import some other headers for some other purposes,</p><ul class="postList"><li name="4560" id="4560" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">iostream</code> because then we can use the I/O stream</li><li name="66b3" id="66b3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">unistd.h</code> because then we can use the <code class="markup--code markup--li-code">sleep</code> function</li><li name="b679" id="b679" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">errno.h</code> because then we can have detailed errors</li></ul><p name="6a0d" id="6a0d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) PThread Creation</strong></p><p name="d491" id="d491" class="graf graf--p graf-after--p">From Birrel’s paper, we have known that we can create a thread by <code class="markup--code markup--p-code">fork</code>. So,</p><pre name="a630" id="a630" class="graf graf--pre graf-after--p">hThread = fork(proc, args)</pre><p name="08ed" id="08ed" class="graf graf--p graf-after--pre">where <code class="markup--code markup--p-code">hTread</code> is the handler of our created thread, <code class="markup--code markup--p-code">proc</code> is the program counter that we want to assign for the new thread, and <code class="markup--code markup--p-code">args</code> is some other arguments for our new thread.</p><p name="aaf1" id="aaf1" class="graf graf--p graf-after--p">For PThread, we should use the <code class="markup--code markup--p-code">pthread_create</code> call to create a thread. While the return value of this call is the error value (return 1 if the creation fails) instead of the handler, we have to manually create a handler by <code class="markup--code markup--p-code">pthread_t</code> type (this is actually defined by <code class="markup--code markup--p-code">typedef unsigned long int pthread_t;</code>),</p><pre name="4a46" id="4a46" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">pthread_t hThread;</code></pre><p name="67d4" id="67d4" class="graf graf--p graf-after--pre">And then transfer this handler to the <code class="markup--code markup--p-code">pthread_create</code> call, which has a synopsis of,</p><pre name="6c47" id="6c47" class="graf graf--pre graf-after--p">int pthread_create(pthread_t *thread,<br>                   const pthread_attr_t *attr,<br>                   void *(*start_routine) (void *),          <br>                   void *arg);</pre><p name="fdb6" id="fdb6" class="graf graf--p graf-after--pre">where <code class="markup--code markup--p-code">thread</code> should be the address of our handler, <code class="markup--code markup--p-code">pthread_attr_t</code> is a data structure that we can specify something about our PThread, <code class="markup--code markup--p-code">start_routine</code> should be the program counter we would like to assign for this thread (similar to <code class="markup--code markup--p-code">proc</code>), and <code class="markup--code markup--p-code">arg</code> is for some other arguments (similar to <code class="markup--code markup--p-code">args</code>).</p><p name="ec53" id="ec53" class="graf graf--p graf-after--p">To create our new thread, we can directly call,</p><pre name="37cb" id="37cb" class="graf graf--pre graf-after--p">pthread_create(&amp;hThread, NULL, thread, NULL);</pre><p name="94f5" id="94f5" class="graf graf--p graf-after--pre">Where <code class="markup--code markup--p-code">hThread</code> is the handler that we have initialized and <code class="markup--code markup--p-code">thread</code> is the function for the new thread to start with. We assign <code class="markup--code markup--p-code">NULL</code> (means to use default values) for both the <code class="markup--code markup--p-code">arg</code> and the <code class="markup--code markup--p-code">attr</code> because we don’t want to specify these values now.</p><p name="bff0" id="bff0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) PThread Termination</strong></p><p name="cede" id="cede" class="graf graf--p graf-after--p">For Birrel’s paper, we have also talked about the <code class="markup--code markup--p-code">join</code> function, which allows one thread to wait until another thread completes its execution. For example,</p><pre name="9fb1" id="9fb1" class="graf graf--pre graf-after--p">ret = join(hThread);</pre><p name="0d4c" id="0d4c" class="graf graf--p graf-after--pre">is used to suspend the current thread until the <code class="markup--code markup--p-code">hThread</code> thread finishes.</p><p name="394c" id="394c" class="graf graf--p graf-after--p">For PThread, we have <code class="markup--code markup--p-code">pthread_join</code> to do exactly the same thing. The synopsis of this call is,</p><pre name="28ed" id="28ed" class="graf graf--pre graf-after--p">int pthread_join(pthread_t thread, void **value_ptr);</pre><p name="bc4a" id="bc4a" class="graf graf--p graf-after--pre">To terminate a thread with a handler <code class="markup--code markup--p-code">hThread</code>, we can directly call,</p><pre name="e8b9" id="e8b9" class="graf graf--pre graf-after--p">pthread_join(hThread, NULL);</pre><p name="550a" id="550a" class="graf graf--p graf-after--pre">We assign <code class="markup--code markup--p-code">NULL</code> (means to use default values) for <code class="markup--code markup--p-code">value_ptr</code> because we don’t want to specify this value now.</p><p name="dada" id="dada" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Example Code 1: PThread Creation and Termination</strong></p><p name="766d" id="766d" class="graf graf--p graf-after--p">Now, let’s implement our first code example. The purpose of this <code class="markup--code markup--p-code">CAT.cpp</code> code is quite simple. We ought to create a new thread by the current thread, and then we suspend the current thread and wait for the complement of the newly created thread.</p><p name="6149" id="6149" class="graf graf--p graf-after--p">To test your code, you may need to run,</p><pre name="b038" id="b038" class="graf graf--pre graf-after--p">$ g++ -Wall -lpthread CAT.cpp -o CAT &amp;&amp; ./CAT</pre><p name="21ac" id="21ac" class="graf graf--p graf-after--pre">Or you can use the <code class="markup--code markup--p-code">Makefile</code> file as follows,</p><figure name="4b6e" id="4b6e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/c6bd2bd8cd9b3c537a820557b78afd86.js"></script></figure><p name="e045" id="e045" class="graf graf--p graf-after--figure">The example code is,</p><figure name="db03" id="db03" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/9948e6a760be0dce77aff3a6ddab3142.js"></script></figure><p name="3965" id="3965" class="graf graf--p graf-after--figure">The output should be,</p><pre name="3aa2" id="3aa2" class="graf graf--pre graf-after--p">Creating a PThread...<br>Successfully created!<br>Block the current thread...<br>PThead: This is a pthread.<br>End of execution.</pre><p name="91b3" id="91b3" class="graf graf--p graf-after--pre">Note that because we use <code class="markup--code markup--p-code">sleep(1);</code> for the thread, so you may notice that there will be a <strong class="markup--strong markup--p-strong">1-second delay</strong> before the output <code class="markup--code markup--p-code">End of execution</code>.</p><p name="c214" id="c214" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. PThread Attributes</strong></p><p name="2d0c" id="2d0c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) PThread Attributes</strong></p><p name="bf26" id="bf26" class="graf graf--p graf-after--p">In the example above, we have created a thread by <code class="markup--code markup--p-code">pthread_create</code>, and for the second argument <code class="markup--code markup--p-code">attr</code>, we used <code class="markup--code markup--p-code">NULL</code> for the default parameters. <code class="markup--code markup--p-code">NULL</code> is equivalent to the <code class="markup--code markup--p-code">attr</code> if we only do the initialization,</p><pre name="9d94" id="9d94" class="graf graf--pre graf-after--p">pthread_attr_t attr;<br>pthread_attr_init(&amp;attr);  // initize <strong class="markup--strong markup--pre-strong">attr</strong> with the default values</pre><p name="77d4" id="77d4" class="graf graf--p graf-after--pre">and then call,</p><pre name="2c66" id="2c66" class="graf graf--pre graf-after--p">pthread_create(&amp;hThread, attr, thread, NULL);</pre><p name="827d" id="827d" class="graf graf--p graf-after--pre">Actually, the <code class="markup--code markup--p-code">pthread_attr_t</code> structure can be used to specify certain attributes in a flexible way. For a thread, we have the following attributes,</p><ul class="postList"><li name="1ab8" id="1ab8" class="graf graf--li graf-after--p">stack size</li><li name="0776" id="0776" class="graf graf--li graf-after--li">scheduling policy</li><li name="5b05" id="5b05" class="graf graf--li graf-after--li">priority</li><li name="ca54" id="ca54" class="graf graf--li graf-after--li">inheritance</li><li name="30d7" id="30d7" class="graf graf--li graf-after--li">joinable</li><li name="5f44" id="5f44" class="graf graf--li graf-after--li">system/process scope</li></ul><p name="7f2c" id="7f2c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Joinable PThreads and Detaching PThreads</strong></p><p name="2cd6" id="2cd6" class="graf graf--p graf-after--p">Now, let’s talk about the joinable attribute. In PThreads, the default behavior of thread creation is joinable. A <strong class="markup--strong markup--p-strong">joinable child thread</strong> means that this thread can join the parent thread at a later time. So parent thread can not complete unless the joinable child thread completes in the first place. If the parent thread exits early, the children thread will become a zombie thread</p><p name="2cc9" id="2cc9" class="graf graf--p graf-after--p">However, a <strong class="markup--strong markup--p-strong">detached child thread</strong> means that when this new thread is created, it has no relationship with the parent thread. So once the thread is detached, this new thread can not be joined to its parent thread.</p><p name="de9c" id="de9c" class="graf graf--p graf-after--p">If we want to create a detached child thread, we can use,</p><pre name="c5db" id="c5db" class="graf graf--pre graf-after--p">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</pre><p name="3e3c" id="3e3c" class="graf graf--p graf-after--pre">Note that we can always use <code class="markup--code markup--p-code">pthread_detech</code> to detach a thread (i.e. <code class="markup--code markup--p-code">hThread</code>) whenever we want by,</p><pre name="4c23" id="4c23" class="graf graf--pre graf-after--p">pthread_detach(hThread);</pre><p name="f8d1" id="f8d1" class="graf graf--p graf-after--pre">If we want to create a joinable child thread, we can either keep the result settings or use,</p><pre name="ebf8" id="ebf8" class="graf graf--pre graf-after--p">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</pre><p name="5c1b" id="5c1b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) System and Process Scope</strong></p><p name="d7c7" id="d7c7" class="graf graf--p graf-after--p">We have talked about the system scope and the process scope for any multithreading systems. For PThreads, if we want to specify a system scope, we can use,</p><pre name="b308" id="b308" class="graf graf--pre graf-after--p">pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM);</pre><p name="8b87" id="8b87" class="graf graf--p graf-after--pre">For PThreads, if we want to specify a process scope, we can use,</p><pre name="4f8f" id="4f8f" class="graf graf--pre graf-after--p">pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_PROCESS);</pre><p name="593c" id="593c" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(4) Set the Stack Size</strong></p><p name="34a5" id="34a5" class="graf graf--p graf-after--p">We can also set the stack size of a PThread by its attribute. Let’s say that we would like to set the stack size of our new thread to 512 bytes, then we should set,</p><pre name="21c9" id="21c9" class="graf graf--pre graf-after--p">pthread_attr_setstacksize(&amp;attr,512);</pre><p name="a1d2" id="a1d2" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(5) Example Code 2: PThread Attributes</strong></p><p name="9e54" id="9e54" class="graf graf--p graf-after--p">In this case, we are going to continue with the first example code. In the previous example, the <code class="markup--code markup--p-code">thread</code> function is relatively simple with,</p><pre name="9c93" id="9c93" class="graf graf--pre graf-after--p">void *thread(void *ptr) {<br>    cout &lt;&lt; &quot;PThead: This is a pthread.&quot; &lt;&lt; endl;<br>    sleep(1);<br>    return 0;<br>}</pre><p name="cd11" id="cd11" class="graf graf--p graf-after--pre">Now, we would like to create a PThread within this function. For this newly created thread, we are going to set it to a detached thread with system scope and a 512-byte stack,</p><pre name="a057" id="a057" class="graf graf--pre graf-after--p">pthread_attr_t attr;<br>pthread_attr_init(&amp;attr);<br>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);<br>pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM);<br>pthread_attr_setstacksize(&amp;attr, 512);</pre><p name="8400" id="8400" class="graf graf--p graf-after--pre">Then we have to create this new thread by these attribute rules,</p><pre name="88c9" id="88c9" class="graf graf--pre graf-after--p">pthread_create(&amp;hThread, &amp;attr, foo, NULL);</pre><p name="656a" id="656a" class="graf graf--p graf-after--pre">Note that we are going to call the <code class="markup--code markup--p-code">foo</code> function because if we call <code class="markup--code markup--p-code">thread</code> function at this time, we are going to create an infinite loop of creating child threads. The <code class="markup--code markup--p-code">foo</code> function can be defined by,</p><pre name="cc6a" id="cc6a" class="graf graf--pre graf-after--p">void *foo(void *ptr) {<br>    cout &lt;&lt; pthread_self() &lt;&lt; &quot;: This is a pthread.&quot; &lt;&lt; endl;     <br>    sleep(1);<br>    return 0; <br>}</pre><p name="0c48" id="0c48" class="graf graf--p graf-after--pre">You may notice that we use the function <code class="markup--code markup--p-code">pthread_self()</code> and this call obtains the ID of the current thread (as tread ID). Thus, we can identify which thread we are in from the output information. We can also compile the script by either <code class="markup--code markup--p-code">g++</code> or Makefile.</p><p name="3a86" id="3a86" class="graf graf--p graf-after--p">The final script is,</p><figure name="8de2" id="8de2" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/d3962c5daab2c580dbd9be264ca56eff.js"></script></figure><p name="35b1" id="35b1" class="graf graf--p graf-after--figure">The code above can also be found in my <a href="https://github.com/Sadamingh/PThreads-Practice/tree/main/02-Attributes" data-href="https://github.com/Sadamingh/PThreads-Practice/tree/main/02-Attributes" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">repo</a>.</p><p name="7d08" id="7d08" class="graf graf--p graf-after--p">The output for this code will be (it’s okay if the thread IDs are different),</p><pre name="7ff5" id="7ff5" class="graf graf--pre graf-after--p">0x1158865c0: Creating a PThread... <br>0x1158865c0: Successfully created! <br>0x1158865c0: Block the current thread... <br>0x700008115000: This is a pthread. <br>0x700008115000: Creating a PThread... <br>0x700008115000: Successfully created! <br>0x700008115000: Block the current thread...failed <br><strong class="markup--strong markup--pre-strong">0x700008198000: This is a pthread. <br>0x700008115000: End of execution. <br>0x1158865c0: End of execution.</strong></pre><p name="7202" id="7202" class="graf graf--p graf-after--pre">Or,</p><pre name="7edb" id="7edb" class="graf graf--pre graf-after--p">0x1158865c0: Creating a PThread... <br>0x1158865c0: Successfully created! <br>0x1158865c0: Block the current thread... <br>0x700008115000: This is a pthread. <br>0x700008115000: Creating a PThread... <br>0x700008115000: Successfully created! <br>0x700008115000: Block the current thread...failed <br><strong class="markup--strong markup--pre-strong">0x700008115000: End of execution. <br>0x700008198000: This is a pthread.<br>0x1158865c0: End of execution.</strong></pre><p name="0040" id="0040" class="graf graf--p graf-after--pre">The sequence of the <code class="markup--code markup--p-code">cout</code> can be different because of the <strong class="markup--strong markup--p-strong">race condition</strong>, which means that a thread tries to read/write a value while another thread modifies it. More information can be found from <a href="https://en.wikipedia.org/wiki/Race_condition" data-href="https://en.wikipedia.org/wiki/Race_condition" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>.</p><p name="8f70" id="8f70" class="graf graf--p graf-after--p">The diagram of this program is,</p><figure name="1b0d" id="1b0d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WHuGagxfESjBoHZ75BIX7w.png" data-width="1900" data-height="756" src="https://cdn-images-1.medium.com/max/800/1*WHuGagxfESjBoHZ75BIX7w.png"></figure><p name="aadb" id="aadb" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) Example Code 3: Multiple PThreads</strong></p><p name="34fe" id="34fe" class="graf graf--p graf-after--p">In this example, we are going to create two child threads for the parent thread by <code class="markup--code markup--p-code">thread</code> function and then create 1 thread for each of these two child threads by <code class="markup--code markup--p-code">foo</code> function. All the attributes of the child threads should be set as DEFAULT by <code class="markup--code markup--p-code">NULL</code>.</p><figure name="c2dc" id="c2dc" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/0f9f57f34608eab3c16884e43df3d8cb.js"></script></figure><p name="73e1" id="73e1" class="graf graf--p graf-after--figure">The output for this code may be (it’s okay if the thread IDs are different),</p><pre name="0151" id="0151" class="graf graf--pre graf-after--p">0x1100985c0: Creating a PThread...<br>0x1100985c0: Successfully created!<br>0x1100985c0: Successfully created!<br>0x1100985c0: Block the current thread...<br>0x700006951000: This is a pthread.<br>0x7000069d4000: This is a pthread.<br>0x700006951000: Creating a PThread...<br>0x7000069d4000: Creating a PThread...<br>0x700006a57000: This is a pthread.<br>0x7000069d4000: Successfully created!<br>0x7000069d4000: Block the current thread...<br>0x700006951000: Successfully created!<br>0x700006951000: Block the current thread...<br>0x700006ada000: This is a pthread.<br>0x700006951000: End of execution.<br>0x7000069d4000: End of execution.<br>0x1100985c0: End of execution.<br>0x1100985c0: Block the current thread...<br>0x1100985c0: End of execution.</pre><p name="49ce" id="49ce" class="graf graf--p graf-after--pre">Sometimes, you may notice an out-of-order output as,</p><pre name="2a39" id="2a39" class="graf graf--pre graf-after--p">0x700006f7f0000x700006efc000: Block the current thread...<br>: This is a pthread.</pre><p name="1597" id="1597" class="graf graf--p graf-after--pre">This is also because of the race condition of the output stream. You can re-execute the program several times to get an in-order output stream.</p><p name="b451" id="b451" class="graf graf--p graf-after--p">The diagram of this program is,</p><figure name="0655" id="0655" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*czJF3kqwZe0gs1BkD1j5TQ.png" data-width="1968" data-height="1406" src="https://cdn-images-1.medium.com/max/800/1*czJF3kqwZe0gs1BkD1j5TQ.png"></figure><p name="eea8" id="eea8" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(7) Quiz 1</strong></p><p name="9200" id="9200" class="graf graf--p graf-after--p">Now, let’s see a quiz. Suppose we have the following program,</p><figure name="199b" id="199b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/06523abca5fe2aed354accddc76ffc27.js"></script></figure><p name="dbef" id="dbef" class="graf graf--p graf-after--figure">Then our problem is, how many times of “Hello Thread” are we going to capture in the output? You can first answer this question and then run the code to see if you are right.</p><p name="2a74" id="2a74" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. PThread Arguments and Mutex</strong></p><p name="7b0f" id="7b0f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) PThread Arguments</strong></p><p name="e8d2" id="e8d2" class="graf graf--p graf-after--p">In the previous cases, we have used the tread IDs (like <code class="markup--code markup--p-code">0x…</code>) to identify different threads. However, can we have a much simple number for us to track the threads? For example, we may want to set a unique thread number for each of the threads we have created. We are going to use the PThread arguments <code class="markup--code markup--p-code">arg</code> of <code class="markup--code markup--p-code">pthread_create</code> to implement this feature,</p><pre name="3a35" id="3a35" class="graf graf--pre graf-after--p">int pthread_create(pthread_t *thread,<br>                   const pthread_attr_t *attr,<br>                   void *(*start_routine) (void *),          <br>                   void *arg);</pre><p name="d459" id="d459" class="graf graf--p graf-after--pre">For example, if we want to pass a unique integer <code class="markup--code markup--p-code">i</code> for each of these PThreads, we can call the following <code class="markup--code markup--p-code">pthread_create</code> function with the address of <code class="markup--code markup--p-code">i</code> being transmitted,</p><pre name="d9f6" id="d9f6" class="graf graf--pre graf-after--p">pthread_create(&amp;hThreads, NULL, thread, &amp;i)</pre><p name="dc99" id="dc99" class="graf graf--p graf-after--pre">And in the <code class="markup--code markup--p-code">thread</code> function, we can achieve this integer value by the <code class="markup--code markup--p-code">ptr</code> parameter,</p><pre name="f9ce" id="f9ce" class="graf graf--pre graf-after--p">void *thread(void *ptr) {<br>    int *p = (int *) ptr;  // convert ptr to pointer, assign to p<br>    int num = *p;          // get the value of pointer p<br>}</pre><p name="aed4" id="aed4" class="graf graf--p graf-after--pre">Then we can output the number by,</p><pre name="358a" id="358a" class="graf graf--pre graf-after--p">cout &lt;&lt; &quot;Thread No.&quot; &lt;&lt; num &lt;&lt; &quot; has ID: &quot; &lt;&lt; pthread_self() &lt;&lt; endl;</pre><p name="e4ca" id="e4ca" class="graf graf--p graf-after--pre">In this case, we would like to create 4 child threads for the current thread and then determine them respectively. In terms of the output, we will remove all the previous <code class="markup--code markup--p-code">cout</code>s like <code class="markup--code markup--p-code">Creating a PThread…</code> to avoid an over-complicated result.</p><pre name="594a" id="594a" class="graf graf--pre graf-after--p">#define NUM_THREADS 4</pre><p name="7ce0" id="7ce0" class="graf graf--p graf-after--pre">We would also like to test the whole program for 5 times to see the result, so</p><pre name="1dd7" id="1dd7" class="graf graf--pre graf-after--p">#define EXE_TIMES 5</pre><p name="289b" id="289b" class="graf graf--p graf-after--pre">So the overall code is,</p><figure name="112c" id="112c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/23b4ccd6ae340804f9d14b0a41db4d94.js"></script></figure><p name="1abf" id="1abf" class="graf graf--p graf-after--figure">What we expect for the result is that, for each of the trials, we expect to see something like,</p><pre name="0abc" id="0abc" class="graf graf--pre graf-after--p">======== i-th trial ========<br>Thread No.1 has ID: 0x70000c1a2000<br>Thread No.2 has ID: 0x70000c225000<br>Thread No.3 has ID: 0x70000c2a8000<br>Thread No.4 has ID: 0x70000c32b000</pre><p name="b517" id="b517" class="graf graf--p graf-after--pre">However, we may get something like,</p><pre name="736f" id="736f" class="graf graf--pre graf-after--p">======== i-th trial ========<br>Thread No.2 has ID: Thread No.0 has ID: 0x70000c1a2000<br>Thread No.0 has ID: 0x70000c32b000<br>0x70000c225000<br>Thread No.0 has ID: 0x70000c2a8000</pre><p name="c143" id="c143" class="graf graf--p graf-after--pre">There are two problems with this result. Firstly, the <code class="markup--code markup--p-code">cout</code> is not outputted in turn, so different threads can write to the output stream in an arbitrary order. Secondly, the number that we have seen is not in order, which means we expect to see <code class="markup--code markup--p-code">1,2,3,4...</code> instead of <code class="markup--code markup--p-code">2,0,0,0...</code>. Let’s deal with these problems one by one.</p><p name="9357" id="9357" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Mutex</strong></p><p name="66d1" id="66d1" class="graf graf--p graf-after--p">First, we have seen that the <code class="markup--code markup--p-code">cout</code> is not safe for a multithreading system because the outputs can be out-of-order. Thus, we have to use a mutex to lock the <code class="markup--code markup--p-code">cout</code> until it finishes. In order to do so, we should include the <code class="markup--code markup--p-code">mutex.h</code> header first,</p><pre name="ae03" id="ae03" class="graf graf--pre graf-after--p">#include &lt;mutex&gt;</pre><p name="8933" id="8933" class="graf graf--p graf-after--pre">And then, we can define a global mutex variable <code class="markup--code markup--p-code">mu</code> by,</p><pre name="c7b6" id="c7b6" class="graf graf--pre graf-after--p">mutex mu;</pre><p name="a6f0" id="a6f0" class="graf graf--p graf-after--pre">To use this lock, we can try <code class="markup--code markup--p-code">mu.lock();</code> and <code class="markup--code markup--p-code">mu.unlock();</code> before and after the code segment we want to lock,</p><pre name="c990" id="c990" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">mu.lock();</strong><br>cout &lt;&lt; &quot;Thread No.&quot; &lt;&lt; num &lt;&lt; &quot; has ID: &quot; &lt;&lt; pthread_self() &lt;&lt; endl;<br><strong class="markup--strong markup--pre-strong">mu.unlock();</strong></pre><p name="240f" id="240f" class="graf graf--p graf-after--pre">So generally the code should be,</p><figure name="18e9" id="18e9" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/77d33f5369630b2d6cb4aa40d1a618e9.js"></script></figure><p name="0cff" id="0cff" class="graf graf--p graf-after--figure">Now, we can get a result in the order. For example,</p><pre name="e727" id="e727" class="graf graf--pre graf-after--p">======== 1-th trial ========<br>Thread No.3 has ID: 0x700009af4000<br>Thread No.0 has ID: 0x700009b77000<br>Thread No.1 has ID: 0x700009c7d000<br>Thread No.2 has ID: 0x700009bfa000<br>======== 2-th trial ========<br>Thread No.1 has ID: 0x700009af4000<br>Thread No.3 has ID: 0x700009b77000<br>Thread No.3 has ID: 0x700009bfa000<br>Thread No.1 has ID: 0x700009c7d000<br>======== 3-th trial ========<br>Thread No.3 has ID: 0x700009af4000<br>Thread No.0 has ID: 0x700009b77000<br>Thread No.1 has ID: 0x700009c7d000<br>Thread No.1 has ID: 0x700009bfa000<br>======== 4-th trial ========<br>Thread No.1 has ID: 0x700009af4000<br>Thread No.0 has ID: 0x700009bfa000<br>Thread No.0 has ID: 0x700009c7d000<br>Thread No.1 has ID: 0x700009b77000<br>======== 5-th trial ========<br>Thread No.2 has ID: 0x700009af4000<br>Thread No.3 has ID: 0x700009b77000<br>Thread No.1 has ID: 0x700009bfa000<br>Thread No.3 has ID: 0x700009c7d000</pre><p name="ef12" id="ef12" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Output Analysis</strong></p><p name="50e8" id="50e8" class="graf graf--p graf-after--p">In the output above, we can find out that the outputted result has two features,</p><ul class="postList"><li name="a27e" id="a27e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">it doesn’t have to be in-order.</strong> For example, we may expect</li></ul><pre name="85dc" id="85dc" class="graf graf--pre graf-after--li">Thread No.0 has ID: 0x700009af4000<br>Thread No.1 has ID: 0x700009b77000<br>Thread No.2 has ID: 0x700009c7d000<br>Thread No.3 has ID: 0x700009bfa000</pre><p name="6c4c" id="6c4c" class="graf graf--p graf-after--pre">However, in the <code class="markup--code markup--p-code">1-th trial</code>, what we have is</p><pre name="2840" id="2840" class="graf graf--pre graf-after--p">Thread No.3 has ID: 0x700009af4000<br>Thread No.0 has ID: 0x700009b77000<br>Thread No.1 has ID: 0x700009c7d000<br>Thread No.2 has ID: 0x700009bfa000</pre><p name="14c2" id="14c2" class="graf graf--p graf-after--pre">This is because we don’t have any controls on how to schedule these newly created threads. So the actual order of how these threads are actually performed is unclear and can be different from the order they were created.</p><ul class="postList"><li name="2419" id="2419" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">it doesn’t have to contain every number</strong>. If some numbers are lost, some other numbers can repeat. For example, in the <code class="markup--code markup--li-code">2-th trial</code>, we have</li></ul><pre name="ee75" id="ee75" class="graf graf--pre graf-after--li">Thread No.1 has ID: 0x700009af4000<br>Thread No.3 has ID: 0x700009b77000<br>Thread No.3 has ID: 0x700009bfa000<br>Thread No.1 has ID: 0x700009c7d000</pre><p name="784e" id="784e" class="graf graf--p graf-after--pre">This is because that the value of the integer variable <code class="markup--code markup--p-code">i</code> is a global variable, and it is passed to the <code class="markup--code markup--p-code">thread</code> function by its address. So when this variable <code class="markup--code markup--p-code">i</code> changes in one thread, all the other threads will see the new value.</p><p name="8d92" id="8d92" class="graf graf--p graf-after--p">So when we create a new thread with <code class="markup--code markup--p-code">pthread_create(&amp;hThreads[i], NULL, thread, &amp;i)</code>, if the parent thread does <code class="markup--code markup--p-code">i++</code> before we do <code class="markup--code markup--p-code">int num = *p;</code> in this new thread, we can not have the original value of this thread. Instead, we will have a value of <code class="markup--code markup--p-code">i</code> after the increment.</p><p name="17ff" id="17ff" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Missing Number Problem</strong></p><p name="51cd" id="51cd" class="graf graf--p graf-after--p">Based on the discussion above, let’s now deal with the <strong class="markup--strong markup--p-strong">missing number problem</strong>. Because we have known that the missing value is because that the <code class="markup--code markup--p-code">i++</code> is executed before the thread reads <code class="markup--code markup--p-code">i</code>, so we can actually assign this value to another variable to avoid the change of variable <code class="markup--code markup--p-code">i</code>.</p><p name="4f5b" id="4f5b" class="graf graf--p graf-after--p">Let’s say we can create a new <code class="markup--code markup--p-code">int</code> variable called <code class="markup--code markup--p-code">tmp_num</code> (temporary number),</p><pre name="745f" id="745f" class="graf graf--pre graf-after--p">int tmp_num;</pre><p name="bb4b" id="bb4b" class="graf graf--p graf-after--pre">And then we assign the value <code class="markup--code markup--p-code">i</code> to it before we call the <code class="markup--code markup--p-code">pthread_create</code> function,</p><pre name="f9ff" id="f9ff" class="graf graf--pre graf-after--p">tmp_num = i;</pre><p name="769e" id="769e" class="graf graf--p graf-after--pre">Then we call <code class="markup--code markup--p-code">pthread_create</code> with respect to this argument,</p><pre name="5dd1" id="5dd1" class="graf graf--pre graf-after--p">pthread_create(&amp;hThreads[i], NULL, thread, &amp;tmp_num);</pre><p name="b77f" id="b77f" class="graf graf--p graf-after--pre">The output can be,</p><pre name="8577" id="8577" class="graf graf--pre graf-after--p">======== 1-th trial ========<br>Thread No.1 has ID: 0x70000221f000<br>Thread No.2 has ID: 0x7000022a2000<br>Thread No.3 has ID: 0x700002325000<br>Thread No.3 has ID: 0x7000023a8000<br>======== 2-th trial ========<br>Thread No.1 has ID: 0x70000221f000<br>Thread No.2 has ID: 0x7000022a2000<br>Thread No.3 has ID: 0x700002325000<br>Thread No.3 has ID: 0x7000023a8000<br>======== 3-th trial ========<br>Thread No.1 has ID: 0x70000221f000<br>Thread No.2 has ID: 0x7000022a2000<br>Thread No.3 has ID: 0x700002325000<br>Thread No.3 has ID: 0x7000023a8000<br>======== 4-th trial ========<br>Thread No.1 has ID: 0x70000221f000<br>Thread No.2 has ID: 0x7000022a2000<br>Thread No.3 has ID: 0x700002325000<br>Thread No.3 has ID: 0x7000023a8000<br>======== 5-th trial ========<br>Thread No.1 has ID: 0x70000221f000<br>Thread No.2 has ID: 0x7000022a2000<br>Thread No.3 has ID: 0x700002325000<br>Thread No.3 has ID: 0x7000023a8000</pre><p name="53cf" id="53cf" class="graf graf--p graf-after--pre">It is pretty because now we can still find some duplicated numbers (i.e. 3 for each trial). So what’s wrong with this? Well, this is because when we pass the <code class="markup--code markup--p-code">&amp;tmp_num</code> , the <code class="markup--code markup--p-code">tmp_num</code> is still a global variable. So if the instruction of the next loop <code class="markup--code markup--p-code">tmp_num = i;</code> executed before the <code class="markup--code markup--p-code">int num = *p;</code> , we will still have the wrong number for this.</p><p name="6e20" id="6e20" class="graf graf--p graf-after--p">The method to deal with this problem is that we can assign different <code class="markup--code markup--p-code">int</code> variables for different numbers. So the newly changed value will not influence the previous values that we have stored. The simplest way to create several <code class="markup--code markup--p-code">int</code> variables and then assign values to them is by creating an <code class="markup--code markup--p-code">int</code> array. Thus, we can create an array by,</p><pre name="c69a" id="c69a" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">int nums[NUM_THREADS];</code></pre><p name="4cf1" id="4cf1" class="graf graf--p graf-after--pre">And then we assign the value <code class="markup--code markup--p-code">i</code> to each of its elements before we call the <code class="markup--code markup--p-code">pthread_create</code> function,</p><pre name="edc4" id="edc4" class="graf graf--pre graf-after--p">nums[i] = i;</pre><p name="5f81" id="5f81" class="graf graf--p graf-after--pre">Then we call <code class="markup--code markup--p-code">pthread_create</code> with respect to this element,</p><pre name="7da0" id="7da0" class="graf graf--pre graf-after--p">pthread_create(&amp;hThreads[i], NULL, thread, &amp;nums[i]);</pre><p name="1ff9" id="1ff9" class="graf graf--p graf-after--pre">So finally, our code should be as follows. You can also find this code from my <a href="https://github.com/Sadamingh/PThreads-Practice/tree/main/05-Arguments" data-href="https://github.com/Sadamingh/PThreads-Practice/tree/main/05-Arguments" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">repo</a>.</p><figure name="5e70" id="5e70" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/d2abc1fea3632a948353c71aabb9f1f1.js"></script></figure><p name="2d6d" id="2d6d" class="graf graf--p graf-after--figure">And we will have an output of,</p><pre name="28e7" id="28e7" class="graf graf--pre graf-after--p">======== 1-th trial ========<br>Thread No.1 has ID: 0x70000e349000<br>Thread No.0 has ID: 0x70000e2c6000<br>Thread No.2 has ID: 0x70000e3cc000<br>Thread No.3 has ID: 0x70000e44f000<br>======== 2-th trial ========<br>Thread No.0 has ID: 0x70000e2c6000<br>Thread No.1 has ID: 0x70000e349000<br>Thread No.3 has ID: 0x70000e44f000<br>Thread No.2 has ID: 0x70000e3cc000<br>======== 3-th trial ========<br>Thread No.0 has ID: 0x70000e2c6000<br>Thread No.1 has ID: 0x70000e349000<br>Thread No.2 has ID: 0x70000e3cc000<br>Thread No.3 has ID: 0x70000e44f000<br>======== 4-th trial ========<br>Thread No.1 has ID: 0x70000e349000<br>Thread No.3 has ID: 0x70000e44f000<br>Thread No.2 has ID: 0x70000e3cc000<br>Thread No.0 has ID: 0x70000e2c6000<br>======== 5-th trial ========<br>Thread No.0 has ID: 0x70000e2c6000<br>Thread No.2 has ID: 0x70000e3cc000<br>Thread No.1 has ID: 0x70000e349000<br>Thread No.3 has ID: 0x70000e44f000</pre><p name="a5fc" id="a5fc" class="graf graf--p graf-after--pre">It is quite good to see that we have no duplicated values or missing values now. But there is a problem because we still have the out-of-order execution of the threads. Well, we are not going to talk about the scheduling problem in this section.</p><p name="d334" id="d334" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. Producer-Consumer Model</strong></p><p name="cc17" id="cc17" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Producer-Consumer Model</strong></p><p name="216c" id="216c" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">producer-consumer problem</strong> (also known as the <strong class="markup--strong markup--p-strong">bounded-buffer problem</strong>) is a classic example of a multi-process synchronization problem. It manages to solve the reading and writing problems to shared buffer in a multithreading system.</p><p name="8c24" id="8c24" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">producer thread</strong> generates some data and then puts those data into a shared buffer and it should stop putting the data and wait when the buffer is filled. While the <strong class="markup--strong markup--p-strong">consumer thread</strong> consumes the data in this buffer and it should stop consuming the data and wait when the buffer is empty.</p><figure name="58f0" id="58f0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*41Crkf05mHrKT4jMVw6N6Q.png" data-width="2078" data-height="800" src="https://cdn-images-1.medium.com/max/800/1*41Crkf05mHrKT4jMVw6N6Q.png"></figure><p name="f338" id="f338" class="graf graf--p graf-after--figure">Note that this buffer should be a <strong class="markup--strong markup--p-strong">first in first out (FIFO)</strong> buffer.</p><p name="4c4a" id="4c4a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Shared Buffer</strong></p><p name="5e18" id="5e18" class="graf graf--p graf-after--p">Now, let’s see how we can implement a shared buffer. Because the shared buffer is a FIFO data structure, we can implement it by an array <code class="markup--code markup--p-code">buffer</code> and three index variables <code class="markup--code markup--p-code">num</code> , <code class="markup--code markup--p-code">add</code> , <code class="markup--code markup--p-code">rem</code> and all these three variables should be initialized with <code class="markup--code markup--p-code">0</code>.</p><pre name="77b4" id="77b4" class="graf graf--pre graf-after--p">int buffer[BUFFER_SIZE];<br>int num = 0;<br>int add = 0;<br>int rem = 0;</pre><p name="2d33" id="2d33" class="graf graf--p graf-after--pre">The size of the array can be specified by the macro <code class="markup--code markup--p-code">BUFFER_SIZE</code> with the define. Suppose we want to define a shared buffer with 5 elements, then,</p><pre name="fa86" id="fa86" class="graf graf--pre graf-after--p">#define BUFFER_SIZE 5</pre><ul class="postList"><li name="8553" id="8553" class="graf graf--li graf-after--pre">the variable <code class="markup--code markup--li-code">num</code> is the <strong class="markup--strong markup--li-strong">number of elements</strong> in this buffer. We can use this value to see if this buffer is full (when <code class="markup--code markup--li-code">num == BUFFER_SIZE</code>) or empty (when <code class="markup--code markup--li-code">num == 0</code>).</li><li name="01c7" id="01c7" class="graf graf--li graf-after--li">the variable <code class="markup--code markup--li-code">add</code> is the <strong class="markup--strong markup--li-strong">index for inserting the next data</strong>. Whenever we need to insert data into the buffer, we can use the <code class="markup--code markup--li-code">buffer[add] = value;</code> instruction. After inserting, we have to add 1 to this variable ( by <code class="markup--code markup--li-code">add++;</code>) to trace the next inserting index. Remember, we should also increase <code class="markup--code markup--li-code">num</code> by 1 if we insert a unit of new data.</li><li name="f9d4" id="f9d4" class="graf graf--li graf-after--li">the variable <code class="markup--code markup--li-code">rem</code> is the <strong class="markup--strong markup--li-strong">index for removing the next data</strong>. Whenever we need to remove data from the buffer, we can directly add 1 to this variable (by <code class="markup--code markup--li-code">rem++;</code>). Remember, we should also decrease <code class="markup--code markup--li-code">num</code> by 1 if we remove a unit of the data.</li></ul><p name="1446" id="1446" class="graf graf--p graf-after--li">The diagram of this buffer is,</p><figure name="b363" id="b363" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*LskkUpHvyPA6k1yDhaccZg.png" data-width="1754" data-height="356" src="https://cdn-images-1.medium.com/max/800/1*LskkUpHvyPA6k1yDhaccZg.png"></figure><p name="6df7" id="6df7" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) PThread Mutex</strong></p><p name="fe21" id="fe21" class="graf graf--p graf-after--p">In the previous case, we have used the <code class="markup--code markup--p-code">mutex</code> header for the lock. Now, we would like to introduce the PThread mutex. In the previous case, the structure of a mutex lock is,</p><pre name="d6cc" id="d6cc" class="graf graf--pre graf-after--p">mutex m; /* global */</pre><pre name="a84a" id="a84a" class="graf graf--pre graf-after--pre">m.lock();<br>// Critical Section<br>m.unlock();</pre><p name="3b38" id="3b38" class="graf graf--p graf-after--pre">For the PThread mutex, similarly, we can have,</p><pre name="bcf2" id="bcf2" class="graf graf--pre graf-after--p">pthread_mutex_t m;  /* global */</pre><p name="d88d" id="d88d" class="graf graf--p graf-after--pre">But this is not enough for a PThread mutex. Each PThread mutex needs to be initialized by,</p><pre name="9d6f" id="9d6f" class="graf graf--pre graf-after--p">pthread_mutex_init(&amp;m, NULL);</pre><p name="bfd8" id="bfd8" class="graf graf--p graf-after--pre">where <code class="markup--code markup--p-code">NULL</code> means the default initialization.</p><p name="6ae2" id="6ae2" class="graf graf--p graf-after--p">Or we can even initialize a mutex at the moment we define it,</p><pre name="a82b" id="a82b" class="graf graf--pre graf-after--p">pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;  /* global */</pre><p name="2a79" id="2a79" class="graf graf--p graf-after--pre">Then, we can lock the critical section by,</p><pre name="1e3b" id="1e3b" class="graf graf--pre graf-after--p">pthread_mutex_lock(&amp;m);<br>// Critical Section<br>pthread_mutex_unlock(&amp;m);</pre><p name="fbb0" id="fbb0" class="graf graf--p graf-after--pre">The PThread mutex also provides some other operations which can be convenient for us to use. For example,</p><ul class="postList"><li name="dffb" id="dffb" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">trylock</code> call: this can be used to lock a mutex. However, if the mutex is locked, the current thread will not be blocked and this call will return <code class="markup--code markup--li-code">EBUSY</code> to show that the mutex was already locked. So we can do something else and maybe try again later.</li></ul><pre name="1e47" id="1e47" class="graf graf--pre graf-after--li">pthread_mutex_trylock(&amp;m);</pre><ul class="postList"><li name="0580" id="0580" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">destory</code> call: we should remember that we need to destroy the mutex to release some memory it takes after the execution.</li></ul><pre name="bb06" id="bb06" class="graf graf--pre graf-after--li">pthread_mutex_destory(&amp;m);</pre><p name="85b3" id="85b3" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(4) PThread Mutex Tips</strong></p><p name="187a" id="187a" class="graf graf--p graf-after--p">We are going to meet hundreds of mutex bugs in the future, so it would be better if you keep in mind some tips when you use the mutex. Here are some common tips that we have to remember,</p><ul class="postList"><li name="0ad2" id="0ad2" class="graf graf--li graf-after--p">Shared data should always be accessed through a <strong class="markup--strong markup--li-strong">single mutex</strong>.</li><li name="386f" id="386f" class="graf graf--li graf-after--li">Mutex scope must be visible to all. This means that it has to be a <strong class="markup--strong markup--li-strong">global</strong> variable.</li><li name="4476" id="4476" class="graf graf--li graf-after--li">For all threads, maintain that there are <strong class="markup--strong markup--li-strong">global ordered locks</strong>. This means that we have to lock the mutexes in order for all threads in case of a <strong class="markup--strong markup--li-strong">deadlock</strong>.</li><li name="77f0" id="77f0" class="graf graf--li graf-after--li">Always <strong class="markup--strong markup--li-strong">unlock</strong> a mutex and also <strong class="markup--strong markup--li-strong">unlock the correct mutex</strong>! It is easy to forget the unlock in most cases.</li></ul><p name="b71b" id="b71b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) PThread Condition Variable</strong></p><p name="1e59" id="1e59" class="graf graf--p graf-after--p">PThread also provides us a lot of operation for the condition variables. In Birrel’s mechanism, we have talked that we need to have a <strong class="markup--strong markup--p-strong">condition type</strong> <code class="markup--code markup--p-code">Condition</code>, which is provided by PThread as <code class="markup--code markup--p-code">pthread_cond_t</code>,</p><pre name="783e" id="783e" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">pthread_cond_t Cond;</code></pre><p name="a1f7" id="a1f7" class="graf graf--p graf-after--pre">We also talked that we have to <strong class="markup--strong markup--p-strong">wait</strong> for the signal by <code class="markup--code markup--p-code">Wait(mutex, cond);</code> and in PThread, this should be,</p><pre name="6cb4" id="6cb4" class="graf graf--pre graf-after--p">pthread_cond_wait(&amp;Cond, &amp;m);</pre><p name="5336" id="5336" class="graf graf--p graf-after--pre">Also, we have to use the <code class="markup--code markup--p-code">Signal(cond);</code> and the <code class="markup--code markup--p-code">Broadcast(cond);</code> calls for sending conditions, this is implemented by,</p><pre name="0ba4" id="0ba4" class="graf graf--pre graf-after--p">pthread_cond_signal(&amp;Cond);</pre><p name="8bbc" id="8bbc" class="graf graf--p graf-after--pre">and,</p><pre name="a3bf" id="a3bf" class="graf graf--pre graf-after--p">pthread_cond_broadcast(&amp;Cond);</pre><p name="ab86" id="ab86" class="graf graf--p graf-after--pre">There are also some other operation for the conditional variables, for example, we can initialize a condition by (where <code class="markup--code markup--p-code">NULL</code> means by default),</p><pre name="ce63" id="ce63" class="graf graf--pre graf-after--p">pthread_cond_init(&amp;Cond, NULL);</pre><p name="bdaf" id="bdaf" class="graf graf--p graf-after--pre">or through its definition by,</p><pre name="fe71" id="fe71" class="graf graf--pre graf-after--p">pthread_cond_t Cond = PTHREAD_COND_INITIALIZER;</pre><p name="ccef" id="ccef" class="graf graf--p graf-after--pre">We can also destroy a condition variable by,</p><pre name="a5e9" id="a5e9" class="graf graf--pre graf-after--p">pthread_cond_destory(&amp;Cond);</pre><p name="de8b" id="de8b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(6) PThread Condition Variable Tips</strong></p><p name="9b25" id="9b25" class="graf graf--p graf-after--p">There are also some tips we should remember for using the condition variables,</p><ul class="postList"><li name="ed31" id="ed31" class="graf graf--li graf-after--p">Don’t forget to notify the waiting threads and make sure you are signaling or broadcasting the <strong class="markup--strong markup--li-strong">correct</strong> condition variable.</li><li name="5185" id="5185" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Always use broadcast</strong> if you are in doubt of using whether the signal or the broadcast. If you are wrong, you only lose some performance.</li><li name="3ef1" id="3ef1" class="graf graf--li graf-after--li">You don’t need a mutex for signaling or broadcasting.</li></ul><p name="f8e6" id="f8e6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Producer-Consumer Model Implementation</strong></p><p name="afb4" id="afb4" class="graf graf--p graf-after--p">Now, let’s implement the producer-consumer model with PThreads.</p><figure name="c195" id="c195" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/d5dff706bca1596cb21ceb1f0c27a35d.js"></script></figure><p name="32bd" id="32bd" class="graf graf--p graf-after--figure graf--trailing">You can also find this example code from my <a href="https://github.com/Sadamingh/PThreads-Practice/tree/main/07-Producer-Consumer-Model" data-href="https://github.com/Sadamingh/PThreads-Practice/tree/main/07-Producer-Consumer-Model" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">repo</a>. Note that you have to quit the process of this program manually because the <code class="markup--code markup--p-code">consumer</code> thread won’t terminate automatically (it will always listen to the new data available in the shared buffer).</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/bf8004e36e70"><time class="dt-published" datetime="2021-02-04T17:58:19.374Z">February 4, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-8-a-tutorial-for-the-pthread-programming-bf8004e36e70" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>