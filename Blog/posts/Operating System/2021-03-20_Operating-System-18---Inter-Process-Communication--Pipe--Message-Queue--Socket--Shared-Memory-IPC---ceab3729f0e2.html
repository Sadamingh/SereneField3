<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 18 | Inter-Process Communication, Pipe, Message Queue, Socket, Shared-Memory IPC …</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 18 | Inter-Process Communication, Pipe, Message Queue, Socket, Shared-Memory IPC …</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="06a0" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2f3c" id="2f3c" class="graf graf--h3 graf--leading graf--title">Operating System 18 | <strong class="markup--strong markup--h3-strong">Inter-Process Communication, Pipe, Message Queue, Socket, Shared-Memory IPC and Its Synchronization</strong></h3><figure name="29f8" id="29f8" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*m9HHlVy9dJjVlTqv.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*m9HHlVy9dJjVlTqv.png"></figure><ol class="postList"><li name="08be" id="08be" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Inter-Process Communication</strong></li></ol><p name="975c" id="975c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Inter-Process Communication (IPC)</strong></p><p name="50ef" id="50ef" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Inter-Process Communication</strong> (aka. <strong class="markup--strong markup--p-strong">IPC</strong>) refers to a set of OS-supported mechanisms used for interaction (e.g. coordination or communication) among processes.</p><p name="64f5" id="64f5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Types of IPC</strong></p><p name="720a" id="720a" class="graf graf--p graf-after--p">IPC mechanisms are broadly categorized as <strong class="markup--strong markup--p-strong">message-based</strong> or <strong class="markup--strong markup--p-strong">memory-based</strong>. Examples for these two categories are,</p><ul class="postList"><li name="5ccc" id="5ccc" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Message-based (message pass)</strong>: sockets, pipes, message queues</li><li name="4b1f" id="4b1f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Memory-based (shared memory)</strong>: shared memory, memory-mapped files</li></ul><p name="a375" id="a375" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">2. Message-Passing IPC</strong></p><p name="ec83" id="ec83" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Message Passing IPC</strong></p><p name="76f8" id="76f8" class="graf graf--p graf-after--p">One model of IPC is called the <strong class="markup--strong markup--p-strong">message passing IPC</strong> or <strong class="markup--strong markup--p-strong">message-based IPC</strong>. As its name implies, processes create messages and then send or receive them.</p><p name="4865" id="4865" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Channel</strong></p><p name="35b3" id="35b3" class="graf graf--p graf-after--p">The OS is responsible for creating and maintaining the <strong class="markup--strong markup--p-strong">channel</strong> that will be used to pass messages among processes. The data structure of the channel can be a buffer or a FIFO queue.</p><p name="0697" id="0697" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of Ports</strong></p><p name="1fb8" id="1fb8" class="graf graf--p graf-after--p">The OS also provides some interfaces to the processes so that they can pass messages via the channel. These interfaces are called <strong class="markup--strong markup--p-strong">ports</strong>. The sending process send/write a message to the port of the receiving process, and the receiving process then recv/read from the port where a message is received. The channel is responsible for passing the message from one port to another.</p><p name="0776" id="0776" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) OS Kernel Responsibilities for IPC</strong></p><p name="0af4" id="0af4" class="graf graf--p graf-after--p">In the IPC process, the OS kernel is required to,</p><ul class="postList"><li name="a5ea" id="a5ea" class="graf graf--li graf-after--p">establish the communication channel</li><li name="1b63" id="1b63" class="graf graf--li graf-after--li">perform every single IPC operation: this means that both the send and receive operations require a system call and a data copy</li></ul><p name="8478" id="8478" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Request-Respond Interaction</strong></p><p name="b8e1" id="b8e1" class="graf graf--p graf-after--p">Now, let’s see the most simple <strong class="markup--strong markup--p-strong">request-respond model</strong> between two processes. Suppose we have 2 processes, and one is going to send a request to the other, and the other one will respond after it receives the message.</p><figure name="0b8c" id="0b8c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dfkqUKIwfxw9qqcc7dc9Tw.png" data-width="1550" data-height="444" src="https://cdn-images-1.medium.com/max/800/1*dfkqUKIwfxw9qqcc7dc9Tw.png"><figcaption class="imageCaption">send a request / recv a request</figcaption></figure><figure name="c753" id="c753" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*XsNyXEB6mfJSBcdRK9NzzQ.png" data-width="1550" data-height="444" src="https://cdn-images-1.medium.com/max/800/1*XsNyXEB6mfJSBcdRK9NzzQ.png"><figcaption class="imageCaption">send a respond / recv a respond</figcaption></figure><p name="08c1" id="08c1" class="graf graf--p graf-after--figure">From the diagrams, we can discover that a simple request-respond model will require 4 system calls, 4 user-kernel crossings, and 4 data copies.</p><p name="9bf5" id="9bf5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Message-Passing IPC Evaluation</strong></p><p name="c891" id="c891" class="graf graf--p graf-after--p">In the message-passing IPC, the <strong class="markup--strong markup--p-strong">downsides</strong> are,</p><ul class="postList"><li name="ce64" id="ce64" class="graf graf--li graf-after--p">overheads for kernel-user crossings</li><li name="02ca" id="02ca" class="graf graf--li graf-after--li">overheads for copying the data</li></ul><p name="d322" id="d322" class="graf graf--p graf-after--li">But there is also an advantage,</p><ul class="postList"><li name="d902" id="d902" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">simplicity</strong>: the kernel takes all the IPC operations including the channel management and the synchronization</li></ul><p name="ea6e" id="ea6e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Pipes</strong></p><p name="a1ff" id="a1ff" class="graf graf--p graf-after--p">The most simple form of the message passing IPC is called <strong class="markup--strong markup--p-strong">pipes</strong>. Pipes are characterized by two endpoints so that only two processes can communicate at a time. There is no notion of the message in the pipe, and there will just be a stream of bytes that are pushed into the pipe from one process to another.</p><p name="bbdd" id="bbdd" class="graf graf--p graf-after--p">One popular use of pipes is to connect the output from one process to the input of another process. So the entire byte stream that’s produced by process 1 will be delivered as input to process 2.</p><figure name="acfd" id="acfd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*O9f0bRS5cPfLQBM1-SpbIQ.png" data-width="1436" data-height="380" src="https://cdn-images-1.medium.com/max/800/1*O9f0bRS5cPfLQBM1-SpbIQ.png"></figure><p name="b615" id="b615" class="graf graf--p graf-after--figure">The pipe is also part of the <strong class="markup--strong markup--p-strong">POSIX</strong> standard.</p><p name="1fdf" id="1fdf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Message Queue</strong></p><p name="b938" id="b938" class="graf graf--p graf-after--p">A more complex form of message passing IPC is the <strong class="markup--strong markup--p-strong">message queue</strong>. As the name suggests, the message queues understand the notion of messages that they transfer. Thus, a sending process must submit a properly formatted message to the channel, and then the channel will deliver a properly formatted message to the receiving process. The OS level functionality regarding message queues also includes things like understanding priorities of messages or scheduling the way messages are being delivered.</p><figure name="0616" id="0616" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rFLl6T4iEzBgkxcZLtVFeA.png" data-width="1436" data-height="382" src="https://cdn-images-1.medium.com/max/800/1*rFLl6T4iEzBgkxcZLtVFeA.png"></figure><p name="bd61" id="bd61" class="graf graf--p graf-after--figure">The use of message queues is supported through different APIs including the <strong class="markup--strong markup--p-strong">POSIX API</strong> and the <strong class="markup--strong markup--p-strong">Sys V API </strong>in a UNIX-like system.</p><p name="cb9e" id="cb9e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Socket</strong></p><p name="11e7" id="11e7" class="graf graf--p graf-after--p">Another IPC that we have talked about in socket programming is the <strong class="markup--strong markup--p-strong">socket</strong>. With the socket form of IPC, the notion of ports that’s required in message-passing IPC mechanisms, that is the socket abstraction that’s supported by the OS.</p><p name="1c05" id="1c05" class="graf graf--p graf-after--p">With sockets, processes send messages or receive messages via the socket AP and it supports <code class="markup--code markup--p-code">send()</code> and <code class="markup--code markup--p-code">recv()</code> to send or receive messages to or from the message buffer.</p><p name="4f2e" id="4f2e" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">socket()</code> call itself creates a kernel-level socket buffer, and it will associate any necessary kernel-level processing that needs to be performed along with the message movement. For instance, the socket may be assigned as a TCP/IP socket.</p><figure name="715a" id="715a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0saKKFJDXrQqwjZ52HjiJg.png" data-width="1436" data-height="450" src="https://cdn-images-1.medium.com/max/800/1*0saKKFJDXrQqwjZ52HjiJg.png"></figure><p name="9224" id="9224" class="graf graf--p graf-after--figure">Sockets, as you probably know, don’t have to be used for processes that are on a single machine. If the two processes are on different machines, then this channel is essentially between a process and the network device that will actually send the data.</p><figure name="06aa" id="06aa" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0csuHBIcCSAmcvNWMHnibQ.png" data-width="1436" data-height="594" src="https://cdn-images-1.medium.com/max/800/1*0csuHBIcCSAmcvNWMHnibQ.png"></figure><p name="b3ea" id="b3ea" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">3. Shared-Memory IPC</strong></p><p name="af14" id="af14" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Shared-Memory IPC</strong></p><p name="75e9" id="75e9" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">shared memory IPC</strong> means that the processes read and write to a <strong class="markup--strong markup--p-strong">shared physical memory region</strong>. The OS is involved in establishing the shared memory channel between the processes, this is implemented by the virtual to physical translation.</p><p name="5daa" id="5daa" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Shared-Memory IPC Implementation</strong></p><p name="bdf3" id="bdf3" class="graf graf--p graf-after--p">To have a shared physical memory region between two processes, the OS will map certain physical pages of memory into the virtual address spaces of both processes.</p><figure name="c5b2" id="c5b2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IufQIDVCbr7CfXWLfWwZ_Q.png" data-width="1436" data-height="400" src="https://cdn-images-1.medium.com/max/800/1*IufQIDVCbr7CfXWLfWwZ_Q.png"></figure><p name="e9d2" id="e9d2" class="graf graf--p graf-after--figure">The physical memory that’s backing the shared memory buffer does not have to be a contiguous portion of physical memory. All of this leverages the memory management support that’s available in operating systems and on modern hardware.</p><p name="dd51" id="dd51" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Shared-Memory IPC Evaluation</strong></p><p name="1f53" id="1f53" class="graf graf--p graf-after--p">There is one big benefit of this approach: once the physical memory is mapped into both address spaces, the OS doesn’t need to be used for maintaining the communication. This brings us some advantages,</p><ul class="postList"><li name="131e" id="131e" class="graf graf--li graf-after--p">system calls are <strong class="markup--strong markup--li-strong">only for setting up</strong> the shared space</li><li name="9866" id="9866" class="graf graf--li graf-after--li">data copies will be significantly <strong class="markup--strong markup--li-strong">reduced</strong></li></ul><p name="253c" id="253c" class="graf graf--p graf-after--li">However, because we are changing the data on the same physical region, there must be some downsides. For example, we need</p><ul class="postList"><li name="7d4a" id="7d4a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">explicit synchronizations</strong></li><li name="bcd5" id="bcd5" class="graf graf--li graf-after--li">complex communication protocol</li><li name="20ff" id="20ff" class="graf graf--li graf-after--li">to manage the shared buffer manually</li></ul><p name="2172" id="2172" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Shared-Memory IPC APIs</strong></p><p name="7eba" id="7eba" class="graf graf--p graf-after--p">For Unix-like platforms, we have,</p><ul class="postList"><li name="1450" id="1450" class="graf graf--li graf-after--p">POSIX APIs</li><li name="39ae" id="39ae" class="graf graf--li graf-after--li">Sys V APIs</li></ul><p name="788a" id="788a" class="graf graf--p graf-after--li">And for Android platforms, we have,</p><ul class="postList"><li name="d08f" id="d08f" class="graf graf--li graf-after--p">Ashmem</li></ul><p name="e19c" id="e19c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Message Passing IPC Vs. Shared Memory IPC</strong></p><p name="583f" id="583f" class="graf graf--p graf-after--p">In message passing,</p><ul class="postList"><li name="2293" id="2293" class="graf graf--li graf-after--p">CPU is involved in <strong class="markup--strong markup--li-strong">copying</strong> the data with <strong class="markup--strong markup--li-strong">kernel-user crossings</strong> and we need to pay the cost of CPU cycles for this</li><li name="496c" id="496c" class="graf graf--li graf-after--li">Good for sending a small amount of data</li></ul><p name="1509" id="1509" class="graf graf--p graf-after--li">In the shared memory case,</p><ul class="postList"><li name="0543" id="0543" class="graf graf--li graf-after--p">CPU cycles are spent <strong class="markup--strong markup--li-strong">mapping</strong> the physical memory into the appropriate address spaces</li><li name="9df0" id="9df0" class="graf graf--li graf-after--li">CPU cycles are also spent copying the data into the channel but without kernel-user crossing</li><li name="e4eb" id="e4eb" class="graf graf--li graf-after--li">A high cost of setup the V2P translation</li><li name="de42" id="de42" class="graf graf--li graf-after--li">Good for using <strong class="markup--strong markup--li-strong">many times</strong> after setups</li><li name="85f9" id="85f9" class="graf graf--li graf-after--li">Perform well for using <strong class="markup--strong markup--li-strong">fewer times</strong> after setups</li><li name="5f0a" id="5f0a" class="graf graf--li graf-after--li">Good for sending <strong class="markup--strong markup--li-strong">large</strong> amount of data</li></ul><p name="978c" id="978c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) Local Procedure Calls</strong></p><p name="ed36" id="ed36" class="graf graf--p graf-after--p">In Windows systems, if the data that needs to be transferred among address spaces is smaller than a certain threshold, then the data is <strong class="markup--strong markup--p-strong">copied via ports</strong>. Otherwise, the data is potentially copied once to make sure that it’s in a page-aligned area and then that area is <strong class="markup--strong markup--p-strong">mapped into the address space</strong>. This mechanism that the windows kernel supports is called <strong class="markup--strong markup--p-strong">local procedure calls </strong>(aka.<strong class="markup--strong markup--p-strong"> LPC</strong>).</p><p name="4c54" id="4c54" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. Sys V APIs</strong></p><p name="6e8e" id="6e8e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Segments</strong></p><p name="78ae" id="78ae" class="graf graf--p graf-after--p">The OS supports <strong class="markup--strong markup--p-strong">segments</strong> of the shared memory that don’t need to be contiguous physical pages. These segments are system-wide and there is a limit for the total number of these segments. In today&#39;s Linux system, this is not an issue because we can use up to 4,000 segments. However, in the past, we can only use 6 segments.</p><p name="8759" id="8759" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Create Segments</strong></p><p name="8808" id="8808" class="graf graf--p graf-after--p">When a process requests that a shared memory segment is <strong class="markup--strong markup--p-strong">created</strong>, the OS allocates the required amount of physical memory. If provided that certain limits of the segments are met, then it assigns to it a <strong class="markup--strong markup--p-strong">unique key</strong>. This key is used to uniquely identify the segment within the OS, and any other process can refer to this particular segment using this key.</p><figure name="8345" id="8345" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kgYngpHhPeSgpBlkgjWmyw.png" data-width="1436" data-height="212" src="https://cdn-images-1.medium.com/max/800/1*kgYngpHhPeSgpBlkgjWmyw.png"></figure><ul class="postList"><li name="16b8" id="16b8" class="graf graf--li graf-after--figure"><code class="markup--code markup--li-code">shmget(shmid, size, flag)</code> (shared memory get) is used to create or open a segment of the appropriate size. <code class="markup--code markup--li-code">shmid</code> is the unique key that must be explicitly assigned by the application.</li><li name="1ca1" id="1ca1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ftok(pathname, proj_id)</code> is used to generate the unique key. This function will generate a token based on its arguments, and it will generate the same keys if we pass the same arguments. This is like hashing.</li></ul><p name="26b1" id="26b1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Attaching Processes</strong></p><p name="8e16" id="8e16" class="graf graf--p graf-after--p">After the segment is created, using the key of this segment, the <strong class="markup--strong markup--p-strong">OS</strong> establishes valid mappings between the processes’ virtual address space and the physical memory that backs the segment. <strong class="markup--strong markup--p-strong">Multiple processes</strong> can attach to the same shared memory segment so that these processes end up sharing access to the same pages. Reads and writes to these pages will be visible across all the processes.</p><figure name="7004" id="7004" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vOkNyd5QAthgdxo-YvezEw.png" data-width="1436" data-height="568" src="https://cdn-images-1.medium.com/max/800/1*vOkNyd5QAthgdxo-YvezEw.png"></figure><ul class="postList"><li name="2053" id="2053" class="graf graf--li graf-after--figure"><code class="markup--code markup--li-code">shmaddr = shmat(shmid, addr, flags)</code> (shared memory attach) is the call that attaches the shared memory segments into the virtual address space of the process. <code class="markup--code markup--li-code">addr</code> is the specific virtual address that the programmer can set for mapping, if it is set to NULL, then the program will arbitrarily select the virtual address for mapping. This function will return the virtual memory <code class="markup--code markup--li-code">shmaddr</code> that can be used for any data type, then the programmers have to decide which type they will use.</li></ul><p name="2fa3" id="2fa3" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Detaching Processes</strong></p><p name="c274" id="c274" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Detaching</strong> a process from a segment means invalidating the address mappings for the virtual region that corresponded to that segment within the process. In other words, the page table entries for those virtual addresses will no longer be valid. However, a segment isn’t really destroyed once it’s detached. In fact, a segment may be attached and detached and reattached multiple times by different processes during its lifetime. What this means is that once a segment is created, it’s like a persistent entity until there’s an explicit request for it to be destroyed.</p><figure name="d26b" id="d26b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rYgwPDDQbyIYM5CP9qbjIw.png" data-width="1436" data-height="568" src="https://cdn-images-1.medium.com/max/800/1*rYgwPDDQbyIYM5CP9qbjIw.png"></figure><ul class="postList"><li name="17be" id="17be" class="graf graf--li graf-after--figure"><code class="markup--code markup--li-code">shmdt(shmaddr)</code> (shared memory detaching) means to detach the segment with the process. The process with a virtual address of <code class="markup--code markup--li-code">shmaddr</code> can not be map to the shared memory anymore.</li></ul><p name="4bd9" id="4bd9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Destroy Segments</strong></p><p name="4818" id="4818" class="graf graf--p graf-after--p">The segment is destroyed only when it’s explicitly <strong class="markup--strong markup--p-strong">deleted</strong> or when there is a <strong class="markup--strong markup--p-strong">system reboot</strong>. This makes it very different than regular non-shared-memory, which is allocated by <code class="markup--code markup--p-code">malloc</code> and it will disappear as soon as the process exits.</p><ul class="postList"><li name="1f76" id="1f76" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">shmctl(shmid, cmd, buf)</code> (shared memory controller) can be used to destroy a segment. The segment will be removed when the <code class="markup--code markup--li-code">cmd</code> argument is assigned to <code class="markup--code markup--li-code">IPC_RMID</code> (IPC remove by ID).</li></ul><p name="850a" id="850a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">4. POSIX API for Shared Memory</strong></p><p name="807f" id="807f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Basis of the POSIX API</strong></p><p name="e12c" id="e12c" class="graf graf--p graf-after--p">Although the POSIX API is the standard API, it is not as widely supported as the Sys V API. The main difference between the POSIX API and the Sys V API is that the POSIX use <strong class="markup--strong markup--p-strong">files</strong> instead of segments. So, every shared memory will be identified with a <strong class="markup--strong markup--p-strong">file descriptor</strong>. This file is not like a real file in the disk, it is actually the concept that exists in the <strong class="markup--strong markup--p-strong">temporary file storage paradigm system</strong> (aka.<strong class="markup--strong markup--p-strong"> tmpfs</strong>).</p><ul class="postList"><li name="f079" id="f079" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Create Files</strong></li></ul><p name="ef3c" id="ef3c" class="graf graf--p graf-after--li">We would use <code class="markup--code markup--p-code">shm_open()</code> for creating the shared memory and it returns a file descriptor.</p><ul class="postList"><li name="efb9" id="efb9" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Attach Processes</strong></li></ul><p name="ad25" id="ad25" class="graf graf--p graf-after--li">We would use <code class="markup--code markup--p-code">mmap()</code> to attach the file descriptor of the shared memory to the virtual address space of a process.</p><ul class="postList"><li name="6b86" id="6b86" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Detach A Process</strong></li></ul><p name="6ca9" id="6ca9" class="graf graf--p graf-after--li">We would use <code class="markup--code markup--p-code">unmmap()</code> to detach the file descriptor of the shared memory to the virtual address space of a process.</p><ul class="postList"><li name="2bb5" id="2bb5" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Detach all the Processes</strong></li></ul><p name="ac08" id="ac08" class="graf graf--p graf-after--li">We can also detach all the processes related to the file descriptor of shared memory by <code class="markup--code markup--p-code">shm_close()</code>. By this means, the file descriptor will be removed from the address space and it can be no longer used.</p><ul class="postList"><li name="295f" id="295f" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Destroy Files</strong></li></ul><p name="304e" id="304e" class="graf graf--p graf-after--li">The <code class="markup--code markup--p-code">shm_close()</code> only removes the file descriptor, but all the data structures related to the file descriptor will be left for us. To deal with this problem, we can use <code class="markup--code markup--p-code">shm_unlink()</code> to eliminate all the information related to the file descriptor and also free the memories related.</p><p name="39ed" id="39ed" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">5. Synchronization for Shared Memory</strong></p><p name="d915" id="d915" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Why We Need Synchronizations?</strong></p><p name="4e67" id="4e67" class="graf graf--p graf-after--p">Because all these processes can have access to the same physical address space, then we have to consider the synchronization (e.g. mutexes and condition variables) for processes.</p><p name="358e" id="358e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Options for Synchronizations</strong></p><p name="9166" id="9166" class="graf graf--p graf-after--p">On one hand, we can synchronize the shared memory based on the mechanisms supported by the process threading library (i.e. <strong class="markup--strong markup--p-strong">PThread</strong> Library). Or on the other hand, there are also some <strong class="markup--strong markup--p-strong">methods provide by the OS</strong> that can be used for synchronization.</p><p name="2166" id="2166" class="graf graf--p graf-after--p">However, regardless of the method we have chosen for synchronization, there must be a synchronization on the number of concurrent accesses to the shared memory and we should also be awared of when the data is available and ready for consumption.</p><p name="b61a" id="b61a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Shared Memory Data Structure</strong></p><p name="9ad9" id="9ad9" class="graf graf--p graf-after--p">Now, let’s see an implementation of the shared memory data structure. Except for the data that must be included in the shared memory data structure, we also need to assign a mutex for this shared memory. Thus, we can define this data structure by,</p><pre name="74ac" id="74ac" class="graf graf--pre graf-after--p">typedef struct {<br>    pthread_mutex_t mutex;<br>    char *data;<br>} shm_data_structure, *shm_data_structure_t;</pre><p name="6499" id="6499" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(4) Initalize the Shared Memory</strong></p><p name="3ff0" id="3ff0" class="graf graf--p graf-after--p">Now that we have got the data structure of the shared memory, what we haven’t got is a real instance of the shared memory. As we have discussed, we can initialize a <code class="markup--code markup--p-code">shm_data_structure</code> instance with the Sys V APIs.</p><pre name="5576" id="5576" class="graf graf--pre graf-after--p">key = ftok(argv[0], 120);<br>seg = shmget(key, 1024, IPC_CREATE | IPC_EXCL);<br>shm_address = shmat(seg, NULL, 0);<br>shm_ptr = (* <code class="markup--code markup--pre-code">shm_data_structure_t</code>) shm_address;</pre><p name="7e3a" id="7e3a" class="graf graf--p graf-after--pre">In the end of this code, we will have a pointer <code class="markup--code markup--p-code">shm_ptr</code> pointing to the shared memory of the type <code class="markup--code markup--p-code">shm_data_structure</code>.</p><p name="54f4" id="54f4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) PThread Synchronization for IPC</strong></p><p name="4bcc" id="4bcc" class="graf graf--p graf-after--p">Now, let’s see how we can synchronize this shared memory with PThread. PThread provides mutex data type <code class="markup--code markup--p-code">pthread_mutexattr_t</code> and condition variable data type <code class="markup--code markup--p-code">pthread_condattr_t</code> , especially for the shared memory. Before we use a mutex for the shared memory, we can first create it by,</p><pre name="f2d7" id="f2d7" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">pthread_mutexattr_t m_attr;</code></pre><p name="0617" id="0617" class="graf graf--p graf-after--pre">We have talked that the mutex can only be valid within a process, but for IPC synchronization, we must allow the access of other process to this mutex. Thus, <code class="markup--code markup--p-code">pthread_mutexattr_setpshared(attr, pshared)</code>can be used to permit a mutex to be operated upon by any thread that has access to the memory where the mutex is allocated, even if the mutex is allocated in memory that is shared by multiple processes. To implement this feature, the <code class="markup--code markup--p-code">pshared</code> argument should be set to <code class="markup--code markup--p-code">PTHREAD_PROCESS_SHARED</code>. So,</p><pre name="963d" id="963d" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">pthread_mutexattr_setpshared(&amp;m_attr, PTHREAD_PROCESS_SHARED);</code></pre><p name="f4c4" id="f4c4" class="graf graf--p graf-after--pre">In the end, we can finally initialize this mutex by,</p><pre name="280b" id="280b" class="graf graf--pre graf-after--p">pthread_mutex_init(&amp;shm_ptr.mutex, &amp;m_attr);</pre><p name="debe" id="debe" class="graf graf--p graf-after--pre">and now it can be used for all the processes.</p><p name="2ca6" id="2ca6" class="graf graf--p graf-after--p">Note that we must keep the synchronization variables <strong class="markup--strong markup--p-strong">within the shared memory region</strong> (i.e. in the shared memory data structure) so that it can be shared among the processes.</p><p name="bacd" id="bacd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">6. IPC Linux Command Lines</strong></p><p name="987e" id="987e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Message Queues</strong></p><p name="4437" id="4437" class="graf graf--p graf-after--p">There are also some other ways for synchronization, for instance, the <strong class="markup--strong markup--p-strong">message queue</strong> and the <strong class="markup--strong markup--p-strong">semaphores</strong>. For the message queue, when a process sends to the shared memory, it will also send a <code class="markup--code markup--p-code">ready</code> to the message queue. When the other process receives the <code class="markup--code markup--p-code">ready</code> message, it will read the data and then send an <code class="markup--code markup--p-code">OK</code> message back.</p><p name="e8ea" id="e8ea" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Semaphores</strong></p><p name="39a4" id="39a4" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">semaphore</strong> is a 1-bit value that can be used as the mutex. We have seen an implementation of this in the midterm review. When this value is set to 0, the process&#39;s access to the shared memory will be blocked and stopped. However, when this value is set to 1, the process that wants to access the shared memory will decrement this value to 0 so that other processes will be blocked. Then the present process can proceed with its execution. After it uses this memory, this value will be increased by 1 so that other processes can have access to the shared memory again.</p><p name="90d5" id="90d5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Linux Commands</strong></p><p name="601f" id="601f" class="graf graf--p graf-after--p">There are some Linux commands that can be used by us to see the utilization of the shared memory. The <code class="markup--code markup--p-code">ipcs</code> command will list all the IPC facilities including message queues, shared memory, and semaphores. And we can use the following command only to show the IPCs with shared memory,</p><pre name="677d" id="677d" class="graf graf--pre graf-after--p">$ ipcs -m</pre><p name="7570" id="7570" class="graf graf--p graf-after--pre graf--trailing">If we want to delete an IPC facility, we can use the <code class="markup--code markup--p-code">ipcrm</code> command. The <code class="markup--code markup--p-code">ipcrm -m [shmid]</code> can be used to delete the shared memory segment with the given <code class="markup--code markup--p-code">shmid</code>.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/ceab3729f0e2"><time class="dt-published" datetime="2021-03-20T14:24:46.418Z">March 20, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-18-inter-process-communication-pipe-message-queue-socket-shared-memory-ipc-ceab3729f0e2" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>