<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 9 | Socket Programming Experiment 2: Enable IPv4 and IPv6</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 9 | Socket Programming Experiment 2: Enable IPv4 and IPv6</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="0976" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c1a7" id="c1a7" class="graf graf--h3 graf--leading graf--title">Operating System 9 | Socket Programming Experiment 2: Enable IPv4 and IPv6</h3><figure name="ee3e" id="ee3e" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*ahdwMXm1dDDc4NTj.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*ahdwMXm1dDDc4NTj.png"></figure><ol class="postList"><li name="2e15" id="2e15" class="graf graf--li graf-after--figure"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">addrinfo</strong></code><strong class="markup--strong markup--li-strong"> Vs. </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">sockaddr_in</strong></code></li></ol><p name="9d07" id="9d07" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Recall: Structure </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">sockaddr_in</strong></code></p><p name="90be" id="90be" class="graf graf--p graf-after--p">In the <a href="https://medium.com/adamedelwiess/operating-system-4-socket-programming-experiment-7e78be945ef5" data-href="https://medium.com/adamedelwiess/operating-system-4-socket-programming-experiment-7e78be945ef5" class="markup--anchor markup--p-anchor" target="_blank">previous socket programming experiment</a>, we have talked about the <code class="markup--code markup--p-code">sockaddr_in</code> structure, which can be used for storing the IPv4 address information. This structure has the following components,</p><pre name="e7b2" id="e7b2" class="graf graf--pre graf-after--p">#include &lt;netinet/in.h&gt;<br><br>struct sockaddr_in {<br>    short            sin_family;   // e.g. AF_INET<br>    unsigned short   sin_port;     // e.g. htons(3490)<br>    struct in_addr   sin_addr;     // see struct in_addr, below<br>    char             sin_zero[8];  // zero this if you want to<br>};<br><br>struct in_addr {<br>    unsigned long s_addr;  // load with inet_aton()<br>};</pre><p name="ae4f" id="ae4f" class="graf graf--p graf-after--pre">where,</p><ul class="postList"><li name="4fc2" id="4fc2" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">sin_family</code> is the address family for the transport address, which should be set to <code class="markup--code markup--li-code">AF_INET</code> for IPv4 protocol.</li><li name="9e7f" id="9e7f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sin_port</code> is to specify the transport port corresponding to a given address.</li><li name="354f" id="354f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sin_addr.s_addr</code> is used to store the resolved address result by the given hostname.</li></ul><p name="d306" id="d306" class="graf graf--p graf-after--li">However, this <code class="markup--code markup--p-code">sockaddr_in</code> can be used only for the IPv4 protocol. If we want to use the IPv6 protocol, we can use a similar structure named <code class="markup--code markup--p-code">sockaddr_in6</code>. More information on the IPv6 structure can be found from <a href="http://osr600doc.xinuos.com/en/SDK_netapi/sockC.TheIPv6sockaddrstructure.html" data-href="http://osr600doc.xinuos.com/en/SDK_netapi/sockC.TheIPv6sockaddrstructure.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>. But there is still a problem. Sometimes we may want to use a socket for both the IPv4 and IPv6 transportation, these structures are not enough for us to use.</p><p name="fb6e" id="fb6e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Structure </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">addrinfo</strong></code></p><p name="7499" id="7499" class="graf graf--p graf-after--p">To deal with this problem, let’s see a new structure called <code class="markup--code markup--p-code">addrinfo</code>. To use this structure, we have to include the following three header files,</p><pre name="84af" id="84af" class="graf graf--pre graf-after--p">#include &lt;sys/types.h&gt;<br>#include &lt;sys/socket.h&gt;<br>#include &lt;netdb.h&gt;</pre><p name="6536" id="6536" class="graf graf--p graf-after--pre">This <code class="markup--code markup--p-code">addrinfo</code> structure has a data structure of,</p><pre name="8b23" id="8b23" class="graf graf--pre graf-after--p">struct addrinfo {<br>  int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.<br>  int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC<br>  int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM<br>  int              ai_protocol;  // use 0 for &quot;any&quot;<br>  size_t           ai_addrlen;   // size of ai_addr in bytes<br>  struct sockaddr *ai_addr;      // struct sockaddr_in or _in6<br>  char            *ai_canonname; // full canonical hostname<br>  struct addrinfo *ai_next;      // linked list, next node<br>};</pre><p name="845c" id="845c" class="graf graf--p graf-after--pre">where,</p><ul class="postList"><li name="9692" id="9692" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">ai_family</code> specifies the desired address family for the returned addresses. It can be specified to <code class="markup--code markup--li-code">AF_INET</code> (for IPv4), <code class="markup--code markup--li-code">AF_INET6</code> (for IPv6), or <code class="markup--code markup--li-code">AF_UNSPEC</code> (for either IPv4 or IPv6). The value <code class="markup--code markup--li-code">AF_UNSPEC</code> indicates that <code class="markup--code markup--li-code">getaddrinfo()</code> (we are going to talk about it later) should return socket addresses for any address family.</li><li name="a0a8" id="a0a8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ai_socktype</code> specifies the preferred socket type, such as <code class="markup--code markup--li-code">SOCK_STREAM</code> (for TCP) or <code class="markup--code markup--li-code">SOCK_DGRAM</code> (for UDP). Specifying <code class="markup--code markup--li-code">0</code> in this field indicates that socket addresses of any type can be returned by <code class="markup--code markup--li-code">getaddrinfo()</code>.</li><li name="94ce" id="94ce" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ai_addr</code> is a pointer that can be used to point towards both the <code class="markup--code markup--li-code">sockaddr_in</code> structure and the <code class="markup--code markup--li-code">sockaddr_in6</code> structure.</li></ul><p name="b9c6" id="b9c6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Initialize a Structure with Zeros by </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">memset</strong></code></p><p name="d7ae" id="d7ae" class="graf graf--p graf-after--p">When we first create an instance of a structure, we actually captured a range of memory that can be used for this specific structure. If we don’t initialize the origin values in this structure, we are going to have some garbage values. Let’s see an example here. Suppose we define a structure <code class="markup--code markup--p-code">Test</code> with integer variables <code class="markup--code markup--p-code">a</code>, <code class="markup--code markup--p-code">b</code>.</p><pre name="ef14" id="ef14" class="graf graf--pre graf-after--p">struct Test {<br>   int a, b;<br>};</pre><p name="bedc" id="bedc" class="graf graf--p graf-after--pre">Then if we create an instance of this structure and then print the value of the variable <code class="markup--code markup--p-code">a</code> and variable <code class="markup--code markup--p-code">b</code>,</p><pre name="c05f" id="c05f" class="graf graf--pre graf-after--p">struct Test test;<br>printf(&quot;%p: a = %d, b = %d\n&quot;, &amp;test, test.a, test.b);</pre><p name="6bc9" id="6bc9" class="graf graf--p graf-after--pre">We are going to have some garbage values like,</p><pre name="7a01" id="7a01" class="graf graf--pre graf-after--p">0x7ffeed38b2b0: a = -315051312, b = 32766</pre><p name="d1c3" id="d1c3" class="graf graf--p graf-after--pre">To initialize the values in this structure, we can either manually assign each of the elements this structure has by,</p><pre name="ebd1" id="ebd1" class="graf graf--pre graf-after--p">test.a = 10001; <br>test.b = 20002;</pre><p name="3841" id="3841" class="graf graf--p graf-after--pre">then print the result,</p><pre name="57fd" id="57fd" class="graf graf--pre graf-after--p">printf(&quot;%p: a = %d, b = %d\n&quot;, &amp;test, test.a, test.b);</pre><p name="cbb0" id="cbb0" class="graf graf--p graf-after--pre">The result should be,</p><pre name="27a7" id="27a7" class="graf graf--pre graf-after--p">0x7ffeed38b2b0: a = 10001, b = 20002</pre><p name="ba96" id="ba96" class="graf graf--p graf-after--pre">Or we can also set all the variables of this structure by zeros by <code class="markup--code markup--p-code">memset</code>,</p><pre name="650c" id="650c" class="graf graf--pre graf-after--p">memset(&amp;test, 0, sizeof test);</pre><p name="7f93" id="7f93" class="graf graf--p graf-after--pre">then print the result,</p><pre name="6282" id="6282" class="graf graf--pre graf-after--p">printf(&quot;%p: a = %d, b = %d\n&quot;, &amp;test, test.a, test.b);</pre><p name="781f" id="781f" class="graf graf--p graf-after--pre">The result should be,</p><pre name="0a14" id="0a14" class="graf graf--pre graf-after--p">0x7ffeed38b2b0: a = 0, b = 0</pre><p name="2a59" id="2a59" class="graf graf--p graf-after--pre">Generally, you can test the following code on your computer to see why we can call <code class="markup--code markup--p-code">memset</code> for initialization.</p><figure name="b680" id="b680" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/c793d2ebcfaac59ff9bf9866d230159b.js"></script></figure><p name="260c" id="260c" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">inet_ntop</strong></code><strong class="markup--strong markup--p-strong"> for Converting Raw Address</strong></p><p name="ce8c" id="ce8c" class="graf graf--p graf-after--p">Actually, if we are provided a hostname or domain name (i.e. <code class="markup--code markup--p-code">localhost</code>), what we want to have is a translation of this hostname to an IP address, so the computer can know where we should actually send a message. For example, if we have <code class="markup--code markup--p-code">localhost</code> as our hostname, we would like it to translate to either <code class="markup--code markup--p-code">127.0.0.1</code> (for IPv4) or <code class="markup--code markup--p-code">::1</code> (for IPv6).</p><p name="d885" id="d885" class="graf graf--p graf-after--p">However, what we have to know is that the computer can read neither <code class="markup--code markup--p-code">127.0.0.1</code> nor <code class="markup--code markup--p-code">::1</code>, these are actually values for humans to read easily. For example, the IPv4 address <code class="markup--code markup--p-code">127.0.0.1</code> actually means <code class="markup--code markup--p-code">0x7F.00.00.01</code> in hexadecimal values and this should be <code class="markup--code markup--p-code">0x7F000001</code> (you can try it <a href="https://miniwebtool.com/ip-address-to-hex-converter/?ip=127.0.0.1" data-href="https://miniwebtool.com/ip-address-to-hex-converter/?ip=127.0.0.1" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>) as its real address value.</p><p name="34eb" id="34eb" class="graf graf--p graf-after--p">Also, because we usually have a little-edian computer, which is different from the network bytes, we have to convert this value to <code class="markup--code markup--p-code">0x01.00.00.7F</code> (see a more rigorous explanation about little-edian from <a href="https://www.developreference.com/article/13325486/Getting+the+ip+address+of+my+machine+in+dotted+decimal+with+C%3f" data-href="https://www.developreference.com/article/13325486/Getting+the+ip+address+of+my+machine+in+dotted+decimal+with+C%3f" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>). Thus, the hexadecimal values of this address should be <code class="markup--code markup--p-code">0x0100007F</code>. If we then convert this hexadecimal number to a decimal value, we are going to have the value <code class="markup--code markup--p-code">16777343</code> (you can calculate this value from <a href="https://www.binaryhexconverter.com/hex-to-decimal-converter" data-href="https://www.binaryhexconverter.com/hex-to-decimal-converter" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>).</p><p name="e8d6" id="e8d6" class="graf graf--p graf-after--p">Suppose now we are given a raw decimal address <code class="markup--code markup--p-code">16777343</code> , how could we convert this value to <code class="markup--code markup--p-code">127.0.0.1</code>? The answer is that we can use the <code class="markup--code markup--p-code">inet_ntop</code> function to print the result. Let’s see a code example here,</p><figure name="24ae" id="24ae" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/f62d25ea467bf6e1bdf5915a2cb6c4a4.js"></script></figure><p name="1521" id="1521" class="graf graf--p graf-after--figure">The result should be,</p><pre name="fb0b" id="fb0b" class="graf graf--pre graf-after--p">16777343 result: 127.0.0.1</pre><p name="9305" id="9305" class="graf graf--p graf-after--pre">You can change the value <code class="markup--code markup--p-code">16777343</code> to see how it changes the output IP string.</p><p name="7655" id="7655" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">gethostbyname</strong></code><strong class="markup--strong markup--p-strong"> for Resolving IPv4 Hostname</strong></p><p name="3719" id="3719" class="graf graf--p graf-after--p">However, in practice, we are not given the real address like <code class="markup--code markup--p-code">16777343</code> , instead, we are given the hostname or domain name like <code class="markup--code markup--p-code">localhost</code> or maybe like <code class="markup--code markup--p-code">google.com</code>. Suppose we are given <code class="markup--code markup--p-code">localhost</code> as our hostname, how can we know that we are mapping to <code class="markup--code markup--p-code">127.0.0.1</code> or <code class="markup--code markup--p-code">::1</code> . For IPv4 mapping, we can use the function <code class="markup--code markup--p-code">gethostbyname</code> to resolve this hostname. This can be easily used by,</p><pre name="8682" id="8682" class="graf graf--pre graf-after--p">char *hostname = &quot;localhost&quot;;</pre><pre name="65e5" id="65e5" class="graf graf--pre graf-after--pre">struct hostent* pHostInfo;<br>int nHostAddress;</pre><pre name="a24c" id="a24c" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">pHostInfo = gethostbyname(hostname);</strong></pre><pre name="0123" id="0123" class="graf graf--pre graf-after--pre">// memcpy: convert the value of pHostInfo-&gt;h_addr to long int<br>memcpy(&amp;nHostAddress, pHostInfo-&gt;h_addr, pHostInfo-&gt;h_length);<br>printf(&quot;%d&quot;, nHostAddress);</pre><p name="b2ac" id="b2ac" class="graf graf--p graf-after--pre">The output of the code is,</p><pre name="3abd" id="3abd" class="graf graf--pre graf-after--p">16777343</pre><p name="aa5e" id="aa5e" class="graf graf--p graf-after--pre">which is exactly the localhost’s real address that we have discussed above. We can then use the function <code class="markup--code markup--p-code">inet_ntop</code> to convert this value to the IP string <code class="markup--code markup--p-code">127.0.0.1</code>.</p><p name="e5fa" id="e5fa" class="graf graf--p graf-after--p">But what will happen if use this to resolve a hostname for the IPv6 address? You can imagine that the return value for the <code class="markup--code markup--p-code">gethostname</code> function is fixed given a specific hostname, however, the real addresses of IPv4 and IPv6 aere actually not the name. Thus, we can not achieve the real IPv6 address because we are using the IPv4 rules for resolving the hostname.</p><p name="617c" id="617c" class="graf graf--p graf-after--p">Let’s now see an example,</p><figure name="581a" id="581a" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/c3ecd505c94d255a7d818e575aca85a4.js"></script></figure><p name="cc23" id="cc23" class="graf graf--p graf-after--figure">The output of the code above is,</p><pre name="7353" id="7353" class="graf graf--pre graf-after--p">IPv6 test fail.<br>============ localhost: ===========<br>IPv4: 127.0.0.1<br>IPv6: 7f00:1:fe7f::b000:80d0:e67f:0<br>Real Address: 140728915198079</pre><p name="f62d" id="f62d" class="graf graf--p graf-after--pre">We can find out the real address is <code class="markup--code markup--p-code">140728915198079</code> but not <code class="markup--code markup--p-code">16777343</code> , this is because we are using the long integer for this case (while in the previous case, we used the <code class="markup--code markup--p-code">int</code> datatype instead). They are the same IPv4 address because both of them have <code class="markup--code markup--p-code">0x0100007F</code> in their value.</p><p name="017c" id="017c" class="graf graf--p graf-after--p">Even though the IPv4 address is all right for us, we can not convert this value to the IPv6 address <code class="markup--code markup--p-code">::1</code>. Thus, we can know that the function <code class="markup--code markup--p-code">gethostbyname</code> can only work for IPv4.</p><p name="5c51" id="5c51" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">getaddrinfo</strong></code><strong class="markup--strong markup--p-strong"> for Resolving Hostname</strong></p><p name="5c17" id="5c17" class="graf graf--p graf-after--p">In the previous case, we have used <code class="markup--code markup--p-code">gethostbyname</code> function and we have seen that we can use this function to resolve the <code class="markup--code markup--p-code">localhost</code> to <code class="markup--code markup--p-code">127.0.0.1</code>. However, for the IPv6 address resolution, we simply have no idea so far! So what we really want is a function that when we tell it that we would like to get the address of localhost, it will not only return <code class="markup--code markup--p-code">127.0.0.1</code> but also return <code class="markup--code markup--p-code">::1</code> for us. So what can we use to implement this feature? The answer is that we can use a <code class="markup--code markup--p-code">getaddrinfo</code> function. Let’s see how it works.</p><p name="6e08" id="6e08" class="graf graf--p graf-after--p">For a hostname or a domain name, it actually can be resolved to several IP addresses. This technique is called a <a href="https://stackoverflow.com/questions/10257969/is-it-possible-that-one-domain-name-has-multiple-corresponding-ip-addresses" data-href="https://stackoverflow.com/questions/10257969/is-it-possible-that-one-domain-name-has-multiple-corresponding-ip-addresses" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">round-robin DNS</a>. Let’s have a try here. Suppose if we want to fetch some IPv4 addresses for yahoo.com, we can run,</p><pre name="538f" id="538f" class="graf graf--pre graf-after--p">$ nslookup yahoo.com</pre><p name="8937" id="8937" class="graf graf--p graf-after--pre">The result will be (I use <code class="markup--code markup--p-code">8.8.8.8</code> as the DNS server),</p><pre name="d442" id="d442" class="graf graf--pre graf-after--p">Name: yahoo.com<br>Address: 98.137.11.164<br>Name: yahoo.com<br>Address: 98.137.11.163<br>Name: yahoo.com<br>Address: 74.6.143.25<br>Name: yahoo.com<br>Address: 74.6.231.20<br>Name: yahoo.com<br>Address: 74.6.143.26<br>Name: yahoo.com<br>Address: 74.6.231.21</pre><p name="17d0" id="17d0" class="graf graf--p graf-after--pre">Similarly, if we want to fetch some IPv6 addresses for yahoo.com, we can run,</p><pre name="1282" id="1282" class="graf graf--pre graf-after--p">$ nslookup -query=AAAA yahoo.com</pre><p name="0948" id="0948" class="graf graf--p graf-after--pre">The result will be (I also use <code class="markup--code markup--p-code">8.8.8.8</code> as the DNS server),</p><pre name="cc47" id="cc47" class="graf graf--pre graf-after--p">yahoo.com has AAAA address 2001:4998:124:1507::f000<br>yahoo.com has AAAA address 2001:4998:44:3507::8000<br>yahoo.com has AAAA address 2001:4998:24:120d::1:1<br>yahoo.com has AAAA address 2001:4998:24:120d::1:0<br>yahoo.com has AAAA address 2001:4998:44:3507::8001<br>yahoo.com has AAAA address 2001:4998:124:1507::f001</pre><p name="403d" id="403d" class="graf graf--p graf-after--pre">So if we want to resolve <code class="markup--code markup--p-code">localhost</code>, the answer is that this hostname can be resolved to 2 different addresses <code class="markup--code markup--p-code">127.0.0.1</code> and <code class="markup--code markup--p-code">::1</code>. So of course, now we need a data structure to store these two addresses. So what can we use now? Remember that we have discussed the <code class="markup--code markup--p-code">addrinfo</code> structure, which can be used to store both the IPv4 address and the IPv6 address if we specify the address family to <code class="markup--code markup--p-code">AF_UNSPEC</code>.</p><p name="75f8" id="75f8" class="graf graf--p graf-after--p">Now, let’s see how the function <code class="markup--code markup--p-code">getaddrinfo</code> works for us. To use this function, we usually have to create three variables <code class="markup--code markup--p-code">hints</code> , <code class="markup--code markup--p-code">res</code> , and <code class="markup--code markup--p-code">p</code>. The <code class="markup--code markup--p-code">hints</code> variable is an instance of the <code class="markup--code markup--p-code">addrinfo</code> structure, while <code class="markup--code markup--p-code">res</code> and <code class="markup--code markup--p-code">p</code> are two pointers that can be used to point towards a <code class="markup--code markup--p-code">addrinfo</code> structure. They are defined by,</p><pre name="fd2f" id="fd2f" class="graf graf--pre graf-after--p">struct addrinfo hints, *res, *p;</pre><p name="a003" id="a003" class="graf graf--p graf-after--pre">Before we use the <code class="markup--code markup--p-code">getaddrinfo</code> to resolve the hostname, we have to specify the values of the <code class="markup--code markup--p-code">hints</code> structure. We want to specify <code class="markup--code markup--p-code">ai_family</code> to <code class="markup--code markup--p-code">AF_UNSPEC</code> because we want to resolve both the IPv4 and the IPv6 addresses for this hostname. Also, we have to use the TCP transformation, so we have to use the stream sockets.</p><pre name="98eb" id="98eb" class="graf graf--pre graf-after--p">memset(&amp;hints, 0, sizeof hints); // initialize hints with 0s<br>hints.ai_family = AF_UNSPEC; // AF_INET or AF_INET6 to force version<br>hints.ai_socktype = SOCK_STREAM; // TCP transformation</pre><p name="502d" id="502d" class="graf graf--p graf-after--pre">Then we can call this magic function <code class="markup--code markup--p-code">getaddrinfo</code> to resolve the hostname,</p><pre name="f94e" id="f94e" class="graf graf--pre graf-after--p">char *hostname = &quot;localhost&quot;;<br>status = getaddrinfo(hostname, NULL, &amp;hints, &amp;res);</pre><p name="f293" id="f293" class="graf graf--p graf-after--pre">The return value <code class="markup--code markup--p-code">status</code> of this function is the status after resolving the hostname. <code class="markup--code markup--p-code">0</code> means that the hostname is resolved successfully. If the returned value is not zero, we can use the function <code class="markup--code markup--p-code">gai_strerror</code> to print the detailed error information.</p><pre name="f476" id="f476" class="graf graf--pre graf-after--p">printf(&quot;%s&quot;, gai_strerror(status));</pre><p name="cbfc" id="cbfc" class="graf graf--p graf-after--pre">After resolution, the <code class="markup--code markup--p-code">res</code> pointer will be pointing towards a <code class="markup--code markup--p-code">addrinfo</code> structure that stores the address information. Because this structure has an element <code class="markup--code markup--p-code">ai_next</code> , which is a pointer pointing to the next <code class="markup--code markup--p-code">addrinfo</code> structure, we actually have a linked list (or maybe we can call it a lined structure) as a result. If we loop this structure and retrieve <code class="markup--code markup--p-code">ai_addr</code>s until we meet a NULL pointer, we can get all the address information of this given hostname.</p><figure name="a0e8" id="a0e8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MTSF-Wc15RW4CY3Ti4KgAA.png" data-width="1974" data-height="176" src="https://cdn-images-1.medium.com/max/800/1*MTSF-Wc15RW4CY3Ti4KgAA.png"></figure><p name="4495" id="4495" class="graf graf--p graf-after--figure">So the looping structure should be,</p><pre name="6719" id="6719" class="graf graf--pre graf-after--p">for(p = res;p != NULL; p = p-&gt;ai_next) {<br>    ...<br>}</pre><p name="c21d" id="c21d" class="graf graf--p graf-after--pre">For each loop, we have to specify whether this is an IPv4 address or an IPv6 address by <code class="markup--code markup--p-code">ai_family</code> and then create a structure instance of either <code class="markup--code markup--p-code">sockaddr_in</code> or <code class="markup--code markup--p-code">sockaddr_in6</code> based on this address. From the <a href="https://man7.org/linux/man-pages/man3/inet_ntop.3.html" data-href="https://man7.org/linux/man-pages/man3/inet_ntop.3.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">manual</a> of the <code class="markup--code markup--p-code">inet_ntop</code> function, we can know that this function accepts the address of the structure <code class="markup--code markup--p-code">sin_addr</code> or <code class="markup--code markup--p-code">sin6_addr</code> for its second argument. Thus, we can use a conditioned structure to resolve the IPv4 and IPv6 addresses of the given hostname.</p><p name="4b0d" id="4b0d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Example Code for Showing IP By Hostname</strong></p><p name="c155" id="c155" class="graf graf--p graf-after--p">Wrap up all the things we have covered, we can have the following program that can resolve the hostname <code class="markup--code markup--p-code">localhost</code> for us. For example,</p><figure name="b78d" id="b78d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/0f511afa6d36b17b27e60747b230f45c.js"></script></figure><p name="88fa" id="88fa" class="graf graf--p graf-after--figure graf--trailing">Remember, in the end, we have to free the linked structure by function <code class="markup--code markup--p-code">freeaddrinfo</code> with the <code class="markup--code markup--p-code">res</code> variable. Note that the code above can also be used to resolve the IP address like <code class="markup--code markup--p-code">127.0.0.1</code> or <code class="markup--code markup--p-code">::1</code> directly.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/c2f034511cd4"><time class="dt-published" datetime="2021-02-06T23:29:46.848Z">February 6, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-9-socket-programming-experiment-2-enable-ipv4-and-ipv6-c2f034511cd4" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>