<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 23 | Introduction to Remote Procedure Calls, Interface Definition Language, RPC…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 23 | Introduction to Remote Procedure Calls, Interface Definition Language, RPC…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="af8f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0d95" id="0d95" class="graf graf--h3 graf--leading graf--title">Operating System 23 | <strong class="markup--strong markup--h3-strong">Introduction to Remote Procedure Calls, Interface Definition Language, RPC Design, RPC Examples, and XDR</strong></h3><figure name="516d" id="516d" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*1WlOcGy8LqpUvEDi.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*1WlOcGy8LqpUvEDi.png"></figure><ol class="postList"><li name="6f04" id="6f04" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Introduction to Remote Procedure Calls (RPC)</strong></li></ol><p name="3507" id="3507" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Remote Procedure Calls (RPC)</strong></p><p name="a407" id="a407" class="graf graf--p graf-after--p">In this section, we are going to talk about <strong class="markup--strong markup--p-strong">remote procedure calls</strong> (aka. <strong class="markup--strong markup--p-strong">RPC</strong>), which is an IPC mechanism that specifies that the processes interact via a <strong class="markup--strong markup--p-strong">procedure call interface</strong>. RPC is intended to simplify the development of <strong class="markup--strong markup--p-strong">cross-address space</strong> and or <strong class="markup--strong markup--p-strong">cross-machine interactions</strong>.</p><p name="c321" id="c321" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Remote Procedure Calls: Two Examples</strong></p><p name="510e" id="510e" class="graf graf--p graf-after--p">To understand RPCs, let’s look at two example applications.</p><p name="ac4c" id="ac4c" class="graf graf--p graf-after--p">The first example is an application where a client requests a file from a server and uses a simple GETFILE protocol similar to HTTP. In this case, we will,</p><ul class="postList"><li name="677b" id="677b" class="graf graf--li graf-after--p">create and init sockets for client-server communication</li><li name="92f9" id="92f9" class="graf graf--li graf-after--li">allocate any buffers that are going to be sent via those sockets</li><li name="010b" id="010b" class="graf graf--li graf-after--li">populate the information with anything that includes the protocol (i.e. GETFILE, file size, etc.)</li><li name="a075" id="a075" class="graf graf--li graf-after--li">explicitly copy the file data in and out of these buffers</li></ul><p name="5054" id="5054" class="graf graf--p graf-after--li">A second example is an application where a client-server application in which the client interacts with a server to upload some images, and that it requests them from the server for these images to be modified to create a grayscale version (or some other algorithms) of an image. See an example from <a href="https://pinetools.com/grayscale-image" data-href="https://pinetools.com/grayscale-image" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>. In this case, we will,</p><ul class="postList"><li name="821f" id="821f" class="graf graf--li graf-after--p">create and init sockets for client-server communication</li><li name="09e0" id="09e0" class="graf graf--li graf-after--li">allocate any buffers that are going to be sent via those sockets</li><li name="7528" id="7528" class="graf graf--li graf-after--li">populate the information with anything that includes the protocol (i.e. algorithm, parameters, etc.)</li><li name="1715" id="1715" class="graf graf--li graf-after--li">explicitly copy the image data in and out of these buffers</li></ul><p name="ef54" id="ef54" class="graf graf--p graf-after--li">We can discover that although these two examples focus on different purposes, they have similar synchronous semantics. So in the 80s as networks were becoming faster and more and more distributed applications were being developed, it became obvious that these kinds of steps are really very common in related interprocess communications and need to be re-implemented for the majority of these kinds of applications.</p><p name="a113" id="a113" class="graf graf--p graf-after--p">So it was obvious that we need some system solution that will simplify this process, which will capture all the common steps that are related to remote interprocess communications. This gave rise to <strong class="markup--strong markup--p-strong">RPCs</strong>.</p><p name="ab5e" id="ab5e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Benefits of RPC</strong></p><p name="a38a" id="a38a" class="graf graf--p graf-after--p">RPCs offer a higher-level interface that captures all aspects of data movement and communications, and there are some benefits of using it,</p><ul class="postList"><li name="f9b8" id="f9b8" class="graf graf--li graf-after--p">RPC offers a <strong class="markup--strong markup--li-strong">higher-level interface</strong>: easy for programmers</li><li name="baa6" id="baa6" class="graf graf--li graf-after--li">RPC provides many <strong class="markup--strong markup--li-strong">error handlings</strong>: don’t need to reimplement the error handlers</li><li name="cd83" id="cd83" class="graf graf--li graf-after--li">RPC<strong class="markup--strong markup--li-strong"> hides the complexities </strong>of cross machines interactions: programmers don’t have to worry about machine differences</li></ul><p name="8890" id="8890" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) RPC Features</strong></p><p name="0996" id="0996" class="graf graf--p graf-after--p">If we want to implement the RPC, there are some system software features. These features include,</p><ul class="postList"><li name="4464" id="4464" class="graf graf--li graf-after--p">RPC can manage client-server interactions</li><li name="808a" id="808a" class="graf graf--li graf-after--li">RPC provides procedure call interfaces: simplify the system calls</li><li name="73a0" id="73a0" class="graf graf--li graf-after--li">RPC can do type checking: optimize run time and handle errors, and it can also provide useful type information</li><li name="60ec" id="60ec" class="graf graf--li graf-after--li">RPC can provide cross-machine communication: we can differ from big-endian and little-endian</li><li name="78fc" id="78fc" class="graf graf--li graf-after--li">RPC would like to perform higher-level protocol: except for TCP and UDP, it should also support access control, authentication, or fault tolerance</li></ul><p name="448a" id="448a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) RPC Organization: Client Stub</strong></p><p name="e335" id="e335" class="graf graf--p graf-after--p">Now let’s see an example about the RPC organization. Consider a client and server system. The client wants to perform some arithmetic operation, let’s say addition, subtraction, multiplication but doesn’t know how to. The server is the calculator process and it knows how to perform all of these operations.</p><p name="b72d" id="b72d" class="graf graf--p graf-after--p">Whenever the client needs to perform some arithmetic operation, it needs to send the message over to the server that specifies what is the operation it wants to perform as well as the arguments. The server is the one that has the implementation of that operation so it will take those arguments, perform the operation, and then return the results.</p><p name="623f" id="623f" class="graf graf--p graf-after--p">To simplify all of the communications-related aspects of the programming like creating sockets, allocating and managing the buffers for the arguments, and for the results, and all the other details, this communication pattern will use RPC.</p><p name="6861" id="6861" class="graf graf--p graf-after--p">In this example, when the RPC add is called, the execution of the program will also jump to another location in the address space but it won’t be where the real implementation of add is. Instead, it will be in a <strong class="markup--strong markup--p-strong">client stub</strong> implementation from the rest of the client’s process it will look just like the real add, but internally what the stub does is something entirely different.</p><p name="0a62" id="0a62" class="graf graf--p graf-after--p">The responsibility of the client stub is to create a buffer and populate that buffer with all of the appropriate information, in this case, it’s the descriptor of the function that the client wants the server to perform, the <code class="markup--code markup--p-code">add</code>, as well as its arguments, the integers i and j. The stub code itself is automatically generated via some tools that are part of the RPC package, so the programmer doesn’t have to write this code.</p><figure name="c4d0" id="c4d0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YW-_8fSgpUbEvSqfST49iA.png" data-width="1368" data-height="490" src="https://cdn-images-1.medium.com/max/800/1*YW-_8fSgpUbEvSqfST49iA.png"></figure><p name="4ba5" id="4ba5" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) RPC Steps</strong></p><p name="0f21" id="0f21" class="graf graf--p graf-after--p">To generalize from the example that we saw in the previous video, we will now summarize the steps that have to take place in an RPC interaction between a client and a server.</p><ul class="postList"><li name="454c" id="454c" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Step #-1 </strong>(<strong class="markup--strong markup--li-strong">register</strong>): the server registers procedure, argument types, location, etc. The server will need to announce to the rest of the world the procedure that it knows how to perform, the argument types that are required for that procedure, its location, the IP address, the port number, etc.</li><li name="5d85" id="5d85" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step #0</strong> (<strong class="markup--strong markup--li-strong">bind</strong>): the client finds and binds to the server</li><li name="8609" id="8609" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step #1</strong> (<strong class="markup--strong markup--li-strong">call</strong>): the client makes an RPC call, which passes the information to the stub and the rest of the client code blocks</li><li name="4800" id="4800" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step #2</strong> (<strong class="markup--strong markup--li-strong">marshal</strong>): the client stub will create a data buffer and it will populate it with the values of the arguments that are passed to the procedure call. This process is called <strong class="markup--strong markup--li-strong">marshalling the arguments</strong>.</li><li name="3245" id="3245" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step #3</strong> (<strong class="markup--strong markup--li-strong">send</strong>): the client sends the message to the server</li><li name="4875" id="4875" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step #4</strong> (<strong class="markup--strong markup--li-strong">receive</strong>): the server receives the message and then passes the message to the server stub. Necessary checks are performed to determine what is the correct server stub that this message needs to be passed to, and it’s possible to include certain access control checks at this particular step.</li><li name="cc7a" id="cc7a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step #5</strong> (<strong class="markup--strong markup--li-strong">unmarshal</strong>): the server stub will unmarshall the data. Unmarshall is clearly the reverse of marshalling, so this will take the byte stream that’s coming from the received buffers, it will extract the arguments, and it will create whatever data structures are needed to hold the values of those arguments.</li><li name="2ced" id="2ced" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step #6</strong> (<strong class="markup--strong markup--li-strong">actual call</strong>): the actual procedure call can be made once the arguments are allocated and set to the appropriate values.</li><li name="318b" id="318b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step #7 </strong>(<strong class="markup--strong markup--li-strong">result</strong>): the server will compute the result of the operation or potentially it will conclude that there is some kind of error message that needs to be returned. The result will be passed to the server stub and it will follow a similar reverse-path in order to be returned back to the client.</li></ul><p name="eb3d" id="eb3d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">2. Interface Definition Language (IDL)</strong></p><p name="1577" id="1577" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Interface Definition Language (IDL)</strong></p><p name="a117" id="a117" class="graf graf--p graf-after--p">The RPC client and server don’t have to be developed together as part of the same application. They may be completely independent processes written by different developers, written even in completely different programming languages.</p><p name="2fd1" id="2fd1" class="graf graf--p graf-after--p">But for this to work, there must be some kind of <strong class="markup--strong markup--p-strong">agreement</strong>, and the RPC systems rely on <strong class="markup--strong markup--p-strong">interface definition languages</strong> (aka. <strong class="markup--strong markup--p-strong">IDLs</strong>). IDLs serve as a protocol of how this agreement will be expressed.</p><p name="7aa1" id="7aa1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Information of IDL</strong></p><p name="303a" id="303a" class="graf graf--p graf-after--p">An IDL is used to describe the interface that particular server exports and this will at least include,</p><ul class="postList"><li name="54bd" id="54bd" class="graf graf--li graf-after--p">the name of the procedure</li><li name="c683" id="c683" class="graf graf--li graf-after--li">the types of the different arguments</li><li name="d393" id="d393" class="graf graf--li graf-after--li">the types of the results</li><li name="a956" id="a956" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">version number:</strong> it is useful when there are a number of servers that perform the same operation and the version number helps a client identify which server is the most current implementation of this procedure so that we don’t have to upgrade all the clients and all the servers at the same time. So, this is basically useful for so-called <strong class="markup--strong markup--li-strong">incremental upgrades</strong>.</li></ul><p name="6ab9" id="6ab9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Types of IDL</strong></p><p name="3c49" id="3c49" class="graf graf--p graf-after--p">The RPC system can use an interface definition for the interface specification that’s <strong class="markup--strong markup--p-strong">completely agnostic</strong> to the pre-existing programming languages (e.g. <a href="http://web.cs.wpi.edu/~rek/DCS/D04/SunRPC.html" data-href="http://web.cs.wpi.edu/~rek/DCS/D04/SunRPC.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">XDR</a> in SunRPC), or we can have a <strong class="markup--strong markup--p-strong">language-specific IDL </strong>(e.g. Java in Java RMI), which means the IDL for this RPC looks just like Java.</p><p name="f0e3" id="f0e3" class="graf graf--p graf-after--p">Now let me reiterate one more time that whatever the choice for the IDL language, this is used only for the interface that the server will export. The IDL is <strong class="markup--strong markup--p-strong">NOT</strong> actually used for the actual implementation of the service.</p><p name="e877" id="e877" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. RPC Design</strong></p><p name="c623" id="c623" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Marshalling</strong></p><p name="78f7" id="78f7" class="graf graf--p graf-after--p">To understand marshalling, let’s look at the add example again. The variables <code class="markup--code markup--p-code">i</code> and <code class="markup--code markup--p-code">j</code> are somewhere in the memory of the client process address space. The client makes the call to the RPC procedure (RPC add) and passes <code class="markup--code markup--p-code">i</code> and<code class="markup--code markup--p-code"> j</code> as arguments to it. At the lowest level of the RPC runtime, this will somehow need to result in a message that’s stored in some buffer that needs to be sent via socket API to some remote server. The marshalling code will take these variables <code class="markup--code markup--p-code">i</code> and <code class="markup--code markup--p-code">j</code> and then it will copy them into this buffer. It will serialize the arguments of the procedure into a contiguous memory location in this manner.</p><figure name="5ad2" id="5ad2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*7SUdQy41bRoqf5mUkWMEmg.png" data-width="1668" data-height="288" src="https://cdn-images-1.medium.com/max/800/1*7SUdQy41bRoqf5mUkWMEmg.png"></figure><p name="e78f" id="e78f" class="graf graf--p graf-after--figure">This means that the marshalling process needs to <strong class="markup--strong markup--p-strong">encode</strong> the data into some agreed-upon format so that it can be correctly interpreted on the receiving side.</p><p name="6617" id="6617" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Unmarshalling</strong></p><p name="03ee" id="03ee" class="graf graf--p graf-after--p">In contrast, in the unmarshalling, we take the buffer that’s provided by the network protocol and then based on the procedure descriptor and the data types that we know are required for that procedure descriptor. As a result of the unmarshalling process, these <code class="markup--code markup--p-code">i</code> and <code class="markup--code markup--p-code">j</code> will be allocated somewhere in the server address space.</p><figure name="6923" id="6923" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*FjLlNn00dsGbvFLZaOyuYw.png" data-width="1668" data-height="596" src="https://cdn-images-1.medium.com/max/800/1*FjLlNn00dsGbvFLZaOyuYw.png"></figure><p name="9062" id="9062" class="graf graf--p graf-after--figure">Note that the marshalling and unmarshalling routines aren’t something that the developer will explicitly have to write, but the RPC systems typically include a special compiler that takes an IDL specification for generating the marshalling and the unmarshalling routines.</p><p name="993f" id="993f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Binding</strong></p><p name="66d8" id="66d8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Binding</strong> is the mechanism that’s used by the client to determine,</p><ul class="postList"><li name="0b52" id="0b52" class="graf graf--li graf-after--p">which is the server that it needs to connect to (by service name, version number, etc.)</li><li name="9702" id="9702" class="graf graf--li graf-after--li">how to connect to that particular server (by IP address, network protocols, etc.)</li></ul><p name="1fa8" id="1fa8" class="graf graf--p graf-after--li">To support binding, the system software needs to support some form of <strong class="markup--strong markup--p-strong">database</strong> of all of the available services, and this is often called a <strong class="markup--strong markup--p-strong">registry</strong>.</p><p name="49e9" id="49e9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) The Definition of Registry</strong></p><p name="1f27" id="1f27" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">registry</strong> is a database of available services that are supported by the system software. It can be treated as the yellow pages that you will need to look up the service name, and then find the best match based on,</p><ul class="postList"><li name="cda0" id="cda0" class="graf graf--li graf-after--p">the protocol</li><li name="e827" id="e827" class="graf graf--li graf-after--li">the version number</li><li name="dc39" id="dc39" class="graf graf--li graf-after--li">the proximity</li><li name="dd8e" id="dd8e" class="graf graf--li graf-after--li">etc.</li></ul><p name="b0ca" id="b0ca" class="graf graf--p graf-after--li">That match will then provide you with the contact details for that particular service instance as,</p><ul class="postList"><li name="b6f3" id="b6f3" class="graf graf--li graf-after--p">the address</li><li name="1d95" id="1d95" class="graf graf--li graf-after--li">the port number</li><li name="1950" id="1950" class="graf graf--li graf-after--li">the needed protocol</li></ul><p name="6210" id="6210" class="graf graf--p graf-after--li">The registry can be deployed either <strong class="markup--strong markup--p-strong">online </strong>(e.g. by something like RPCregistry.com) or <strong class="markup--strong markup--p-strong">machine-specific</strong> (means that every machine knows only about those services that run on that particular machine).</p><p name="eee1" id="eee1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Naming Protocol</strong></p><p name="844b" id="844b" class="graf graf--p graf-after--p">Regardless of how the registry is implemented, it will require some sort of <strong class="markup--strong markup--p-strong">naming protocol</strong> (aka.<strong class="markup--strong markup--p-strong"> naming conventions</strong>). For instance, the simplest approach could require that a client has to specify the exact name and version of the service that it requires like <code class="markup--code markup--p-code">add</code>. Or a more sophisticated naming scheme could consider the fact that words like,</p><ul class="postList"><li name="bed7" id="bed7" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">summation</code></li><li name="7692" id="7692" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sum</code></li><li name="6ea4" id="6ea4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">addition</code></li></ul><p name="d623" id="d623" class="graf graf--p graf-after--li">are likely equivalent to the use of the word <code class="markup--code markup--p-code">add</code> and so any service that uses any one of these function names or service names is a fair candidate to be considered when trying to find the best match.</p><p name="99bb" id="99bb" class="graf graf--p graf-after--p">Allowing this type of reasoning will require support for things like <strong class="markup--strong markup--p-strong">ontology</strong> or other cognitive learning methods, but we will not discuss this in this course.</p><p name="617d" id="617d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) An RPC Problem: Pointers</strong></p><p name="0248" id="0248" class="graf graf--p graf-after--p">A tricky issue when it comes to RPC’s is the use of pointers as arguments to procedures. In regular procedures, it makes perfect sense to have procedures like this foo that takes two arguments, an integer and a second argument is a pointer to an integer or an integer array. For example,</p><pre name="355d" id="355d" class="graf graf--pre graf-after--p">foo(int x, int *y);</pre><p name="5a3d" id="5a3d" class="graf graf--p graf-after--pre">However, in RPC, passing a pointer to the remote server <strong class="markup--strong markup--p-strong">makes no sense</strong> since this pointer points to some location in the caller’s address space. The server cannot possibly get to the contents that are stored at this particular address.</p><p name="62df" id="62df" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) RPC Pointers Problem: Solutions</strong></p><p name="4245" id="4245" class="graf graf--p graf-after--p">In order to solve this problem, the RPC systems can make one of two decisions,</p><ul class="postList"><li name="3824" id="3824" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">No pointers</strong>: the simplest idea is that we will not allow any pointers to be used as arguments of any procedure that’s an RPC procedure so that we don’t have to worry about this problem</li><li name="cf5c" id="cf5c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Data copied</strong>: the other idea is that the marshalling code that gets generated with the fact that an argument is a pointer, and that instead of just taking that argument, the actual data pointed by this buffer will also be copied into the buffer. What that means is that it will copy the reference into the data buffer, into one <strong class="markup--strong markup--li-strong">serial representation</strong>.</li></ul><p name="afaa" id="afaa" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) RPC Failures</strong></p><p name="93d6" id="93d6" class="graf graf--p graf-after--p">In the RPC process, there can be many kinds of failures. These failures include,</p><ul class="postList"><li name="185a" id="185a" class="graf graf--li graf-after--p">overloaded server</li><li name="4e4b" id="4e4b" class="graf graf--li graf-after--li">lost client request</li><li name="4f0c" id="4f0c" class="graf graf--li graf-after--li">client packet lost</li><li name="01c8" id="01c8" class="graf graf--li graf-after--li">server packet lost</li><li name="6f63" id="6f63" class="graf graf--li graf-after--li">server machine crashed</li><li name="a932" id="a932" class="graf graf--li graf-after--li">server process crashed</li><li name="46f2" id="46f2" class="graf graf--li graf-after--li">network elements (e.g. network link) down</li><li name="ff2f" id="ff2f" class="graf graf--li graf-after--li">switch or router down</li><li name="9308" id="9308" class="graf graf--li graf-after--li">etc.</li></ul><p name="8618" id="8618" class="graf graf--p graf-after--li">Even if the RPC runtime incorporates some mechanisms that timeout whenever a client RPC call hangs, and then retries them automatically, there really are no guarantees that the problem will be resolved or that the RPC runtime will be able to provide some better understanding of what’s going on. What’s more, even if for some cases, it is possible to really understand what is the cause of the error, but in principle that is too complex, it would take a lot of overhead, and ultimately it’s still <strong class="markup--strong markup--p-strong">unlikely</strong> that it will provide a definitive answer.</p><p name="e8af" id="e8af" class="graf graf--p graf-after--p">For this reason, RPC systems typically try to introduce a new type of <strong class="markup--strong markup--p-strong">error notification</strong> or a new type of signal or exception that tries to capture what goes wrong with an RPC request <strong class="markup--strong markup--p-strong">without claiming to provide the exact detail</strong>. This serves as a catch-all for all types of errors, all types of failures that can potentially happen during an RPC call and it also can potentially indicate a partial failure.</p><p name="b2af" id="b2af" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) RPC Design Summary</strong></p><p name="8487" id="8487" class="graf graf--p graf-after--p">In the last few videos, we described some issues with the RPC mechanisms, and now let’s review them.</p><ul class="postList"><li name="7e9c" id="7e9c" class="graf graf--li graf-after--p">binding: how to find the server</li><li name="5953" id="5953" class="graf graf--li graf-after--li">IDL: how to talk to the server</li><li name="3bd2" id="3bd2" class="graf graf--li graf-after--li">marshalling: how to package the data</li><li name="9b52" id="9b52" class="graf graf--li graf-after--li">pointers dealers: disallowed pointers or serialized data</li><li name="1c2b" id="1c2b" class="graf graf--li graf-after--li">partial/entire failures: special error notifications</li></ul><p name="c5b4" id="c5b4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">4. RPC Examples</strong></p><p name="403c" id="403c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Sun RPC History</strong></p><p name="000e" id="000e" class="graf graf--p graf-after--p">Sun RPC is an RPC package originally developed by <strong class="markup--strong markup--p-strong">Sun</strong> in the 80s for their network file system or <strong class="markup--strong markup--p-strong">NFS for UNIX</strong> systems. But it became popular and now it’s widely available on other platforms.</p><p name="39f3" id="39f3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Sun RPC Design</strong></p><p name="034d" id="034d" class="graf graf--p graf-after--p">Sun RPC makes the following design choices,</p><ul class="postList"><li name="f099" id="f099" class="graf graf--li graf-after--p">Binding: a <strong class="markup--strong markup--li-strong">registry daemon per machine</strong> because the server machine is known upfront</li><li name="d840" id="d840" class="graf graf--li graf-after--li">IDL: relying on the agnostic language <strong class="markup--strong markup--li-strong">XDR</strong> for interface specification and for encoding</li><li name="ad73" id="ad73" class="graf graf--li graf-after--li">Pointers: allowed and <strong class="markup--strong markup--li-strong">serialized</strong></li><li name="fe23" id="fe23" class="graf graf--li graf-after--li">Failures: internally <strong class="markup--strong markup--li-strong">retry</strong> mechanism when timeout, and return as much information as possible when meets an error (<strong class="markup--strong markup--li-strong">meaning error information</strong>)</li></ul><p name="c652" id="c652" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Sun RPC Organization Overview</strong></p><p name="f30d" id="f30d" class="graf graf--p graf-after--p">Sun RPC client and Sun RPC server are allowed to interact via <strong class="markup--strong markup--p-strong">procedure call interface</strong>, and this is specified in the language XDR in the <code class="markup--code markup--p-code">.x</code> file. Sun RPC includes a compiler called <code class="markup--code markup--p-code">rpcgen</code> that will compile the interface specified in the <code class="markup--code markup--p-code">.x</code> file to a language-specific stub. It will generate separate stubs for the client and the server.</p><figure name="2f76" id="2f76" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*H1zFFpN3FW25StNJ9WdLUw.png" data-width="1604" data-height="684" src="https://cdn-images-1.medium.com/max/800/1*H1zFFpN3FW25StNJ9WdLUw.png"></figure><p name="7715" id="7715" class="graf graf--p graf-after--figure">The server process when <strong class="markup--strong markup--p-strong">launched</strong> will register itself with the registry daemon that’s available on the local machine. The per-machine registry will keep track of information that includes the name of the service, the version, any of the protocols that are supported with the service, and also the port number that needs to be contacted when the client-side RPC sends a request to the server. A client must explicitly contact the registry on the target machine in order to obtain information about the server process.</p><p name="f2e7" id="f2e7" class="graf graf--p graf-after--p">When the binding happens, the client creates an <strong class="markup--strong markup--p-strong">RPC handle</strong> and this handle is used whenever the client makes any RPC calls and in this way, the runtime is able to track all of the per-client RPC-related states.</p><figure name="68fc" id="68fc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0xQW4m4qEeev6rnLcpCmVg.png" data-width="1604" data-height="422" src="https://cdn-images-1.medium.com/max/800/1*0xQW4m4qEeev6rnLcpCmVg.png"></figure><p name="eb5b" id="eb5b" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Sun RPC and TI RPC</strong></p><p name="8e1e" id="8e1e" class="graf graf--p graf-after--p">Because Oracle purchased Sun in 2010, Sun RPC is now maintained by Oracle. You can find an <a href="https://docs.oracle.com/cd/E18752_01/html/816-1435/toc.html" data-href="https://docs.oracle.com/cd/E18752_01/html/816-1435/toc.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ONC+ developer’s guide</a> of the Sun RPC, and you may find references to <strong class="markup--strong markup--p-strong">TI RPC</strong> as opposed to Sun RPC in this link.</p><p name="1b8d" id="1b8d" class="graf graf--p graf-after--p">TI RPC stands for <strong class="markup--strong markup--p-strong">Transport Independent RPC</strong> and that means that the protocol that will be used for the client and server communication doesn’t have to specify at compile time. It can be specified <strong class="markup--strong markup--p-strong">dynamically</strong> at runtime. Other than that, the documentation and the examples closely follow the original SunRPC specification as well as the XDR interface definition language.</p><p name="a3d0" id="a3d0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) An XDR Example</strong></p><p name="caf7" id="caf7" class="graf graf--p graf-after--p">We’ll now take a look at the various components of Sun RPC using an example. The client again will be contacting a server that can perform calculations except for this time the client will pass a single argument <em class="markup--em markup--p-em">x</em> for which it will want the server to compute the square value <em class="markup--em markup--p-em">x</em>².</p><p name="e72f" id="e72f" class="graf graf--p graf-after--p">Here is the <code class="markup--code markup--p-code">.x</code> file for this example with which the server specifies its interface. In this case, the server supports one procedure <code class="markup--code markup--p-code">SQUARE_PROG</code> that has one argument of the type <code class="markup--code markup--p-code">square_in</code> and returns a result of the type <code class="markup--code markup--p-code">square_out</code>. The data types square_in and square_out are both defined in the <code class="markup--code markup--p-code">.x</code> file. If we take a look at them, it turns out that both of them have a single element and that’s an int and in XDR an int is an integer just like the integers in C, a 32-bit integer. Also, note that this notation <code class="markup--code markup--p-code">_in</code>, <code class="markup--code markup--p-code">_out</code> is not any part of the required syntax for specifying the input and the output data types in XDR.</p><p name="a933" id="a933" class="graf graf--p graf-after--p">In our case, the <code class="markup--code markup--p-code">SQUARE_PROG</code> service supports exactly one procedure and that’s <code class="markup--code markup--p-code">SQUARE_PROC</code> procedure. There is an ID number that is associated with it. This is 1 in this case. This number is not used by the programmer. The name <code class="markup--code markup--p-code">SQUARE_PROC</code> instead will use this value 1 as a reference.</p><p name="3a12" id="3a12" class="graf graf--p graf-after--p">There is also a version ID and a service ID. The former one is defined so that we don’t have to coordinate and upgrade all of the servers and all of the clients at the exact same time. The latter one is defined so that the RPC runtime can refer to for differentiating among the different services.</p><figure name="b688" id="b688" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/34724763f7dafb11524810d1d9c107a6.js"></script></figure><p name="6e63" id="6e63" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) Compiling XDR File</strong></p><p name="ddc4" id="ddc4" class="graf graf--p graf-after--p">Let’s show you actually compile a <code class="markup--code markup--p-code">.x</code> file. Assume that we’re using the <code class="markup--code markup--p-code">square.x</code> file we have discussed, and we would like to compile this file to automatically generate a bunch of code that’s used for the client and the service. For example, we will use the <code class="markup--code markup--p-code">-c</code> option to generate C code with <code class="markup--code markup--p-code">rpcgen</code> by,</p><pre name="7562" id="7562" class="graf graf--pre graf-after--p">$ rpcgen -c square.x</pre><p name="323c" id="323c" class="graf graf--p graf-after--pre">The outcome of this operation will be that a number of files will be generated.</p><ul class="postList"><li name="b855" id="b855" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">square.h</code>: language-specific definitions of data types and function prototypes</li><li name="eb83" id="eb83" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">square_svc.c</code>: server stub which also includes the skeleton of the actual server. This file will consist of two parts. The first one is the <code class="markup--code markup--li-code">main</code> function for the server that will include the code that does the registration and housekeeping. The other is the <code class="markup--code markup--li-code">square_prog_1</code> function that contains all the code related to the RPC service. This will include the automatically generate code for parsing the request, generate the arguments, conducting the argument marshaling operations, and other steps. In addition, in the stub file, the auto-generated code will include the prototype for the actual procedure that’s invoked in the server process named <code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">square_proc_1_svc</strong></code>, and this should be implemented by the programmer.</li><li name="ade7" id="ade7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">square_clnt.c</code>: client stub. It will include a procedure that’s automatically generated called <code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">square_proc_1</strong></code>. And this will represent a wrapper for the actual RPC call that the client makes to the server-side process where the implementation of the service <code class="markup--code markup--li-code">square_proc_1_svc</code> is actually called. Once we have all of this, the developer then writes the client application and makes a call to this wrapper function that looks something like this <code class="markup--code markup--li-code">y = square_proc_1(&amp;x…)</code>. This very much looks like a regular procedure call, there is no need to create sockets, create buffers, copy data into the buffers and this is what makes RPC appealing.</li><li name="7be4" id="7be4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">square_xdr.c</code>: some common code that’s related to the marshaling and unmarshalling routines for all data types arguments, and results that are used both at the client and on the server-side.</li></ul><figure name="7cc3" id="7cc3" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*tMYUDIJnW-6jTabqXjQGfQ.png" data-width="2012" data-height="1092" src="https://cdn-images-1.medium.com/max/800/1*tMYUDIJnW-6jTabqXjQGfQ.png"></figure><p name="61ac" id="61ac" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(7) Compiling Multithreading XDR</strong></p><p name="9d5c" id="9d5c" class="graf graf--p graf-after--p">We should point out that <code class="markup--code markup--p-code">rpcgen</code>, when used only with the flag <code class="markup--code markup--p-code">-c</code> generates code that is <strong class="markup--strong markup--p-strong">not thread-safe</strong>. The output of the compilation results in a function that will need to be called with something like,</p><pre name="833a" id="833a" class="graf graf--pre graf-after--p">y = squareproc_1(&amp;x, client_handle);</pre><p name="a88f" id="a88f" class="graf graf--p graf-after--pre">And the problem with this function is that internally the implementation of this operation as well at the runtime level, there are a number of statically allocated data structures including for the result and this leads to <strong class="markup--strong markup--p-strong">race conditions</strong> when multiple threads are trying to make RPC calls to this routine concurrently.</p><p name="a8ac" id="a8ac" class="graf graf--p graf-after--p">To generate thread-safe code, the code must be compiled with the <code class="markup--code markup--p-code">-M</code> option and M stands for <strong class="markup--strong markup--p-strong">multithreading safe</strong>,</p><pre name="0361" id="0361" class="graf graf--pre graf-after--p">$ rpcgen -c -M square.x</pre><p name="233d" id="233d" class="graf graf--p graf-after--pre">This will also create a wrapper function square_proc_1 like,</p><pre name="4507" id="4507" class="graf graf--pre graf-after--p">status = squareproc_1(&amp;x, &amp;y, client_handle);</pre><p name="adf0" id="adf0" class="graf graf--p graf-after--pre">However it has a different signature, and its implementation differs, for instance, it will dynamically allocate memory for the results of this operation so some of the issues that are coming up with the previous implementation will not come up in this case.</p><p name="b7e9" id="b7e9" class="graf graf--p graf-after--p">On Solaris platforms, there is another option <code class="markup--code markup--p-code">-a</code>. Using this option that actually generates <strong class="markup--strong markup--p-strong">multi-threaded server</strong> code. But on Linux, this option is not supported and any multithreaded server has to be created manually using the multithreaded safe routines as a starting point.</p><p name="f623" id="f623" class="graf graf--p graf-after--p">You can have a try at this by downloading the <a href="https://s3.amazonaws.com/content.udacity-data.com/courses/ud923/resources/ud923-p4l1-square.x" data-href="https://s3.amazonaws.com/content.udacity-data.com/courses/ud923/resources/ud923-p4l1-square.x" class="markup--anchor markup--p-anchor" rel="noreferrer noopener noopener" target="_blank">square.x file</a>, and then run <code class="markup--code markup--p-code">rpcgen</code> on the Ubuntu VM provided with this class. If you have not set up the Ubuntu VM yet, follow the <a href="https://www.udacity.com/wiki/ud923/resources/software/vm-setup" data-href="https://www.udacity.com/wiki/ud923/resources/software/vm-setup" class="markup--anchor markup--p-anchor" rel="noreferrer noopener noopener" target="_blank">Ubuntu VM Setup Instructions</a>.</p><p name="3372" id="3372" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Sun RPC Registry</strong></p><p name="0e6a" id="0e6a" class="graf graf--p graf-after--p">In SunRPC, the <strong class="markup--strong markup--p-strong">registry daemon</strong> is a process that runs on every single machine, and it’s called <strong class="markup--strong markup--p-strong">portmapper</strong>. To start this process on Linux, we have to have administrative permission or <code class="markup--code markup--p-code">sudo</code> access privileges, and then we can launch it with the following command <code class="markup--code markup--p-code">/sbin/portmap</code>.</p><pre name="a71e" id="a71e" class="graf graf--pre graf-after--p">$ sudo /usr<code class="markup--code markup--pre-code">/sbin/portmap</code></pre><p name="bb01" id="bb01" class="graf graf--p graf-after--pre">This is the process that has to be contacted by both the servers (when registering a service) and also by the clients (when finding a service). Given that the client already got to talk to this RPC daemon, it clearly knows what is the IP address of the machine that it will need to interact with. So the information that the client can extract from the portmapper includes,</p><ul class="postList"><li name="5a9f" id="5a9f" class="graf graf--li graf-after--p">port number</li><li name="20b1" id="20b1" class="graf graf--li graf-after--li">version</li><li name="8d73" id="8d73" class="graf graf--li graf-after--li">protocol</li><li name="4863" id="4863" class="graf graf--li graf-after--li">etc.</li></ul><p name="d69f" id="d69f" class="graf graf--p graf-after--li">Once the RPC daemon is running, we can explicitly check what are the services that are registered with it using <code class="markup--code markup--p-code">rpcinfo -p</code> by the following command,</p><pre name="35d0" id="35d0" class="graf graf--pre graf-after--p">$ /usr<code class="markup--code markup--pre-code">/sbin/rpcinfo -p</code></pre><p name="270d" id="270d" class="graf graf--p graf-after--pre">And the output may be,</p><pre name="5788" id="5788" class="graf graf--pre graf-after--p">program vers proto   port  service<br> 100000    4   tcp    111  portmapper<br> 100000    3   tcp    111  portmapper<br> 100000    2   tcp    111  portmapper<br> 100000    4   udp    111  portmapper<br> 100000    3   udp    111  portmapper<br> 100000    2   udp    111  portmapper</pre><p name="5dca" id="5dca" class="graf graf--p graf-after--pre">From the result, we can find out information about,</p><ul class="postList"><li name="c8e1" id="c8e1" class="graf graf--li graf-after--p">program ID</li><li name="f280" id="f280" class="graf graf--li graf-after--li">service name</li><li name="3969" id="3969" class="graf graf--li graf-after--li">version</li><li name="ba82" id="ba82" class="graf graf--li graf-after--li">contact information (protocol, socket port number)</li></ul><p name="56e2" id="56e2" class="graf graf--p graf-after--li">The <code class="markup--code markup--p-code">portmapper</code> service is registered with TCP and UDP on the same port number 111. This means that there are two different sockets that the server is listening to. One is the TCP socket and another one is the UDP socket and they both happen to use the exact same port number 111. This means that with this service, the portmapper will be able to talk to both TCP clients as well as UDP clients.</p><p name="6994" id="6994" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Sun RPC Binding</strong></p><p name="a7e2" id="a7e2" class="graf graf--p graf-after--p">Now, let’s talk about the Sun RPC binding process. The binding process is initiated by the client using the following operations,</p><pre name="440c" id="440c" class="graf graf--pre graf-after--p">CLIENT* clnt_handle = clnt_create(rpc_host_name, SQUARE_PROG, SQUARE_VERS, &quot;tcp&quot;);</pre><p name="b02b" id="b02b" class="graf graf--p graf-after--pre">To use this function, we have to specify the name of the RPC service <code class="markup--code markup--p-code">rpc_host_name</code> as well as the protocol we want to use when communicating with the server, and we will specify the name of the RPC service by <code class="markup--code markup--p-code">SQUARE_PROG</code> as well as the version number <code class="markup--code markup--p-code">SQUARE_VERS</code>. These two arguments of the client create operations are auto-generated in the <code class="markup--code markup--p-code">rpcgen</code> process from the <code class="markup--code markup--p-code">.x</code> file and will be included in the header file as hash-defined values.</p><p name="c770" id="c770" class="graf graf--p graf-after--p">The return from this operation is a variable <code class="markup--code markup--p-code">clnt_handle</code> that’s of data type <code class="markup--code markup--p-code">CLIENT</code>. This is the client handle that the client will include in every single RPC operation that it requests, and this handle will be used to track certain information such as,</p><ul class="postList"><li name="40d5" id="40d5" class="graf graf--li graf-after--p">status of the current RPC operation</li><li name="686a" id="686a" class="graf graf--li graf-after--li">error messages</li><li name="a809" id="a809" class="graf graf--li graf-after--li">authentication-related information</li></ul><p name="2ea4" id="2ea4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(10) XDR Data Types</strong></p><p name="ccc7" id="ccc7" class="graf graf--p graf-after--p">Because all the input and output arguments must be described in the XDR file, we have to know the XDR data types. Some of the default XDR data types are those that are commonly available in programming C languages (e.g. character, byte, int, and float) but XDR supports many other data types. You can find all of them from <a href="https://tools.ietf.org/html/rfc4506#page-4" data-href="https://tools.ietf.org/html/rfc4506#page-4" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this document</a>, but we will explain some of the common ones here. For example,</p><ul class="postList"><li name="55e9" id="55e9" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">const</code>: a <code class="markup--code markup--li-code">#define</code> value</li><li name="46b2" id="46b2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">hyper</code>: a 64-bit integer</li><li name="2707" id="2707" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">guadruple</code>: a 128-bit float</li><li name="024c" id="024c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">opaque</code>: uninterpreted binary data (e.g. the image data can be represented by an array of <code class="markup--code markup--li-code">opaque</code> type data)</li></ul><p name="8f86" id="8f86" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(11) XDR Array</strong></p><p name="b419" id="b419" class="graf graf--p graf-after--p">Let’s talk more specifically about arrays because in XDR we can specify two types of arrays.</p><p name="94fb" id="94fb" class="graf graf--p graf-after--p">The first is a <strong class="markup--strong markup--p-strong">fixed-length array</strong> that’s described as follows. And here, the exact number of elements in the array is specified. The RPC runtime will allocate the corresponding amount of memory whenever arguments of this data type are sent or received and it will also know exactly how many bytes from the incoming packet stream it should read out in order to populate a variable that’s of this type of array.</p><pre name="59b3" id="59b3" class="graf graf--pre graf-after--p">int data[80];</pre><p name="d9eb" id="d9eb" class="graf graf--p graf-after--pre">There are also <strong class="markup--strong markup--p-strong">variable-length arrays</strong> where the length is specified in angular brackets, and this doesn’t denote the actual length, rather the <strong class="markup--strong markup--p-strong">maximum expected length</strong>. When compiled, this will translate into a data structure that has two fields, an integer <code class="markup--code markup--p-code">len</code> that corresponds to the actual size of this array and a pointer <code class="markup--code markup--p-code">val</code> that is the address of where the data in this array is actually stored.</p><pre name="f1c2" id="f1c2" class="graf graf--pre graf-after--p">int data&lt;80&gt;;</pre><p name="56e8" id="56e8" class="graf graf--p graf-after--pre">A <strong class="markup--strong markup--p-strong">variable-length string</strong> is defined as follows and it is really just a C pointer to characters. In memory, this string will be stored just like a <strong class="markup--strong markup--p-strong">normal null-terminated string</strong>, so it will be an array of characters with the null character at the end.</p><pre name="f01d" id="f01d" class="graf graf--pre graf-after--p">string line&lt;80&gt;;</pre><p name="89bb" id="89bb" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(12) XDR Routines</strong></p><p name="1095" id="1095" class="graf graf--p graf-after--p">XDR provides the RPC runtime with some helpful <strong class="markup--strong markup--p-strong">routines</strong>.</p><p name="d80e" id="d80e" class="graf graf--p graf-after--p">For instance, after we compile an XDR file, the compiler will generate a number of routines that are used for <strong class="markup--strong markup--p-strong">marshalling</strong> or <strong class="markup--strong markup--p-strong">unmarshalling</strong> the various data types that can be found in <code class="markup--code markup--p-code">square_xdr.c</code> file.</p><p name="ca91" id="ca91" class="graf graf--p graf-after--p">In addition, the compiler will generate some <strong class="markup--strong markup--p-strong">cleanup operations</strong> like <code class="markup--code markup--p-code">xdr_free</code> that are used to deallocate or to free up memory regions that are used for the data structures or the arguments in the RPC operations. These routines will typically be called within a procedure, that the name of the procedure typically ends with <code class="markup--code markup--p-code">_freeresult</code> (e.g. <code class="markup--code markup--p-code">square_prog_1_freeresult</code>). The RPC runtime will automatically call this procedure after it’s done computing a result.</p><p name="b4ab" id="b4ab" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(13) XDR Buffer</strong></p><p name="7cce" id="7cce" class="graf graf--p graf-after--p">One remaining question is what ends up in the buffers that are being passed for transmission among the client and the server, and here, we will talk about its answer. The buffer will include,</p><ul class="postList"><li name="8988" id="8988" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">RPC header</strong>: containing server procedure ID, version number, request ID, etc. Similar types of information will be sent from the server back to the client again as part of the <strong class="markup--strong markup--li-strong">RPC header</strong>.</li><li name="87aa" id="87aa" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Actual data</strong>: containing the actual data, the actual arguments, or results. As opposed to just directly copying from memory into the packets we have to first <strong class="markup--strong markup--li-strong">encode</strong> all of the different data types for the arguments and the results into a byte stream to serialize them in a way that depends on the actual data type.</li><li name="6e3d" id="6e3d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Transport header</strong>: containing the networking header including the protocol, the destination address, and etc.</li></ul><p name="7d1b" id="7d1b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(14) XDR Encoding Rules</strong></p><p name="89eb" id="89eb" class="graf graf--p graf-after--p">Here are some encoding rules of the XDR,</p><ul class="postList"><li name="3601" id="3601" class="graf graf--li graf-after--p">all data types are encoded in multiples of <strong class="markup--strong markup--li-strong">4 bytes</strong>: even if we have 1-byte data, there need to be three more paddings</li><li name="05d5" id="05d5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">big-endian</strong> is used for the transmission standard: in some cases, this will be pure overheads, but we eliminate any kinds of ambiguity</li><li name="ca28" id="ca28" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">2’s complement</strong> is used for integers</li><li name="4066" id="4066" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">IEEE format</strong> is used for the floating points</li><li name="3f59" id="3f59" class="graf graf--li graf-after--li">etc.</li></ul><p name="100a" id="100a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(15) XDR Encoding: An Example</strong></p><p name="8493" id="8493" class="graf graf--p graf-after--p">Suppose we have a definition of the data type in an XDR file as follows,</p><pre name="38ac" id="38ac" class="graf graf--pre graf-after--p">string data&lt;10&gt;;<br>data = &quot;Hello&quot;;</pre><p name="673c" id="673c" class="graf graf--p graf-after--pre">If we have C processes, then this variable will take 6 bytes, 5 bytes for each char, and 1 last byte for the last NULL terminating character <code class="markup--code markup--p-code">\0</code>. However, in the transmission buffer, the variable will be encoded and it will take actually 12 bytes for,</p><ul class="postList"><li name="8a08" id="8a08" class="graf graf--li graf-after--p">4 bytes for the length integer (i.e. <code class="markup--code markup--li-code">len = 5</code>)</li><li name="1438" id="1438" class="graf graf--li graf-after--li">5 bytes for the characters</li><li name="fa57" id="fa57" class="graf graf--li graf-after--li">no NULL terminating character</li><li name="5879" id="5879" class="graf graf--li graf-after--li graf--trailing">3 bytes for padding because of the XDR encoding rules</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/f8922e69bea3"><time class="dt-published" datetime="2021-04-16T15:44:29.011Z">April 16, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-23-introduction-to-remote-procedure-calls-interface-definition-language-rpc-f8922e69bea3" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>