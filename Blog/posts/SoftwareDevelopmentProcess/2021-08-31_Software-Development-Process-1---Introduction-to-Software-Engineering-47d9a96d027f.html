<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Software Development Process 1 | Introduction to Software Engineering</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Software Development Process 1 | Introduction to Software Engineering</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Software Development Process
</section>
<section data-field="body" class="e-content">
<section name="1d00" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="43a3" id="43a3" class="graf graf--h3 graf--leading graf--title">Software Development Process 1 | <strong class="markup--strong markup--h3-strong">Introduction to Software Engineering</strong></h3><figure name="1e01" id="1e01" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*BwRKeiwQ9m3ttrQ0HwDd4w.png" data-width="1516" data-height="712" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*BwRKeiwQ9m3ttrQ0HwDd4w.png"></figure><ol class="postList"><li name="7d6e" id="7d6e" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Introduction to Software Engineering</strong></li></ol><p name="836f" id="836f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Discipline of Software Engineering</strong></p><p name="c790" id="c790" class="graf graf--p graf-after--p">In order to build high-quality software that works and fits our budget, we should have the following disciplines of software engineering,</p><ul class="postList"><li name="2a1c" id="2a1c" class="graf graf--li graf-after--p">Methodologies</li><li name="c417" id="c417" class="graf graf--li graf-after--li">Techniques</li><li name="8486" id="8486" class="graf graf--li graf-after--li">Tools</li></ul><p name="1dc5" id="1dc5" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) The Software Crisis</strong></p><p name="360b" id="360b" class="graf graf--p graf-after--p">Before the 60s, the size and complexity of software were very limited and hardware components were dominating the scene. Then in the 60s, people realized they couldn&#39;t create the software they needed, and the result of this is called the software crisis. There are three major reasons for the software crisis,</p><ul class="postList"><li name="217a" id="217a" class="graf graf--li graf-after--p">increasing product complexity</li><li name="4dc5" id="4dc5" class="graf graf--li graf-after--li">slow programmer’s productivity growth</li><li name="c6b0" id="c6b0" class="graf graf--li graf-after--li">rising demand for softwares</li></ul><p name="e63a" id="e63a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Development Effort</strong></p><p name="0efa" id="0efa" class="graf graf--p graf-after--p">Even though people have demands for software engineering, it is not an easy task to find the right person at that time. There is an increasing amount of development effort needed due to product complexity and the development effort is not linear.</p><p name="7ebe" id="7ebe" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">programming effort</strong> is something that the heroic effort of an individual developer can get the job done. If you’re a good programmer you can go sit down and do it right. This includes,</p><ul class="postList"><li name="5b9c" id="5b9c" class="graf graf--li graf-after--p">class exercises</li><li name="4047" id="4047" class="graf graf--li graf-after--li">small project</li><li name="ec03" id="ec03" class="graf graf--li graf-after--li">team project</li></ul><p name="782c" id="782c" class="graf graf--p graf-after--li">However, for the <strong class="markup--strong markup--p-strong">software engineering effort</strong>, no matter how much programming languages, development environments, and software tools improved, developers just could not keep up with increasing software size and complexity. This includes,</p><ul class="postList"><li name="ad1c" id="ad1c" class="graf graf--li graf-after--p">word processor</li><li name="f7ec" id="f7ec" class="graf graf--li graf-after--li">operating system</li><li name="19a2" id="19a2" class="graf graf--li graf-after--li">distributed system</li></ul><p name="a913" id="a913" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) 9 Software Development Contracts</strong></p><p name="1d65" id="1d65" class="graf graf--p graf-after--p">This is a study performed by Davis in the 1990s and the total cost of this study is 7 million dollars. The study is performed on nine software projects and the result is,</p><ul class="postList"><li name="8d2d" id="8d2d" class="graf graf--li graf-after--p">some are useable as delivered: only a small segment</li><li name="05b0" id="05b0" class="graf graf--li graf-after--li">others are useable after changes (with additional costs): a medium segment</li><li name="2f25" id="2f25" class="graf graf--li graf-after--li">others are useable after extensive modification (even more costs): a medium segment</li><li name="d098" id="d098" class="graf graf--li graf-after--li">others are delivered but never successfully used: a large segment</li><li name="b29a" id="b29a" class="graf graf--li graf-after--li">others are never delivered: a large segment</li></ul><p name="1c24" id="1c24" class="graf graf--p graf-after--li">The last 2 segments took 5 of the total 7 million dollars. In short, it shows clear evidence that the softwares were too difficult to build and the software engineering industry is facing a crisis.</p><p name="fb4f" id="fb4f" class="graf graf--p graf-after--p">This result led to the NATO Software Engineering Conference in January 1969, which is now what we considered as the birth of software engineering development.</p><p name="8792" id="8792" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) The Definition of Software Engineering</strong></p><p name="c237" id="c237" class="graf graf--p graf-after--p">Software engineering is fundamentally going from an abstract idea in somebody’s head to a concrete system that actually implements that idea and hopefully in the right way.</p><p name="0e70" id="0e70" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) The Definition of Software Processing</strong></p><p name="1629" id="1629" class="graf graf--p graf-after--p">Software processing is a way for breaking down an unimaginable task into smaller steps that we can tackle individually. We must have this process for the following several reasons,</p><ul class="postList"><li name="edb2" id="edb2" class="graf graf--li graf-after--p">we can not just sit down and develop a non-trivial system</li><li name="59c6" id="59c6" class="graf graf--li graf-after--li">we need to break down the software in a systematic way</li><li name="42b8" id="42b8" class="graf graf--li graf-after--li">we need to break the software down in a more or less formal way</li></ul><p name="d6a8" id="d6a8" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Different Kinds of Software Processes</strong></p><p name="c021" id="c021" class="graf graf--p graf-after--p">Depending on the applications we are developing, there can be multiple software processes.</p><ul class="postList"><li name="089a" id="089a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Waterfall process</strong>: go from one phase to another as waterfalls in a waterfall</li><li name="b317" id="b317" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Evolutionary prototyping process</strong>: start with an initial prototype and evolve it based on feedback from the customers</li><li name="5096" id="5096" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Rational Unified Process (RUP)/Unified Software Process (USP)</strong>: this is a process that heavily based on the use of UML</li><li name="3d60" id="3d60" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">The family of Agile processes</strong>: we may sacrifice the disciplines a little bit to be more flexible and more able to account for changes in requirements</li></ul><p name="f35b" id="f35b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) The Definition of Software Phases</strong></p><p name="efa4" id="efa4" class="graf graf--p graf-after--p">In fact, software development is normally characterized by several phases, and this is what we called the software phases.</p><ul class="postList"><li name="4ea8" id="4ea8" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Requirements Engineering</strong>: the phase where we talk to customers or stakeholders or whoever we’re building the software for and we try to understand what kind of system we need to build</li><li name="078e" id="078e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Design</strong>: a high-level structure that can become more and more detailed of our software system</li><li name="a94a" id="a94a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Implementation</strong>: write code that implements the design we just defined</li><li name="2006" id="2006" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Verification and Validation</strong>: make sure code behave as intended</li><li name="7e0f" id="7e0f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Maintenance</strong>: involves several activities including adding new functionality or eliminating bugs from the code or responding to problems that were reported from the field after the release of the software</li></ul><p name="d01e" id="d01e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(9) Tools for Improving the Software Phases</strong></p><p name="cfbb" id="cfbb" class="graf graf--p graf-after--p">Now, let’s see some tools that can be used to improve the software phases. Tools and automation are fundamental in software engineering. Fundamental for improving productivity and effectiveness of our activities in the software development process. Common tools for software development are,</p><ul class="postList"><li name="091a" id="091a" class="graf graf--li graf-after--p">IDEs (integrated development environments): these are advanced editors in which you can write, compile, run, debug, and test the code</li><li name="db33" id="db33" class="graf graf--li graf-after--li">Git (version control systems or VCS): these are the systems that allow you to save, restore, and check the difference between different versions of the code</li><li name="1bf6" id="1bf6" class="graf graf--li graf-after--li">Coverage and Verification Tools: these are the tools that can help you during testing</li></ul><p name="030f" id="030f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(10) Benefits of Software Development Tools</strong></p><p name="7f96" id="7f96" class="graf graf--p graf-after--p">So how can these tools improve the developer’s productivity? Let’s think about the following aspects,</p><ul class="postList"><li name="0b58" id="0b58" class="graf graf--li graf-after--p">For development: from punch cards to modern IDEs</li><li name="645a" id="645a" class="graf graf--li graf-after--li">For language: from machine code to high-level languages</li><li name="1943" id="1943" class="graf graf--li graf-after--li graf--trailing">For debugging: from print lines to symbolic debuggers</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/47d9a96d027f"><time class="dt-published" datetime="2021-08-31T20:10:11.810Z">August 31, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/software-development-process-1-introduction-to-software-engineering-47d9a96d027f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>