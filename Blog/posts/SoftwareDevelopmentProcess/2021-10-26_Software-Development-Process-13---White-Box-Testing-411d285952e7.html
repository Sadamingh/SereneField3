<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Software Development Process 13 | White-Box Testing</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Software Development Process 13 | White-Box Testing</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Software Development Process
</section>
<section data-field="body" class="e-content">
<section name="4eef" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3092" id="3092" class="graf graf--h3 graf--leading graf--title">Software Development Process 13 | White-Box Testing</h3><figure name="2fa0" id="2fa0" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*SI3m32uR4CLL9uhu.png" data-width="700" data-height="328" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*SI3m32uR4CLL9uhu.png"></figure><ol class="postList"><li name="cba1" id="cba1" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">White-Box Testing</strong></li></ol><p name="8231" id="8231" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of White-Box Testing</strong></p><p name="45cd" id="45cd" class="graf graf--p graf-after--p">As we said at the end of the previous section, white-box testing (aka. functional testing) is the testing of the software when we look inside the program, and we actually test it based on its code. And there is one basic assumption behind the idea of white-box testing, and the assumption is that executing the faulty statement is a necessary condition for revealing a fault. In other words, if there is a bug in the program there is no way for us to find this bug or this fault if we don’t execute the statement that contains it.</p><p name="58ad" id="58ad" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Advantages of Using White-Box Testing</strong></p><ul class="postList"><li name="fefa" id="fefa" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Based on the code</strong>: So the quality of white-box testing can be measured objectively compared with black-box testing when many test cases are subjective decisions. Also, because white-box testing is based on the code, it can be measured automatically. So we can build tools and there are tools that can measure the level of white-box testing which can be achieved in a fully automated way.</li><li name="51e8" id="51e8" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Can be used to compare test suites</strong>: if you have two alternative sets of tests that you can use to assess the quality of your software, white-box testing techniques can tell you which one of these two test suites is likely to be more effective in testing your code.</li><li name="bb06" id="bb06" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Allows for covering the coded behavior</strong>: if there is some mistake in the code and is not obvious by looking at the specification of the code, white box testing might be able to catch it because it tries to exercise the code.</li></ul><p name="e9e8" id="e9e8" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Types of White-Box Testing</strong></p><p name="6079" id="6079" class="graf graf--p graf-after--p">There are many different kinds of white-box testing, such as,</p><ul class="postList"><li name="4af5" id="4af5" class="graf graf--li graf-after--p">Control-flow based techniques</li><li name="49f2" id="49f2" class="graf graf--li graf-after--li">Data-flow based techniques</li><li name="c0db" id="c0db" class="graf graf--li graf-after--li">Fault based techniques</li></ul><p name="8808" id="8808" class="graf graf--p graf-after--li">In this section, we will talk about white-box testing by focusing mainly on control-flow based testing techniques.</p><p name="45cf" id="45cf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Code </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">printSum</strong></code><strong class="markup--strong markup--p-strong"> Example</strong></p><p name="5b62" id="5b62" class="graf graf--p graf-after--p">Now let’s start our lesson on white docs testing by considering again the program <code class="markup--code markup--p-code">printSum</code>.</p><pre name="618a" id="618a" class="graf graf--pre graf-after--p">printSum(int a, int b) {<br>    int result = a + b<br>    if (result &gt; 0)<br>        printcol(&quot;red&quot;, result)<br>    else if (result &lt; 0)<br>        printcol(&quot;blue&quot;, result)<br>}</pre><p name="e5ad" id="e5ad" class="graf graf--p graf-after--pre">In this function, it will first take two integers <code class="markup--code markup--p-code">a</code> and <code class="markup--code markup--p-code">b</code>, and produces the sum of the two. This programmer was kind of creative because instead of just adding the two numbers and printing them, he or she also decided to print them in a specific color by <code class="markup--code markup--p-code">printcol</code> depending on whether they were positive numbers or negative numbers. So positive results are printed in red and negative results are printed in blue.</p><p name="f24e" id="f24e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) The Definition of Coverage Criteria</strong></p><p name="4b69" id="4b69" class="graf graf--p graf-after--p">Coverage criteria are defined in terms of <strong class="markup--strong markup--p-strong">test requirements</strong>, where test requirements are the elements, the entities in the code, that we need to exercise or execute in order to satisfy the criteria.</p><p name="00b6" id="00b6" class="graf graf--p graf-after--p">Normally, when you apply a coverage criterion, they will result in,</p><ul class="postList"><li name="61ee" id="61ee" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Test specifications</strong>: they are basically descriptions, or specifications, of how the tests should be in order to satisfy the requirements.</li><li name="fc8c" id="fc8c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Test cases</strong>: they are instantiations of the test specifications.</li></ul><p name="9622" id="9622" class="graf graf--p graf-after--li">And again this is exactly analogous to what we saw when we were talking about black-box testing.</p><p name="6767" id="6767" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Statement Coverage</strong></p><p name="f1bc" id="f1bc" class="graf graf--p graf-after--p">Statement coverage is a specific coverage criterion and this criterion is characterized by two aspects,</p><ul class="postList"><li name="5fc6" id="5fc6" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Test Requirements</strong>: for statement coverage, the test requirements are all the statements in the program.</li><li name="38fa" id="38fa" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Coverage Measure</strong>: a good measure of how well we exercise the code, is the ratio of the number of executed statements.</li></ul><figure name="c83f" id="c83f" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*08TaHOolMsvBq7SC7z_j5A.png" data-width="1486" data-height="102" src="https://cdn-images-1.medium.com/max/800/1*08TaHOolMsvBq7SC7z_j5A.png"></figure><p name="80ef" id="80ef" class="graf graf--p graf-after--figure">An example here is the <code class="markup--code markup--p-code">printSum</code> function we have mentioned. Suppose we have two test cases,</p><pre name="8923" id="8923" class="graf graf--pre graf-after--p">TC #1<br>a = 3<br>b = 9</pre><pre name="e383" id="e383" class="graf graf--pre graf-after--pre">TC #2<br>a = -5<br>b = -8</pre><p name="8b05" id="8b05" class="graf graf--p graf-after--pre">When we run test case #1, we actually execute the following lines in bold, and we have 5 tested lines. So the statement coverage should be 5/7 = 71%.</p><pre name="7dd7" id="7dd7" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">printSum(int a, int b) {<br>    int result = a + b<br>    if (result &gt; 0)<br>        printcol(&quot;red&quot;, result)</strong><br>    else if (result &lt; 0)<br>        printcol(&quot;blue&quot;, result)<br><strong class="markup--strong markup--pre-strong">}</strong></pre><p name="f87d" id="f87d" class="graf graf--p graf-after--pre">Then we continue to run test case #2. After running, all the statements are covered, so we are able to say that statement coverage is now 7/7 = 100%.</p><pre name="b56b" id="b56b" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">printSum(int a, int b) {<br>    int result = a + b<br>    if (result &gt; 0)<br>        printcol(&quot;red&quot;, result)<br>    else if (result &lt; 0)<br>        printcol(&quot;blue&quot;, result)<br>}</strong></pre><p name="3e29" id="3e29" class="graf graf--p graf-after--pre">Normally, a company uses statement coverage criterion in the industry for targeting 80% ~ 90% of testings. And this is because the statement testing can only test the conditions included in the statements.</p><p name="f1e3" id="f1e3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Control Flow Graphs (CFG)</strong></p><p name="1037" id="1037" class="graf graf--p graf-after--p">Let’s look at the code for <code class="markup--code markup--p-code">printSum</code> in a slightly different way by making something explicit. If we go through the code, we can see that the code does something if the result is greater than zero, does something else if the result is less than zero, and otherwise in the case in which neither of these two conditions is true, nothing really happens.</p><pre name="d7c5" id="d7c5" class="graf graf--pre graf-after--p">printSum(int a, int b) {<br>    int result = a + b<br>    if (result &gt; 0)<br>        printcol(&quot;red&quot;, result)<br>    else if (result &lt; 0)<br>        printcol(&quot;blue&quot;, result)<br>    <strong class="markup--strong markup--pre-strong">[else do nothing]</strong><br>}</pre><p name="f323" id="f323" class="graf graf--p graf-after--pre">The code does nothing, in this case, where it should do something. With the help of statement coverage, we can never reach this point for either of the test cases even if we have a coverage rate of 100%. So in order to express this, we have to introduce a very useful concept of <strong class="markup--strong markup--p-strong">control flow graphs</strong>.</p><p name="a475" id="a475" class="graf graf--p graf-after--p">The control flow graph is just a representation of the code that is very convenient when we run our reason about the code and its structure. And it’s a fairly simple one that represents statements with nodes and the flow of control within the code with edges.</p><p name="f1c1" id="f1c1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Branch Coverage</strong></p><p name="6171" id="6171" class="graf graf--p graf-after--p">Now we can leverage our knowledge of CFG by introducing the branch coverage. Again, this coverage is characterized by two aspects,</p><ul class="postList"><li name="2a82" id="2a82" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Test Requirements</strong>: for branch coverage, the test requirements are all the branches in the program.</li><li name="0302" id="0302" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Coverage Measure</strong>: a good measure of how well we exercise the code, is the ratio of the number of executed branches.</li></ul><figure name="9ed6" id="9ed6" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*md8H0k5yXgHo9s-SbETfUg.png" data-width="1486" data-height="102" src="https://cdn-images-1.medium.com/max/800/1*md8H0k5yXgHo9s-SbETfUg.png"></figure><p name="4638" id="4638" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(9) Branch Coverage Example</strong></p><p name="273f" id="273f" class="graf graf--p graf-after--p">Now let’s look back to our example,</p><pre name="46cd" id="46cd" class="graf graf--pre graf-after--p">printSum(int a, int b) {<br>    int result = a + b<br>    if (result &gt; 0)<br>        printcol(&quot;red&quot;, result)<br>    else if (result &lt; 0)<br>        printcol(&quot;blue&quot;, result)<br>    [else do nothing]<br>}</pre><p name="4c03" id="4c03" class="graf graf--p graf-after--pre">The CFG of this program should be,</p><figure name="d160" id="d160" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Kb7bUDYhtEzuWhG3ignuCA.png" data-width="1544" data-height="638" src="https://cdn-images-1.medium.com/max/800/1*Kb7bUDYhtEzuWhG3ignuCA.png"></figure><p name="c4df" id="c4df" class="graf graf--p graf-after--figure">In this case, we have three branches. If we have the two cases we have mentioned the statement coverage part, we will not cover all the branches. So what happens is that we’re missing one branch.</p><figure name="fabb" id="fabb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mEKWJd_8HYOVrwm5VcfQtA.png" data-width="1544" data-height="638" src="https://cdn-images-1.medium.com/max/800/1*mEKWJd_8HYOVrwm5VcfQtA.png"></figure><p name="6fa5" id="6fa5" class="graf graf--p graf-after--figure">So in order to cover all the branches, the simplest possibility, in this case, is the test case for which a is equal to zero and b is equal to zero. So now if we execute this test case our execution again followed these paths, will reach our 100% branch coverage.</p><pre name="3718" id="3718" class="graf graf--pre graf-after--p">TC #3<br>a = 0<br>b = 0</pre><p name="b05f" id="b05f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(10) Test Criteria Subsumption</strong></p><p name="df62" id="df62" class="graf graf--p graf-after--p">If we identify a test suite that achieves 100% branch coverage the same test suite will also necessarily achieve 100% statement coverage. That’s what happened in general because branch coverage is a stronger criterion than statement coverage.</p><p name="3ffa" id="3ffa" class="graf graf--p graf-after--p">In this case, we have a subsumption relation on branch coverage subsumes statement coverage. It also means that it is more expensive to receive branch coverage than to achieve statement coverage because achieving branch coverage requires the generation of a larger number of test cases.</p><p name="5f66" id="5f66" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) Branch Coverage Problem</strong></p><p name="5ca2" id="5ca2" class="graf graf--p graf-after--p">Now, let’s think about another program example,</p><pre name="de62" id="de62" class="graf graf--pre graf-after--p">void main() {<br>    float x, y;<br>    read(x);<br>    read(y);<br>    if (X == 0 || y &gt; 0)<br>        y = y / x;<br>    else<br>        x = y + 2;<br>    write(x);<br>    write(y);<br>}</pre><p name="294b" id="294b" class="graf graf--p graf-after--pre">In this case, we have the following CFG</p><figure name="04cf" id="04cf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tMYFaWRhhyTPxPYF0wI-6w.png" data-width="1544" data-height="758" src="https://cdn-images-1.medium.com/max/800/1*tMYFaWRhhyTPxPYF0wI-6w.png"></figure><p name="a002" id="a002" class="graf graf--p graf-after--figure">If we have the following two test cases,</p><pre name="5749" id="5749" class="graf graf--pre graf-after--p">TC #1<br>x = 5, y = 6</pre><pre name="edce" id="edce" class="graf graf--pre graf-after--pre">TC #2<br>x = 5, y = -5</pre><p name="89e9" id="89e9" class="graf graf--p graf-after--pre">Then we can see that these two test cases actually cover all the branches. However, we do have a case when x equals 0 and it can be an error, but we never include it in our test case even we have a 100% branch coverage. This problem brings us to the concept of condition coverage.</p><p name="2310" id="2310" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(12) Condition Coverage</strong></p><p name="abc7" id="abc7" class="graf graf--p graf-after--p">The answer is that we can make each condition true and false instead of just considering the whole predicate here, and that’s exactly what is required by <strong class="markup--strong markup--p-strong">condition coverage</strong>.</p><ul class="postList"><li name="23ab" id="23ab" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Test Requirements</strong>: for branch coverage, the test requirements are all the individual conditions in the program.</li><li name="8afa" id="8afa" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Coverage Measure</strong>: a good measure of how well we exercise the code, is the ratio of the number of conditions that are both true and false.</li></ul><figure name="6cba" id="6cba" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*v4XXL5v6YRixkJDRIYjnzg.png" data-width="1544" data-height="116" src="https://cdn-images-1.medium.com/max/800/1*v4XXL5v6YRixkJDRIYjnzg.png"></figure><p name="911d" id="911d" class="graf graf--p graf-after--figure">Keep in mind that the condition coverage doesn’t imply branch coverage.</p><figure name="8058" id="8058" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*UjW6M0fhC-gwjdkde-Cb9w.png" data-width="1544" data-height="456" src="https://cdn-images-1.medium.com/max/800/1*UjW6M0fhC-gwjdkde-Cb9w.png"></figure><p name="235b" id="235b" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(13) Branch and Condition Coverage (aka. Decision and Condition Coverage)</strong></p><p name="a301" id="a301" class="graf graf--p graf-after--p">So normally we will have two coverage criteria we just saw, the branch coverage and the condition coverage, and this is also called the <strong class="markup--strong markup--p-strong">decision and condition coverage</strong>.</p><p name="a3ad" id="a3ad" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(14) Modified Condition/Decision Coverage (aka. MC/D Coverage or MC/DC)</strong></p><p name="ffb2" id="ffb2" class="graf graf--p graf-after--p">Because we have to consider all the possible combinations of conditions, and they are extremely expensive to the point of being impractical. So, instead of defining that B&amp;CC criterion, we’re going to find another one that finds a good tradeoff between the thoroughness of the tests and their cost. And this criterion is called Modified Condition/Decision Coverage.</p><p name="d3c0" id="d3c0" class="graf graf--p graf-after--p">The key idea is to test only the important combinations of conditions instead of all of them and limit the testing cost by excluding the other combinations. And the way in which it works is by extending branch and decision coverage with the requirement that each condition should affect the decision outcome <strong class="markup--strong markup--p-strong">independently</strong>.</p><p name="03f4" id="03f4" class="graf graf--p graf-after--p">You should also know that MC/DC criterion is <strong class="markup--strong markup--p-strong">stronger </strong>than branch and condition coverage because it requires every single condition to be true and false. And it also requires every predicate to be true and false and therefore, this section is branch coverage. In addition, it’s got the additional requirements that the true and false values, all the conditions have to also decide the overall value of the predicate.</p><p name="1bed" id="1bed" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(15) Other Criteria</strong></p><p name="892c" id="892c" class="graf graf--p graf-after--p">We also have many other coverage criteria and we are not going to explain them all here. Here is a list of them and probably you can search for more details online. For relevant papers on this topic, you can check <a href="https://cs.gmu.edu/~offutt/rsrch/mut.html" data-href="https://cs.gmu.edu/~offutt/rsrch/mut.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this</a> out.</p><ul class="postList"><li name="58c1" id="58c1" class="graf graf--li graf-after--p">Path coverage</li><li name="6b6b" id="6b6b" class="graf graf--li graf-after--li">Data-flow coverage</li><li name="f1c4" id="f1c4" class="graf graf--li graf-after--li graf--trailing">Mutation coverage</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/411d285952e7"><time class="dt-published" datetime="2021-10-26T02:36:51.102Z">October 26, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/software-development-process-13-white-box-testing-411d285952e7" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>