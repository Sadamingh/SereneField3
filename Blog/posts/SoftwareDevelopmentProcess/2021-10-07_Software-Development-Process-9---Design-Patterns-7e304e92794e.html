<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Software Development Process 9 | Design Patterns</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Software Development Process 9 | Design Patterns</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Software Development Process
</section>
<section data-field="body" class="e-content">
<section name="34a6" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5011" id="5011" class="graf graf--h3 graf--leading graf--title">Software Development Process 9 | <strong class="markup--strong markup--h3-strong">Design Patterns</strong></h3><figure name="db60" id="db60" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*xBWFz2DeezBCb7fK.png" data-width="700" data-height="328" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*xBWFz2DeezBCb7fK.png"></figure><ol class="postList"><li name="53b0" id="53b0" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Design Patterns</strong></li></ol><p name="20f4" id="20f4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) History of Design Patterns</strong></p><ul class="postList"><li name="95f2" id="95f2" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">1977</strong>: Christopher Alexander, an American professor of architecture at UC Berkeley, introduces the idea of patterns as successful solutions to problems in his book called <em class="markup--em markup--li-em">A Pattern Language</em>. The book contains about 250 patterns.</li><li name="198e" id="198e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">1987</strong>: Ward Cunningham and Kent Beck leveraged this idea of Alexander’s patterns in the context of an object-oriented language. In this specific case, the language was called “Small Talk”.</li><li name="6e29" id="6e29" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">1987</strong>: At the same time, Eric Gamma was working on his dissertation, whose topic was the importance of patterns and how to capture them.</li><li name="6aa3" id="6aa3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">1987~1992</strong>: There were several workshops related to design patterns.</li><li name="6342" id="6342" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">1992</strong>: Jim Coplien compiled a catalog of C++ items, which are some sort of patterns, and he listed this catalog of patterns in his book, which was titled <em class="markup--em markup--li-em">Advanced C++ Programming Styles and Idioms</em>.</li><li name="dccd" id="dccd" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">1993~1994</strong>: There were several additional workshops focused on patterns. This workshop brought together many patterns folks, including Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. These guys are also known as the “Gang of 4”. The result of this collaboration was the famous book <em class="markup--em markup--li-em">Design Patterns: Elements of Reusable Object-Oriented Software</em>.</li></ul><p name="bdbf" id="bdbf" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Pattern Catalogue</strong></p><p name="ca44" id="ca44" class="graf graf--p graf-after--p">The book <em class="markup--em markup--p-em">Design Patterns: Elements of Reusable Object-Oriented Software</em> we mentioned above describes five main classes of patterns,</p><ul class="postList"><li name="c2e4" id="c2e4" class="graf graf--li graf-after--p">Fundamental Patterns: the basic patterns (e.g. delegation pattern, interface pattern, proxy pattern)</li><li name="2bd0" id="2bd0" class="graf graf--li graf-after--li">Creational Patterns: the patterns that support object creation (e.g. abstract factory pattern, <strong class="markup--strong markup--li-strong">factory method pattern</strong>, lazy initialization pattern, singleton pattern)</li><li name="b97e" id="b97e" class="graf graf--li graf-after--li">Structural Patterns: the patterns that help compose objects and put objects together (e.g. adapter pattern, bridge pattern, decorator pattern)</li><li name="86f8" id="86f8" class="graf graf--li graf-after--li">Behavioral Patterns: the patterns that are mostly focused on realizing interactions among different objects (e.g. chain of responsibility pattern, iterator pattern, observer pattern, state pattern, <strong class="markup--strong markup--li-strong">strategy pattern</strong>, visitor pattern)</li><li name="41fd" id="41fd" class="graf graf--li graf-after--li">Concurrency Patterns: the patterns that support concurrency or relate to concurrency aspects (e.g. active object, monitor object, thread pool pattern)</li></ul><p name="aa80" id="aa80" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) The Definition of Pattern Format Subset</strong></p><p name="47a3" id="47a3" class="graf graf--p graf-after--p">In Gang of Four’s book, we can see that these definitions contain a lot of information, and what we are going to list here is just a subset of this information. So in this part, let’s focus on four essential elements of a design pattern. These are its,</p><ul class="postList"><li name="fd1e" id="fd1e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Name</strong></li><li name="b0f4" id="b0f4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Intent</strong>: the goal of the pattern</li><li name="3f57" id="3f57" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Applicability</strong>: the least of situations or context in which the pattern is applicable</li><li name="4f49" id="4f49" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Structure and Participants</strong>: the static model that describes the elements (e.g. normally, the classes or the objects involved in the pattern). In addition to that, the structure also describes the relationships, responsibilities, and collaborations among these classes or objects.</li></ul><p name="10fe" id="10fe" class="graf graf--p graf-after--li">An extra element we would like to mention is the <strong class="markup--strong markup--p-strong">sample code</strong> that illustrates the use of patterns.</p><p name="22af" id="22af" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Elements of The Factory Method Pattern</strong></p><p name="9ee7" id="9ee7" class="graf graf--p graf-after--p">Let’s now look at the first design pattern that we will discuss, the factory method pattern. We are going to start by discussing the intent of the pattern and its applicability.</p><p name="7397" id="7397" class="graf graf--p graf-after--p">As far as the<strong class="markup--strong markup--p-strong"> intent</strong> is concerned, the factory method pattern allows for creating objects without specifying their class, by invoking what we call a <strong class="markup--strong markup--p-strong">factory method</strong>, which is a method whose main goal is to create class instances.</p><p name="3c14" id="3c14" class="graf graf--p graf-after--p">This pattern is <strong class="markup--strong markup--p-strong">applicable</strong> because of the following reasons,</p><ul class="postList"><li name="e598" id="e598" class="graf graf--li graf-after--p">A class cannot anticipate the type of object it must create. This means the type of an object is not known at the compile time and it is not known until the code runs (e.g. Frameworks)</li><li name="b413" id="b413" class="graf graf--li graf-after--li">A class wants its subclasses to specify the type of objects it creates</li><li name="96fe" id="96fe" class="graf graf--li graf-after--li">A class needs control over the creation of its objects (e.g. limited number of objects can be created)</li></ul><p name="4c50" id="4c50" class="graf graf--p graf-after--li">The <strong class="markup--strong markup--p-strong">structure</strong> of this pattern is represented here, using the UML notation, includes three classes, the <code class="markup--code markup--p-code">Creator</code>, the <code class="markup--code markup--p-code">ConcreteCreator</code>, and the <code class="markup--code markup--p-code">Product</code>.</p><p name="5f5e" id="5f5e" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">participants</strong> for the factory method pattern should be,</p><p name="cb32" id="cb32" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">Creator</code> provides the interface for the factory method. So when the interface for the factory method is invoked, it returns an object of type <code class="markup--code markup--p-code">Product</code>.</p><p name="5775" id="5775" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">ConcreteCreator</code> provides the actual method for creating the <code class="markup--code markup--p-code">Product</code>. So the method <code class="markup--code markup--p-code">factoryMethod()</code> is a concrete implementation of the interface.</p><p name="d8e2" id="d8e2" class="graf graf--p graf-after--p">Finally, the <code class="markup--code markup--p-code">Product</code> is the object created by the factory method.</p><p name="c96f" id="c96f" class="graf graf--p graf-after--p">So summarizing, we have the interface for the factory method (i.e. <code class="markup--code markup--p-code">factoryMethod()</code> in <code class="markup--code markup--p-code">Creator</code>), the actual implementation of the summary method (i.e. <code class="markup--code markup--p-code">factoryMethod()</code> in <code class="markup--code markup--p-code">ConcreteCreator</code>), and the object that is created by the factory method (i.e. <code class="markup--code markup--p-code">Product</code>), when it is invoked.</p><figure name="a402" id="a402" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qJ0HyWNCp2toU9ch__iEjw.png" data-width="1360" data-height="402" src="https://cdn-images-1.medium.com/max/800/1*qJ0HyWNCp2toU9ch__iEjw.png"></figure><p name="fff6" id="fff6" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Factory Method Pattern: Example</strong></p><p name="40cc" id="40cc" class="graf graf--p graf-after--p">The example I’m going to use consists of a class called <code class="markup--code markup--p-code">ImageReaderFactory</code> which provides the factory method <code class="markup--code markup--p-code">createImageReader</code>. As you can see the method takes an <code class="markup--code markup--p-code">InputStream</code> as input and returns an object of type <code class="markup--code markup--p-code">ImageReader</code>, and it’s <code class="markup--code markup--p-code">static</code> so that we can invoke it even if we don’t have an instance of the <code class="markup--code markup--p-code">ImageReaderFactory</code>.</p><pre name="aff8" id="aff8" class="graf graf--pre graf-after--p">public class ImageReaderFactory{<br>    public static ImageReader createImageReader(InputStream iS) {<br>        int imageType = getImageType(iS);<br>        switch(imageType){<br>            case ImageReaderFactory.GIF<br>                return new GifReader(iS);<br>            case ImageReaderFactory.JPEG<br>                return new JpegReader(iS);<br>            // ...<br>        }<br>    }<br>}</pre><p name="ec3d" id="ec3d" class="graf graf--p graf-after--pre">So why is this a situation in which it is appropriate to use the factory method pattern?</p><ul class="postList"><li name="be61" id="be61" class="graf graf--li graf-after--p">It corresponds exactly to the cases that we saw before of applicability.</li><li name="e580" id="e580" class="graf graf--li graf-after--li">It is a case in which we don’t know the type of object that we need to create until we run the code because it depends on the value and content of the <code class="markup--code markup--li-code">InputStream</code>. So, until we read the <code class="markup--code markup--li-code">InputStream</code>, we cannot figure out whether we need to create a GIF, a JPEG, or some other type of image. In this case, we want to simply delegate to this class the creation of the object once we know what type of object needs to be created.</li></ul><p name="67a7" id="67a7" class="graf graf--p graf-after--li">Let’s now see the participants in this example,</p><ul class="postList"><li name="946a" id="946a" class="graf graf--li graf-after--p">ConcreteCreator: <code class="markup--code markup--li-code">ImageReaderFactory</code></li><li name="7301" id="7301" class="graf graf--li graf-after--li">factoryMethod: <code class="markup--code markup--li-code">createImageReader</code></li><li name="2d0c" id="2d0c" class="graf graf--li graf-after--li">Creator 1: <code class="markup--code markup--li-code">GifReader</code></li><li name="3db0" id="3db0" class="graf graf--li graf-after--li">Creator 2: <code class="markup--code markup--li-code">JpegReader</code></li><li name="9a81" id="9a81" class="graf graf--li graf-after--li">Product: image object of different types</li></ul><p name="f488" id="f488" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) Strategy Pattern</strong></p><p name="4265" id="4265" class="graf graf--p graf-after--p">The second pattern I want to discuss is the strategy pattern, which provides a way to configure a class with one of many behaviors. This pattern allows for defining a family of algorithms, encapsulating them into separate classes, so each algorithm is in one class, and making these classes interchangeable, but providing a common interface for all the encapsulated algorithms.</p><p name="4e43" id="4e43" class="graf graf--p graf-after--p">So in essence, the <strong class="markup--strong markup--p-strong">intent</strong> of a strategy pattern is to allow for switching between different algorithms for accomplishing a given task. For example, imagine having different sorting patterns with different space or time tradeoffs. You might want to be able to have them all available and use different ones in different situations.</p><p name="0f4a" id="0f4a" class="graf graf--p graf-after--p">This pattern is <strong class="markup--strong markup--p-strong">applicable</strong> when,</p><ul class="postList"><li name="fead" id="fead" class="graf graf--li graf-after--p">we have different variants of an algorithm</li><li name="8edc" id="8edc" class="graf graf--li graf-after--li">we have many related classes that differ only in their behavior</li></ul><p name="18c9" id="18c9" class="graf graf--p graf-after--li">The <strong class="markup--strong markup--p-strong">structure</strong> of this pattern is represented here using the UML notation.</p><figure name="2706" id="2706" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*LCBwSWTFOPogdfRmxL8wIA.png" data-width="1372" data-height="282" src="https://cdn-images-1.medium.com/max/800/1*LCBwSWTFOPogdfRmxL8wIA.png"></figure><p name="b038" id="b038" class="graf graf--p graf-after--figure">We have 3 types of <strong class="markup--strong markup--p-strong">participants</strong> for this pattern, the <code class="markup--code markup--p-code">Context</code>, the <code class="markup--code markup--p-code">Strategy</code>(or <code class="markup--code markup--p-code">Algorithm</code>), and the <code class="markup--code markup--p-code">ConcreteStrategy...</code>, which can be as many concrete strategies as the number of behaviors that we need to implement.</p><p name="7663" id="7663" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">Context</code> is the interface to the outside world. It maintains a reference to the current strategy and allows for updating this reference at run time. Basically, the outside world will invoke the functionality provided by the different algorithms, by using the interface <code class="markup--code markup--p-code">contextInterface()</code>. Depending on which algorithm is currently selected, that’s the one that will be executed when the functionality is involved.</p><p name="7125" id="7125" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">Strategy</code> (or <code class="markup--code markup--p-code">Algorithm</code>) is the common interface for the different algorithms, so all the algorithms implement this interface.</p><p name="aa57" id="aa57" class="graf graf--p graf-after--p">Finally, the concrete strategies <code class="markup--code markup--p-code">ConcreteStrategy...</code> are the actual implementations of the algorithms. So if I have 10 different variants of my algorithm, I will implement 10 different concrete strategies.</p><p name="cdc9" id="cdc9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Strategy Pattern: Example</strong></p><p name="ec36" id="ec36" class="graf graf--p graf-after--p">Now, let’s see how this strategy pattern works within an example. We’re going to consider a program that takes an input as text file and produce an output as a filtered file. So basically it outputs a subset of the content of this text file based on some filters.</p><ul class="postList"><li name="694e" id="694e" class="graf graf--li graf-after--p">Input: Text File</li><li name="3c27" id="3c27" class="graf graf--li graf-after--li">Output: Filter File</li></ul><p name="fd21" id="fd21" class="graf graf--p graf-after--li">And we’re going to have four different types of filters.</p><ul class="postList"><li name="4e9e" id="4e9e" class="graf graf--li graf-after--p">#1: NO Filter.</li><li name="93be" id="93be" class="graf graf--li graf-after--li">#2: Output only words that starts with <code class="markup--code markup--li-code">t</code>.</li><li name="06e4" id="06e4" class="graf graf--li graf-after--li">#3: Output only words that are longer than five characters.</li><li name="636d" id="636d" class="graf graf--li graf-after--li">#4: Output only words in the text file that are palindromes (e.g. the word “kayak”).</li></ul><p name="3e88" id="3e88" class="graf graf--p graf-after--li">The implementation of this program should use some packages,</p><pre name="681e" id="681e" class="graf graf--pre graf-after--p">import <code class="markup--code markup--pre-code">java.io.BufferedReader;<br></code>import java.io.FileReader;<br>import java.io.IOException;<br>import java.util.StringTokenizer;</pre><p name="0a82" id="0a82" class="graf graf--p graf-after--pre">So let’s see how this program could be implemented using a strategy pattern. The general algorithm interface is as follows,</p><pre name="29b8" id="29b8" class="graf graf--pre graf-after--p">interface CheckStrategy {<br>    public boolean check(String s);<br>}</pre><p name="4be6" id="4be6" class="graf graf--p graf-after--pre">And one general implementation of this interface should be,</p><pre name="c3c6" id="c3c6" class="graf graf--pre graf-after--p">class All implements CheckStrategy {<br>    @Override<br>    public boolean check(String s) {<br>        return true;<br>    }<br>}</pre><p name="8dc6" id="8dc6" class="graf graf--p graf-after--pre">And we will start by looking at the <code class="markup--code markup--p-code">Context</code> class.</p><pre name="1fa5" id="1fa5" class="graf graf--pre graf-after--p">class Context {<br>    private CheckStrategy strategy;</pre><pre name="ae52" id="ae52" class="graf graf--pre graf-after--pre">    public Context() {<br>        this.strategy = new All();<br>    }</pre><pre name="8980" id="8980" class="graf graf--pre graf-after--pre">    public void changeStrategy(CheckStrategy strategy) {<br>        this.strategy = strategy;<br>    }</pre><pre name="e443" id="e443" class="graf graf--pre graf-after--pre">    public void filter(String filename) throws IOException {<br>        BufferedReader infile = new BufferedReader(new FileReader(filename));<br>        String buffer = null;<br>        while((buffer = infile.readLine()) != null) {<br>            StringTokenizer words = new StringTokenizer(buffer);<br>            while( words.hasMoreTokens() ) {<br>                String word = words.nextToken();<br>                if (strategy.check(word)) {<br>                    System.out.println(word);<br>                }<br>            }<br>        }<br>    }<br>}</pre><p name="992f" id="992f" class="graf graf--p graf-after--pre">The Context class contains a reference of the current <code class="markup--code markup--p-code">strategy</code> of type <code class="markup--code markup--p-code">CheckStrategy</code>. The construction function of the <code class="markup--code markup--p-code">Context</code> class <code class="markup--code markup--p-code">Context()</code> is called when the content is created by default. It will set the current <code class="markup--code markup--p-code">strategy</code> to the <code class="markup--code markup--p-code">All</code> strategy, which is a strategy that accepts all the inputs. Later on, if we want to specify a strategy of this context, we have to call <code class="markup--code markup--p-code">changeStrategy</code> and it simply replaces the current strategy with the one specified as the parameter. Also, in this form, the <code class="markup--code markup--p-code">Context</code> also performs <code class="markup--code markup--p-code">filter</code> , which is a function reads a file line by line and then apply the <code class="markup--code markup--p-code">check</code> method to utilize the corresponding strategy.</p><p name="317c" id="317c" class="graf graf--p graf-after--p">Then, let’s see how we implement the <code class="markup--code markup--p-code">main</code> method. The <code class="markup--code markup--p-code">main</code> method simply creates the <code class="markup--code markup--p-code">Context</code> by <code class="markup--code markup--p-code">new Context()</code>. Rethink profile from the arguments, and then what he does is simply as a demonstration, it will perform the filtering using all the different filters.</p><pre name="91bf" id="91bf" class="graf graf--pre graf-after--p">public class StrategyPattern {</pre><pre name="6875" id="6875" class="graf graf--pre graf-after--pre">    public static void main(String[] args) throws IOException {<br>        Context context = new Context();<br>        String filename = &quot;foo.txt&quot;;</pre><pre name="3c9c" id="3c9c" class="graf graf--pre graf-after--pre">        System.out.println(&quot;\n* Default:&quot;);<br>        context.filter(filename);</pre><pre name="1c37" id="1c37" class="graf graf--pre graf-after--pre">        System.out.println(&quot;\n* Longer than 5:&quot;);<br>        context.changeStrategy(new LongerThan5());<br>        context.filter(filename);</pre><pre name="3334" id="3334" class="graf graf--pre graf-after--pre">        System.out.println(&quot;\n*Palindromes:&quot;);<br>        context.changeStrategy(new Palindrome());<br>        context.filter(filename);<br>    }<br>}</pre><p name="2439" id="2439" class="graf graf--p graf-after--pre">Now let’s look at the actual algorithm. This is the interface, the algorithm interface. We have all the different implementations of the algorithm, the simplest one is the <code class="markup--code markup--p-code">All</code> algorithm, the simple return is always true, so all the words will be printed. The second one <code class="markup--code markup--p-code">StartWithT</code>, and again, without looking at the details of implementations that don’t really matter, what it does is basically check in that the first character is <code class="markup--code markup--p-code">t</code>, and returns true in that case and false otherwise.</p><pre name="8876" id="8876" class="graf graf--pre graf-after--p">class StartWithT implements CheckStrategy {<br>    @Override<br>    public boolean check(String s) {<br>        if( s == null || s.length() == 0) {<br>            return false;<br>        }<br>        return s.charAt(0) == &#39;t&#39;;<br>    }<br>}</pre><p name="526b" id="526b" class="graf graf--p graf-after--pre">For the <code class="markup--code markup--p-code">LongerThan5</code> algorithm, this will implement the check strategy interface, and the check will be performed. By checking that the word is longer than five characters and returning true in that case and false otherwise.</p><pre name="f74f" id="f74f" class="graf graf--pre graf-after--p">class LongerThan5 implements CheckStrategy {<br>    @Override<br>    public boolean check(String s) {<br>        if(s == null) {<br>            return false;<br>        }<br>        return s.length() &gt; 5;<br>    }<br>}</pre><p name="4eb7" id="4eb7" class="graf graf--p graf-after--pre">Finally, the <code class="markup--code markup--p-code">Palindrome</code> check is a little more complicated, but basically it just checks whether the word is a Palindrome and returns true in that case.</p><pre name="933a" id="933a" class="graf graf--pre graf-after--p">class Palindrome implements CheckStrategy {<br>    @Override<br>    public boolean check(String s) {<br>        if(s == null) {<br>            return false;<br>        }<br>        int length = s.length();<br>        if(length &lt; 2) {<br>            return true;<br>        }<br>        int half = length/2;<br>        for(int i = 0; i &lt; half; ++i) {<br>            if(s.charAt(i) != s.charAt(length - 1 - i)) {<br>                return false;<br>            }<br>        }<br>        return true;<br>    }<br>}</pre><p name="b47c" id="b47c" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(8) Other Common Patterns</strong></p><p name="aadd" id="aadd" class="graf graf--p graf-after--p">Finally, let’s see a few more patterns. Although it will take too long to cover them in detail, we would like to at least mention and quickly discuss a few more of these more commonly-used patterns. We are going to introduce the following patterns,</p><ul class="postList"><li name="c897" id="c897" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Visitor Pattern</strong>: a way of separating an algorithm from an object structure on which it operates. And a practical result of this separation is the ability to add the new operation to existing object structures, without modifying the structures (e.g. decouple operations from a graph object)</li><li name="e70c" id="e70c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Decorator Pattern</strong>: a wrapper that adds functionality to a class. For all the functionality that was already in the original class, it will simply invoke this functionality and for the new one, you will implement it using the services of the class. A nice property of the decorator pattern is that it’s <strong class="markup--strong markup--li-strong">stackable</strong>.</li><li name="aa19" id="aa19" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Iterator Pattern</strong>: the iterator allows you to do, is basically access elements of a collection without knowing the underlying representation. So the iterator will allow you to just go through a set of objects without worrying about how the objects are stored. So you basically just ask the iterator to give you the first object, the next object, and so on. This is broadly used in many standard libraries.</li><li name="ca6c" id="ca6c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Observed Pattern</strong>: this pattern is very useful when you have an object of interest and a set of other objects that are interested in the changes that might occur in this first object. So what the observer pattern allows you to do is to register these objects, so that they let the system know that they’re interested in changes in this first object. And then, every time that there is a change, these other objects will be automatically notified. So basically, the observer pattern allows for notifying dependents when an object of interest changes. (e.g. File system)</li><li name="917c" id="917c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Proxy Pattern</strong>: a pattern in which a surrogate controls access to an object. So what the proxy allows you to do is to control how this object, that is behind the proxy, is actually accessed, for example, by filtering some calls. In a sense, the proxy allows you for masking some of the functionality of the object that is behind the proxy.</li></ul><p name="bc71" id="bc71" class="graf graf--p graf-after--li">For more information, you can find an interesting paper of non-software examples of software design pattern <a href="https://drive.google.com/file/d/1-k4svh14rTIi57w1L57uWDrcT0sBcCEw/view" data-href="https://drive.google.com/file/d/1-k4svh14rTIi57w1L57uWDrcT0sBcCEw/view" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">at this link</a>.</p><p name="a889" id="a889" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Approach for Choosing A Pattern</strong></p><p name="91fe" id="91fe" class="graf graf--p graf-after--p">With so many patterns, we can choose them based on a possible approach,</p><ul class="postList"><li name="41b5" id="41b5" class="graf graf--li graf-after--p">make sure you understand your design context</li><li name="509e" id="509e" class="graf graf--li graf-after--li">examine the patterns catalog or think about / identify the possible patterns that you could use</li><li name="d89d" id="d89d" class="graf graf--li graf-after--li">study the pattern you want to use and study the related patterns</li><li name="ed06" id="ed06" class="graf graf--li graf-after--li">apply that pattern</li></ul><p name="f080" id="f080" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(10) Pitfalls for Using Patterns</strong></p><p name="400b" id="400b" class="graf graf--p graf-after--p">When you choose a pattern, be mindful that there are pitfalls in the use of patterns.</p><ul class="postList"><li name="8cff" id="8cff" class="graf graf--li graf-after--p">One obvious one is the fact that you might select the <strong class="markup--strong markup--li-strong">wrong pattern </strong>and make your design worse instead of better.</li><li name="8254" id="8254" class="graf graf--li graf-after--li">The second one is that if you get too excited about patterns, then you might be <strong class="markup--strong markup--li-strong">abusing patterns</strong>, so just using too many patterns, and end up with a design that is more complicated rather than less complicated.</li></ul><p name="6bfa" id="6bfa" class="graf graf--p graf-after--li">So always be careful, spend the time to figure out which one is the right pattern to apply, and make sure that you don’t use patterns that you don’t actually need.</p><p name="118f" id="118f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) Negative Design Patterns</strong></p><p name="4995" id="4995" class="graf graf--p graf-after--p graf--trailing">The concept of negative design patterns (also anti-patterns or bad smells) is the pattern that should be avoided. So negative design patterns are basically guidelines on how not to do things. We will discuss it in later sections.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/7e304e92794e"><time class="dt-published" datetime="2021-10-07T01:42:06.380Z">October 7, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/software-development-process-9-design-patterns-7e304e92794e" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>