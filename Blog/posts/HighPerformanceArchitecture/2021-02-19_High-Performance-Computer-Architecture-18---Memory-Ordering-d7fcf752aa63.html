<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 18 | Memory Ordering</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 18 | Memory Ordering</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="49d3" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6147" id="6147" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 18 | <strong class="markup--strong markup--h3-strong">Memory Ordering</strong></h3><figure name="a129" id="a129" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*zXgpEzhtkcEssm5M.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*zXgpEzhtkcEssm5M.png"></figure><ol class="postList"><li name="af25" id="af25" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Review</strong></li></ol><p name="72ea" id="72ea" class="graf graf--p graf-after--li">We have seen that using the ROB and Tomasulo&#39;s Algorithm, we can enforce the order of dependencies on registers between the instructions. The remaining question is that how we can conduct the memory access ordering.</p><p name="0252" id="0252" class="graf graf--p graf-after--p">Commonly, in the program, we have lots of load/store instructions. So our question is, should these instructions be done in the programming order or should they be reordered too. So far, we have eliminated,</p><ul class="postList"><li name="e812" id="e812" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Control Dependencies</strong> by branch prediction</li><li name="1616" id="1616" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">False Data Dependencies of Registers </strong>by register renaming</li><li name="a994" id="a994" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">True Data Dependencies (RAW Dependencies)</strong> by Tomasulo’s algorithm</li><li name="6f56" id="6f56" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">OOE Exceptions</strong> by reorder buffer (ROB)</li></ul><p name="6156" id="6156" class="graf graf--p graf-after--li">This section discusses a method for handling memory dependencies, the Load/Store Queue.</p><p name="0a33" id="0a33" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Memory Ordering</strong></p><p name="063a" id="063a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Timing for Memory Write</strong></p><p name="c4f6" id="c4f6" class="graf graf--p graf-after--p">For store instructions, the memory writes actually happens at the <strong class="markup--strong markup--p-strong">commit</strong> stage, because it is unsafe to update memory at any point before the instruction commits. An instruction that is not yet committed can be canceled because of a branch misprediction, so doing a memory write prematurely (before commit) might mean later we have to undo the accesses to the memory. Thus, we have to delay the memory stores until commit.</p><p name="c6d2" id="c6d2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Timing for Memory Read</strong></p><p name="26b4" id="26b4" class="graf graf--p graf-after--p">We have known that the memory write should happen at commit. The question is that if we write the values on stores at commits, where does the load get data? In fact, we want our load instructions to get data <strong class="markup--strong markup--p-strong">as early as possible</strong> so that we can finish those loads and supply the data to the subsequent instructions depend on those loads.</p><p name="98da" id="98da" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Load-Store Queue (LSQ)</strong></p><p name="cf1d" id="cf1d" class="graf graf--p graf-after--p">The load-store queue (LSQ) is a structure like ROB (means that things will be put into this queue in order) for implementing the as-early-as-possible memory read and at-commit memory write. For each entry in an LSQ, there should be a 1-bit L/S field that tells about which instruction do we have (load or store), a field for what is the address that this instruction is accessing, a field for the value that instruction should be storing or loading, and there’s also a field for the showing whether or not this instruction is completed.</p><figure name="46e7" id="46e7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*brARr0ZhmCGpSo0B6P9cMA.png" data-width="1500" data-height="416" src="https://cdn-images-1.medium.com/max/800/1*brARr0ZhmCGpSo0B6P9cMA.png"></figure><p name="3146" id="3146" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Load-Store Queue (LSQ): An Example</strong></p><p name="b770" id="b770" class="graf graf--p graf-after--p">Now, let’s see an example of the load-store queue. Suppose we have the following program,</p><pre name="15c0" id="15c0" class="graf graf--pre graf-after--p">LW R1, 0(R1)<br>SW R2, 0(R3)<br>LW R4, 0(R4)<br>SW R2, 0(R0)<br>LW R5, 0(R8)</pre><p name="68d9" id="68d9" class="graf graf--p graf-after--pre">And the registers and the memory status at the beginning should be,</p><figure name="b0da" id="b0da" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*oFYcqJYhCcF6QzIytLAwBg.png" data-width="2030" data-height="650" src="https://cdn-images-1.medium.com/max/800/1*oFYcqJYhCcF6QzIytLAwBg.png"></figure><p name="da9f" id="da9f" class="graf graf--p graf-after--figure">After the <code class="markup--code markup--p-code">LW R1, 0(R1)</code> code, because we have a load and the load should get the data as early as possible, we directly achieve the data in the memory and complete this instruction.</p><figure name="61c4" id="61c4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*hV380yPMP2wBuN5MRY8ROA.png" data-width="2030" data-height="650" src="https://cdn-images-1.medium.com/max/800/1*hV380yPMP2wBuN5MRY8ROA.png"></figure><p name="7513" id="7513" class="graf graf--p graf-after--figure">Then we should run <code class="markup--code markup--p-code">SW R2, 0(R3)</code> . When we are doing so, the present instruction has to wait for the commit stage so it will not be marked as completed.</p><figure name="49fc" id="49fc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*QNX_I_qrjls2vEuW0OqTiQ.png" data-width="2030" data-height="692" src="https://cdn-images-1.medium.com/max/800/1*QNX_I_qrjls2vEuW0OqTiQ.png"></figure><p name="7b26" id="7b26" class="graf graf--p graf-after--figure">The next one is <code class="markup--code markup--p-code">LW R4, 0(R4)</code> and this one is a little bit tricky. The load instruction is going to load from the same address of the last save instruction which is not committed yet. So if the present load instruction load from the memory, it will get a completely wrong value. To deal with this problem, we have 2 options. One is to wait until the completion of the last save instruction. However, this can be inefficient because the save instruction will have to take a long time before commit. The other is to check the load-store queue each time before we load a new value from the memory. If there are save instructions with the same address that have not been completed yet, we can directly read from the last one before the current instruction.</p><p name="8dfe" id="8dfe" class="graf graf--p graf-after--p">For example, in this case, because the last instruction is to write to the same memory address we would like to read, we can directly load from the value of this instruction instead of going to the memory. This method is called <strong class="markup--strong markup--p-strong">store-to-load forwarding</strong>.</p><figure name="a1fd" id="a1fd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*naJTB2yKsRi3xUjhcMqO9A.png" data-width="2030" data-height="692" src="https://cdn-images-1.medium.com/max/800/1*naJTB2yKsRi3xUjhcMqO9A.png"></figure><p name="5df2" id="5df2" class="graf graf--p graf-after--figure">After the last two instructions, the LSQ should finally be,</p><figure name="531c" id="531c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dQpt7LsAknMFxYOYfPm8Dw.png" data-width="2030" data-height="692" src="https://cdn-images-1.medium.com/max/800/1*dQpt7LsAknMFxYOYfPm8Dw.png"></figure><p name="b8c1" id="b8c1" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Exceptions for Store-to-Load Forwarding: Out-Of-Order Execution</strong></p><p name="72cd" id="72cd" class="graf graf--p graf-after--p">Now, let’s think about another situation. It is entirely possible that because of the delay, a store instruction can have no address when a load is checking the queue. This situation may be caused by the as-early-as-possible rule for the load instructions. For example,</p><figure name="bd96" id="bd96" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZMM7aYVvsAECzZQELPXsVQ.png" data-width="1424" data-height="454" src="https://cdn-images-1.medium.com/max/800/1*ZMM7aYVvsAECzZQELPXsVQ.png"></figure><p name="abdd" id="abdd" class="graf graf--p graf-after--figure">In the table above, the load instruction would like to check address 174 in the LSQ for store-to-load forwarding at the moment, but there appears to be a store instruction with no address. So the current load instruction can not know whether it should load from the memory or not. So here, we have three options to deal with this problem,</p><ul class="postList"><li name="ff39" id="ff39" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">OPTION 1</strong>. <strong class="markup--strong markup--li-strong">Wait for the store instruction to get its address</strong>. This means that we have to <strong class="markup--strong markup--li-strong">perform all the load/store instructions in order</strong>. When the store gets the address, we can compare it to the address needed by the load instructions and proceed. Although this idea is simple and easy for us, it can be slow for the processor and leads to unnecessary waiting.</li><li name="a6c3" id="a6c3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">OPTION 2.</strong> <strong class="markup--strong markup--li-strong">Wait for all the previous store instructions</strong>. With the previous idea, we have to wait for all the load/store instructions to get the address. However, this can be improved because we can know that the load instructions won’t work for generating the address of the store instruction. Although this method improves some sorts of efficiency, it can still be</li><li name="b763" id="b763" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">OPTION 3</strong>. <strong class="markup--strong markup--li-strong">Directly goes to memory to grab the data</strong>. It is also okay if we ignore the possible dependency of the previous instructions and just load from the memory. This method is pretty aggressive and we are really possible to get wrong values from the memory. However, this method is good for efficiency. What we have to do is that if we read a wrong value from the memory, we need to <strong class="markup--strong markup--li-strong">recover</strong> the value and also supply this value to the later instructions. Most modern processors actually go with this option because it produces the best performance and the cost of recovery is affordable.</li></ul><p name="0509" id="0509" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) Example Out-Of-Order Load/Store Execution</strong></p><p name="8a7e" id="8a7e" class="graf graf--p graf-after--p">Suppose we have the following code,</p><pre name="3c90" id="3c90" class="graf graf--pre graf-after--p">I1: LW   R3, 0(R6)<br>I2: ADD  R7, R3, R9<br>I3: SW   R4, 0(R7)<br>I4: SUB  R1, R1, R2<br>I5: LW   R8, 0(R1)</pre><p name="64a0" id="64a0" class="graf graf--p graf-after--pre">Assume that the address in R6 is not in the cache (means that we have to take a longer time to read from the memory), thus we can have an out-of-order execution for these instructions.</p><p name="f129" id="f129" class="graf graf--p graf-after--p">Firstly, the first load instruction I1 only depends on R6, then it is supposed to dispatch in the first place. But because R6 is a cache miss, it has to go to the memory for reading the data and it will take a while until this load comes back.</p><p name="bb15" id="bb15" class="graf graf--p graf-after--p">The instructions I2 and I3 only depend on I1, so they will wait until I1 returns. Because I3 is a store instruction, so the address can not be available until I1 returns.</p><p name="a1cc" id="a1cc" class="graf graf--p graf-after--p">Because I4 only depends on R1 and R2, it will be executed very quickly and then the load instruction I5 will then have the address stored in R1. When the I5 instruction dispatches, suppose the address in R1 is already in the cache, then this is going to be a cache hit. The value of this address will be returned very fast. However, before getting this value in the cache, we have to check the LSQ and make sure there is not a save instruction for the same address, or we will conduct the load-to-store forwarding.</p><p name="dff0" id="dff0" class="graf graf--p graf-after--p">But wait! Because we are stilling waiting for the address of the I3 store instruction, we actually can not figure out if need a load-to-store forwarding. If we use the option of going to the memory directly and grab the data, there can be two possibilities.</p><p name="d6c7" id="d6c7" class="graf graf--p graf-after--p">The first one is that the store address of I3 <strong class="markup--strong markup--p-strong">doesn’t match</strong> the load address of I5, so it will okay for us to read from the memory. However, the other one is that the store address of I3 <strong class="markup--strong markup--p-strong">matches</strong> the load address of I5, so the I5 actually loaded some stale value from the memory.</p><p name="17d6" id="17d6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Solution 1: In-Order Execution</strong></p><p name="7598" id="7598" class="graf graf--p graf-after--p">At the point of dispatching the load instruction I5, we will check whether there are any proceeding instructions that might eventually result in the same address. Because the load instruction I1 and the store instruction I3 are not finished yet, we are also not going to execute I5 if we want to maintain an in-order load/store execution.</p><p name="ded1" id="ded1" class="graf graf--p graf-after--p">Of course, you can say that this solution is suboptimal if the store doesn’t store at the same address. We have been waiting at I5 for a very long time, and thus all of the later instructions depend on this instruction will be delayed. We will discuss the second solution of recovery later.</p><p name="e118" id="e118" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) End of an LSQ</strong></p><p name="a58f" id="a58f" class="graf graf--p graf-after--p">Before we talk about the recovery solution, let’s first see how we can complete an LSQ. In the previous example, we only add the instructions to the LSQ without changing the data cache. Now, we are going to focus on how we can end an LSQ after the execution and write to the memory. Suppose we have the following LSQ and data cache,</p><figure name="13ea" id="13ea" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XoN0d-nRa3Fpg0cJdHE4gQ.png" data-width="1886" data-height="780" src="https://cdn-images-1.medium.com/max/800/1*XoN0d-nRa3Fpg0cJdHE4gQ.png"></figure><p name="4e3c" id="4e3c" class="graf graf--p graf-after--figure">Now, let’s start to commit these load/store instructions, and based on the at-commit rule, we can now write to the memory. We have said that we need to send the values to the memory or the data cache at the time the store commits not at the time it executes, and here’s why. If we want to take an exception when committing the instructions, we can flush to the front (youngest one) of the queue, and the data in the data cache or memory is exactly the value that should be at our program exception.</p><p name="8269" id="8269" class="graf graf--p graf-after--p">So finally, the LSQ and data cache should be,</p><figure name="7539" id="7539" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OTyiM36trMaTHEsANTPIgQ.png" data-width="1886" data-height="780" src="https://cdn-images-1.medium.com/max/800/1*OTyiM36trMaTHEsANTPIgQ.png"></figure><p name="1391" id="1391" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">3. Relationship Between LSQ, ROB, and RS</strong></p><p name="8784" id="8784" class="graf graf--p graf-after--p">When we issue a <strong class="markup--strong markup--p-strong">load/store</strong> instruction, we need,</p><ul class="postList"><li name="b517" id="b517" class="graf graf--li graf-after--p">a ROB (reorder buffer) entry</li><li name="3c67" id="3c67" class="graf graf--li graf-after--li">an LSQ (load-store queue) entry</li></ul><p name="0264" id="0264" class="graf graf--p graf-after--li">Then to execute a <strong class="markup--strong markup--p-strong">load/store</strong> instruction, we have to,</p><ul class="postList"><li name="6ce8" id="6ce8" class="graf graf--li graf-after--p">compute an address</li><li name="db11" id="db11" class="graf graf--li graf-after--li">produce a value</li><li name="3a65" id="3a65" class="graf graf--li graf-after--li">if this is a load instruction, we have also to write-result/broadcast</li><li name="bed9" id="bed9" class="graf graf--li graf-after--li">commit the instruction by free the ROB &amp; LSQ entries</li><li name="7e22" id="7e22" class="graf graf--li graf-after--li">if this is a store instruction, we have to send (write) the data to memory</li></ul><p name="ab29" id="ab29" class="graf graf--p graf-after--li">When we issue a <strong class="markup--strong markup--p-strong">non-load/store</strong> instruction, we need,</p><ul class="postList"><li name="60a6" id="60a6" class="graf graf--li graf-after--p">a ROB (reorder buffer) entry</li><li name="6fe4" id="6fe4" class="graf graf--li graf-after--li graf--trailing">an RS (reservation station) for the right type</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/d7fcf752aa63"><time class="dt-published" datetime="2021-02-19T09:23:24.982Z">February 19, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-18-memory-ordering-d7fcf752aa63" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>