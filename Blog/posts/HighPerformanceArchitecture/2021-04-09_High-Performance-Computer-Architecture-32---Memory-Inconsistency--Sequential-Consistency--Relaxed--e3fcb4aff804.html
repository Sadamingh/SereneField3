<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 32 | Memory Inconsistency, Sequential Consistency, Relaxed…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 32 | Memory Inconsistency, Sequential Consistency, Relaxed…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="ac5b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ad56" id="ad56" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 32 | <strong class="markup--strong markup--h3-strong">Memory Inconsistency, Sequential Consistency, Relaxed Consistency, Data Races, and Data-­Race­-Free Program</strong></h3><figure name="a8ff" id="a8ff" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*wNjTDV8mC0EOULMb.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*wNjTDV8mC0EOULMb.png"></figure><ol class="postList"><li name="1498" id="1498" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Memory Inconsistency Problems</strong></li></ol><p name="2f18" id="2f18" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Consistency Vs. Coherence</strong></p><p name="1d61" id="1d61" class="graf graf--p graf-after--p">Before we discuss consistency, let’s first differ it from coherence. What <strong class="markup--strong markup--p-strong">coherence</strong> does is that it defines the order of accesses observable by different threads to <strong class="markup--strong markup--p-strong">the same address</strong>. In order to make the data on the same address the same in all the caches containing the corresponding block and in the memory, we have to maintain cache coherence. To allow coherence, we have to allow cache-to-cache transfer between caches.</p><p name="5509" id="5509" class="graf graf--p graf-after--p">However, memory <strong class="markup--strong markup--p-strong">consistency</strong> defines the order of accesses to <strong class="markup--strong markup--p-strong">different addresses</strong>. If we have out-of-order reads and writes from different addresses, the reader result we can get will be different from what we expect. Let’s see an example about why this actually matters.</p><p name="eeb0" id="eeb0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Memory Consistency: An Example</strong></p><p name="0448" id="0448" class="graf graf--p graf-after--p">It turns out that consistency does matter and let’s see an example of why it matters. Suppose we have two threads A and B, and each of them will execute the following programs,</p><pre name="f10b" id="f10b" class="graf graf--pre graf-after--p">Thread A               Thread B<br>=============          =============<br>SW 1, D                LW F, R1<br>SW 1, F                LW D, R2</pre><p name="dff4" id="dff4" class="graf graf--p graf-after--pre">Suppose initially, we have both D and F in the memory with the value 0, then if we don’t have any synchronization, the behaviors we expect will be,</p><pre name="1010" id="1010" class="graf graf--pre graf-after--p">SW 1, D<br>SW 1, F<br>LW F, R1<br>LW D, R2<br>---------------<br><strong class="markup--strong markup--pre-strong">R1 = 1, R2 = 1</strong></pre><pre name="ecad" id="ecad" class="graf graf--pre graf-after--pre">SW 1, D<br>LW F, R1<br>LW D, R2<br>SW 1, F<br>---------------<br><strong class="markup--strong markup--pre-strong">R1 = 0, R2 = 1</strong></pre><pre name="23b3" id="23b3" class="graf graf--pre graf-after--pre">LW F, R1<br>LW D, R2<br>SW 1, D<br>SW 1, F<br>---------------<br><strong class="markup--strong markup--pre-strong">R1 = 0, R2 = 0</strong></pre><p name="fd30" id="fd30" class="graf graf--p graf-after--pre">We can not get a result of <code class="markup--code markup--p-code">R1 = 1, R2 = 0</code> because if we have <code class="markup--code markup--p-code">R1 = 1</code>, then it must mean that we have executed <code class="markup--code markup--p-code">SW 1, D</code> and the value of R2 must be 1. However, if we don’t maintain the order of access to different addresses, we can have an out-of-order load from the memory as follows,</p><pre name="10ef" id="10ef" class="graf graf--pre graf-after--p">Thread A               Thread B<br>=============          =============<br>SW 1, D                <strong class="markup--strong markup--pre-strong">LW D, R2</strong><br>SW 1, F                <strong class="markup--strong markup--pre-strong">LW F, R1</strong></pre><p name="f2d1" id="f2d1" class="graf graf--p graf-after--pre">If we have a real execution order like that, we can have the following actual behaviors,</p><pre name="661e" id="661e" class="graf graf--pre graf-after--p">SW 1, D<br>SW 1, F<br>LW D, R2<br>LW F, R1<br>---------------<br><strong class="markup--strong markup--pre-strong">R1 = 1, R2 = 1</strong></pre><pre name="63d9" id="63d9" class="graf graf--pre graf-after--pre">SW 1, D<br>LW D, R2<br>LW F, R1<br>SW 1, F<br>---------------<br><strong class="markup--strong markup--pre-strong">R1 = 0, R2 = 1</strong></pre><pre name="3bbe" id="3bbe" class="graf graf--pre graf-after--pre">LW D, R2<br>LW F, R1<br>SW 1, D<br>SW 1, F<br>---------------<br><strong class="markup--strong markup--pre-strong">R1 = 0, R2 = 0</strong></pre><pre name="ebb7" id="ebb7" class="graf graf--pre graf-after--pre">LW D, R2<br>SW 1, D<br>SW 1, F<br>LW F, R1<br>---------------<br><strong class="markup--strong markup--pre-strong">R1 = 1, R2 = 0</strong></pre><p name="cea6" id="cea6" class="graf graf--p graf-after--pre">Now, we can find out that we will have a case of <code class="markup--code markup--p-code">R1 = 1, R2 = 0</code> that doesn’t exist in the expected behaviors. Note that we didn’t violate any rules of coherence, so this is what we called a consistency problem.</p><p name="3a0b" id="3a0b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Memory Inconsistency: Data-Ready Flag Synchronization</strong></p><p name="3d1b" id="3d1b" class="graf graf--p graf-after--p">Now, let’s see another example. Suppose we have two threads A and B, and they are executing the following programs,</p><pre name="b9b6" id="b9b6" class="graf graf--pre graf-after--p">/* global */<br>flag = 0; <br>data = 0;</pre><pre name="6c0f" id="6c0f" class="graf graf--pre graf-after--pre">Thread A                   Thread B<br>=====================      =====================<br>while (!flag)              data = 10;<br>    wait;                  data = data + 5;<br>print data;                flag = 1;</pre><p name="2a13" id="2a13" class="graf graf--p graf-after--pre">Assume that we have <strong class="markup--strong markup--p-strong">perfect branch predictions</strong> with all stores strictly in the program order and if all the <strong class="markup--strong markup--p-strong">loads can be reordered</strong>. Because all the stores should be ordered, we have to keep the sequence of codes in thread B. The problem is in thread A when we have perfect branch prediction. When we predict that we will have flag = 1 in the future, then we are going to break the loop and fetch the data. However, at this moment, we can not make sure whether the data we fetch is <code class="markup--code markup--p-code">0</code> (thread B not executes), <code class="markup--code markup--p-code">10</code> (thread B executes 1 instruction), or <code class="markup--code markup--p-code">15</code> (thread B executes 2 or 3 instructions).</p><p name="5e14" id="5e14" class="graf graf--p graf-after--p">This inconsistency problem is called the <strong class="markup--strong markup--p-strong">data-ready flag synchronization</strong>.</p><p name="78cc" id="78cc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Memory Inconsistency: Thread Termination</strong></p><p name="1903" id="1903" class="graf graf--p graf-after--p">Let’s see another inconsistency problem called the <strong class="markup--strong markup--p-strong">thread termination</strong> problem where</p><ul class="postList"><li name="e79c" id="e79c" class="graf graf--li graf-after--p">thread A creates thread B</li><li name="03d3" id="03d3" class="graf graf--li graf-after--li">thread B executed and updates the data</li><li name="f0ef" id="f0ef" class="graf graf--li graf-after--li">thread A waits until B exits by a system call in thread A. This step will have branch prediction</li><li name="b159" id="b159" class="graf graf--li graf-after--li">when thread B has done, OS will mark that B is done</li></ul><p name="3d7a" id="3d7a" class="graf graf--p graf-after--li">So when we confirm the data, thread B can still execute because of the branch prediction. This example is quite similar to the data-read flag synchronization problem.</p><p name="fab0" id="fab0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Memory Consistency Models</strong></p><p name="0c5c" id="0c5c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Consistency Models</strong></p><p name="787d" id="787d" class="graf graf--p graf-after--p">Let’s now introduce some of the consistency models. Commonly, there will be two models of consistency, the <strong class="markup--strong markup--p-strong">sequential consistency model,</strong> and a family of <strong class="markup--strong markup--p-strong">relaxed consistency models</strong>,</p><ul class="postList"><li name="cef9" id="cef9" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Sequential consistency</strong></li><li name="e65a" id="e65a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Relaxed consistency</strong>: some of the models that are mostly used are called weak consistency, processor consistency, release consistency, lazy release consistency, scope consistency, and etc.</li></ul><p name="35af" id="35af" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Sequential Consistency</strong></p><p name="e1bd" id="e1bd" class="graf graf--p graf-after--p">For programmers, the most natural type of consistency is called <strong class="markup--strong markup--p-strong">sequential consistency</strong>. It is said that the result of any execution should be as if accesses are executed by each processor were executed <strong class="markup--strong markup--p-strong">in order</strong>, and accesses among different processors were arbitrarily interleaved. Therefore, we can do anything we want to interleave accesses from different processors. But what comes from each of the processors needs to be exactly in the program order.</p><p name="4952" id="4952" class="graf graf--p graf-after--p">So the simplest implementation of a sequential consistency and a core performs the next memory access only when all previous accesses are completely successful. This means that if we have the following program,</p><pre name="96a7" id="96a7" class="graf graf--pre graf-after--p">while (!flag) wait;<br>print data;</pre><p name="937c" id="937c" class="graf graf--p graf-after--pre">We can not access the memory to get the data until the while loop finishes. So then we will have no inconsistency problem.</p><p name="8ef1" id="8ef1" class="graf graf--p graf-after--p">However, there are drawbacks to the simple sequential consistency. If we issue the next access to the memory only when all prior accesses are complete, the memory level parallelism (MLP) can only be 1. In this case, because different accesses to the memory can not overlap each other, we will spend a lot of time loading the data from the memory and this is really <strong class="markup--strong markup--p-strong">bad for performance</strong>.</p><p name="bb74" id="bb74" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Relaxed Consistency</strong></p><p name="9a23" id="9a23" class="graf graf--p graf-after--p">An alternative approach that tries to create better performance is to actually relax the consistency so that we will not expect sequential consistency. Before we talk about the relaxed consistency, let’s first have a look at what we can do to improve the consistency. Suppose we have the following program that loads A and B,</p><pre name="6c46" id="6c46" class="graf graf--pre graf-after--p">LW A, R1<br>...<br>LW B, R2</pre><p name="5d56" id="5d56" class="graf graf--p graf-after--pre">If there is no save instruction between these two loads, we will have no inconsistency problem. However, if we have a load instruction between these two loads and the loads are executed out-of-order, then we will have an inconsistency problem.</p><pre name="a8e7" id="a8e7" class="graf graf--pre graf-after--p">LW A, R1<br>RD 1, A<br>LW B, R2</pre><p name="847e" id="847e" class="graf graf--p graf-after--pre">So basically, in a program, we have 4 types of read/write ordering,</p><ul class="postList"><li name="70b5" id="70b5" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">WR A -&gt; WR B</code></li><li name="e1c9" id="e1c9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">WR A -&gt; RD B</code></li><li name="f39f" id="f39f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">RD A -&gt; WR B</code></li><li name="5f1c" id="5f1c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">RD A -&gt; RD B</code></li></ul><p name="c112" id="c112" class="graf graf--p graf-after--li">For sequential consistency, we must obey all of these four orders. However, for a relaxed consistency, the following order doesn’t have to be obeyed because it will not affect the result,</p><ul class="postList"><li name="89f3" id="89f3" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">RD A -&gt; RD B</code></li></ul><p name="7dbc" id="7dbc" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">msync</strong></code><strong class="markup--strong markup--p-strong"> Instruction</strong></p><p name="fb4f" id="fb4f" class="graf graf--p graf-after--p">When we do relaxed consistency, we are allowed to reorder the normal accesses, and we will also add some special non-reorderable accesses by some system calls. An example for managing non-reordering accesses is the x86 <code class="markup--code markup--p-code">msync</code> instruction.</p><p name="be93" id="be93" class="graf graf--p graf-after--p">So now we will have all the accesses may be reordered, but none of them can be reordered across the <code class="markup--code markup--p-code">msync</code> instruction.</p><figure name="9307" id="9307" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kUPRIoqThYAxxp4PJV9iag.png" data-width="1298" data-height="474" src="https://cdn-images-1.medium.com/max/800/1*kUPRIoqThYAxxp4PJV9iag.png"></figure><p name="ceb3" id="ceb3" class="graf graf--p graf-after--figure">So now for the previous case, we can add a <code class="markup--code markup--p-code">msync</code> after while to maintain that the data is only read after the while statement.</p><pre name="eccd" id="eccd" class="graf graf--pre graf-after--p">while (!flag) wait;<br><strong class="markup--strong markup--pre-strong">msync;</strong><br>print data;</pre><p name="f171" id="f171" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. Data Races</strong></p><p name="b17f" id="b17f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of the Data Race</strong></p><p name="503d" id="503d" class="graf graf--p graf-after--p">The data race occurs when accesses to the same address by different cores that are not ordered by synchronization. So to have a data race problem, we need to have one processor reading and another writing (<code class="markup--code markup--p-code">RD -&gt; WR</code>), or the other way around (<code class="markup--code markup--p-code">WR -&gt; RD</code>), or both of them writing (<code class="markup--code markup--p-code">WR -&gt; WR</code>). Because we can hard to decide which one happens first and which one happens later without proper synchronization, we will then have <strong class="markup--strong markup--p-strong">data races</strong>.</p><p name="710a" id="710a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Data-­Race­-Free Program</strong></p><p name="4ed3" id="4ed3" class="graf graf--p graf-after--p">A data-race-free program is a program that can not create any data races in its executions, and that program is considered to be well synchronized so that any accesses to the data are correctly ordered by synchronization.</p><p name="2227" id="2227" class="graf graf--p graf-after--p">A key property of a data-race-free program is that it will behave exactly the same in a sequential consistency even if we run them in any relaxed consistency model because the synchronization maintains the order of the programs. So the program can be debugged in a sequential consistency model, then run on a relaxed consistency model.</p><p name="2c1c" id="2c1c" class="graf graf--p graf-after--p graf--trailing">However, for debugging a non-data-race-free program, anything can happen because we have data race problems. The results can be really weird and this makes the debugging process very difficult. So some processors support sequential consistency only when debugging.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/e3fcb4aff804"><time class="dt-published" datetime="2021-04-09T09:21:45.734Z">April 9, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-32-memory-inconsistency-sequential-consistency-relaxed-e3fcb4aff804" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>