<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 19 | Compiler for Improving ILP, Tree Height Reduction…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 19 | Compiler for Improving ILP, Tree Height Reduction…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="3b1f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ebff" id="ebff" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 19 | Compiler for Improving ILP, <strong class="markup--strong markup--h3-strong">Tree Height Reduction, Instruction Scheduling, Loop Unrolling, and Function Inlining</strong></h3><figure name="2580" id="2580" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*mDNvKonXvSKfTenl.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*mDNvKonXvSKfTenl.png"></figure><ol class="postList"><li name="51ad" id="51ad" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Review</strong></li></ol><p name="0a39" id="0a39" class="graf graf--p graf-after--li">We have completed the discussion that if we want to improve the IPC, we have to implement the out-of-order execution for the load/store instructions and non-load/store instructions. And in order to deal with the exceptions, we developed the ROB. However, to implement more than one instruction per cycle, we will discuss how the <strong class="markup--strong markup--p-strong">compiler </strong>can help.</p><p name="6acf" id="6acf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Compiler For ILP</strong></p><p name="e6d7" id="e6d7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Instruction-level Parallelism (ILP)</strong></p><p name="0b9d" id="0b9d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Instruction-level Parallelism</strong> (<strong class="markup--strong markup--p-strong">ILP</strong>) is a family of processor and compiler design techniques that speed up execution by causing individual machine operations, such as memory loads and stores, integer additions, and floating-point multiplications, to execute in parallel.</p><p name="8f19" id="8f19" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Limited ILP Problem</strong></p><p name="302d" id="302d" class="graf graf--p graf-after--p">In a real program, if we have a <strong class="markup--strong markup--p-strong">long chain of dependent instructions</strong>, we can do very little ILPs because we can really execute only one instruction at a time. However, with the help of a compiler, we will see that the compiler might help us actually avoid these kinds of dependence chains.</p><p name="a981" id="a981" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Limited “Window” Problem</strong></p><p name="b09f" id="b09f" class="graf graf--p graf-after--p">There is another problem because of this long dependence chain. The hardware will have a limited window into the program. For example, there might be independent instructions, so an ideal processor might be able to achieve good ILP under the program. But because these independent instructions are far apart, a real processor simply can not see those instructions because it runs out of the ROB space before it reaches those instructions that are independent. As we will see, the compiler can help us put these independence instructions closer to each other, so that the IPC achieved by the processor is closer to the available ILP.</p><p name="ee48" id="ee48" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Compiler ILP Techniques</strong></p><p name="6e3f" id="6e3f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Tree Height Reduction</strong></p><p name="84c5" id="84c5" class="graf graf--p graf-after--p">One of the examples of a technique to actually improve the ILP of the program is <strong class="markup--strong markup--p-strong">tree height reduction</strong>. Let’s say we need a program that has to add the values in R1, R2, R3, and R4, and then store the final result in R5,</p><pre name="caf8" id="caf8" class="graf graf--pre graf-after--p">R5 = R1 + R2 + R3 + R4</pre><p name="dfab" id="dfab" class="graf graf--p graf-after--pre">One way to get that result is,</p><pre name="995d" id="995d" class="graf graf--pre graf-after--p">ADD R5, R1, R2<br>ADD R5, R5, R3<br>ADD R5, R5, R4</pre><p name="faef" id="faef" class="graf graf--p graf-after--pre">However, this form of dependence chain is quite long. We can find out that the second instruction depends on the first one, and the third instruction depends on the second one. So all of these instructions have to be done one after another.</p><p name="4e35" id="4e35" class="graf graf--p graf-after--p">The<strong class="markup--strong markup--p-strong"> tree height reduction</strong> is that the compiler figures out that instead of adding one number at a time to get the sum and thus creating a chain of dependencies, what we can do is to group the computation in the following way for the same result,</p><pre name="7959" id="7959" class="graf graf--pre graf-after--p">R5 = (R1 + R2) + (R3 + R4)</pre><p name="0a0d" id="0a0d" class="graf graf--p graf-after--pre">So in this way, the assembly should be,</p><pre name="82ce" id="82ce" class="graf graf--pre graf-after--p">ADD R5, R1, R2<br>ADD R8, R3, R4<br>ADD R5, R5, R8</pre><p name="4614" id="4614" class="graf graf--p graf-after--pre">We can know that the third instruction depends on both the first instruction and the second instruction. However, the first instruction is independent of the second instruction, so they can be executed parallelly. So without the tree height reduction, we need three cycles to execute this program, while with the tree height reduction, we only need two cycles because the first instruction and the second instruction can be executed in parallel.</p><p name="0059" id="0059" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Instruction Scheduling</strong></p><p name="826c" id="826c" class="graf graf--p graf-after--p">We will look now at the instruction scheduling in the compiler. Here’s what can happen. Let’s first look at the following program,</p><pre name="81a5" id="81a5" class="graf graf--pre graf-after--p">Loop:<br>    LW  R2, 0(R1)<br>    ADD R2, R2, R0<br>    SW  R2, 0(R1)<br>    ADD R1, R1, 4<br>    BNE R1, R3, Loop</pre><p name="4538" id="4538" class="graf graf--p graf-after--pre">Assume that we have a very simple processor that can only look at the very next instruction and can only execute 1 instruction in a cycle. So it does not really have the reservation stations and the out-of-order execution. Suppose that the add instruction takes 3 cycles for execution, the load instruction takes 2 cycles, and the store takes only 1 cycle. So the schedule of the program above will be,</p><pre name="9e70" id="9e70" class="graf graf--pre graf-after--p">LW  R2, 0(R1)<br>STALL<br>ADD R2, R2, R0<br>STALL<br>STALL<br>SW  R2, 0(R1)<br>ADD R1, R1, 4<br>STALL<br>STALL<br>BNE R1, R3, Loop</pre><p name="cae5" id="cae5" class="graf graf--p graf-after--pre">This is because even though the instruction <code class="markup--code markup--p-code">ADD R1, R1, 4</code> can be executed right after the instruction <code class="markup--code markup--p-code">LW R2, 0(R1)</code> , the processor can only look at the very next instruction and it didn’t know that we have <code class="markup--code markup--p-code">ADD R1, R1, 4</code> . Thus, in general, we have to wait for 10 cycles to complete this program.</p><p name="fc7a" id="fc7a" class="graf graf--p graf-after--p">The instruction scheduling means that the compiler will move the independent instructions to build a new schedule. In this new program, the compiler will move the instruction <code class="markup--code markup--p-code">ADD R1, R1, 4</code> after the <code class="markup--code markup--p-code">LW R2, 0(R1)</code> , and because the value in R1 will be changed by an increment of 4, thus, we have to reduce the 4 for the instruction <code class="markup--code markup--p-code">SW R2, 0(R1)</code>.</p><pre name="9f7b" id="9f7b" class="graf graf--pre graf-after--p">Loop:<br>    LW  R2, 0(R1)<br>    <strong class="markup--strong markup--pre-strong">ADD R1, R1, 4</strong><br>    ADD R2, R2, R0<br>    SW  R2, <strong class="markup--strong markup--pre-strong">-4</strong>(R1)<br>    BNE R1, R3, Loop</pre><p name="425e" id="425e" class="graf graf--p graf-after--pre">So the schedule for the new program above will be,</p><pre name="5fa1" id="5fa1" class="graf graf--pre graf-after--p">LW  R2, 0(R1)<br>ADD R1, R1, 4<br>ADD R2, R2, R0<br>STALL<br>STALL<br>SW  R2, -4(R1)<br>BNE R1, R3, Loop</pre><p name="247e" id="247e" class="graf graf--p graf-after--pre">We can find out that only 7 cycles are required now. Note that if we have a better processor, the first instruction and the second instruction can even be executed in the same cycle parallelly.</p><p name="b616" id="b616" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Instruction Scheduling: Another Example</strong></p><p name="416f" id="416f" class="graf graf--p graf-after--p">Let’s see another example of instruction scheduling. Suppose we have the following program,</p><pre name="d376" id="d376" class="graf graf--pre graf-after--p">LW  R1, 0(R2)<br>ADD R1, R1, R3<br>SW  R1, 0(R2)<br>LW  R1, 0(R4)<br>ADD R1, R1, R5<br>SW  R1, 0(R4)</pre><p name="b457" id="b457" class="graf graf--p graf-after--pre">Suppose that we have a processor with the following features,</p><ul class="postList"><li name="72bb" id="72bb" class="graf graf--li graf-after--p">1 instruction / cycle, in-order execution</li><li name="924f" id="924f" class="graf graf--li graf-after--li">load instruction takes 2 cycles</li><li name="04dc" id="04dc" class="graf graf--li graf-after--li">add instruction takes 1 cycle</li><li name="6dd0" id="6dd0" class="graf graf--li graf-after--li">store instruction takes 1 cycle</li></ul><p name="20c9" id="20c9" class="graf graf--p graf-after--li">Then the as-is instruction schedule should be as follows,</p><pre name="547f" id="547f" class="graf graf--pre graf-after--p">LW  R1, 0(R2)<br>STALL<br>ADD R1, R1, R3<br>SW  R1, 0(R2)<br>LW  R1, 0(R4)<br>STALL<br>ADD R1, R1, R5<br>SW  R1, 0(R4)</pre><p name="6e60" id="6e60" class="graf graf--p graf-after--pre">After the instruction scheduling, we can move the second load instruction <code class="markup--code markup--p-code">LW R1, 0(R4)</code> to the front of this program. However, because this instruction will write to the R1 and then cause a data conflicting problem, we have to rename the register of this instruction. So after the instruction scheduling, the program will be,</p><pre name="a924" id="a924" class="graf graf--pre graf-after--p">LW  R1, 0(R2)<br>LW  R10, 0(R4)<br>ADD R1, R1, R3<br>ADD R10, R10, R5<br>SW  R1, 0(R2)<br>SW  R10, 0(R4)</pre><p name="afdc" id="afdc" class="graf graf--p graf-after--pre">Note that the add instruction and the store instruction will also be moved to make the program even more structured.</p><p name="1c82" id="1c82" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Instruction Scheduling and If-Conversion</strong></p><p name="edef" id="edef" class="graf graf--p graf-after--p">Let’s first recall what is the if-conversion. The if-conversation is a technique for us to avoid the branch instructions. This means that we will calculate both ways of taken the branch and not taken the branch, and then use a conditional move to decide which one to use finally.</p><p name="9291" id="9291" class="graf graf--p graf-after--p">Then we have to think about how the instruction scheduling is going to interact with the if-conversation. Actually, we can conclude that the if-conversation is going to help with the scheduling. Why? Let’s think about a branch model. In the following model, we can hardly conduct the instruction scheduling because if we mispredict the branch, all the things we have done for the scheduling are then useless because we never go to that branch.</p><figure name="4c50" id="4c50" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*1JELJBmLACIh17bwuFJf8A.png" data-width="2016" data-height="1250" src="https://cdn-images-1.medium.com/max/800/1*1JELJBmLACIh17bwuFJf8A.png"></figure><p name="8085" id="8085" class="graf graf--p graf-after--figure">However, after if-conversion, both of the branches are executed and we can then conduct the instruction scheduling because this is a branch-free code and we don’t have to worry about the branch not taken.</p><figure name="4e6b" id="4e6b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Q3S47SS0Ztum5nQTVYAIbg.png" data-width="1868" data-height="1026" src="https://cdn-images-1.medium.com/max/800/1*Q3S47SS0Ztum5nQTVYAIbg.png"></figure><p name="f3bd" id="f3bd" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) If-Convert Looping</strong></p><p name="dc49" id="dc49" class="graf graf--p graf-after--p">Could the if-conversation work for the loop so that we can then conduct instruction scheduling? To answer this question, let’s see an example here. Similarly, suppose we still have the looping program above,</p><pre name="32b0" id="32b0" class="graf graf--pre graf-after--p">Loop:<br>    LW  R2, 0(R1)<br>    ADD R2, R2, R0<br>    SW  R2, 0(R1)<br>    ADD R1, R1, 4<br>    BNE R1, R3, Loop</pre><p name="b78b" id="b78b" class="graf graf--p graf-after--pre">Assume that our processor is an in-cycle, 1 IPC processor with 2 cycles for a load instruction, 2 cycles for an add instruction, and 1 cycle for a store instruction. By what we have discussed before, before the instruction scheduling, we can have the following schedule for each loop,</p><pre name="1684" id="1684" class="graf graf--pre graf-after--p">LW  R2, 0(R1)<br>STALL<br>ADD R2, R2, R0<br>STALL<br>SW  R2, 0(R1)<br>ADD R1, R1, 4<br>STALL<br>BNE R1, R3, Loop</pre><p name="2715" id="2715" class="graf graf--p graf-after--pre">However, after the instruction scheduling, we will then have the program,</p><pre name="53a1" id="53a1" class="graf graf--pre graf-after--p">Loop:<br>    LW  R2, 0(R1)<br>    <strong class="markup--strong markup--pre-strong">ADD R1, R1, 4</strong><br>    ADD R2, R2, R0<br>    SW  R2, <strong class="markup--strong markup--pre-strong">-4</strong>(R1)<br>    BNE R1, R3, Loop</pre><p name="5e8e" id="5e8e" class="graf graf--p graf-after--pre">And the schedule for each loop should be,</p><pre name="c8d7" id="c8d7" class="graf graf--pre graf-after--p">LW  R2, 0(R1)<br>ADD R1, R1, 4<br>ADD R2, R2, R0<br>STALL<br>SW  R2, -4(R1)<br>BNE R1, R3, Loop</pre><p name="4d75" id="4d75" class="graf graf--p graf-after--pre">While in each of the loops, we can find that there is still one stall. If we think about using the if-conversion, we can actually fill in this stall with some instructions after the loop (because the branch will be eliminated). But this method has a problem. The loop is not really suitable for if-conversion because every time we have a new iteration, we will have a new predicate. After several loops, we will have many predicates that can not be dealt with easily. For example, if we are executing a million iteration loop, only in one loop we will break out, so almost a million iterations will have a useless predicate. Thus, the program will be very slow.</p><p name="362b" id="362b" class="graf graf--p graf-after--p">Now, we want to find some instructions to fill in the stalls but we don’t really want to do the if-conversion of a loop. Is there anything else we can do? Well, the answer is the <strong class="markup--strong markup--p-strong">loop</strong> <strong class="markup--strong markup--p-strong">unrolling</strong>.</p><p name="6b22" id="6b22" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Loop Unrolling</strong></p><p name="0627" id="0627" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Loop unrolling</strong> creates a loop with fewer iterations by having each iteration do the work of two or more iterations. To understand the loop unrolling, let’s first see an example of C. Suppose we have the following program,</p><pre name="0a5a" id="0a5a" class="graf graf--pre graf-after--p">for(i=1000;i!=0;i--) <br>   a[i] = a[i] + s;</pre><p name="35a4" id="35a4" class="graf graf--p graf-after--pre">Then the compiled assembly code is,</p><pre name="19c3" id="19c3" class="graf graf--pre graf-after--p">Loop:<br>  LW   R2, 0(R1)<br>  ADD  R2, R2, R3<br>  SW   R2, 0(R1)<br>  ADDI R1, R1, -4<br>  BNE  R1, R5, Loop </pre><p name="f91a" id="f91a" class="graf graf--p graf-after--pre">Where R1 stores the address for the <code class="markup--code markup--p-code">a[i]</code> and R3 stores the value of <code class="markup--code markup--p-code">s</code> .</p><p name="2108" id="2108" class="graf graf--p graf-after--p">Unrolling <strong class="markup--strong markup--p-strong">once</strong> means that we will do <strong class="markup--strong markup--p-strong">two iterations</strong> at a time in the loop (it is a common mistake to think that unrolling twice is to do two iterations at a time in the loop), this is to say that the C program will then be,</p><pre name="07a6" id="07a6" class="graf graf--pre graf-after--p">for(i=1000;i!=0;i-=2) <br>   a[i] = a[i] + s;<br>   a[i-1] = a[i-1] + s;</pre><p name="b08b" id="b08b" class="graf graf--p graf-after--pre">Then the compiled assembly code should be,</p><pre name="947a" id="947a" class="graf graf--pre graf-after--p">Loop:<br>  LW   R2, 0(R1)<br>  ADD  R2, R2, R3<br>  SW   R2, 0(R1)<br>  LW   R2, -4(R1)<br>  ADD  R2, R2, R3<br>  SW   R2, -4(R1)<br>  ADDI R1, R1, -8<br>  BNE  R1, R5, Loop</pre><p name="1ad7" id="1ad7" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(7) Loop Unrolling for ILP</strong></p><p name="0979" id="0979" class="graf graf--p graf-after--p">Now let’s discuss how does the unrolling loop improve the ILP. The ILP is improved in two ways,</p><ul class="postList"><li name="4a19" id="4a19" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">decrease the overall number of instructions</strong></li></ul><p name="1be6" id="1be6" class="graf graf--p graf-after--li">In the last example, before the loop unrolling, we have to run 5 instructions 1,000 times, which means that we&#39;ll have 5,000 instructions in general. However, after unrolling once, we only have to run 8 instructions 500 times, and this means that we are going to have 4,000 instructions generally. We have this improvement by reducing what is called the <strong class="markup--strong markup--p-strong">looping overhead</strong>. In the case of unrolling once, we do twice of the work but we only do have to apply half of the looping overheads.</p><p name="b1f5" id="b1f5" class="graf graf--p graf-after--p">Recall that the execution time of a program is the number of the instructions times the CPI times the cycle time per instruction. And because we have reduced the number of the instructions with almost no impact on the cycle time per instruction, so the overall execution time is going to be determined by the CPI and the number of instructions.</p><p name="7db4" id="7db4" class="graf graf--p graf-after--p">Now, let’s see what happens to the CPI.</p><ul class="postList"><li name="8a80" id="8a80" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">decrease the overall CPI</strong></li></ul><p name="733f" id="733f" class="graf graf--p graf-after--li">Assume that we have a 4-issue, in-order processor (meaning that it is only able to look at the next 1 instructions to see what can be executed) with perfect branch prediction.</p><p name="6bb1" id="6bb1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">=&gt; Case 1</strong>: No unrolling, without scheduling</p><p name="0b9e" id="0b9e" class="graf graf--p graf-after--p">Suppose we have the following instructions (as we have talked about in the loop unrolling),</p><pre name="47e4" id="47e4" class="graf graf--pre graf-after--p">Loop:<br>  LW   R2, 0(R1)<br>  ADD  R2, R2, R3<br>  SW   R2, 0(R1)<br>  ADDI R1, R1, -4<br>  BNE  R1, R5, Loop</pre><p name="6733" id="6733" class="graf graf--p graf-after--pre">We can calculate the CPI of this program by the following table,</p><figure name="e343" id="e343" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0ClO5wEGAfYdqoP21snz3Q.png" data-width="1868" data-height="544" src="https://cdn-images-1.medium.com/max/800/1*0ClO5wEGAfYdqoP21snz3Q.png"></figure><p name="3a97" id="3a97" class="graf graf--p graf-after--figure">Because we can execute all these 5 instructions in 3 cycles, the overall CPI for this program is <code class="markup--code markup--p-code">3/5 = 0.6</code>.</p><p name="2a7a" id="2a7a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">=&gt; Case 2</strong>: No unrolling, with scheduling</p><p name="f134" id="f134" class="graf graf--p graf-after--p">In the previous case, we didn’t take instruction scheduling into consideration. After instruction scheduling, we will have,</p><pre name="b5cb" id="b5cb" class="graf graf--pre graf-after--p">Loop:<br>  LW   R2, 0(R1)<br>  <strong class="markup--strong markup--pre-strong">ADDI R1, R1, -4</strong><br>  ADD  R2, R2, R3<br>  SW   R2, <strong class="markup--strong markup--pre-strong">4</strong>(R1)<br>  BNE  R1, R5, Loop</pre><p name="5b05" id="5b05" class="graf graf--p graf-after--pre">Then the looping diagram would be,</p><figure name="60c5" id="60c5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0Q0C1DAvJM0NheuCBMpoTA.png" data-width="1868" data-height="544" src="https://cdn-images-1.medium.com/max/800/1*0Q0C1DAvJM0NheuCBMpoTA.png"></figure><p name="441d" id="441d" class="graf graf--p graf-after--figure">Because we can execute all these 5 instructions in only 2 cycles, the overall CPI for this program is <code class="markup--code markup--p-code">2/5 = 0.4</code>.</p><p name="6da4" id="6da4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">=&gt; Case 3</strong>: Unrolling once, without scheduling</p><p name="bd0d" id="bd0d" class="graf graf--p graf-after--p">As we have discussed, if we conduct unrolling once, we will then have the program,</p><pre name="e6c6" id="e6c6" class="graf graf--pre graf-after--p">Loop:<br>  LW   R2, 0(R1)<br>  ADD  R2, R2, R3<br>  SW   R2, 0(R1)<br>  LW   R2, -4(R1)<br>  ADD  R2, R2, R3<br>  SW   R2, -4(R1)<br>  ADDI R1, R1, -8<br>  BNE  R1, R5, Loop</pre><p name="4781" id="4781" class="graf graf--p graf-after--pre">So the resulting diagram will be,</p><figure name="2728" id="2728" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XDsfThwP4fIcXZ3Q77XDug.png" data-width="1868" data-height="734" src="https://cdn-images-1.medium.com/max/800/1*XDsfThwP4fIcXZ3Q77XDug.png"></figure><p name="9007" id="9007" class="graf graf--p graf-after--figure">Because we can execute all these 8 instructions in 5 cycles, the overall CPI for this program is <code class="markup--code markup--p-code">5/8 = 0.625</code>.</p><p name="5f85" id="5f85" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">=&gt; Case 4</strong>: Unrolling once, with scheduling</p><p name="a604" id="a604" class="graf graf--p graf-after--p">Let’s see what will happen if we conduct a scheduled unrolling once. The program would be,</p><pre name="1abf" id="1abf" class="graf graf--pre graf-after--p">Loop:<br>  LW   R2, 0(R1)<br>  LW   R10, -4(R1)<br>  ADD  R2, R2, R3<br>  ADD  R10, R10, R3<br>  ADDI R1, R1, -8<br>  SW   R2, 8(R1)<br>  SW   R10, 4(R1)<br>  BNE  R1, R5, Loop</pre><p name="2833" id="2833" class="graf graf--p graf-after--pre">The resulting diagram would be,</p><figure name="1cd4" id="1cd4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*igQ0KS1dKf6E9D0a4FnyIw.png" data-width="1868" data-height="744" src="https://cdn-images-1.medium.com/max/800/1*igQ0KS1dKf6E9D0a4FnyIw.png"></figure><p name="300a" id="300a" class="graf graf--p graf-after--figure">Because we can execute all these 8 instructions in 3 cycles, the overall CPI for this program is <code class="markup--code markup--p-code">3/8 = 0.375</code>.</p><p name="1b92" id="1b92" class="graf graf--p graf-after--p">So in conclusion, we can find out that the loop unrolling can not only reduce the number of the instruction and the overall CPI. So that the execution time of the processor can be reduced.</p><p name="078b" id="078b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Loop Unrolling Downsides</strong></p><p name="c9a8" id="c9a8" class="graf graf--p graf-after--p">So far, unrolling seems like a pretty good thing and we tend to do unrolling all the time. However, there are some downsides to enrolling, and let’s discuss them now.</p><ul class="postList"><li name="a7d9" id="a7d9" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Code Bloat</strong>: code bloat is the production of program code that is perceived as unnecessarily long. You can see that with fewer unrollings, we can have a shorter code, while the code size grows rapidly with the number of the underlings with much more unrollings we do</li><li name="b476" id="b476" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Can’t handle the situation that the unknown number of interaction</strong>: for example, this could be a while loop and we may not sure about how many iterations we would have. So it is impossible for us to implement unrollings</li><li name="3d5e" id="3d5e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Can’t handle the situation that the number of iteration is not n times the number of unrollings</strong>: if this happens, that means we have to break the loop in its middle and this is difficult to implement</li></ul><p name="05e4" id="05e4" class="graf graf--p graf-after--li">We may talk about these sections above in a compiler series.</p><p name="15f1" id="15f1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Function Inlining</strong></p><p name="4c63" id="4c63" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">inlining</strong> is another technique for the functions. The inlining for functions is similar to unrolling for loopings. Inlining involves removing the function call and just replacing it with the body of the function. Let’s see an example here, suppose we have the following program,</p><pre name="47a1" id="47a1" class="graf graf--pre graf-after--p">some work ...<br>prepare function parameters<br>call function<br>other work ...</pre><p name="1e4b" id="1e4b" class="graf graf--p graf-after--pre">And we assume that the function call is supposed to be,</p><pre name="ace9" id="ace9" class="graf graf--pre graf-after--p">function: ADD Rn, A0, A1<br>RET</pre><p name="78c8" id="78c8" class="graf graf--p graf-after--pre">Then if we conduct the function inlining, the overall code can be,</p><pre name="5d6e" id="5d6e" class="graf graf--pre graf-after--p">some work ...<br>ADD R7, R7, R8<br>other work ...</pre><p name="dde7" id="dde7" class="graf graf--p graf-after--pre">You can find out that we don’t have to do the preparation for the parameters anymore.</p><p name="44a2" id="44a2" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">benefits</strong> of the inlining are that,</p><ul class="postList"><li name="0830" id="0830" class="graf graf--li graf-after--p">eliminate call/return overheads (fewer instructions)</li><li name="7677" id="7677" class="graf graf--li graf-after--li">instruction scheduling can be conducted for the whole code (lower CPI)</li></ul><p name="5db6" id="5db6" class="graf graf--p graf-after--li">Thus, in general, the overall execution time will be reduced by a lot and the performance will be improved.</p><p name="48fb" id="48fb" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">downsides</strong> of inlining are as follows,</p><ul class="postList"><li name="e029" id="e029" class="graf graf--li graf-after--p">Again, <strong class="markup--strong markup--li-strong">code bloat</strong>: we know that the same function may be called for several times in a program, and if we conduct the inlining, the code size grows rapidly. So the application results in a lot more code than the original calling and returning code.</li></ul><p name="7e88" id="7e88" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">3. Other IPC Enhancing Compiler Techniques</strong></p><p name="340a" id="340a" class="graf graf--p graf-after--p">There are some other techniques that can be used for compilers to improve the IPC. The present series do not require these techniques, but we may learn more about them in the compiler series. These techniques are,</p><ul class="postList"><li name="5da5" id="5da5" class="graf graf--li graf-after--p">software pipelining: covert some instructions to avoid dependencies</li><li name="1cc3" id="1cc3" class="graf graf--li graf-after--li graf--trailing">trace scheduling: the common path will be extracted for scheduling. Note that because we use the common path for most cases, we may have to execute some fixing code if we have a less common path</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/4ada4103d326"><time class="dt-published" datetime="2021-02-21T14:12:17.644Z">February 21, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-19-compiler-for-improving-ilp-tree-height-reduction-4ada4103d326" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>