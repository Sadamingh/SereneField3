<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 21 | Midterm Review</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 21 | Midterm Review</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="5ad8" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c433" id="c433" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 21 | Midterm Review</h3><figure name="bdd4" id="bdd4" class="graf graf--figure graf-after--h3 graf--trailing"><img class="graf-image" data-image-id="0*zzjINmnxYq8N3wrO.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*zzjINmnxYq8N3wrO.png"></figure></div></div></section><section name="e3c6" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><ol class="postList"><li name="0c92" id="0c92" class="graf graf--li graf--leading"><strong class="markup--strong markup--li-strong">Metrics and Evaluations</strong></li></ol><p name="6d2f" id="6d2f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Dynamic</strong> <strong class="markup--strong markup--p-strong">Power (Active Power)</strong></p><figure name="7573" id="7573" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*xoELFY63S5xrzYhP.png" data-width="1236" data-height="90" src="https://cdn-images-1.medium.com/max/800/0*xoELFY63S5xrzYhP.png"></figure><p name="5546" id="5546" class="graf graf--p graf-after--figure">where,</p><ul class="postList"><li name="917e" id="917e" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">C</code> is the total capacitance</li><li name="fd82" id="fd82" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">V²</code> is the voltage square and this is the power supply voltage</li><li name="d343" id="d343" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">f</code> is the clock frequency</li><li name="d395" id="d395" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">α</code> is the activity factor</li></ul><p name="c9e4" id="c9e4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Overall Power</strong></p><figure name="0be7" id="0be7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*aNgD1ah46H3ByUBn.png" data-width="1232" data-height="92" src="https://cdn-images-1.medium.com/max/800/0*aNgD1ah46H3ByUBn.png"></figure><p name="0fd2" id="0fd2" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) Fabrication Yield</strong></p><figure name="7134" id="7134" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*DhOaKIFn7P-2K84i.png" data-width="1692" data-height="122" src="https://cdn-images-1.medium.com/max/800/0*DhOaKIFn7P-2K84i.png"></figure><p name="0b97" id="0b97" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Latency and Throughput</strong></p><figure name="da91" id="da91" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XbVtb-FJVBuRVuCFEqearg.png" data-width="1206" data-height="102" src="https://cdn-images-1.medium.com/max/800/1*XbVtb-FJVBuRVuCFEqearg.png"></figure><p name="d817" id="d817" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Speedup</strong></p><figure name="5659" id="5659" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BMNa-j46hhfevkWV-btr-w.png" data-width="1428" data-height="110" src="https://cdn-images-1.medium.com/max/800/1*BMNa-j46hhfevkWV-btr-w.png"></figure><p name="6785" id="6785" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) Mean Speedup (Geometric Mean)</strong></p><figure name="5454" id="5454" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ixQ1meNK1piRvMcQmqBiow.png" data-width="1198" data-height="86" src="https://cdn-images-1.medium.com/max/800/1*ixQ1meNK1piRvMcQmqBiow.png"></figure><p name="86ce" id="86ce" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(7) Iron Law of Performance</strong></p><figure name="947d" id="947d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*4-IzjnLIdXvRbeki.png" data-width="1178" data-height="60" src="https://cdn-images-1.medium.com/max/800/0*4-IzjnLIdXvRbeki.png"></figure><p name="7c68" id="7c68" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(8) General Iron Law of Performance</strong></p><figure name="9725" id="9725" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*1FgWZBevmEKFM00YQP6DgA.png" data-width="1628" data-height="142" src="https://cdn-images-1.medium.com/max/800/1*1FgWZBevmEKFM00YQP6DgA.png"></figure><p name="4ab2" id="4ab2" class="graf graf--p graf-after--figure">Note that different kinds of instructions can have different cycles.</p><p name="b044" id="b044" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Amdahl’s Law</strong></p><figure name="c71d" id="c71d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WMCxU363Z5Ks38hdkD4mzg.png" data-width="1988" data-height="176" src="https://cdn-images-1.medium.com/max/800/1*WMCxU363Z5Ks38hdkD4mzg.png"></figure><p name="fa40" id="fa40" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(10) Lhadma’s Law</strong></p><p name="ad9f" id="ad9f" class="graf graf--p graf-after--p">While trying to make the common case fast, don&#39;t make the uncommon case worse.</p><p name="b6b5" id="b6b5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 1-1</strong>. (Amdahl’s Law) Booth’s algorithm is used to perform signed binary multiplication. The machine that uses Booth’s algorithm to perform a multiplication executes 129 cycles and the machine with the hardware multiplier takes 15 cycles per multiple. Given that 5% of all the instructions in a given benchmark are 32-bit binary multiplications. Calculate how much faster after the hardware machine is enhanced by Booth’s algorithm.</p><p name="b111" id="b111" class="graf graf--p graf-after--p">Ans:</p><pre name="1572" id="1572" class="graf graf--pre graf-after--p">Speedup_mul = 129/15 = 8.6<br>Speedup_frac = 1/(0.95+0.05/8.6) = 1.0462</pre><p name="35e2" id="35e2" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Example 1-2</strong>. (Iron Law and Amdahl’s Law) Your company currently uses the “<code class="markup--code markup--p-code">High RISC</code>” processor by RISCy Solutions. It is a 2GHz processor with an average CPI of 1.5. RISCy Solutions has just come out with two new processors which you are to compare and select the best performer.</p><ul class="postList"><li name="60ee" id="60ee" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">Triple the RISC</code> is a three pipelined machine that also runs at 2GHz, and maintains the same CPI as the High RISC. It is estimated that one-third of your code can use all three pipelines and another third can use two pipelines. For an n-pipelined processor, the ideal speedup is n.</li><li name="bd8f" id="bd8f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">RISCily Fast</code> is a 5GHz single processor, that due to its speed encounters a larger memory penalty. When the cache misses (5% of the time) on memory accesses (40% of all instructions), it incurs a penalty of 50 cycles more than the original High RISC processor. In all other ways, it is identical to the High RISC.</li></ul><p name="397f" id="397f" class="graf graf--p graf-after--li">Ans:</p><pre name="43b8" id="43b8" class="graf graf--pre graf-after--p">// speedup for &quot;<code class="markup--code markup--pre-code">Triple the RISC</code>&quot;<br>Speedup_1 = 1/(1/3 + (1/3)/3 + (1/3)/2) = 18/11 = 1.6364</pre><pre name="d9b6" id="d9b6" class="graf graf--pre graf-after--pre">// speedup for &quot;<code class="markup--code markup--pre-code">RISCily Fast</code>&quot;<br>Speedup_2 = Latency(<code class="markup--code markup--pre-code">High RISC</code>) / Latency(<code class="markup--code markup--pre-code">RISCily Fast</code>)<br>          = CPUtime_HR / CPUtime_<code class="markup--code markup--pre-code">RF</code><br>          = IC * CPI_HR * CCT_HR / (IC * CPI_RF * CCT_RF)<br>          = 1.5 * (1/2) / (CPI_RF * (1/5))<br>          = 1.5 * (1/2) / ((CPI_HR + 50*5%*40%) * (1/5))<br>          = 1.5 * 5 / (2.5 * 2)<br>          = 1.5</pre><pre name="aa3b" id="aa3b" class="graf graf--pre graf-after--pre">Because Speedup_1 &gt; Speedup_2, we should choose <code class="markup--code markup--pre-code">Triple the RISC</code></pre><p name="45e6" id="45e6" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Example 1-3</strong>. (Amdahl’s Law and Diminishing Returns)</p><p name="0b92" id="0b92" class="graf graf--p graf-after--p">Memory operations currently take 20% of execution time.</p><ul class="postList"><li name="ec7f" id="ec7f" class="graf graf--li graf-after--p">a first new widget speeds up 80% of the memory operations by a factor of 4</li><li name="6300" id="6300" class="graf graf--li graf-after--li">a second new widget then speeds up 30% of the memory operations by a factor of 2 after the first widget</li></ul><p name="cd6c" id="cd6c" class="graf graf--p graf-after--li">What is the total speed up after these two widgets?</p><p name="0a09" id="0a09" class="graf graf--p graf-after--p">Ans:</p><pre name="0835" id="0835" class="graf graf--pre graf-after--p">// Note that we have to take diminishing returns into consideration<br>// first widget<br>Speedup_1 = 1/((1-20%) + (1-80%)*20% + 80%*20%/4) = 1/0.88 = 1.1364</pre><pre name="8252" id="8252" class="graf graf--pre graf-after--pre">// calculate the diminishing return<br>Original:  |-------80%--------|--20%--|<br>Frac_non_mem = 0.8/0.88 = 91%<br>Frac_mem = 1-Frac_non_mem = 9%<br>After:     |-------91%--------|9%|</pre><pre name="1bde" id="1bde" class="graf graf--pre graf-after--pre">// second widget<br>Speedup_2 = 1/(91% + 9%*70% + 9%*30%/2) = 1/0.9865 = 1.0137</pre><pre name="d07a" id="d07a" class="graf graf--pre graf-after--pre">// total speedup<br>Speedup = Speedup_1*Speedup_2 = 1.1520 = 1.15</pre><p name="9984" id="9984" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Example 1-4</strong>. (Amdahl’s Law)</p><p name="d2b2" id="d2b2" class="graf graf--p graf-after--p">Use Amdahl’s law to prove the conclusion that it is important to keep a system balanced in terms of the performance of the I/O (memory operation) speed and the CPU (non-memory operation) speed.</p><p name="f71e" id="f71e" class="graf graf--p graf-after--p">Ans:</p><p name="7111" id="7111" class="graf graf--p graf-after--p">Assume that we have 10% of the I/O operation time and 90% of the CPU operation time. Suppose the CPU operation has speedups of 10, 100, and 1,000. Then the total speedup of the system will be,</p><pre name="03bb" id="03bb" class="graf graf--pre graf-after--p">Speedup_1 = 1/(10% + 90%/10) = 5.2632<br>Speedup_2 = 1/(10% + 90%/100) = 9.1743<br>Speedup_3 = 1/(10% + 90%/1000) = 9.9108</pre><p name="b884" id="b884" class="graf graf--p graf-after--pre">We can find out that the system performance will be restricted by the I/O operations if we don’t balance the performance.</p><p name="fdcd" id="fdcd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 1-5</strong>. (Iron’s Law)</p><p name="ee76" id="ee76" class="graf graf--p graf-after--p">Suppose we have a 1-ns clock cycle unpipelined processor that uses 4 cycles for the ALU operations, 5 cycles for the branches, and 4 cycles for the memory operations. Assume that we have a program that has 50% ALU operations, 35% branches, and 15% memory operations.</p><p name="9e5e" id="9e5e" class="graf graf--p graf-after--p">Now we can develop this processor by the clock skew and pipeline setups, the developed processor with one pipeline adds 0.15 ns of overhead to the clock. Ignore the latency impact, how much speed up in the instruction execution rate will we gain from a pipeline?</p><p name="4c2d" id="4c2d" class="graf graf--p graf-after--p">Ans:</p><pre name="6d66" id="6d66" class="graf graf--pre graf-after--p">// Unpipelined Processor<br>average_CPI_un = 4*50% + 5*35% + 4*15% = 4.35</pre><pre name="a791" id="a791" class="graf graf--pre graf-after--pre">// Developed Processor<br>CPI_pip = 1</pre><pre name="a817" id="a817" class="graf graf--pre graf-after--pre graf--trailing">// Speedup<br>Speedup = IC*average_CPI_un*CCT_1/(IC*CPI_pip*CCT_2)<br>        = 4.35*1 / (1*(1+0.15))<br>        = 4.35 / 1.15<br>        = 3.7826</pre></div></div></section><section name="078c" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="8698" id="8698" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">2. Pipeline</strong></p><p name="edd7" id="edd7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) 5-Stage Model</strong></p><ul class="postList"><li name="f808" id="f808" class="graf graf--li graf-after--p">Fetch</li><li name="1cb0" id="1cb0" class="graf graf--li graf-after--li">Decode</li><li name="0a51" id="0a51" class="graf graf--li graf-after--li">ALU</li><li name="a1bd" id="a1bd" class="graf graf--li graf-after--li">Memory Access</li><li name="6a88" id="6a88" class="graf graf--li graf-after--li">Write Registers</li></ul><p name="a316" id="a316" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Dependency</strong></p><p name="5fea" id="5fea" class="graf graf--p graf-after--p">When an instruction is dependent on the outcome from another instruction, these instructions have a <strong class="markup--strong markup--p-strong">dependency</strong>.</p><p name="a4e4" id="a4e4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Control Dependencies</strong></p><p name="e00b" id="e00b" class="graf graf--p graf-after--p">When an instruction is dependent on the outcome of a branch decision, these instructions are said to have a <strong class="markup--strong markup--p-strong">control dependence</strong>.</p><p name="b544" id="b544" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Data Deependendices</strong></p><p name="f67c" id="f67c" class="graf graf--p graf-after--p">When an instruction needs data from another instruction that is called a <strong class="markup--strong markup--p-strong">data dependence</strong>.</p><p name="83be" id="83be" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) True Dependency, Flow Dependency, RAW Dependency</strong></p><p name="68e3" id="68e3" class="graf graf--p graf-after--p">The read-after-write (RAW) dependency.</p><p name="5039" id="5039" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) False Dependency, Name Dependency</strong></p><p name="ced7" id="ced7" class="graf graf--p graf-after--p">The write-after-write (WAW) dependency and the write-after-read (WAR) dependency.</p><p name="d310" id="d310" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Hazard</strong></p><p name="54c0" id="54c0" class="graf graf--p graf-after--p">A hazard is created when there is a dependency between instructions and they are close enough that the overlap caused by pipelining would change the order of access to the dependent operand.</p><ul class="postList"><li name="f3c3" id="f3c3" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Control hazards</strong> are created when an instruction fetch depends on some branches under execution.</li><li name="e39c" id="e39c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Data hazards</strong> are true dependencies that result in incorrect execution of the program.</li></ul><p name="9492" id="9492" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) Stall</strong></p><p name="37c8" id="37c8" class="graf graf--p graf-after--p">A pipeline <strong class="markup--strong markup--p-strong">stall</strong> is a delay (NOP) in the execution of an instruction in order to resolve a hazard.</p><p name="39d2" id="39d2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Flush</strong></p><p name="df4e" id="df4e" class="graf graf--p graf-after--p">A <strong class="markup--strong markup--p-strong">pipeline flush</strong> means that when the mispredict occurs (the incorrect branch is taken), then all the incorrect instructions that we have fetched must be flushed from the pipeline by replacing them with NOPs.</p><p name="4df9" id="4df9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) Ideal CPI</strong></p><p name="7b4b" id="7b4b" class="graf graf--p graf-after--p">Suppose we have an N-issue (means that we can execute N instruction in a cycle) ideal processor (means no penalty for misprediction), the ideal CPI is,</p><figure name="f638" id="f638" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*7ZZoJmDAXZk-uFGFRFttCQ.png" data-width="1368" data-height="92" src="https://cdn-images-1.medium.com/max/800/1*7ZZoJmDAXZk-uFGFRFttCQ.png"></figure><p name="6135" id="6135" class="graf graf--p graf-after--figure">Note that if we have a pipeline with 5 stages, it doesn’t mean that we have 5 pipelines.</p><p name="a3b6" id="a3b6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) Real CPI</strong></p><p name="5eea" id="5eea" class="graf graf--p graf-after--p">Because the processor is not perfect, so the real CPI ≠ ideal CPI. We have to take penalties into our consideration,</p><figure name="fe3b" id="fe3b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*x3uU8iUwF4T6GrzaUpSHyw.png" data-width="1368" data-height="82" src="https://cdn-images-1.medium.com/max/800/1*x3uU8iUwF4T6GrzaUpSHyw.png"></figure><p name="d330" id="d330" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(12) Misprediction Penalty</strong></p><p name="7c54" id="7c54" class="graf graf--p graf-after--p">Sometimes we want to calculate the penalty (wasted cycles) per misprediction. Theoretically, this can be calculated by,</p><figure name="7074" id="7074" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Yz-g0a8Det_IMXzLxyhdsw.png" data-width="1368" data-height="106" src="https://cdn-images-1.medium.com/max/800/1*Yz-g0a8Det_IMXzLxyhdsw.png"></figure><p name="462b" id="462b" class="graf graf--p graf-after--figure">However, in practice, this should be calculated by</p><figure name="22fd" id="22fd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*M8xL7ZWabtrksBg_1jBMtg.png" data-width="1368" data-height="110" src="https://cdn-images-1.medium.com/max/800/1*M8xL7ZWabtrksBg_1jBMtg.png"></figure><p name="bbaf" id="bbaf" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(13) Forwarding</strong></p><p name="2279" id="2279" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">forwarding </strong>means that instead of reading from the register (after the writing stage), we directly use the result from the ALU stage (for the non-memory instructions) or the Memory access stage (for the memory operations). However, it can only supply the data in the <strong class="markup--strong markup--p-strong">next</strong> cycle.</p><p name="f104" id="f104" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(14) Branch Delay Slot</strong></p><p name="4b3e" id="4b3e" class="graf graf--p graf-after--p">The branch delay slot is caused because the branch would not be resolved until the instruction has worked its way through the pipeline.</p><p name="f7fb" id="f7fb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 2-1</strong>. (Dependencies and Hazards) Specify TRUE or FALSE to all the following statements.</p><ul class="postList"><li name="1022" id="1022" class="graf graf--li graf-after--p">Dependencies are caused by both the program and the pipeline.</li><li name="393d" id="393d" class="graf graf--li graf-after--li">Hazards are caused by both the program and the pipeline.</li><li name="e39e" id="e39e" class="graf graf--li graf-after--li">Not all true dependencies will result in a hazard.</li><li name="206e" id="206e" class="graf graf--li graf-after--li">Not all hazards are caused by true dependencies.</li></ul><p name="5722" id="5722" class="graf graf--p graf-after--li">Ans:</p><pre name="3143" id="3143" class="graf graf--pre graf-after--p">F       // Only by the program<br>T<br>T<br>T       // can also be caused by control dependencies</pre><p name="cd19" id="cd19" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Example 2–2</strong>. (Data Dependencies) Specify TRUE or FALSE to all the following statements.</p><ul class="postList"><li name="e1ae" id="e1ae" class="graf graf--li graf-after--p">Only flow dependencies require data being transmitted between instructions</li><li name="f42c" id="f42c" class="graf graf--li graf-after--li">The name dependencies can not cause the hazards</li><li name="b2d0" id="b2d0" class="graf graf--li graf-after--li">The name dependencies can be dealt with by register renaming</li><li name="17ef" id="17ef" class="graf graf--li graf-after--li">The flow dependencies can be dealt with by out-of-order execution</li></ul><p name="a2a5" id="a2a5" class="graf graf--p graf-after--li">Ans:</p><pre name="8d33" id="8d33" class="graf graf--pre graf-after--p">T<br>T<br>T<br>T</pre><p name="d856" id="d856" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Example 2–3</strong>. (Handling Hazards, Forwarding) Suppose we have the following code fragment,</p><pre name="8127" id="8127" class="graf graf--pre graf-after--p">Loop: <br>    LD   R1, 0(R2)<br>    ADDI R1, R1, #1<br>    SD   R1, 0(R2)<br>    ADDI R2, R2, #4<br>    SUB  R4, R3, R2<br>    BNEZ R4, Loop</pre><p name="b354" id="b354" class="graf graf--p graf-after--pre">Answer the following questions, and note that we assume that one iteration ends for the <strong class="markup--strong markup--p-strong">execution stage</strong> of the branch instruction.</p><p name="3b45" id="3b45" class="graf graf--p graf-after--p">a. Draw the timing of this instruction sequence for a 5-stage pipeline for one iteration <strong class="markup--strong markup--p-strong">without forwarding</strong>. Assuming that registers can be r/w in the same cycle.</p><p name="86e7" id="86e7" class="graf graf--p graf-after--p">Ans:</p><figure name="b092" id="b092" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zcp4V-9XNhfIZJZUeSWhsA.png" data-width="1996" data-height="484" src="https://cdn-images-1.medium.com/max/800/1*zcp4V-9XNhfIZJZUeSWhsA.png"></figure><p name="79b7" id="79b7" class="graf graf--p graf-after--figure">b. Draw the timing of this instruction sequence for a 5-stage pipeline for one iteration <strong class="markup--strong markup--p-strong">with forwarding</strong>. Assuming that registers can be r/w in the same cycle.</p><p name="dd1b" id="dd1b" class="graf graf--p graf-after--p">Ans:</p><figure name="5b28" id="5b28" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mBqqy0LpS2PV12W_mLRWmQ.png" data-width="1996" data-height="484" src="https://cdn-images-1.medium.com/max/800/1*mBqqy0LpS2PV12W_mLRWmQ.png"></figure><p name="dc8a" id="dc8a" class="graf graf--p graf-after--figure">c. Suppose we have a timing of this instruction sequence for a 5-stage pipeline for one iteration as follows,</p><figure name="392b" id="392b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NDLnqVZVm4PHSTT782ZnwA.png" data-width="1996" data-height="484" src="https://cdn-images-1.medium.com/max/800/1*NDLnqVZVm4PHSTT782ZnwA.png"></figure><p name="4ed1" id="4ed1" class="graf graf--p graf-after--figure">Note that the BNEZ instruction has one delay slot. Rewrite the code to fill in the slot and then draw the timing with forwarding.</p><p name="4294" id="4294" class="graf graf--p graf-after--p">Ans:</p><p name="a662" id="a662" class="graf graf--p graf-after--p">The point is that any instruction in the branch delay slot will get executed regardless of whether the branch is taken, even though it appears that the instruction will only be executed when the branch is not taken. So the code can be rescheduled to,</p><pre name="d760" id="d760" class="graf graf--pre graf-after--p">Loop: <br>    LD   R1, 0(R2)<br>    ADDI R1, R1, #1<br>    ADDI R2, R2, #4<br>    SUB  R4, R3, R2<br>    BNEZ R4, Loop<br>    SD   R1, -4(R2)</pre><p name="9cf8" id="9cf8" class="graf graf--p graf-after--pre">So what we want to do is take one of the existing instructions that would have been executed before the branch, and instead execute it during the delay caused by the branch. The reason why <code class="markup--code markup--p-code">SD</code> was chosen is that no other instruction in the loop depends on that instruction, until the next iteration.</p><figure name="b151" id="b151" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*w3zjN0aOQFgRLJzYWkT4DQ.png" data-width="1996" data-height="484" src="https://cdn-images-1.medium.com/max/800/1*w3zjN0aOQFgRLJzYWkT4DQ.png"></figure></div></div></section><section name="9711" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="aba9" id="aba9" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">3. Branch Prediction and Precidcation</strong></p><p name="dccf" id="dccf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Rule of Thumb</strong></p><p name="d11e" id="d11e" class="graf graf--p graf-after--p">Branches account for 20% of all instructions.</p><p name="3e43" id="3e43" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Prediction Accuracy</strong></p><figure name="0940" id="0940" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*JlHk3sXfFYbd7Ko9NwhqCA.png" data-width="1756" data-height="110" src="https://cdn-images-1.medium.com/max/800/1*JlHk3sXfFYbd7Ko9NwhqCA.png"></figure><p name="9f31" id="9f31" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) Refuse-to-Predict Predictor</strong>: no prediction</p><ul class="postList"><li name="f44d" id="f44d" class="graf graf--li graf-after--p">For non-branch operations: 2 cycles</li><li name="cf7b" id="cf7b" class="graf graf--li graf-after--li">For branches: 3 cycles</li></ul><p name="60bd" id="60bd" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Not-taken Predictor</strong>: always predict not taken</p><ul class="postList"><li name="3519" id="3519" class="graf graf--li graf-after--p">For non-branch operations: 1 cycle</li><li name="98c3" id="98c3" class="graf graf--li graf-after--li">For not-taken branches: 1 cycles</li><li name="671e" id="671e" class="graf graf--li graf-after--li">For taken branches: 3 cycles</li></ul><p name="a97b" id="a97b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Branch Target Buffer (BTB): predict by history branch PC</strong></p><p name="9fd8" id="9fd8" class="graf graf--p graf-after--p">A table mapping the current branch PC number to the target PC. It is only accessed when the BHT says the instruction is a taken branch.</p><ul class="postList"><li name="864c" id="864c" class="graf graf--li graf-after--p">Least Significant Bits (LSB) indexing</li></ul><p name="f84d" id="f84d" class="graf graf--p graf-after--li">Note that the not-taken predictor takes no branches.</p><p name="a591" id="a591" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Branch History Table (BHT)</strong></p><p name="bce8" id="bce8" class="graf graf--p graf-after--p">The branch history table (BHT) is used to determine if the branch is taken or not taken.</p><p name="a31e" id="a31e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) 1 Bit Predictor (1BP)</strong></p><p name="ed65" id="ed65" class="graf graf--p graf-after--p">The BHT stores a 1-bit history for each branch.</p><pre name="722c" id="722c" class="graf graf--pre graf-after--p">1 == Taken<br>0 == Not Taken</pre><p name="48f2" id="48f2" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(8) 2 Bit Predictor (2BP)</strong></p><p name="97fc" id="97fc" class="graf graf--p graf-after--p">The BHT stores a 2-bit history for each branch.</p><pre name="fd87" id="fd87" class="graf graf--pre graf-after--p">00 == Strongly Not Taken<br>01 == Weakly Not Taken<br>10 == Weakly Taken<br>11 == Strongly Taken</pre><p name="d260" id="d260" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(9) History-Based Predictor</strong></p><p name="4b24" id="4b24" class="graf graf--p graf-after--p">We have to use a history-based predictor because the patterns can be learned.</p><p name="011e" id="011e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) 1-Bit History 2-Bit Predictor/Counter (1BH2BP/BC)</strong></p><pre name="1bd0" id="1bd0" class="graf graf--pre graf-after--p">// History Bit<br>0 == Choose the 1st 2-bit counter<br>1 == Choose the 2nd 2-bit counter</pre><pre name="c204" id="c204" class="graf graf--pre graf-after--pre">// 1st 2-bit counter<br>00 == Strongly Not Taken<br>01 == Weakly Not Taken<br>10 == Weakly Taken<br>11 == Strongly Taken</pre><pre name="7545" id="7545" class="graf graf--pre graf-after--pre">// 2nd 2-bit counter <br>00 == Strongly Not Taken<br>01 == Weakly Not Taken<br>10 == Weakly Taken<br>11 == Strongly Taken</pre><p name="cdc8" id="cdc8" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(11) 2-Bit History 2-Bit Predictor/Counter (2BH2BP/BC)</strong></p><pre name="b033" id="b033" class="graf graf--pre graf-after--p">// History Bit<br>00 == Choose the 1st 2-bit counter<br>01 == Choose the 2nd 2-bit counter<br>10 == Choose the 3rd 2-bit counter<br>11 == Choose the 4th 2-bit counter</pre><pre name="8537" id="8537" class="graf graf--pre graf-after--pre">// 1st 2-bit counter<br>00 == Strongly Not Taken<br>01 == Weakly Not Taken<br>10 == Weakly Taken<br>11 == Strongly Taken</pre><pre name="5e5f" id="5e5f" class="graf graf--pre graf-after--pre">// 2nd 2-bit counter <br>00 == Strongly Not Taken<br>01 == Weakly Not Taken<br>10 == Weakly Taken<br>11 == Strongly Taken</pre><pre name="17b5" id="17b5" class="graf graf--pre graf-after--pre">// 3rd 2-bit counter <br>00 == Strongly Not Taken<br>01 == Weakly Not Taken<br>10 == Weakly Taken<br>11 == Strongly Taken</pre><pre name="7dad" id="7dad" class="graf graf--pre graf-after--pre">// 4th 2-bit counter <br>00 == Strongly Not Taken<br>01 == Weakly Not Taken<br>10 == Weakly Taken<br>11 == Strongly Taken</pre><p name="ab7f" id="ab7f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(11) N-Bit History 2-Bit Predictor/Counter (NBH2BP/BC) Requirements</strong></p><ul class="postList"><li name="288c" id="288c" class="graf graf--li graf-after--p">Can predict patterns of length <code class="markup--code markup--li-code">N+1</code></li><li name="d578" id="d578" class="graf graf--li graf-after--li">Cost <code class="markup--code markup--li-code">N+2*2^N</code> bits per entry</li></ul><p name="ab6e" id="ab6e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(12) Shared Counters</strong></p><p name="f1bc" id="f1bc" class="graf graf--p graf-after--p">Because the cost of the history-based predictors is high and most of the counters are wasted, we use the <strong class="markup--strong markup--p-strong">shared counters</strong> in a BHT to reduce the cost of the predictor.</p><p name="0a8e" id="0a8e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(13) Pattern History Table (PHT)</strong></p><p name="1e54" id="1e54" class="graf graf--p graf-after--p">Because all the histories are going to use the same BHT for shared counters to reduce the cost, we can then split the BHT and store the pattern history in a table call the <strong class="markup--strong markup--p-strong">pattern history table (PHT)</strong>.</p><p name="a02b" id="a02b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(14) PShare (Local History Predictor)</strong></p><p name="5207" id="5207" class="graf graf--p graf-after--p">PHT with entries for different pattern histories. This is good for <strong class="markup--strong markup--p-strong">small</strong> loops and predictable <strong class="markup--strong markup--p-strong">short</strong> patterns.</p><p name="3016" id="3016" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(15) GShare (Global History Predictor)</strong></p><p name="0e5e" id="0e5e" class="graf graf--p graf-after--p">PHT with an entry for one global pattern history. This is good for <strong class="markup--strong markup--p-strong">correlated branches</strong>.</p><p name="2fb0" id="2fb0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(16) Tournament Predictor</strong></p><p name="e6aa" id="e6aa" class="graf graf--p graf-after--p">A tournament predictor combines two good predictors (i.e. PShare and GShare). It uses a meta predictor to choose between these two good predictors.</p><p name="2231" id="2231" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(17) MetaPredictor</strong></p><p name="5d05" id="5d05" class="graf graf--p graf-after--p">A predictor for choosing between two good predictors.</p><pre name="9b99" id="9b99" class="graf graf--pre graf-after--p">00 == Strongly GShare<br>01 == Weakly GShare<br>10 == Weakly PShare<br>11 == Strongly PShare</pre><p name="82df" id="82df" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(18) Hierarchical Predictor</strong></p><p name="ff04" id="ff04" class="graf graf--p graf-after--p">A hierarchical predictor combines a good predictor and an okay predictor (i.e. PShare and 2BP predictor). The good predictor is <strong class="markup--strong markup--p-strong">only updated</strong> when the okay predictor is incorrect, so it saves the cost.</p><p name="3281" id="3281" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(19) Return Address Stack (RAS) Predictor</strong></p><p name="429c" id="429c" class="graf graf--p graf-after--p">The RAS is a small stack (i.e. with only 4 entries) used to store the return address of the functions.</p><p name="3098" id="3098" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(20) Predication</strong></p><p name="9db0" id="9db0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Predication</strong> is doing the work of both directions and then choosing the correct one and throwing away the incorrect path work.</p><p name="eb7f" id="eb7f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(21) If-Conversion</strong></p><p name="0d26" id="0d26" class="graf graf--p graf-after--p">The if-conversion technique means that we are going to use conditions instructions for these two directions, such as <code class="markup--code markup--p-code">MOVC</code> and <code class="markup--code markup--p-code">MOVZ</code>.</p><p name="c81b" id="c81b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(22) Full Predication</strong></p><p name="c803" id="c803" class="graf graf--p graf-after--p">The full predication means that instead of using a conditioning move, we can conditional bits to every instruction for telling us what is the condition.</p><p name="2233" id="2233" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 3-1</strong>. (Predictors and Mispredictions) Consider the following MIPS code,</p><pre name="f103" id="f103" class="graf graf--pre graf-after--p">ADDR   LW R2, #0                // v = 0<br>       LW R3, #16<br>       LW R4, #0                // i = 0<br>       LoopI:<br>0x11C    BEQ R4, R3, EndloopI<br>         LW  R5, #0             // j = 0<br>       LoopJ:<br>0x124    BEQ  R5, R3, EndloopJ<br>         ADD  R6, R5, R4        // j+i<br>         ANDI R6, R6, #3        // (j+i)%4<br>0x130    BNE  R6, R0, EndIf     // skip if (j+i)%4 != 0<br>         ADD  R2, R2, R5        // v += j<br>       EndIf:<br>         ADDI R5, R5, #1<br>0x13C    BEQ  R0, R0, LoopJ<br>       EndloopJ:<br>         ADDI R4, R4, #1<br>0x144    BEQ  R0, R0, LoopI<br>       EndloopI:</pre><p name="5e59" id="5e59" class="graf graf--p graf-after--pre">a. Rewrite the code in C.</p><p name="9ef7" id="9ef7" class="graf graf--p graf-after--p">b. If we use an <strong class="markup--strong markup--p-strong">always-taken predictor</strong>, determine the exact number of branch mispredictions.</p><p name="340c" id="340c" class="graf graf--p graf-after--p">c. Note that the MIPS instructions always start at <strong class="markup--strong markup--p-strong">word-aligned</strong> addresses, so the two least significant bits are never used to index the BHT. If we use a <strong class="markup--strong markup--p-strong">one-bit predictor with an 8-entry BHT</strong>, and assume that all predictor entries <strong class="markup--strong markup--p-strong">start out with zero values</strong>, determine the exact number of branch mispredictions.</p><p name="2022" id="2022" class="graf graf--p graf-after--p">d. Note that the MIPS instructions always start at <strong class="markup--strong markup--p-strong">word-aligned</strong> addresses, so the two least significant bits are never used to index the BHT. If we use a <strong class="markup--strong markup--p-strong">local history predictor with 8 entries</strong>. Each entry has a <strong class="markup--strong markup--p-strong">2-bit local history</strong> and <strong class="markup--strong markup--p-strong">four 2-bit counters</strong>. All history bits and 2-bit counters <strong class="markup--strong markup--p-strong">start out with zero values</strong>. Determine the exact number of branch mispredictions.</p><p name="6dac" id="6dac" class="graf graf--p graf-after--p">a. Ans:</p><pre name="58a8" id="58a8" class="graf graf--pre graf-after--p">v = 0;<br>for (i = 0; i &lt; 16; i++) {<br>   for (j = 0; j&lt; 16; j++) {<br>      if ((i+j)%4 != 0) continue;<br>      v += j;<br>   }<br>}</pre><p name="b5ea" id="b5ea" class="graf graf--p graf-after--pre">b. Ans:</p><p name="e3fb" id="e3fb" class="graf graf--p graf-after--p">Because this branch is predicted as always-taken, then the misprediction happens when,</p><ul class="postList"><li name="c20e" id="c20e" class="graf graf--li graf-after--p">i = 0~15</li><li name="a059" id="a059" class="graf graf--li graf-after--li">j = 0~15</li><li name="cb29" id="cb29" class="graf graf--li graf-after--li">(i + j) % 4 = 0</li></ul><p name="e0a7" id="e0a7" class="graf graf--p graf-after--li">Note that we don’t have to consider the last two branches because they are always taken.</p><p name="d9ac" id="d9ac" class="graf graf--p graf-after--p">For the first case, because the instruction <code class="markup--code markup--p-code">BEQ R4, R3, EndloopI</code> is executed 17 times and the last time it is taken. So the number of misprediction is 16.</p><p name="f80f" id="f80f" class="graf graf--p graf-after--p">For the second case, because the instruction is executed both in the loop for <code class="markup--code markup--p-code">i</code> and the loop for <code class="markup--code markup--p-code">j</code> , so it is executed 16*17 times. And because in each of the last iteration of the loop for j, it will be taken, the number of misprediction is 16*16 = 256 times.</p><p name="8d86" id="8d86" class="graf graf--p graf-after--p">For the last case, we have to consider the case when <code class="markup--code markup--p-code">(i + j) % 4 == 0</code> . Both variable <code class="markup--code markup--p-code">i</code> and variable <code class="markup--code markup--p-code">j</code> can be chosen from 0 to 15, so,</p><pre name="16e0" id="16e0" class="graf graf--pre graf-after--p">i        j<br>----     --------------------<br>0        0     4     8     12<br>1        3     7     11    15<br>...      ...<br>15       1     5     9     13</pre><p name="4ed4" id="4ed4" class="graf graf--p graf-after--pre">Thus, the misprediction for this case is 16*4 = 64.</p><p name="f5cd" id="f5cd" class="graf graf--p graf-after--p">In conclusion, the exact number of branch mispredictions is <code class="markup--code markup--p-code">16 + 256 + 64 = 366</code>.</p><p name="4d41" id="4d41" class="graf graf--p graf-after--p">c. Ans:</p><p name="632b" id="632b" class="graf graf--p graf-after--p">The 1-bit predictor 8-entry BHT at the beginning should be,</p><pre name="e29a" id="e29a" class="graf graf--pre graf-after--p">INDEX            PREDICTOR<br>-----------      -------------<br>000              0<br>001              0<br>010              0<br>011              0<br>100              0<br>101              0<br>110              0<br>111              0</pre><p name="42d0" id="42d0" class="graf graf--p graf-after--pre">The five branches are,</p><pre name="456d" id="456d" class="graf graf--pre graf-after--p">0x11C    BEQ R4, R3, EndloopI<br>0x124    BEQ R5, R3, EndloopJ<br>0x130    BNE  R6, R0, EndIf<br>0x13C    BEQ  R0, R0, LoopJ<br>0x144    BEQ  R0, R0, LoopI</pre><p name="db9e" id="db9e" class="graf graf--p graf-after--pre">Because we have a <strong class="markup--strong markup--p-strong">word-aligned</strong> LSB indexing (which means the last two bits should be ignored), the mapping rules should be</p><pre name="6a48" id="6a48" class="graf graf--pre graf-after--p">Address       Binary               LSB (3bits)<br>---------     ---------------      ----------------<br>0x11C         0001 0001 11<strong class="markup--strong markup--pre-strong">00   </strong>    111<br>0x124         0001 0010 01<strong class="markup--strong markup--pre-strong">00 </strong>      001<br>0x130         0001 0011 00<strong class="markup--strong markup--pre-strong">00</strong>       100<br>0x13C         0001 0011 11<strong class="markup--strong markup--pre-strong">00</strong>       111<br>0x144         0001 0100 01<strong class="markup--strong markup--pre-strong">00</strong>       001</pre><p name="6bce" id="6bce" class="graf graf--p graf-after--pre">As a result, both <code class="markup--code markup--p-code">0x11C</code> and <code class="markup--code markup--p-code">0x13C</code> will be mapping to the <code class="markup--code markup--p-code">111</code> entry in the BHT, both <code class="markup--code markup--p-code">0x124</code> and <code class="markup--code markup--p-code">0x144</code> will be mapping to the <code class="markup--code markup--p-code">001</code> entry in BHT, and finally, <code class="markup--code markup--p-code">0x130</code> will be mapping to the <code class="markup--code markup--p-code">100</code> entry in the BHT.</p><p name="f0b3" id="f0b3" class="graf graf--p graf-after--p">Now, let’s first consider the <code class="markup--code markup--p-code">111</code> entry. This entry will be used for both <code class="markup--code markup--p-code">0x11C</code> and <code class="markup--code markup--p-code">0x13C</code> . For the branch <code class="markup--code markup--p-code">0x11C</code> , it will be,</p><pre name="b03a" id="b03a" class="graf graf--pre graf-after--p">N N N N N N N N N N N N N N N N T</pre><p name="3c2c" id="3c2c" class="graf graf--p graf-after--pre">Or we could write it as,</p><pre name="0cf5" id="0cf5" class="graf graf--pre graf-after--p">{N}*16 T</pre><p name="5cef" id="5cef" class="graf graf--p graf-after--pre">Although the branch <code class="markup--code markup--p-code">0x13C</code> seems to branch all the time, there will be some mispredictions because it uses the same BHT entry with <code class="markup--code markup--p-code">0x13C</code> . So, for each of the iteration for <code class="markup--code markup--p-code">i</code>, it will be,</p><pre name="fda5" id="fda5" class="graf graf--pre graf-after--p">T T T T T T T T T T T T T T T T</pre><p name="2f68" id="2f68" class="graf graf--p graf-after--pre">Or we could write it as,</p><pre name="b9f2" id="b9f2" class="graf graf--pre graf-after--p">{T}*16</pre><p name="a35f" id="a35f" class="graf graf--p graf-after--pre">So in general, the overall branches would be,</p><pre name="91c5" id="91c5" class="graf graf--pre graf-after--p">{N {T}*16}*16 T</pre><p name="f04b" id="f04b" class="graf graf--p graf-after--pre">This is also to say that we have,</p><pre name="872b" id="872b" class="graf graf--pre graf-after--p">|---------------- 17*16 ------------------|<br>N <strong class="markup--strong markup--pre-strong">T</strong>....T <strong class="markup--strong markup--pre-strong">N T</strong>....T ... ... <strong class="markup--strong markup--pre-strong">N T</strong>....T <strong class="markup--strong markup--pre-strong">N T</strong>....T T<br>  |-16-|   |-16-|           |-16-|   |-16-|</pre><p name="062e" id="062e" class="graf graf--p graf-after--pre">By this diagram, we can find out that we have 31 mispredictions for this entry, 1 for the first Taken, and 15 times of conversion of Taken-Not Taken-Taken. So in summary, there would be <code class="markup--code markup--p-code">1+15*2 = 31</code> mispredictions for this case.</p><p name="20fe" id="20fe" class="graf graf--p graf-after--p">Similarly, for <code class="markup--code markup--p-code">001</code> entry in the BHT, <code class="markup--code markup--p-code">0x124</code> will be executed 16*17 times and in the branching status will be,</p><pre name="5dfc" id="5dfc" class="graf graf--pre graf-after--p">{N N N N N N N N N N N N N N N N T}*16</pre><p name="df22" id="df22" class="graf graf--p graf-after--pre">Or we could write it as,</p><pre name="7bf9" id="7bf9" class="graf graf--pre graf-after--p">{{N}*16 T}*16</pre><p name="5445" id="5445" class="graf graf--p graf-after--pre">For the <code class="markup--code markup--p-code">0x144</code> branch, we can know it is always taken but because it is written to the same entry of <code class="markup--code markup--p-code">0x124</code> , it will also cause some mispredictions,</p><pre name="f858" id="f858" class="graf graf--pre graf-after--p">T T T T T T T T T T T T T T T T</pre><p name="b15c" id="b15c" class="graf graf--p graf-after--pre">Because it will be executed after every 17 iterations of j, then the overall branching status for the <code class="markup--code markup--p-code">001</code> entry should be,</p><pre name="ea65" id="ea65" class="graf graf--pre graf-after--p">{{N}*16 T T}*16</pre><p name="bf51" id="bf51" class="graf graf--p graf-after--pre">This is also to say that we have,</p><pre name="577c" id="577c" class="graf graf--pre graf-after--p">|------------------ 16 * 18 -----------------|<br>N .... N <strong class="markup--strong markup--pre-strong">T</strong> T <strong class="markup--strong markup--pre-strong">N</strong> .... N <strong class="markup--strong markup--pre-strong">T</strong> T ... ... <strong class="markup--strong markup--pre-strong">N</strong> .... N <strong class="markup--strong markup--pre-strong">T</strong> T<br>|--16--|     |--16--|             |--16--|</pre><p name="f0fa" id="f0fa" class="graf graf--p graf-after--pre">By this diagram, we can find out that we also have 31 mispredictions for this entry, 1 for the first Taken, and 15 times of conversion of Taken-Not Taken-Taken. So in summary, there would be <code class="markup--code markup--p-code">1+15*2 = 31</code> mispredictions for this case.</p><p name="2dd5" id="2dd5" class="graf graf--p graf-after--p">In the end, let’s consider the entry <code class="markup--code markup--p-code">100</code> only for the branch <code class="markup--code markup--p-code">0x130</code> . This is simpler because we only have to consider only one branch. For this branch, as we have discussed before, it has a pattern of,</p><pre name="3ea1" id="3ea1" class="graf graf--pre graf-after--p">{N T...T N T...T N T...T N T...T}*16</pre><p name="92b2" id="92b2" class="graf graf--p graf-after--pre">Or we could write it as,</p><pre name="5708" id="5708" class="graf graf--pre graf-after--p">{N T...T}*64</pre><p name="04d7" id="04d7" class="graf graf--p graf-after--pre">Or, we can make it easier for us to find the mispredictions by,</p><pre name="a5ad" id="a5ad" class="graf graf--pre graf-after--p">N <strong class="markup--strong markup--pre-strong">T</strong>...T {<strong class="markup--strong markup--pre-strong">N T</strong>...T}*63</pre><p name="2726" id="2726" class="graf graf--p graf-after--pre">So in summary, the mispredictions for this case is <code class="markup--code markup--p-code">1+63*2 = 127</code>.</p><p name="840d" id="840d" class="graf graf--p graf-after--p">And in conclusion, the overall number of mispredictions should then be <code class="markup--code markup--p-code">31 + 31 + 127 = 189</code>.</p><p name="03db" id="03db" class="graf graf--p graf-after--p">d. Ans:</p><p name="3ca4" id="3ca4" class="graf graf--p graf-after--p">The 2BH-2BC BHT at the beginning should be,</p><pre name="9a0a" id="9a0a" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        00        00        00        00        00</pre><p name="10a3" id="10a3" class="graf graf--p graf-after--pre">As we have discussed, <code class="markup--code markup--p-code">0x11C</code> and <code class="markup--code markup--p-code">0x13C</code> will share the <code class="markup--code markup--p-code">111</code> entry, <code class="markup--code markup--p-code">0x124</code> and <code class="markup--code markup--p-code">0x144</code> will share the <code class="markup--code markup--p-code">001</code> entry, and <code class="markup--code markup--p-code">0x130</code> will use the <code class="markup--code markup--p-code">100</code> entry.</p><p name="ab49" id="ab49" class="graf graf--p graf-after--p">For the <code class="markup--code markup--p-code">111</code> entry, the pattern would be,</p><pre name="d7fb" id="d7fb" class="graf graf--pre graf-after--p">{N {T}*16}*16 T</pre><p name="2c72" id="2c72" class="graf graf--p graf-after--pre">For the <code class="markup--code markup--p-code">001</code> entry, the pattern would be,</p><pre name="54f3" id="54f3" class="graf graf--pre graf-after--p">{{N}*16 T T}*16</pre><p name="cd4d" id="cd4d" class="graf graf--p graf-after--pre">For the <code class="markup--code markup--p-code">100</code> entry, the pattern would be (note that the sequence of NTTT is not solid),</p><pre name="c79f" id="c79f" class="graf graf--pre graf-after--p">{N T T T}*64</pre><p name="c3d2" id="c3d2" class="graf graf--p graf-after--pre">Let’s discuss them one by one. Firstly, let’s talk about the <code class="markup--code markup--p-code">111</code> entry,</p><ul class="postList"><li name="101e" id="101e" class="graf graf--li graf-after--p">the first <code class="markup--code markup--li-code">N {T}*16</code> iteration,</li></ul><p name="7df6" id="7df6" class="graf graf--p graf-after--li">For the first status (N), there will be nothing and we will predict it <strong class="markup--strong markup--p-strong">correctly</strong>,</p><pre name="0d1b" id="0d1b" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        00        00        00        00        00</pre><p name="b308" id="b308" class="graf graf--p graf-after--pre">For the second status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it,</p><pre name="43e2" id="43e2" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        00        01        00        00        00</pre><p name="5e8b" id="5e8b" class="graf graf--p graf-after--pre">For the third status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it,</p><pre name="8c20" id="8c20" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        01        01        01        00        00</pre><p name="e7fc" id="e7fc" class="graf graf--p graf-after--pre">For the fourth status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it,</p><pre name="89e0" id="89e0" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        11        01        01        00        01</pre><p name="bc8e" id="bc8e" class="graf graf--p graf-after--pre">For the fifth status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it, because the 2BC needs to be confirmed twice,</p><pre name="ca4e" id="ca4e" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        11        01        01        00        10</pre><p name="e544" id="e544" class="graf graf--p graf-after--pre">For the 6th status (T), we will <strong class="markup--strong markup--p-strong">predict</strong> it correctly,</p><pre name="215b" id="215b" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        11        01        01        00        11</pre><p name="63d6" id="63d6" class="graf graf--p graf-after--pre">For the 7th~17th status (T), we will <strong class="markup--strong markup--p-strong">predict</strong> them correctly.</p><ul class="postList"><li name="a1f4" id="a1f4" class="graf graf--li graf-after--p">the second <code class="markup--code markup--li-code">N {T}*16</code> iteration,</li></ul><p name="ceec" id="ceec" class="graf graf--p graf-after--li">For the 18th status (N), we will mispredict it,</p><pre name="3d3f" id="3d3f" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        11        01        01        00        10</pre><p name="4985" id="4985" class="graf graf--p graf-after--pre">For the 19th status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it,</p><pre name="0601" id="0601" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        10        01        01        01        10</pre><p name="990d" id="990d" class="graf graf--p graf-after--pre">For the 20th status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it, because the 2BC needs to be confirmed twice,</p><pre name="2729" id="2729" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        01        01        10        01        10</pre><p name="75f8" id="75f8" class="graf graf--p graf-after--pre">For the 21st status (T), we will <strong class="markup--strong markup--p-strong">predict</strong> it correctly,</p><pre name="9441" id="9441" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        11        01        10        01        11</pre><p name="503f" id="503f" class="graf graf--p graf-after--pre">For the 22nd~34th status (T), we will <strong class="markup--strong markup--p-strong">predict</strong> them correctly.</p><ul class="postList"><li name="32a5" id="32a5" class="graf graf--li graf-after--p">the third <code class="markup--code markup--li-code">N {T}*16</code> iteration,</li></ul><p name="4252" id="4252" class="graf graf--p graf-after--li">For the 35th status (N), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it,</p><pre name="d277" id="d277" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        11        01        10        01        10</pre><p name="5d5d" id="5d5d" class="graf graf--p graf-after--pre">For the 36th status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it, because the 2BC needs to be confirmed twice,</p><pre name="bd8d" id="bd8d" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        10        01        10        10        10</pre><p name="47de" id="47de" class="graf graf--p graf-after--pre">For the 36th status (T), we will <strong class="markup--strong markup--p-strong">predict</strong> it correctly,</p><pre name="1bbd" id="1bbd" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        01        01        11        10        10</pre><ul class="postList"><li name="6a47" id="6a47" class="graf graf--li graf-after--pre">For the other iterations, we will only mispredict the Not-taken branch (the first branch in each iteration).</li></ul><p name="35d8" id="35d8" class="graf graf--p graf-after--li">So in summary, the number of mispredictions, in this case, should be 22, because,</p><pre name="5e47" id="5e47" class="graf graf--pre graf-after--p">|   1-st iter   | | 2-nd iter | | 3rditer | |  other 13 iters |<br>N T T T T T ... T N T T T ... T N T T ... T N T ... T N T ... T<br>o x x x x o ... o x x x o ... o x x o ... o x o ... o x o ... o</pre><p name="108a" id="108a" class="graf graf--p graf-after--pre">So the number of mispredictions for the entry <code class="markup--code markup--p-code">111</code> should be <code class="markup--code markup--p-code">4+3+2+1*13 = 22</code>.</p><p name="85bb" id="85bb" class="graf graf--p graf-after--p">Secondly, let’s talk about the <code class="markup--code markup--p-code">001</code> entry, it has the pattern of,</p><pre name="1f11" id="1f11" class="graf graf--pre graf-after--p">{{N}*16 T T}*16</pre><ul class="postList"><li name="7832" id="7832" class="graf graf--li graf-after--pre">the first <code class="markup--code markup--li-code">{N}*16 T T</code> iteration,</li></ul><p name="fda1" id="fda1" class="graf graf--p graf-after--li">For the 1st status (N), we will <strong class="markup--strong markup--p-strong">predict</strong> it correctly,</p><pre name="bb6d" id="bb6d" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        00        00        00        00        00</pre><p name="7b50" id="7b50" class="graf graf--p graf-after--pre">For the 2nd status (N), we will <strong class="markup--strong markup--p-strong">predict</strong> it correctly,</p><pre name="a1fd" id="a1fd" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        00        00        00        00        00</pre><p name="a610" id="a610" class="graf graf--p graf-after--pre">For the 3rd status (N), we will <strong class="markup--strong markup--p-strong">predict</strong> it correctly,</p><pre name="89b1" id="89b1" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        00        00        00        00        00</pre><p name="f3f7" id="f3f7" class="graf graf--p graf-after--pre">For the 4th~16th status (N), we will <strong class="markup--strong markup--p-strong">predict</strong> them correctly.</p><p name="0fc4" id="0fc4" class="graf graf--p graf-after--p">For the 17th status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it,</p><pre name="210e" id="210e" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        00        01        00        00        00</pre><p name="7180" id="7180" class="graf graf--p graf-after--pre">For the 18th status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it,</p><pre name="b011" id="b011" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        01        01        01        00        00</pre><ul class="postList"><li name="e23f" id="e23f" class="graf graf--li graf-after--pre">the second <code class="markup--code markup--li-code">{N}*16 T T</code> iteration,</li></ul><p name="5714" id="5714" class="graf graf--p graf-after--li">For the 19th status (N), we will <strong class="markup--strong markup--p-strong">predict</strong> it correctly,</p><pre name="4dfd" id="4dfd" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        11        01        01        00        00</pre><p name="647e" id="647e" class="graf graf--p graf-after--pre">For the 20th status (N), we will <strong class="markup--strong markup--p-strong">predict</strong> it correctly,</p><pre name="655a" id="655a" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        10        01        01        00        00</pre><p name="1dce" id="1dce" class="graf graf--p graf-after--pre">For the 21st status (N), we will <strong class="markup--strong markup--p-strong">predict</strong> it correctly,</p><pre name="749b" id="749b" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        00        00        01        00        00</pre><p name="8e75" id="8e75" class="graf graf--p graf-after--pre">For the 22nd~34th status (N), we will <strong class="markup--strong markup--p-strong">predict</strong> them correctly.</p><p name="98c8" id="98c8" class="graf graf--p graf-after--p">For the 35th status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it,</p><pre name="8310" id="8310" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        00        01        01        00        00</pre><p name="cedb" id="cedb" class="graf graf--p graf-after--pre">For the 36th status (T), we will <strong class="markup--strong markup--p-strong">mispredict</strong> it, because the 2BC needs to be confirmed twice,</p><pre name="7fd8" id="7fd8" class="graf graf--pre graf-after--p">INDEX      Hist      2BC-0     2BC-1     2BC-2     2BC-3<br>-----      -----     -----     -----     -----     -----<br>000        00        00        00        00        00<br>001        00        00        00        00        00<br>010        00        00        00        00        00<br>011        00        00        00        00        00<br>100        00        00        00        00        00<br>101        00        00        00        00        00<br>110        00        00        00        00        00<br>111        01        01        10        00        00</pre><ul class="postList"><li name="5699" id="5699" class="graf graf--li graf-after--pre">For the other iterations, we will only mispredict the first Taken branch in each iteration.</li></ul><p name="f8ca" id="f8ca" class="graf graf--p graf-after--li">Thus, in summary, we have,</p><pre name="e16d" id="e16d" class="graf graf--pre graf-after--p">|1-st iter| |2-nd iter| |        other 14 iters       |<br>N ... N T T N ... N T T N ... N T T ... ... N ... N T T<br>o ... o x x o ... o x x o ... o x o ... ... o ... o x o</pre><p name="46b8" id="46b8" class="graf graf--p graf-after--pre">so the number of mispredictions for the <code class="markup--code markup--p-code">001</code> entry should be <code class="markup--code markup--p-code">2*2 + 14 = 18</code>.</p><p name="8d47" id="8d47" class="graf graf--p graf-after--p">Finally, let’s talk about the <code class="markup--code markup--p-code">100</code> entry, the pattern should be,</p><pre name="4fed" id="4fed" class="graf graf--pre graf-after--p">{N T T T}*64</pre><p name="f7bf" id="f7bf" class="graf graf--p graf-after--pre">We have said that this is not exactly right because the sequence is not solid. In fact, the real pattern for this case should be,</p><pre name="cdb8" id="cdb8" class="graf graf--pre graf-after--p">{{N T T T}*4 {T T T N}*4 {T T N T}*4 {T N T T}*4}*4</pre><p name="114a" id="114a" class="graf graf--p graf-after--pre">Similarly (we are not going to write in details here), the number of mispredictions in the 1st iteration is 9, the number of mispredictions in the 2nd iteration is 5, the number of mispredictions in the 3rd iteration is 7, the number of mispredictions in the 4th iteration is 3, the number of mispredictions in the 5th iteration is 4. The other iterations are then going to loop from 5–7–3–4 until the end.</p><p name="ed93" id="ed93" class="graf graf--p graf-after--p">Then, in summary, the number of mispredictions for the <code class="markup--code markup--p-code">100</code> entry should be <code class="markup--code markup--p-code">9 + (5+7+3+4)*3 + (5+7+3) = 81</code>.</p><p name="8f66" id="8f66" class="graf graf--p graf-after--p">As a result, the overall misprediction for this case should be <code class="markup--code markup--p-code">22+18+81 = 121</code>.</p><p name="cd1d" id="cd1d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 3-2</strong>. (BTB Predictor)</p><p name="7524" id="7524" class="graf graf--p graf-after--p">Suppose we have a single-issue, statically-scheduled, deeply-pipelined processor executing a program of 1,000,000 instructions and 20% of them are branch instructions.</p><ul class="postList"><li name="626b" id="626b" class="graf graf--li graf-after--p">With a perfect BTB, all the branches are correctly predicted and there would be no stalls in the pipeline. The program would complete the program in 1 ms.</li><li name="a75e" id="a75e" class="graf graf--li graf-after--li">With an imperfect BTB, only 170,000 branch instructions are BTB hits (means that those branches do not have an entry in BTB) and 30,000 instructions are BTB misses (means that those branches do not have an entry in BTB). Within these 170,000 BTB hits, 150,000 are correctly predicted and 20,000 are mispredicted. Within these 30,000 BTB misses, 1/3 are branches not taken and the other 2/3 are branches taken. With this imperfect BTB, the overall execution time of the program is 1.8 ms.</li></ul><p name="53d5" id="53d5" class="graf graf--p graf-after--li">Assume that the processor makes <strong class="markup--strong markup--p-strong">no attempt to correct a mispredicted branch until the branch goes through the last stage of the pipeline</strong>. If needed, in the next cycle the fetch restarts from the first instruction that should execute after the branch. How many stages are there in the processor’s pipeline?</p><p name="312e" id="312e" class="graf graf--p graf-after--p">Ans:</p><p name="a6e9" id="a6e9" class="graf graf--p graf-after--p">There are only two kinds of branches we have to recover for an imperfect BTB, the BTB misses branches taken (20,000 instructions) and the BTB hits mispredictions (20,000 instructions). So the overall number of instructions that need to be recovered is 40,000.</p><p name="e6f3" id="e6f3" class="graf graf--p graf-after--p">For a perfect BTB, the processor takes N+1000000–1 to execute all the instructions, where N is the depth of the pipeline (because the pipeline has to be filled for the first instruction, it takes N cycles for the first instruction and 1 cycle for the rest of the instructions). Because as a rule of thumb, <code class="markup--code markup--p-code">N &lt;&lt; 1000000</code>, so we can neglect the impact of N.</p><p name="cbbd" id="cbbd" class="graf graf--p graf-after--p">For an imperfect BTB, the execution time is 1.8 ms. Because we have discussed that 1 ms can have 1,000,000 cycles, 1.8 ms is supposed to have 1,800,000 cycles. The 800,000 cycles difference between these two values is the overall penalty we pay for the recovery.</p><p name="3da0" id="3da0" class="graf graf--p graf-after--p">Note that the processor makes no attempt to correct a mispredicted branch until the branch goes through the last stage of the pipeline, this means that we have to flush all the stages in the pipeline. So the number of wasted cycles for each recovery is the depth of the pipeline.</p><p name="24fa" id="24fa" class="graf graf--p graf-after--p graf--trailing">Finally, the depth of the pipeline can be calculated by <code class="markup--code markup--p-code">800000/40000 = 20</code>.</p></div></div></section><section name="c83e" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="c818" id="c818" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">4. ILP, Instruction Scheduling, and Reorder Buffer</strong></p><p name="4776" id="4776" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Architectural Registers</strong></p><p name="0dfb" id="0dfb" class="graf graf--p graf-after--p">Architectural registers are registers that the programmers can access.</p><p name="239f" id="239f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Physical Registers</strong></p><p name="1ee4" id="1ee4" class="graf graf--p graf-after--p">Physical registers are all the places a value can be stored. This includes the reservation station (RS), reorder buffer (ROB), and etc.</p><p name="d68c" id="d68c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Register Allocation Table (RAT)</strong></p><p name="2981" id="2981" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">register allocation table (RAT)</strong> is a table that keeps track of which physical register is linked to which architecture register. The usage of RAT will eliminate the name dependencies.</p><p name="8cfd" id="8cfd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Register Renaming</strong></p><p name="1f86" id="1f86" class="graf graf--p graf-after--p">Register renaming is a technique that abstracts logical registers from physical registers.</p><p name="fd58" id="fd58" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Instruction Level Parallelism (ILP) Conditions</strong></p><ul class="postList"><li name="82a8" id="82a8" class="graf graf--li graf-after--p">the processor does the entire instruction (FDEMW) in 1 cycle</li><li name="1e2e" id="1e2e" class="graf graf--li graf-after--li">the processor can do any number of instructions in the same cycle, but it still has to obey the true dependencies</li></ul><p name="56f2" id="56f2" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) Issue</strong></p><p name="153f" id="153f" class="graf graf--p graf-after--p">Instruction exit the queue and go to either the reservation station (RS) or the PC adder.</p><p name="ceb0" id="ceb0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Dispatch</strong></p><p name="c685" id="c685" class="graf graf--p graf-after--p">Instruction exits RS and goes to either the adder or the multiplier (ALU) for execution.</p><p name="45bc" id="45bc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Write Result or Broadcast</strong></p><p name="b444" id="b444" class="graf graf--p graf-after--p">Instruction exits the adder or the multiplier (ALU) and is put on the bus CDB.</p><p name="bf4b" id="bf4b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Tomasulo’s Algorithm</strong></p><p name="0703" id="0703" class="graf graf--p graf-after--p">It determines which instructions have inputs ready for execution, and it supports the out-of-order execution.</p><p name="afde" id="afde" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) More than 1 Dispatch</strong></p><ul class="postList"><li name="5dc9" id="5dc9" class="graf graf--li graf-after--p">oldest</li><li name="0565" id="0565" class="graf graf--li graf-after--li">most dependencies (hard to implement)</li><li name="f445" id="f445" class="graf graf--li graf-after--li">random</li></ul><p name="3ebd" id="3ebd" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(11) More than 1 Broadcast</strong></p><ul class="postList"><li name="bcfb" id="bcfb" class="graf graf--li graf-after--p">separate bus (increase hardware needs)</li><li name="33d2" id="33d2" class="graf graf--li graf-after--li">priority to the slower unit (i.e. multiplication/divide)</li></ul><p name="934d" id="934d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(12) Stale Result</strong></p><p name="f599" id="f599" class="graf graf--p graf-after--p">A result is stale if it no longer has an entry in the RAT. Although a stale result may exist in the RS and can be broadcasted when the ALU finishes, the RAT is not altered because any future instructions will not use this value.</p><p name="fb05" id="fb05" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(13) Out-Of-Order (OOO) Exceptions</strong></p><p name="b248" id="b248" class="graf graf--p graf-after--p">The major drawback of Tomasulo’s Algorithm is the exceptions. The common exceptions are,</p><ul class="postList"><li name="a287" id="a287" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Divided by 0</strong></li></ul><p name="9c38" id="9c38" class="graf graf--p graf-after--li">When the division figures out that it is divided by 0, the register values are already changed by the out-of-order instructions. Then the values stored in the exception handler are not right and there is no way to proceed after handling the exception.</p><ul class="postList"><li name="1430" id="1430" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Page fault</strong></li></ul><p name="abd2" id="abd2" class="graf graf--p graf-after--li">If we page back from the disk and then go back to execute the load, some instructions that after the load instruction might have executed and there is no way to proceed.</p><ul class="postList"><li name="4cd2" id="4cd2" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Branch Mispredictions</strong></li></ul><p name="0121" id="0121" class="graf graf--p graf-after--li">When we finally figure out that we have taken the wrong branch, register values are already changed by the out-of-order instructions.</p><ul class="postList"><li name="48c8" id="48c8" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Phantom exceptions</strong></li></ul><p name="223e" id="223e" class="graf graf--p graf-after--li">If a branch is mispredicted and a number of instructions of this branch are executed before the misprediction is detected. It is possible to generate an exception within these executed instructions. While if we take the right branch, then this exception should not have occurred.</p><ul class="postList"><li name="28f2" id="28f2" class="graf graf--li graf-after--p">etc.</li></ul><p name="7b9c" id="7b9c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(14) Reorder Buffer (ROB)</strong></p><p name="366a" id="366a" class="graf graf--p graf-after--p">A reorder buffer is used in Tomasulo’s algorithm for <strong class="markup--strong markup--p-strong">avoiding the exceptions</strong> of the out-of-order instruction execution because it allows the instructions to be committed <strong class="markup--strong markup--p-strong">in-order</strong>. The reorder buffer is useful because it remembers the program order and keeps the result until it is safe to write them.</p><p name="066b" id="066b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(15) Time To Free RS</strong></p><ul class="postList"><li name="6f9a" id="6f9a" class="graf graf--li graf-after--p">For Tomasulo’s algorithm, the RS can only be freed after broadcasting</li><li name="9d62" id="9d62" class="graf graf--li graf-after--li">For ROB, the RS can be free earlier after dispatch because the broadcast will use the ROB name instead of the RS name</li></ul><p name="a59a" id="a59a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(16) Time to Commit</strong></p><p name="ac21" id="ac21" class="graf graf--p graf-after--p">Because the results in the ROB should be committed in order, a commit should satisfy the following 2 conditions,</p><ul class="postList"><li name="edad" id="edad" class="graf graf--li graf-after--p">All the previous instructions are committed</li><li name="dfd0" id="dfd0" class="graf graf--li graf-after--li">The present instruction has passed the writing stage</li></ul><p name="8ad1" id="8ad1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(16) Handling the Branch Misprediction Exception</strong></p><p name="733d" id="733d" class="graf graf--p graf-after--p">Instructions that come after the branches are no committed until the branch is committed. When a branch is mispredicted, we should then do the recovery,</p><ul class="postList"><li name="931c" id="931c" class="graf graf--li graf-after--p">flush ROB by set the issue pointer = the commit pointer</li><li name="0cb7" id="0cb7" class="graf graf--li graf-after--li">flush RS</li><li name="da27" id="da27" class="graf graf--li graf-after--li">flush RAT by pointing to the correct registers</li><li name="33fc" id="33fc" class="graf graf--li graf-after--li">fetch the correct instructions from the correct address</li></ul><p name="98d6" id="98d6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(17) Handling the OOO Instruction Exception</strong> (Page Fault and Divided by Zero)</p><p name="ec45" id="ec45" class="graf graf--p graf-after--p">When an exception occurs when the ROB has not committed, everything can be flushed and the exception handler can be loaded.</p><p name="d3a3" id="d3a3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(18) Handling the Phantom Exception</strong></p><p name="2418" id="2418" class="graf graf--p graf-after--p">Since nothing is committed after the branch, any misprediction results in a flush of the instructions, including any exceptions and a load of the correct instructions (Delay the exceptions until all the prior instructions are committed).</p><p name="47f8" id="47f8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(19) Unified RS</strong></p><p name="f1dd" id="f1dd" class="graf graf--p graf-after--p">Unified RS combines the RS for the Adder and the Multiplier for space efficiency but increases the complexity in hardware.</p><p name="e753" id="e753" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 4-1</strong>. (ILP and IPC) Specify TRUE or FALSE to all of the following statements,</p><ul class="postList"><li name="c24a" id="c24a" class="graf graf--li graf-after--p">In practice, ILP ≥ IPC.</li><li name="1f1f" id="1f1f" class="graf graf--li graf-after--li">IPC only depends on the processor.</li><li name="08c3" id="08c3" class="graf graf--li graf-after--li">ILP only depends on the program.</li><li name="a902" id="a902" class="graf graf--li graf-after--li">ILP is based on the dependencies of the program.</li><li name="78eb" id="78eb" class="graf graf--li graf-after--li">Structural dependencies do not apply to ILP.</li><li name="7347" id="7347" class="graf graf--li graf-after--li">ILP assumes perfect branch predictions.</li><li name="b1e9" id="b1e9" class="graf graf--li graf-after--li">ILP will be impacted by the RAW dependencies.</li><li name="81ac" id="81ac" class="graf graf--li graf-after--li">ILP should assume out-of-order execution.</li></ul><p name="a6fa" id="a6fa" class="graf graf--p graf-after--li">Ans:</p><pre name="6dc6" id="6dc6" class="graf graf--pre graf-after--p">T<br>F       // also depends on the program<br>T<br>T<br>T<br>T<br>T<br>T</pre><p name="ae06" id="ae06" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Example 4-2</strong>. (ILP and IPC) As we have known, the ILP available in many applications can be fairly high. Nevertheless, in practice, the IPC for a processor is hard to exploit ILP. Select all the factors that might limit the IPC,</p><ul class="postList"><li name="8098" id="8098" class="graf graf--li graf-after--p">In-order Execution</li><li name="99e6" id="99e6" class="graf graf--li graf-after--li">Narrow Issue</li><li name="863d" id="863d" class="graf graf--li graf-after--li">Window Size</li><li name="b240" id="b240" class="graf graf--li graf-after--li">Branch Mispredictions</li><li name="6d02" id="6d02" class="graf graf--li graf-after--li">Finite Registers</li><li name="3f05" id="3f05" class="graf graf--li graf-after--li">Imperfect Alias</li></ul><p name="605f" id="605f" class="graf graf--p graf-after--li">Ans:</p><p name="3dd8" id="3dd8" class="graf graf--p graf-after--p">All of the above.</p><p name="f771" id="f771" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 4-3</strong>. (Exception and ROB) Suppose we have the following instruction sequence and registers values,</p><figure name="15b7" id="15b7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*faL2oGqeQUXbdG_tFKh3IA.png" data-width="2010" data-height="730" src="https://cdn-images-1.medium.com/max/800/1*faL2oGqeQUXbdG_tFKh3IA.png"></figure><p name="89bf" id="89bf" class="graf graf--p graf-after--figure">We have the following assumptions for executing this program,</p><ul class="postList"><li name="6015" id="6015" class="graf graf--li graf-after--p">using Tomasulo’s algorithm</li><li name="e369" id="e369" class="graf graf--li graf-after--li">multiplication takes 4 cycles for execution</li><li name="8b53" id="8b53" class="graf graf--li graf-after--li">divide takes 8 cycles for execution</li><li name="e002" id="e002" class="graf graf--li graf-after--li">other instructions take 2 cycles for execution</li><li name="16a1" id="16a1" class="graf graf--li graf-after--li">results are written in the cycle after the execution</li><li name="ffd1" id="ffd1" class="graf graf--li graf-after--li">dependent instruction can begin execution after the results are written</li><li name="4f2f" id="4f2f" class="graf graf--li graf-after--li">1 ALU for MUL/DIV, and 2 reservation stations for MUL/DIV</li><li name="7ba3" id="7ba3" class="graf graf--li graf-after--li">1 ALU for ADD/SUB, and 4 reservation stations for ADD/SUB</li><li name="6803" id="6803" class="graf graf--li graf-after--li">More than 1 execute: older priority</li><li name="bbd0" id="bbd0" class="graf graf--li graf-after--li">More than 1 write to the bus: ADD/SUB over MUL/DIV</li><li name="4d9d" id="4d9d" class="graf graf--li graf-after--li">1 ALU can execute only 1 instruction in a cycle (no ALU pipeline)</li><li name="5a24" id="5a24" class="graf graf--li graf-after--li">only 1 instruction issuing per cycle</li><li name="0460" id="0460" class="graf graf--li graf-after--li">only 1 CDB for writing results</li></ul><p name="8726" id="8726" class="graf graf--p graf-after--li">a. Fill in the table with cycles.</p><p name="149f" id="149f" class="graf graf--p graf-after--p">b. Confirm that instruction I5 causes a <strong class="markup--strong markup--p-strong">divide-by-zero exception</strong>. Suppose this exception is detected at the very end of the <strong class="markup--strong markup--p-strong">6th (6/8) cycle</strong> of the DIV execution stage. And nothing can be done about it until the start of the next cycle. If the exception handler prints out the values of F1, F2, F3, and F4, what will be these values?</p><p name="e859" id="e859" class="graf graf--p graf-after--p">c. Suppose we add an 8-entry ROB to deal with this exception. Assume that no more than one instruction can be committed in each cycle and the instruction can only be committed in the cycle after writing the result. <strong class="markup--strong markup--p-strong">Remember that the RS is freed as soon as possible with a ROB.</strong> Fill in the following new table with cycles.</p><figure name="8af2" id="8af2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*VFtBnyNGa9rREXi_NUuT8Q.png" data-width="1702" data-height="736" src="https://cdn-images-1.medium.com/max/800/1*VFtBnyNGa9rREXi_NUuT8Q.png"></figure><p name="2879" id="2879" class="graf graf--p graf-after--figure">d. With the same assumption of question b but with this ROB, if the exception handler prints out the values of F1, F2, F3, and F4, what will be these values?</p><p name="22ec" id="22ec" class="graf graf--p graf-after--p">a. Ans:</p><p name="6c6b" id="6c6b" class="graf graf--p graf-after--p">First, we can issue the first 4 instructions and we have to wait for a MUL/DIV RS space for I5,</p><figure name="2572" id="2572" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YJi_DVlkYecVqrPCsXCX3g.png" data-width="2010" data-height="730" src="https://cdn-images-1.medium.com/max/800/1*YJi_DVlkYecVqrPCsXCX3g.png"></figure><p name="d4a1" id="d4a1" class="graf graf--p graf-after--figure">Then we can fill in the timing of these 4 instructions by the given information,</p><figure name="f060" id="f060" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cTk9_7pZ3AcbeC8FdCuxbg.png" data-width="2010" data-height="730" src="https://cdn-images-1.medium.com/max/800/1*cTk9_7pZ3AcbeC8FdCuxbg.png"></figure><p name="fe44" id="fe44" class="graf graf--p graf-after--figure">The next DIV can be issued in cycle 7 after instruction I1 writes the result and frees its RS, so</p><figure name="6129" id="6129" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*m_tUAfKzergbl4NnagEEbw.png" data-width="2010" data-height="730" src="https://cdn-images-1.medium.com/max/800/1*m_tUAfKzergbl4NnagEEbw.png"></figure><p name="9e2e" id="9e2e" class="graf graf--p graf-after--figure">Because I5 and I6 are both RAW dependent on I2, so they need to be executed in cycle 16. And also the instruction I7 depends on I5, so it needs to be executed in cycle 25,</p><figure name="0140" id="0140" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IwUyy4mw4AsPVoUstc_iHg.png" data-width="2010" data-height="730" src="https://cdn-images-1.medium.com/max/800/1*IwUyy4mw4AsPVoUstc_iHg.png"></figure><p name="6169" id="6169" class="graf graf--p graf-after--figure">The instruction I8 should wait for the MUL/DIV RS space after writing the result of I2, so it has to be issued in cycle 16,</p><figure name="07a8" id="07a8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*nUfrjMfPCHIgdRdYMqNYIw.png" data-width="2010" data-height="730" src="https://cdn-images-1.medium.com/max/800/1*nUfrjMfPCHIgdRdYMqNYIw.png"></figure><p name="d697" id="d697" class="graf graf--p graf-after--figure">And the final timing result should be,</p><figure name="ec56" id="ec56" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BbzZuTSP7YNFGr-rT0F6rQ.png" data-width="2010" data-height="730" src="https://cdn-images-1.medium.com/max/800/1*BbzZuTSP7YNFGr-rT0F6rQ.png"></figure><p name="e210" id="e210" class="graf graf--p graf-after--figure">b. Ans:</p><p name="3e75" id="3e75" class="graf graf--p graf-after--p">Note that the execution stage for I5 takes 8 cycles and it starts from the 16th cycle. Thus, this exception is detected in cycle 22 (16+6) and we should call the exception handler in cycle 23.</p><p name="bfe3" id="bfe3" class="graf graf--p graf-after--p">As we can be confirmed from this timing table, because of the OOO execution, the instruction I6 and I10 is already written even it is not safe. Thus, although the exception is caused in the I5 when the program finally detects this exception, the F1 ~ F4 is not the result of the I1 ~ I4.</p><p name="f14b" id="f14b" class="graf graf--p graf-after--p">So, after I1 ~ I4, the registers should have,</p><pre name="134b" id="134b" class="graf graf--pre graf-after--p">F1           F2           F3           F4<br>-------      -------      -------      -------<br>2            0            -2           0</pre><p name="b41f" id="b41f" class="graf graf--p graf-after--pre">Note that we can confirm that there will be a divide-by-zero exception.</p><p name="c7a9" id="c7a9" class="graf graf--p graf-after--p">Then after I6, the registers should have,</p><pre name="bb87" id="bb87" class="graf graf--pre graf-after--p">F1           F2           F3           F4<br>-------      -------      -------      -------<br>2            0            -2           0</pre><p name="311b" id="311b" class="graf graf--p graf-after--pre">After I10, the registers should have,</p><pre name="9ab5" id="9ab5" class="graf graf--pre graf-after--p">F1           F2           F3           F4<br>-------      -------      -------      -------<br>2            0            -2           -1</pre><p name="71f9" id="71f9" class="graf graf--p graf-after--pre">c. Ans:</p><figure name="2922" id="2922" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*od_HoldxevwITLwk53yE3Q.png" data-width="1702" data-height="736" src="https://cdn-images-1.medium.com/max/800/1*od_HoldxevwITLwk53yE3Q.png"></figure><p name="f7e9" id="f7e9" class="graf graf--p graf-after--figure">Note that I10 should be issued in cycle 17 because the ROB is full until cycle 17.</p><p name="249b" id="249b" class="graf graf--p graf-after--p">d. Ans:</p><p name="acff" id="acff" class="graf graf--p graf-after--p">The values of F1 to F4 will be,</p><pre name="e71e" id="e71e" class="graf graf--pre graf-after--p">F1           F2           F3           F4<br>-------      -------      -------      -------<br>2            0            -2           0</pre><p name="0ea5" id="0ea5" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Example 4-4</strong>. (Register Renaming)</p><p name="14b9" id="14b9" class="graf graf--p graf-after--p">Given the following set of instructions, use register renaming to eliminate the false dependencies.</p><pre name="c4c8" id="c4c8" class="graf graf--pre graf-after--p">ADD R1, R2, R3<br>SUB R3, R2, R1<br>MUL R1, R2, R3<br>DIV R2, R1, R3</pre><p name="ddc0" id="ddc0" class="graf graf--p graf-after--pre">Assume there are 7 possible locations for the registers; L1, L2, L3, L4, L5, L6, L7. The registers at the start of the instructions are assigned as L1 = R1, L2 = R2, L3 = R3.</p><p name="eae7" id="eae7" class="graf graf--p graf-after--p">Ans:</p><p name="0b6a" id="0b6a" class="graf graf--p graf-after--p">R1 will be rewritten by the first instruction, so we have to eliminate the possible previous WAR dependency by renaming <code class="markup--code markup--p-code">R1</code> to <code class="markup--code markup--p-code">L4</code>,</p><pre name="2a74" id="2a74" class="graf graf--pre graf-after--p">ADD L4, L2, L3</pre><p name="88ca" id="88ca" class="graf graf--p graf-after--pre">Continue and renaming the whole program,</p><pre name="7576" id="7576" class="graf graf--pre graf-after--p">ADD L4, L2, L3<br>SUB L5, L2, L4<br>MUL L6, L2, L5<br>DIV L7, L6, L5</pre><p name="083f" id="083f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Example 4-5</strong>. (ideal processor IPC and ILP)</p><p name="29a6" id="29a6" class="graf graf--p graf-after--p">Suppose we have the following instructions,</p><pre name="d152" id="d152" class="graf graf--pre graf-after--p">ADD R1, R2, R3<br>LD  R4, 0(R5)<br>SUB R7, R1, R9<br>MUL R5, R4, R4<br>SUB R1, R12, R10<br>ST  R14, 0(R13)<br>OR  R15, R14, R12</pre><p name="e0cc" id="e0cc" class="graf graf--p graf-after--pre">Assume that the processor can execute in any order that <strong class="markup--strong markup--p-strong">doesn’t violate true dependencies</strong> (means that we can do the register renaming), and all the instructions have <strong class="markup--strong markup--p-strong">1 cycle latencies</strong> (means that the whole any kinds of instruction will be finished in 1 cycle).</p><p name="512b" id="512b" class="graf graf--p graf-after--p">a. Suppose the processor’s ALU can execute <strong class="markup--strong markup--p-strong">any kinds</strong> of instructions in the fragment, and the processor can <strong class="markup--strong markup--p-strong">only execute up to two</strong> instructions in a cycle. Calculate the IPC.</p><p name="b7f5" id="b7f5" class="graf graf--p graf-after--p">b. Suppose the processor’s ALU can execute <strong class="markup--strong markup--p-strong">any kinds</strong> of instructions in the fragment, and the processor can <strong class="markup--strong markup--p-strong">execute up to four </strong>instructions in a cycle.</p><p name="8d0d" id="8d0d" class="graf graf--p graf-after--p">c. If we can <strong class="markup--strong markup--p-strong">not do the register renaming</strong> (means that we can not violate the data dependencies) based on some faults of the processor, with all the other features hold from question b. Note that the read and write to the same register can happen in one cycle. Will the IPC change? Explain why.</p><p name="565a" id="565a" class="graf graf--p graf-after--p">d. Calculate the ILP of this program.</p><p name="2272" id="2272" class="graf graf--p graf-after--p">a. Ans:</p><figure name="4d8a" id="4d8a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cRQthhZpXxEiyaPZjUa7jA.png" data-width="1960" data-height="546" src="https://cdn-images-1.medium.com/max/800/1*cRQthhZpXxEiyaPZjUa7jA.png"></figure><p name="13e9" id="13e9" class="graf graf--p graf-after--figure">Based on this table, the IPC is <code class="markup--code markup--p-code">7/4 = 1.75</code>.</p><p name="4132" id="4132" class="graf graf--p graf-after--p">b. Ans:</p><figure name="e39f" id="e39f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*2MNDNGpaGiWbO52ScCYcsA.png" data-width="1960" data-height="546" src="https://cdn-images-1.medium.com/max/800/1*2MNDNGpaGiWbO52ScCYcsA.png"></figure><p name="e357" id="e357" class="graf graf--p graf-after--figure">Based on this table, the IPC is <code class="markup--code markup--p-code">7/2 = 3.5</code>.</p><p name="8139" id="8139" class="graf graf--p graf-after--p">Note that we can execute <code class="markup--code markup--p-code">SUB R1, R12, R10</code> in the first cycle and then <code class="markup--code markup--p-code">SUB R7, R1, R9</code> in the second cycle without worrying about the WAR dependency because we have the register renaming.</p><p name="2db0" id="2db0" class="graf graf--p graf-after--p">c. Ans:</p><figure name="462d" id="462d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*u1iQ4JW9OZ3oeiWAMkCWxA.png" data-width="1960" data-height="546" src="https://cdn-images-1.medium.com/max/800/1*u1iQ4JW9OZ3oeiWAMkCWxA.png"></figure><p name="b403" id="b403" class="graf graf--p graf-after--figure">If we have to avoid all the data dependencies without register renaming, we need to execute <code class="markup--code markup--p-code">SUB R1, R12, R10</code> in the second cycle. Based on this table, the IPC is <code class="markup--code markup--p-code">7/2 = 3.5</code>. Because we still need 2 cycles to finish the execution, the IPC of this program won’t change.</p><p name="c614" id="c614" class="graf graf--p graf-after--p">d. Ans:</p><p name="c4db" id="c4db" class="graf graf--p graf-after--p">The ILP means an ideal processor that can do,</p><ul class="postList"><li name="dd79" id="dd79" class="graf graf--li graf-after--p">the processor does the entire instruction (FDEMW) in 1 cycle</li><li name="7017" id="7017" class="graf graf--li graf-after--li">the processor can do any number of instructions in the same cycle, but it still has to obey the true dependencies</li></ul><p name="085e" id="085e" class="graf graf--p graf-after--li">So then, we are going to have,</p><figure name="90fb" id="90fb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*c-B0DxPkvwykdhQLNJkjkg.png" data-width="1960" data-height="546" src="https://cdn-images-1.medium.com/max/800/1*c-B0DxPkvwykdhQLNJkjkg.png"></figure><p name="1c01" id="1c01" class="graf graf--p graf-after--figure">We can find out that even we can execute 5 instructions in the first cycle, we still need to have the second cycle because of the data dependency. Based on this table, the ILP of this program is <code class="markup--code markup--p-code">7/2 = 3.5</code>.</p><p name="2341" id="2341" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 4-6</strong>. (Tomasulo’s Algorithm)</p><p name="67a1" id="67a1" class="graf graf--p graf-after--p">Suppose we have a processor with dynamic scheduling with the following features,</p><ul class="postList"><li name="063c" id="063c" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">issue-bound fetch</strong> means that the operands are fetched during the instruction issuing</li><li name="9ee0" id="9ee0" class="graf graf--li graf-after--li">RS is freed <strong class="markup--strong markup--li-strong">at the beginning of</strong> the writing stage</li><li name="6c4d" id="6c4d" class="graf graf--li graf-after--li">an instruction can be executed in the cycle <strong class="markup--strong markup--li-strong">after</strong> its dependent instructions are written</li><li name="444f" id="444f" class="graf graf--li graf-after--li">1 ADD/SUB ALU, with 1 RS for this ALU</li><li name="47c0" id="47c0" class="graf graf--li graf-after--li">1 MUL/DIV ALU, with 1 RS for this ALU</li><li name="91ba" id="91ba" class="graf graf--li graf-after--li">1 LOAD/STORE ALU, with 1 RS for this ALU</li><li name="9bbf" id="9bbf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">out-of-order issue</strong> (no need to follow the instruction queue)</li><li name="7f81" id="7f81" class="graf graf--li graf-after--li">out-of-order execution</li><li name="5d35" id="5d35" class="graf graf--li graf-after--li">no data forwarding</li><li name="66a9" id="66a9" class="graf graf--li graf-after--li">Load/Store takes 2 cycles</li><li name="e060" id="e060" class="graf graf--li graf-after--li">Add/Sub takes 1 cycle</li><li name="f92d" id="f92d" class="graf graf--li graf-after--li">MUL takes 2 cycles</li><li name="f231" id="f231" class="graf graf--li graf-after--li">DIV takes 4 cycles</li></ul><p name="ed5c" id="ed5c" class="graf graf--p graf-after--li">Suppose we have the following instruction sequence. Fill in the timing table.</p><figure name="2851" id="2851" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3iG1BZJLFUqIfxrz9tLoEQ.png" data-width="1600" data-height="476" src="https://cdn-images-1.medium.com/max/800/1*3iG1BZJLFUqIfxrz9tLoEQ.png"></figure><p name="cb28" id="cb28" class="graf graf--p graf-after--figure">Ans:</p><p name="a512" id="a512" class="graf graf--p graf-after--p">We have to be careful about the out-of-order issuing, and this means that we can issue more than 1 instruction in the first cycle. The final result should be,</p><figure name="53c8" id="53c8" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*GFcSheuKWTQW-8PiSocVkQ.png" data-width="1600" data-height="476" src="https://cdn-images-1.medium.com/max/800/1*GFcSheuKWTQW-8PiSocVkQ.png"></figure></div></div></section><section name="bb35" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="5326" id="5326" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">5. Memory Ordering, Compiler ILP, and VLIW</strong></p><p name="ec2a" id="ec2a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Load-Store Queue (LSQ)</strong></p><p name="80aa" id="80aa" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">load-store queue (LSQ)</strong> is the structure that stores the data needed to read/write from/to the memory at commit <strong class="markup--strong markup--p-strong">in order</strong>.</p><p name="ae6b" id="ae6b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Store-to-Load Forwarding</strong></p><p name="6d8e" id="6d8e" class="graf graf--p graf-after--p">When a load command is put into the queue, the <strong class="markup--strong markup--p-strong">requested address of the load is compared to all previous store addresses in the queue</strong>. If there is a match, this value in the queue is used and eliminating the need to go to the memory.</p><p name="e8c7" id="e8c7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Missing Address Exception</strong></p><p name="af1e" id="af1e" class="graf graf--p graf-after--p">It is possible that some store addresses are not ready (i.e. because of the cache miss) when the load instructions check the address for the load-to-store forwarding. The most common way to deal with this is to go to the memory and load the data anyway. If we read a stale value, we have to do a recovery.</p><p name="3550" id="3550" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Compiler Technique #1: Tree Height Reduction</strong></p><p name="9b7a" id="9b7a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Tree height reduction</strong> is used for re-grouping an associative calculation to reduce the long dependency chain.</p><p name="9fe5" id="9fe5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Compiler Technique #2: Instruction Scheduling with Compiler</strong></p><p name="5232" id="5232" class="graf graf--p graf-after--p">The compiler can reschedule the code to fill in the stalls caused by dependencies. This is called <strong class="markup--strong markup--p-strong">instruction scheduling</strong>.</p><p name="d36a" id="d36a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Compiler Technique #3: If-Conversion</strong></p><p name="ba27" id="ba27" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">If-conversion</strong> means to execute both ways of a branch and finally choose between them. It allows for greater flexibility in the instruction scheduling.</p><p name="0710" id="0710" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Compiler Technique #4: Loop Unrolling</strong></p><p name="d6dd" id="d6dd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Loop unrolling</strong> creates a loop with fewer iterations by having each iteration do the work of <strong class="markup--strong markup--p-strong">two or more</strong> iterations.</p><p name="eecb" id="eecb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Compiler Technique #5: Function Inlining</strong></p><p name="16b6" id="16b6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Inlining</strong> involves removing the function call and replacing it with the body of the function.</p><p name="d899" id="d899" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Superscalar</strong></p><p name="d177" id="d177" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">superscalar</strong> processors are processors that can finish more than 1 instruction per cycle without long instruction words. The superscalar tries to FDEMW more than 1 instruction in each stage.</p><p name="8a6a" id="8a6a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) VLIW</strong></p><p name="6233" id="6233" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">very long instruction word (VLIW)</strong> processors load the commands into instruction words and split them if there are data dependencies. It may results in many NOPs in order to deal with the dependencies. This is especially useful for digital signal processing (DSP).</p><p name="4f76" id="4f76" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Example 5-1</strong>. (VLIW and Compiler ILP)</p><p name="bf0c" id="bf0c" class="graf graf--p graf-after--p">Suppose have a VLIW processor with 16 registers and the following units,</p><ul class="postList"><li name="581c" id="581c" class="graf graf--li graf-after--p">A branch unit (for branch and jump operations), with a one-cycle latency</li><li name="4a20" id="4a20" class="graf graf--li graf-after--li">A load/store (LW/SW operations) unit, with a six-cycle latency</li><li name="f57f" id="f57f" class="graf graf--li graf-after--li">Two arithmetic units for all other operations, with a two-cycle latency</li></ul><p name="5b72" id="5b72" class="graf graf--p graf-after--li">Each instruction specifies what each of these four units should be doing in each cycle. The processor does not check for dependencies nor does it stall to avoid violating program dependences the program must be written so that all dependencies are satisfied. For example, when a load-containing instruction is executed, the next five instructions cannot use that value.</p><p name="55e3" id="55e3" class="graf graf--p graf-after--p">If we execute the following loop (each row represents one VLIW instruction),</p><pre name="f8bb" id="f8bb" class="graf graf--pre graf-after--p">Loop:<br>    LW   R4, 0(R0)<br>    ADDI R0, R0, 4<br>    LW   R5, 0(R1)<br>    ADDI R1, R1, 4<br>    ADDI R2, R2, 4<br>    ADD  R6, R4, R5<br>    BNE  R2, R3, Loop<br>    SW   R6, -4(R2)</pre><p name="c103" id="c103" class="graf graf--p graf-after--pre">which performs element-wise addition of two 60-element vectors (whose address are in R0 in R1) into a third (address is in R2), where the end address of the result vector is in R3, and each element is a 32-bit integer:</p><figure name="8ab7" id="8ab7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0gQFs5tU9LrX6VT2JLzIAw.png" data-width="669" data-height="338" src="https://cdn-images-1.medium.com/max/800/1*0gQFs5tU9LrX6VT2JLzIAw.png"></figure><p name="18af" id="18af" class="graf graf--p graf-after--figure">Note how we increment the vector points while waiting for loads to complete. Also, note how each operation reads its source registers in the first cycle of its execution, so we can modify source registers in subsequent cycles. Each operation also writes its result registers in the last cycle, so we can read the old value of the register until then. Overall, this code takes ten cycles per element, for a total of 600 cycles.</p><p name="0187" id="0187" class="graf graf--p graf-after--p">We will unroll (unroll twice) so three old iterations are now one iteration, and then have the compiler schedule the instructions in that (new) loop. What does the new code look like (use only as many instruction slots in the table below as you need) and how many cycles does the entire 60-iteration (20 iterations after unrolling) loop take now?</p><figure name="8cc3" id="8cc3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vsro2glgecHdwaSNeTSgsg.png" data-width="669" data-height="591" src="https://cdn-images-1.medium.com/max/800/1*vsro2glgecHdwaSNeTSgsg.png"></figure><p name="3c7b" id="3c7b" class="graf graf--p graf-after--figure">Ans:</p><p name="0aaf" id="0aaf" class="graf graf--p graf-after--p">The C code for this program is,</p><pre name="ad8b" id="ad8b" class="graf graf--pre graf-after--p">v = a + 60;<br>while (a != v) {<br>    c[i] = a[i] + b[i];<br>    i++;<br>}</pre><p name="0d19" id="0d19" class="graf graf--p graf-after--pre">If we unrolling twice, the C code should be,</p><pre name="51cc" id="51cc" class="graf graf--pre graf-after--p">v = a + 60;<br>while (a != v) {<br>    c[i] = a[i] + b[i];<br>    c[i+1] = a[i+1] + b[i+1];<br>    c[i+2] = a[i+2] + b[i+2];<br>    i += 3;<br>}</pre><p name="d5dd" id="d5dd" class="graf graf--p graf-after--pre">Then the assembly code should be,</p><pre name="ba69" id="ba69" class="graf graf--pre graf-after--p">Loop:<br>    LW   R4, 0(R0)<br>    ADDI R2, R2, 12<br>    LW   R5, 0(R1)<br>    LW   R7, 4(R0)<br>    LW   R8, 4(R1)<br>    ADDI R0, R0, 12<br>    ADDI R1, R1, 12<br>    LW   R10, 8(R0)<br>    LW   R11, 8(R1)<br>    ADD  R6, R4, R5<br>    SW   R6, -12(R2)<br>    ADD  R9, R7, R8<br>    SW   R9, -8(R2)<br>    ADD  R12, R10, R11<br>    BNE  R2, R3, Loop<br>    SW   R12, -4(R2)</pre><p name="3d20" id="3d20" class="graf graf--p graf-after--pre">We can write the result in the table as,</p><figure name="5a40" id="5a40" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*PBaxa_lDc-_qHVBg_eCftQ.png" data-width="713" data-height="705" src="https://cdn-images-1.medium.com/max/800/1*PBaxa_lDc-_qHVBg_eCftQ.png"></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/19748900b111"><time class="dt-published" datetime="2021-02-25T13:28:54.765Z">February 25, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-21-midterm-review-19748900b111" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>