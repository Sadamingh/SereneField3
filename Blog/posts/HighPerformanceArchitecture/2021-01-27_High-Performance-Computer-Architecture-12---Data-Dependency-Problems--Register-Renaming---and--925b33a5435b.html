<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 12 | Data Dependency Problems, Register Renaming,  and…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 12 | Data Dependency Problems, Register Renaming,  and…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="67cf" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2f5b" id="2f5b" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 12 | <strong class="markup--strong markup--h3-strong">Data Dependency Problems, Register Renaming, and Instruction Level Parallelism</strong></h3><figure name="a7c0" id="a7c0" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*NFULhpAeY4VVVoLD.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*NFULhpAeY4VVVoLD.png"></figure><ol class="postList"><li name="7984" id="7984" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Data Dependency Problems</strong></li></ol><p name="96ae" id="96ae" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Recall: Problems for Data Dependencies</strong></p><p name="d00a" id="d00a" class="graf graf--p graf-after--p">Branch prediction and if-conversion help us eliminate most of the pipeline problems caused by hazards. But data dependencies can also prevent us from finishing <code class="markup--code markup--p-code">1</code> instruction per cycle. So now we are going to discuss what can we do about data dependencies and why we stop at only 1 instruction per cycle.</p><p name="747c" id="747c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Recall: Ideal Condition</strong></p><p name="1f96" id="1f96" class="graf graf--p graf-after--p">Suppose we have infinite instructions that do not have any data dependency or control dependencies. When we run them simultaneously in a 5-stage pipeline, then all of them can be finished within 5 stages.</p><figure name="fd49" id="fd49" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*8iovJJn16W5RabutNRcCZw.png" data-width="1794" data-height="362" src="https://cdn-images-1.medium.com/max/800/1*8iovJJn16W5RabutNRcCZw.png"></figure><p name="4238" id="4238" class="graf graf--p graf-after--figure">Thus, the CPI for this is <code class="markup--code markup--p-code">CPI = 5/∞ = 0</code> and that’s really wonderful. However, in reality, because we have finite registers, that means we must reuse (read/write) some of them in order to execute all the instructions and this causes data dependencies. The problem will be caused if we read a value from the register before it is written by the last instruction. So the CPI can not be 0 in practice.</p><p name="90cd" id="90cd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Recall: Forwarding</strong></p><p name="5978" id="5978" class="graf graf--p graf-after--p">We have seen the problem of reading a value from the register before it is written by the last instruction (<strong class="markup--strong markup--p-strong">RAW data dependency</strong>). Recall that the <strong class="markup--strong markup--p-strong">forwarding</strong> is defined as that we can directly use the result from ALU or some other stage instead of waiting for the writing stage. Suppose we have two instructions <code class="markup--code markup--p-code">I1</code> and <code class="markup--code markup--p-code">I2</code>, then the forwarding would work if <code class="markup--code markup--p-code">I1</code> reaches the executing stage (ALU stage) in the first place and then <code class="markup--code markup--p-code">I2</code> reaches the executing stage in the next cycle.</p><p name="0af0" id="0af0" class="graf graf--p graf-after--p">Let’s now imagine that if <code class="markup--code markup--p-code">I1</code> and <code class="markup--code markup--p-code">I2</code> works simultaneously on a pipeline. If they execute at the same time, the forwarding no longer works! In order to make this work, we have to <strong class="markup--strong markup--p-strong">stall</strong> the <code class="markup--code markup--p-code">I2</code> for 1 cycle so that the forwarding works for <code class="markup--code markup--p-code">I2</code> because it will be executed after <code class="markup--code markup--p-code">I1</code> is executed.</p><p name="ccf9" id="ccf9" class="graf graf--p graf-after--p">Suppose we run five instructions simultaneously in a 5-stage pipeline, and the instruction I2 has to be stalled for 1 cycle because of the forwarding. Regardless of the initial filling problem of this pipeline, the overall CPI of these 5 instructions is <code class="markup--code markup--p-code">CPI = 2/5 = 0.4</code>.</p><p name="2ce4" id="2ce4" class="graf graf--p graf-after--p">So even the <strong class="markup--strong markup--p-strong">ideal processor</strong> that can execute any number of instructions per cycle (like infinite), it still has to obey the RAW dependencies.</p><p name="c3c4" id="c3c4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Forwarding: An Example</strong></p><p name="a480" id="a480" class="graf graf--p graf-after--p">Suppose we have 5 instruction <code class="markup--code markup--p-code">I1</code> to <code class="markup--code markup--p-code">I5</code>.</p><p name="a709" id="a709" class="graf graf--p graf-after--p">If <code class="markup--code markup--p-code">I2</code> is RAW dep. to <code class="markup--code markup--p-code">I1</code>, <code class="markup--code markup--p-code">I4</code> is RAW dep. to <code class="markup--code markup--p-code">I3</code>, and <code class="markup--code markup--p-code">I5</code> is RAW dep. to <code class="markup--code markup--p-code">I4</code>. Regardless of the initial filling problem of this pipeline, the overall CPI is supposed to be <code class="markup--code markup--p-code">CPI = 3/5 = 0.6</code>.</p><p name="0016" id="0016" class="graf graf--p graf-after--p">If <code class="markup--code markup--p-code">I2</code> is RAW dep. to <code class="markup--code markup--p-code">I1</code>, <code class="markup--code markup--p-code">I3</code> is RAW dep. to <code class="markup--code markup--p-code">I2</code>, <code class="markup--code markup--p-code">I4</code> is RAW dep. to <code class="markup--code markup--p-code">I3</code>, and <code class="markup--code markup--p-code">I5</code> is RAW dep. to <code class="markup--code markup--p-code">I4</code>. Regardless of the initial filling problem of this pipeline, the overall CPI is supposed to be <code class="markup--code markup--p-code">CPI = 5/5 = 1</code>.</p><p name="5396" id="5396" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) WAW Dependencies Problems</strong></p><p name="f295" id="f295" class="graf graf--p graf-after--p">Even though the WAW data dependency doesn’t seem to be as serious as the RAW dependency, it can be a problem especially when two writing instructions executing simultaneously.</p><p name="1b88" id="1b88" class="graf graf--p graf-after--p">Let’s imagine a situation of 5 instructions. Suppose both <code class="markup--code markup--p-code">I2</code> and <code class="markup--code markup--p-code">I5</code> is going to write the register R4 and <code class="markup--code markup--p-code">I2</code> has a RAW dependency to <code class="markup--code markup--p-code">I1</code>. Then I2 should be stalled by 1 cycle because it needs to wait for the result of <code class="markup--code markup--p-code">I1</code> by forwarding. Because all these instructions are running simultaneously at the beginning, then <code class="markup--code markup--p-code">I5</code> will write R4 first and then the value of R4 will be replaced by the result of <code class="markup--code markup--p-code">I2</code> in the next cycle. However, this is not the right order because we want to keep the result of <code class="markup--code markup--p-code">I5</code> in R4.</p><p name="d5ea" id="d5ea" class="graf graf--p graf-after--p">In order to maintain the correct order of the <code class="markup--code markup--p-code">I2</code> and <code class="markup--code markup--p-code">I5</code>, two stalls have to be inserted before the writing stage for <code class="markup--code markup--p-code">I5</code>. Then the R4 will be firstly written by <code class="markup--code markup--p-code">I2</code> and then be written by <code class="markup--code markup--p-code">I5</code>.</p><p name="6797" id="6797" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) True Dependencies Vs. False Dependencies</strong></p><p name="ef6a" id="ef6a" class="graf graf--p graf-after--p">We have talked about the <strong class="markup--strong markup--p-strong">true dependencies</strong> (RAW) and the <strong class="markup--strong markup--p-strong">false (name) dependencies</strong> (WAW or WAR). The true dependencies are called so because we actually have to obey them in order to compute the true values. In contrast, the false (name) dependencies are called so because there’s actually nothing fundamental about them. They are dependencies just because we are using the same register for two different results. If we can use another register to write a value, then there will be no dependency.</p><p name="0d86" id="0d86" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Removing False Dependencies #1: Duplicating Register Values</strong></p><p name="7d5e" id="7d5e" class="graf graf--p graf-after--p">One of the methods that can be used to remove the false dependencies is to duplicate the register values. The basic idea of duplication is to keep multiple versions of a register and find the <strong class="markup--strong markup--p-strong">latest</strong> version if an instruction reads from this register. The latest version means the <strong class="markup--strong markup--p-strong">first</strong> instruction that is writing to this register <strong class="markup--strong markup--p-strong">before</strong> our reading instruction.</p><p name="7444" id="7444" class="graf graf--p graf-after--p">Even though all the things will be correct for the false dependencies, it requires us to create multiple versions of each register that we wrote, and this can be really <strong class="markup--strong markup--p-strong">complicated</strong>.</p><p name="9b9b" id="9b9b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Removing False Dependencies #2: Register Renaming</strong></p><p name="f6b2" id="f6b2" class="graf graf--p graf-after--p">The register renaming is another scheme that can provide relief from false dependencies but in a way that is more <strong class="markup--strong markup--p-strong">manageable</strong> compared with duplications. Register renaming separates the concept of registers to architecture registers and physical registers,</p><ul class="postList"><li name="5843" id="5843" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Architecture registers</strong>: the registers that the programmers and the compilers use</li><li name="e03b" id="e03b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Physical registers</strong>: the physical registers that we actually put the value in</li></ul><p name="0093" id="0093" class="graf graf--p graf-after--li">As the processor reads the instructions and figures out which registers (architecture register) they are using, it also does the register renaming, and this means that it <strong class="markup--strong markup--p-strong">rewrites</strong> the program to the physical registers. To implement this renaming feature, it uses a table called <strong class="markup--strong markup--p-strong">register allocate table</strong> (aka. <strong class="markup--strong markup--p-strong">RAT</strong>).</p><p name="99b2" id="99b2" class="graf graf--p graf-after--p">The RAT is a table that shows which physical register has value for which architecture register. So for each of the architecture registers, there will be a corresponding entry in this table and it will say what is the current location in the physical registers where the value for that architecture register can be found.</p><p name="e17b" id="e17b" class="graf graf--p graf-after--p">So why it works? Let’s see an example here. Suppose we have the following code,</p><pre name="49d9" id="49d9" class="graf graf--pre graf-after--p">I1: ADD R1, R2, R3<br>I2: SUB R4, R1, R5<br>I3: XOR R6, R7, R8<br>I4: MUL R5, R8, R9<br>I5: ADD R4, R8, R9</pre><p name="7873" id="7873" class="graf graf--p graf-after--pre">And we also have a RAT on which <code class="markup--code markup--p-code">P1</code>, <code class="markup--code markup--p-code">P2</code> … means the physical registers we have. In the starting state, architecture registers <code class="markup--code markup--p-code">R1</code> to <code class="markup--code markup--p-code">R16</code> (say we have 16 registers) are mapped to <code class="markup--code markup--p-code">P1</code> to <code class="markup--code markup--p-code">P16</code> as follows,</p><figure name="dd9b" id="dd9b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NO8I8MpxZDv666-bZ3daoA.png" data-width="1474" data-height="592" src="https://cdn-images-1.medium.com/max/800/1*NO8I8MpxZDv666-bZ3daoA.png"></figure><p name="ef83" id="ef83" class="graf graf--p graf-after--figure">The renaming means that the processor has to rewrite the origin assembly program so that they will be using the physical registers. Because we have more than 16 physical registers, we can allocate more physical registers to the same architecture register. Thus, there will not be any register reusing problems for false dependencies. The code should be rewritten to,</p><pre name="a4d1" id="a4d1" class="graf graf--pre graf-after--p">I1: ADD P17, P2, P3<br>I2: SUB P18, P17, P5<br>I3: XOR R19, P7, P8<br>I4: MUL R20, P8, P9<br>I5: ADD R21, P8, P9</pre><p name="7107" id="7107" class="graf graf--p graf-after--pre">So the final RAT should be,</p><figure name="0d68" id="0d68" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*RvStaGc2ZTZkwOc2pfRhew.png" data-width="1918" data-height="824" src="https://cdn-images-1.medium.com/max/800/1*RvStaGc2ZTZkwOc2pfRhew.png"></figure><p name="0df0" id="0df0" class="graf graf--p graf-after--figure">You should be able to find out that all the false dependencies no longer exist in this program. However, all the true dependencies are maintained even after the renaming.</p><p name="da5b" id="da5b" class="graf graf--p graf-after--p">For our origin program, if we run these 5 instructions simultaneously, <code class="markup--code markup--p-code">I2</code> is RAW dep. to <code class="markup--code markup--p-code">I1</code>, <code class="markup--code markup--p-code">I4</code> is WAR dep. to <code class="markup--code markup--p-code">I2</code>, <code class="markup--code markup--p-code">I5</code> is WAW dep. to <code class="markup--code markup--p-code">I2</code>. Thus, <code class="markup--code markup--p-code">I2</code> should be one cycle after <code class="markup--code markup--p-code">I1</code>, <code class="markup--code markup--p-code">I4</code> should be one cycle after <code class="markup--code markup--p-code">I2</code>, and <code class="markup--code markup--p-code">I5</code> should be one cycle after <code class="markup--code markup--p-code">I2</code>. Thus, in total there will be 3 cycles and the CPI is <code class="markup--code markup--p-code">CPI = 3/5 = 0.6 cycle/inst</code>.</p><p name="90a3" id="90a3" class="graf graf--p graf-after--p">For the program after renaming, if we run these 5 instructions simultaneously, although <code class="markup--code markup--p-code">I2</code> is still RAW dep. to <code class="markup--code markup--p-code">I1</code>, there will be no more false dependencies so that <code class="markup--code markup--p-code">I1</code>, <code class="markup--code markup--p-code">I3</code>, <code class="markup--code markup--p-code">I4</code>, <code class="markup--code markup--p-code">I5</code> can be executed at the same time. Thus, in total there will be 2 cycles and the CPI is <code class="markup--code markup--p-code">CPI = 2/5 = 0.4 cycle/inst</code>.</p><p name="eea0" id="eea0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Instruction Level Parallelism (ILP)</strong></p><p name="c31f" id="c31f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Instruction Level Parallelism</strong></p><p name="01f8" id="01f8" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">instruction-level parallelism (ILP)</strong> can be actually defined as the <strong class="markup--strong markup--p-strong">instruction per cycle (IPC)</strong> for an <strong class="markup--strong markup--p-strong">ideal</strong> processor. This ideal processor must have two properties,</p><ul class="postList"><li name="b901" id="b901" class="graf graf--li graf-after--p">the processor does the entire instruction (FDEMW) in 1 cycle</li><li name="f5b5" id="f5b5" class="graf graf--li graf-after--li">the processor can do any number of instructions in the same cycle, but it still has to obey the true dependencies</li></ul><p name="26c8" id="26c8" class="graf graf--p graf-after--li">So the conclusion is that the ILP is a property of the program and we can calculate with the assumption of an ideal processor. The processor, however, doesn&#39;t matter for ILP in any cases.</p><p name="0999" id="0999" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Steps for Calculating the ILP</strong></p><p name="33f4" id="33f4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 1. Register renaming</strong>: rename all the registers</p><p name="c4f0" id="c4f0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 2. Execute</strong>: In the first cycle, we have instructions that don’t depend on anything. In the second cycle, we have the instructions that depend only on the results from the first cycle, and so on. And finally, we can figure out how many cycles we need for this program.</p><p name="1888" id="1888" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 3. Calculate</strong>: thus the ILP can be calculated by <code class="markup--code markup--p-code">ILP = IPC = # of instructions / # of cycles</code></p><p name="5f33" id="5f33" class="graf graf--p graf-after--p">In practice, we can save our time of calculation by counting only the true dependencies of the original program so that we don’t have to get the program after renaming while calculating.</p><p name="21b7" id="21b7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) ILP: An Example</strong></p><p name="9622" id="9622" class="graf graf--p graf-after--p">Suppose we have the following program after renaming,</p><pre name="9fc4" id="9fc4" class="graf graf--pre graf-after--p">ADD P10, P2, P3<br>XOR P6, P7, P8<br>MUL P5, P8, P9<br>ADD P4, P8, P9<br>SUB P11, P10, P5</pre><p name="f8db" id="f8db" class="graf graf--p graf-after--pre">then we have the following true dependencies of <code class="markup--code markup--p-code">I5</code> depend on both <code class="markup--code markup--p-code">I1</code> and <code class="markup--code markup--p-code">I3</code>,</p><figure name="3444" id="3444" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OKjV550TMi8cF8UbmuR58A.png" data-width="1612" data-height="294" src="https://cdn-images-1.medium.com/max/800/1*OKjV550TMi8cF8UbmuR58A.png"></figure><p name="34a3" id="34a3" class="graf graf--p graf-after--figure">So we can figure out that we need 2 cycles for this program and the ILP should be <code class="markup--code markup--p-code">ILP = 5/2 = 2.5</code>.</p><p name="1df9" id="1df9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) ILP with Structural Dependencies</strong></p><p name="1425" id="1425" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">structural dependencies</strong> occur when we don’t have enough hardware to do things in the same cycle. However, for the ILP, we are assuming that we have <strong class="markup--strong markup--p-strong">ideal</strong> hardware that can do any number of instructions in the same cycle. So the answer is that there will be <strong class="markup--strong markup--p-strong">NO</strong> structural dependencies for the ILP. So any instructions that could possibly be executed in the same cycle will be executed in the same cycle.</p><p name="4710" id="4710" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) ILP with Control Dependencies</strong></p><p name="1631" id="1631" class="graf graf--p graf-after--p">For the control dependencies, we assume we have <strong class="markup--strong markup--p-strong">perfect same-cycle branch prediction </strong>meaning that the branches are successfully predicted in the same cycle when we fetch them. Thus, we are supposed to see all correct predictions after the branch in the same cycle.</p><p name="564f" id="564f" class="graf graf--p graf-after--p">Now let’s see an example. Suppose we have the following program,</p><pre name="dff7" id="dff7" class="graf graf--pre graf-after--p">ADD R1, R2, R3<br>MUL R1, R1, R1<br>BNE R5, R1, Label<br>ADD R5, R1, R2<br>...<br>Label:<br>   MUL R5, R7, R8</pre><p name="8818" id="8818" class="graf graf--p graf-after--pre">We can know that the <code class="markup--code markup--p-code">I2</code> is RAW dep. to <code class="markup--code markup--p-code">I1</code>, <code class="markup--code markup--p-code">I3</code> is Raw dep to <code class="markup--code markup--p-code">I2</code>. Suppose the branch will work for us, then based on the perfect same-cycle branch prediction,<strong class="markup--strong markup--p-strong"> </strong>the instruction <code class="markup--code markup--p-code">MUL R5, R7, R8</code> will be executed in the first cycle. So,</p><figure name="5c23" id="5c23" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*94-El-lN52JP2BXN4FeUlw.png" data-width="1998" data-height="468" src="https://cdn-images-1.medium.com/max/800/1*94-El-lN52JP2BXN4FeUlw.png"></figure><p name="b32c" id="b32c" class="graf graf--p graf-after--figure">Thus, even the branch instructions are delayed, but its control dependencies on that branch will have no impact on what ILP will be because we are assuming perfect branch prediction where all the branches in the program are perfectly predicted in the same cycle.</p><p name="1d84" id="1d84" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) ILP and IPC for Real Processors</strong></p><p name="7f2a" id="7f2a" class="graf graf--p graf-after--p">The ILP is the IPC for an ideal processor that has perfect branch predictions and only true data dependencies. In fact, because there are no ideal processors, the IPC of a program on a real processor is not equal to the ILP of this program.</p><p name="9758" id="9758" class="graf graf--p graf-after--p">Suppose we are given three processors, processor A, processor B, and processor C.</p><p name="94e6" id="94e6" class="graf graf--p graf-after--p">Processor A is,</p><ul class="postList"><li name="434d" id="434d" class="graf graf--li graf-after--p">an <strong class="markup--strong markup--li-strong">infinite-issue</strong> processor</li><li name="4ea3" id="4ea3" class="graf graf--li graf-after--li">with an <strong class="markup--strong markup--li-strong">out-of-order</strong> superscalar (means that it doesn&#39;t need to execute instructions exactly in the program order)</li><li name="68f5" id="68f5" class="graf graf--li graf-after--li">with 1 ALU for <code class="markup--code markup--li-code">MUL</code> and 2 ALUs for <code class="markup--code markup--li-code">ADD/SUB/XOR</code></li></ul><p name="7f91" id="7f91" class="graf graf--p graf-after--li">Processor B is,</p><ul class="postList"><li name="a24f" id="a24f" class="graf graf--li graf-after--p">a <strong class="markup--strong markup--li-strong">2-issue</strong> processor</li><li name="fb75" id="fb75" class="graf graf--li graf-after--li">with an <strong class="markup--strong markup--li-strong">out-of-order</strong> superscalar (means that it doesn’t need to execute instructions exactly in the program order)</li><li name="400d" id="400d" class="graf graf--li graf-after--li">with 1 ALU for <code class="markup--code markup--li-code">MUL</code> and 2 ALUs for <code class="markup--code markup--li-code">ADD/SUB/XOR</code></li></ul><p name="27c8" id="27c8" class="graf graf--p graf-after--li">Processor C is,</p><ul class="postList"><li name="88fa" id="88fa" class="graf graf--li graf-after--p">a <strong class="markup--strong markup--li-strong">2-issue</strong> processor</li><li name="e1a0" id="e1a0" class="graf graf--li graf-after--li">with an <strong class="markup--strong markup--li-strong">out-of-order</strong> superscalar (means that it doesn’t need to execute instructions exactly in the program order)</li><li name="c7a9" id="c7a9" class="graf graf--li graf-after--li">with 1 ALU for <code class="markup--code markup--li-code">MUL</code> and 1 ALUs for <code class="markup--code markup--li-code">ADD/SUB/XOR</code></li></ul><p name="d161" id="d161" class="graf graf--p graf-after--li">Processor D is,</p><ul class="postList"><li name="c82b" id="c82b" class="graf graf--li graf-after--p">a <strong class="markup--strong markup--li-strong">2-issue</strong> processor</li><li name="ee42" id="ee42" class="graf graf--li graf-after--li">with an <strong class="markup--strong markup--li-strong">in-order</strong> superscalar (means that it needs to execute instructions exactly in the program order)</li><li name="6991" id="6991" class="graf graf--li graf-after--li">with 1 ALU for <code class="markup--code markup--li-code">MUL</code> and 1 ALUs for <code class="markup--code markup--li-code">ADD/SUB/XOR</code></li></ul><p name="b0e1" id="b0e1" class="graf graf--p graf-after--li">Also, suppose we are given the following program (which has only 1 true dependency of <code class="markup--code markup--p-code">I2</code> and <code class="markup--code markup--p-code">I1</code>),</p><pre name="c776" id="c776" class="graf graf--pre graf-after--p">ADD R1, R2, R3<br>SUB R4, R1, R5<br>XOR R6, R7, R8<br>MUL R5, R8, R9<br>ADD R4, R8, R9</pre><p name="71a3" id="71a3" class="graf graf--p graf-after--pre">For processor A, there should be 2 cycles, so the <code class="markup--code markup--p-code">IPC = 5/2 = 2.5</code> ,</p><pre name="66cb" id="66cb" class="graf graf--pre graf-after--p">------------------ C1 ------ C2 ------ C3 ------ C4 ------ C5<br>ADD R1, R2, R3     **  <br>SUB R4, R1, R5               **<br>XOR R6, R7, R8     **<br>MUL R5, R8, R9     **<br>ADD R4, R8, R9               **</pre><p name="1c02" id="1c02" class="graf graf--p graf-after--pre">For processor B, there should be 3 cycles, so the <code class="markup--code markup--p-code">IPC = 5/3 = 1.67</code> ,</p><pre name="effc" id="effc" class="graf graf--pre graf-after--p">------------------ C1 ------ C2 ------ C3 ------ C4 ------ C5<br>ADD R1, R2, R3     **  <br>SUB R4, R1, R5               **<br>XOR R6, R7, R8     **<br>MUL R5, R8, R9               **<br>ADD R4, R8, R9                         **</pre><p name="3c0d" id="3c0d" class="graf graf--p graf-after--pre">For processor C, there should be 4 cycles, so the <code class="markup--code markup--p-code">IPC = 5/4 = 1.25</code> ,</p><pre name="bfb1" id="bfb1" class="graf graf--pre graf-after--p">------------------ C1 ------ C2 ------ C3 ------ C4 ------ C5<br>ADD R1, R2, R3     **  <br>SUB R4, R1, R5               **<br>XOR R6, R7, R8                         **<br>MUL R5, R8, R9     **<br>ADD R4, R8, R9                                   **</pre><p name="a0f5" id="a0f5" class="graf graf--p graf-after--pre">For processor D, there should be 4 cycles, so the <code class="markup--code markup--p-code">IPC = 5/4 = 1.25</code> ,</p><pre name="585e" id="585e" class="graf graf--pre graf-after--p">------------------ C1 ------ C2 ------ C3 ------ C4 ------ C5<br>ADD R1, R2, R3     **  <br>SUB R4, R1, R5               **<br>XOR R6, R7, R8                         **<br>MUL R5, R8, R9                                   **<br>ADD R4, R8, R9                                   **</pre><p name="d494" id="d494" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(6) Properties of ILP and IPC</strong></p><ul class="postList"><li name="b2c4" id="b2c4" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Property #1</strong>: ILP ≥ IPC</li><li name="8fed" id="8fed" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Property #2</strong>: given a narrow issue in-order processor, the IPC is mostly limited by the narrow issue</li><li name="e741" id="e741" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Property #3</strong>: given a wide issue in-order processor, the IPC is mostly limited by the in-order superscalar</li></ul><p name="e062" id="e062" class="graf graf--p graf-after--li graf--trailing">If we want to get a higher IPC, we have to use a wide-issue out-of-order processor. This processor requires us to have a lot more than 1 instructions per cycle (wide-issue), eliminate all the false dependencies (probably by register renaming), and reorder the instructions (out-of-order).</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/925b33a5435b"><time class="dt-published" datetime="2021-01-27T05:21:27.781Z">January 27, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-12-data-dependency-problems-register-renaming-and-925b33a5435b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>