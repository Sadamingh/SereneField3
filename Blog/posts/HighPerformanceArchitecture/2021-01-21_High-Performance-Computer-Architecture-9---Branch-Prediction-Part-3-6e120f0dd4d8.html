<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 9 | Branch Prediction Part 3</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 9 | Branch Prediction Part 3</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="97ca" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6c78" id="6c78" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 9 | Branch Prediction Part 3</h3><figure name="d132" id="d132" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*9EUpOrARXo77riut.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*9EUpOrARXo77riut.png"></figure><ol class="postList"><li name="5637" id="5637" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">History-Based Predictor With Shared Counters</strong></li></ol><p name="9e76" id="9e76" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Continue with the Wasted 2BCs</strong></p><p name="4844" id="4844" class="graf graf--p graf-after--p">In the previous section, we have encountered the case that with <code class="markup--code markup--p-code">N + 1</code> patterns and now let’s talk about how to reduce the waste by having fewer than 2 to the nth counter and yet have a long history.</p><p name="50ab" id="50ab" class="graf graf--p graf-after--p">The motivation for this is that with N-bit history,</p><ul class="postList"><li name="dbe4" id="dbe4" class="graf graf--li graf-after--p">we will need <code class="markup--code markup--li-code">2^N</code> 2BCs per entry</li><li name="29fd" id="29fd" class="graf graf--li graf-after--li">only about <code class="markup--code markup--li-code">N</code> 2BCs are actually used, and the other 2BCs are wasted</li></ul><p name="a7c9" id="a7c9" class="graf graf--p graf-after--li">So the idea here is to share these 2BCs between entries instead of dedicating <code class="markup--code markup--p-code">2^N</code> 2BC counters to each entry.</p><p name="4502" id="4502" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Conflict Concerns of the Shared Counters</strong></p><p name="0caf" id="0caf" class="graf graf--p graf-after--p">We will have a pool of 2BCs that entries will then use, but it is also possible that different entries with different program counters with different histories will end up using the same 2BC. So there’s a possibility of conflict, but if we have enough of these 2BCs because each entity doesn’t need too many of them, we will usually have very few conflicts.</p><p name="f377" id="f377" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Shared Counters Implementation</strong></p><p name="6885" id="6885" class="graf graf--p graf-after--p">So how can we implement the shared counters? The answer is as follows. We have the program counter PC and we take some of the lower bits. Then we use these bits to index into a table called <strong class="markup--strong markup--p-strong">pattern history table (PHT)</strong> which is a table that keeps the history bits alone with the current branch. This can also be treated as only the history sign part in the <strong class="markup--strong markup--p-strong">previous BHT</strong>. To grab some 2BCs for this history, we take the history from this table and then <strong class="markup--strong markup--p-strong">XOR</strong> it with the bits from the PC. The result from this XOR operation can be then used to index the <strong class="markup--strong markup--p-strong">branch history table (BHT)</strong>. Note that this BHT is not the same as the previous one and each entity in this BHT is only a single 2BC. Then, this entry will tell us whether or not we should be predicting taken or not taken.</p><figure name="b4b3" id="b4b3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*t0GhDIQmK6NyaoZCGhVfTw.png" data-width="1600" data-height="468" src="https://cdn-images-1.medium.com/max/800/1*t0GhDIQmK6NyaoZCGhVfTw.png"></figure><p name="b5ae" id="b5ae" class="graf graf--p graf-after--figure">Note that it is possible for another PC to XOR with its history and to index us the same 2BC in the BHT. But we can ignore this overlap because it is quite rare to happen.</p><p name="b3a6" id="b3a6" class="graf graf--p graf-after--p">Now let’s do some calculations to see how much we have reduced the memory cost. Suppose we grab 11 bits from the current PC for indexing and our history has 10 patterns. Based on what we have discussed, a history of 9 bits is enough for representing this pattern.</p><p name="3437" id="3437" class="graf graf--p graf-after--p">For the previous BHT without shared counters,</p><ul class="postList"><li name="ad32" id="ad32" class="graf graf--li graf-after--p">Memory cost = memory cost per entry * # of the entries, so,</li></ul><pre name="ce69" id="ce69" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">Memory cost = [N + 2 * (2^N)] * (2^n) = [9 + 2 * (2^9)] * (2^11)<br>= </code>2115584 bits = 25.86 KB</pre><p name="fff7" id="fff7" class="graf graf--p graf-after--pre">For the PHT and BHT with shared counters,</p><ul class="postList"><li name="aa9e" id="aa9e" class="graf graf--li graf-after--p">Memory cost = (memory cost per entry in PHT + memory cost per entry in BHT )* # of the entries, so,</li></ul><pre name="1e6f" id="1e6f" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">Memory cost = (N + 2)</code> <code class="markup--code markup--pre-code">* (2^n) = (9 + 2) * (2^11) <br>= </code>22528 bits = 2.75 KB</pre><p name="4bc6" id="4bc6" class="graf graf--p graf-after--pre">Based on this calculation, we can find out that the memory cost reduces about <code class="markup--code markup--p-code">9/10</code> if we use the shared counters. So this is a huge progress for us and we can tolerate some conflicts in order to achieve this improvement.</p><p name="bebf" id="bebf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. PShare and GShare</strong></p><p name="3ead" id="3ead" class="graf graf--p graf-after--p">(<strong class="markup--strong markup--p-strong">1) The Definitions of Private Share and Global Share</strong></p><p name="77c7" id="77c7" class="graf graf--p graf-after--p">When we have shared counters, we actually separate the history bits (in PHT) and the 2BCs (in BHT).</p><p name="607f" id="607f" class="graf graf--p graf-after--p">A <strong class="markup--strong markup--p-strong">private share (PShare) predictor </strong>has a private history for each branch and each branch should have its own history in the PHT. The PShare predictor also has shared counters so that different histories and different branches might map to the same counter. The PShare predictor is good for things whenever the branch on previous behavior is<strong class="markup--strong markup--p-strong"> predictive</strong> of its future behavior (i.e. <strong class="markup--strong markup--p-strong">Even-odd behavior</strong> like <code class="markup--code markup--p-code">(NT)*</code> or loops with few iterations).</p><p name="a4d4" id="a4d4" class="graf graf--p graf-after--p">A <strong class="markup--strong markup--p-strong">global share (GShare)</strong> predictor has a single global history for all branches (or you can think about a PHT with only one entry). The GShare predictor also has shared counters so that different histories and different branches might map to the same counter. So what we have is now we actually have a <strong class="markup--strong markup--p-strong">single global history</strong> that we can use for all branches.</p><figure name="c5e5" id="c5e5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*pO_VpxD55PW3glsJka2y0g.png" data-width="1336" data-height="494" src="https://cdn-images-1.medium.com/max/800/1*pO_VpxD55PW3glsJka2y0g.png"></figure><p name="5f78" id="5f78" class="graf graf--p graf-after--figure">The GShare is good from the <strong class="markup--strong markup--p-strong">correlated branches</strong> like the two <code class="markup--code markup--p-code">if</code> statements in the following code. If we have the history of the first line, we will be sure to make the right prediction when executing the second line.</p><pre name="2fc8" id="2fc8" class="graf graf--pre graf-after--p">if (shape == square) { ... }<br>if (shape != square) { ... }</pre><p name="94e5" id="94e5" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(2) PShare Vs. GShare: An Example</strong></p><p name="665a" id="665a" class="graf graf--p graf-after--p">Now let’s do some calculations to see the difference between a PShare predictor and a GShare predictor. Suppose we have the following C program,</p><pre name="d76b" id="d76b" class="graf graf--pre graf-after--p">for (int i = 100; i != 0; i--) <br>    if (i % 2)<br>         n += i;</pre><p name="9398" id="9398" class="graf graf--p graf-after--pre">This can be compiled to</p><pre name="2c0e" id="2c0e" class="graf graf--pre graf-after--p">Loop:<br>    BEQ R1, 0, Exit<br>    AND R2, R1, 1<br>    BEQ R2, 0, Even<br>    ADD R3, R3, R1<br>Even: <br>    ADD R1, R1, -1<br>    B Loop<br>Exit:</pre><p name="fff6" id="fff6" class="graf graf--p graf-after--pre">Suppose we want good accuracies on all branches, then how many bits of history should the PShare and GShare have respectively?</p><p name="9e88" id="9e88" class="graf graf--p graf-after--p">Note that we have three branches in this program.</p><p name="d8d6" id="d8d6" class="graf graf--p graf-after--p">For PShare,</p><ul class="postList"><li name="8ca9" id="8ca9" class="graf graf--li graf-after--p">The first <code class="markup--code markup--li-code">BEQ</code> has a pattern of <code class="markup--code markup--li-code">NN...NT</code> and only the last branch is taken. So it doesn’t matter whether we have a history or not for this branch.</li><li name="1ba2" id="1ba2" class="graf graf--li graf-after--li">The second <code class="markup--code markup--li-code">BEQ</code> has an odd-even pattern of <code class="markup--code markup--li-code">NTNT...</code> and we need to have at least 1 bit of history to predict this branch</li><li name="4fd5" id="4fd5" class="graf graf--li graf-after--li">The last loop <code class="markup--code markup--li-code">B</code> is an unconditional loop of <code class="markup--code markup--li-code">TT...</code> , so this means that the branch will always be taken. Thus, it doesn’t matter whether we have a history or not for this branch.</li></ul><p name="8c42" id="8c42" class="graf graf--p graf-after--li">Therefore, the minimum size of PHT should be <code class="markup--code markup--p-code">1</code> bit per entry.</p><p name="b86e" id="b86e" class="graf graf--p graf-after--p">For GShare, we have to consider the three branches together for the overall history. The first branch <code class="markup--code markup--p-code">BEQ</code> should be <code class="markup--code markup--p-code">N</code> until the last bit, the second <code class="markup--code markup--p-code">NEQ</code> should be <code class="markup--code markup--p-code">N</code> or <code class="markup--code markup--p-code">T</code> based on the history, and the last branch <code class="markup--code markup--p-code">B</code> must be taken <code class="markup--code markup--p-code">T</code>. Thus, the branches follow,</p><pre name="6e0d" id="6e0d" class="graf graf--pre graf-after--p">N <strong class="markup--strong markup--pre-strong">N</strong> T N <strong class="markup--strong markup--pre-strong">T</strong> T N <strong class="markup--strong markup--pre-strong">N</strong> T N <strong class="markup--strong markup--pre-strong">T</strong> T ...</pre><p name="3eef" id="3eef" class="graf graf--p graf-after--pre">Based on this record, we can know that the minimum size of history we need to make an accurate prediction is <code class="markup--code markup--p-code">3</code> bits. The reason is,</p><pre name="147b" id="147b" class="graf graf--pre graf-after--p">NNT -&gt; N<br>NTN -&gt; T<br>TNT -&gt; T<br>NTT -&gt; N<br>TTN -&gt; N<br>TNN -&gt; T</pre><p name="839d" id="839d" class="graf graf--p graf-after--pre">This example gives us an insight that the GShare predictor has a longer history than the PShare.</p><p name="f417" id="f417" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) PShare or GShare: Which One to Choose?</strong></p><p name="0f77" id="0f77" class="graf graf--p graf-after--p">We have known that GShare can do some <strong class="markup--strong markup--p-strong">correlated branches</strong>, while PShare takes a <strong class="markup--strong markup--p-strong">shorter history</strong> than GShare. So which one should we choose for our processor? Many earlier processors choose between either PShare or GShare, but very quickly, people figured out that we can actually choose <strong class="markup--strong markup--p-strong">both of them</strong>.</p><p name="b59e" id="b59e" class="graf graf--p graf-after--p">This brings us to an idea called <strong class="markup--strong markup--p-strong">tournament predictor</strong>.</p><p name="f5cb" id="f5cb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Tournament Predictor and Hierarchical Predictor</strong></p><p name="a181" id="a181" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Tournament Predictor</strong></p><p name="f2c4" id="f2c4" class="graf graf--p graf-after--p">Let’s say we have two predictors, and we have known that PShare is better for some branches, while GShare is better for some other branches. So the best idea is to use the PShare for some branches, and GShare for the others. To implement that, we will use our current PC for indexing into both of the predictors. Then we will generate two results and we have to choose which one to use.</p><figure name="f789" id="f789" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0KvfQFSRAI8_HaZT8W1aLg.png" data-width="1596" data-height="490" src="https://cdn-images-1.medium.com/max/800/1*0KvfQFSRAI8_HaZT8W1aLg.png"></figure><p name="d33a" id="d33a" class="graf graf--p graf-after--figure">The idea for a <strong class="markup--strong markup--p-strong">tournament predictor</strong> is to use a <strong class="markup--strong markup--p-strong">meta-predictor </strong>which is just an array of 2BCs. We also use the current PC to index there, but the entry of a tournament predictor is actually going to tell you which of the two predictors is going to give a more accurate prediction for that branch. So we use the 2-bit result from the tournament predictor for choosing which predictor should we selected.</p><figure name="9f45" id="9f45" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*znEH5NDJMGcmeRUJ4WVioA.png" data-width="1596" data-height="886" src="https://cdn-images-1.medium.com/max/800/1*znEH5NDJMGcmeRUJ4WVioA.png"></figure><p name="5f48" id="5f48" class="graf graf--p graf-after--figure">Note that the PShare and GShare predictors are trained just like before, while the meta-predictor should be trained in a different way. If two predictors are both correct or both wrong, then the meta-predictor doesn’t change anything. If the first predictor is correct, then this predictor counts down. If the second predictor is correct, then this predictor counts up.</p><pre name="bb58" id="bb58" class="graf graf--pre graf-after--p">00 Strongly Choose the 1st Predictor<br>01 Weakly Choose the 1st Predictor<br>10 Weakly Choose the 2nd Predictor<br>11 Strongly Choose the 2nd Predictor</pre><p name="c03f" id="c03f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(2) The Definition of Hierarchical Predictor</strong></p><p name="d072" id="d072" class="graf graf--p graf-after--p">The tournament predictor typically combines two good predictors, while a <strong class="markup--strong markup--p-strong">hierarchical predictor</strong> combines a good predictor and an ok predictor (which is not so good). This is because if we do 2 good predictions for every branch just use one of them and each of the good predictors <strong class="markup--strong markup--p-strong">costs</strong> you a lot.</p><p name="1282" id="1282" class="graf graf--p graf-after--p">The tournament predictor <strong class="markup--strong markup--p-strong">updates both</strong> of the predictors on each decision, while the hierarchical predictor <strong class="markup--strong markup--p-strong">update only the ok predictor</strong> on each decision and the good predictor will be updated only if the ok predictor is not good.</p><p name="a2fd" id="a2fd" class="graf graf--p graf-after--p">In practice, the hierarchical predictor always wins.</p><p name="2aad" id="2aad" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Hierarchical Predictor: An Example</strong></p><p name="aef1" id="aef1" class="graf graf--p graf-after--p">We will now have a look at the Pentium M predictors as our example. This processor includes,</p><ul class="postList"><li name="9c38" id="9c38" class="graf graf--li graf-after--p">2BC Predictor (Cheap)</li><li name="55c2" id="55c2" class="graf graf--li graf-after--li">Local History Predictor</li><li name="8e1a" id="8e1a" class="graf graf--li graf-after--li">Global History Predictor</li></ul><figure name="dc04" id="dc04" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*DGc-rYV4xfEqmpB9IGFgiA.png" data-width="1942" data-height="1044" src="https://cdn-images-1.medium.com/max/800/1*DGc-rYV4xfEqmpB9IGFgiA.png"></figure><p name="2243" id="2243" class="graf graf--p graf-after--figure">Note that the meta-predictor in the hierarchical predictor stores the <strong class="markup--strong markup--p-strong">matching tags</strong> which decide whether or not to use a better predictor. In the beginning, all the meta-predictor would be empty and there will be no matching tags. If 2BC mispredict the result, then some bits of this branch address will be added to the matching tags of the local predictor, so next time, it will use the local predictor for prediction. When to use the local predictor and the global predictor has the same rules.</p><p name="2637" id="2637" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. Return Address Stack (RAS) Predictor</strong></p><p name="a014" id="a014" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Problems for Predicting Function Returns</strong></p><p name="bc2d" id="bc2d" class="graf graf--p graf-after--p">We have seen that there are several types of branches that we need to predict.</p><p name="7039" id="7039" class="graf graf--p graf-after--p">For <strong class="markup--strong markup--p-strong">conditional branches</strong>,</p><ul class="postList"><li name="1af9" id="1af9" class="graf graf--li graf-after--p">we need to predict the <strong class="markup--strong markup--li-strong">direction</strong> (taken or not taken). We have already seen many branches that can make good predictions of this.</li><li name="ea0d" id="ea0d" class="graf graf--li graf-after--li">if the branch is taken, we also need to predict the <strong class="markup--strong markup--li-strong">target</strong> address. A simple BTB predictor will be fine because we always have the same target.</li></ul><p name="64da" id="64da" class="graf graf--p graf-after--li">For <strong class="markup--strong markup--p-strong">unconditional jumps</strong> and <strong class="markup--strong markup--p-strong">function calls</strong>,</p><ul class="postList"><li name="0c38" id="0c38" class="graf graf--li graf-after--p">the direction is always taken so this is trivial</li><li name="ec14" id="ec14" class="graf graf--li graf-after--li">the target will either jump to a label or call a specific function, so BTB will be just fine</li></ul><p name="f7a9" id="f7a9" class="graf graf--p graf-after--li">For <strong class="markup--strong markup--p-strong">function returns</strong>,</p><ul class="postList"><li name="dd17" id="dd17" class="graf graf--li graf-after--p">the direction is always taken so this is trivial</li><li name="7242" id="7242" class="graf graf--li graf-after--li">the target of a function returns will often <strong class="markup--strong markup--li-strong">difficult to predict</strong>. Usually, we create a function and then call this function from multiple locations in the program. In this case, BTB will be our bad choice and we have to use RAS for this case.</li></ul><p name="acf5" id="acf5" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) The Definition of Return Address Stack (RAS) Predictor</strong></p><p name="0c34" id="0c34" class="graf graf--p graf-after--p">The return address stack (RAS) is a separate predictor dedicated to predicting the function returns. The way it works is that the RAS is actually a <strong class="markup--strong markup--p-strong">small stack </strong>close to the branch instructions (for finishing the predictions in 1 cycle). As we execute the program when we have a function call, we will push the return address. When we have the return instruction, we will pop the address and then move the pointer. Actually, it can be seen as address storage instead of a prediction.</p><p name="78f3" id="78f3" class="graf graf--p graf-after--p">There is a problem with RAS because the RAS is a really small stack and it can be exceeded by calling new functions easily. If our RAS is full, we have two strategies,</p><ul class="postList"><li name="fd21" id="fd21" class="graf graf--li graf-after--p">don’t push anything in order to preserve our address on RAS</li><li name="6a20" id="6a20" class="graf graf--li graf-after--li">wrap around by continue writing to the RAS. The wrap-around approach is better because the function returns follow the rule of LIFO (last in first out). So it is more useful for us to keep the latest function call.</li></ul><p name="9328" id="9328" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) How to Know a Return?</strong></p><p name="8212" id="8212" class="graf graf--p graf-after--p">A remaining problem is that how could we know whether a branch is a function return branch or not in the fetching stage? Because the instruction is not decoded yet but we have to decide whether or not to pop from the RAS. We have two methods for knowing this,</p><ul class="postList"><li name="f8d5" id="f8d5" class="graf graf--li graf-after--p">Using a 1BP predictor</li></ul><p name="fccb" id="fccb" class="graf graf--p graf-after--li">This will be a very accurate predictor because it is significantly possible for a PC to be a function return branch if it was a function return branch before</p><ul class="postList"><li name="1f8c" id="1f8c" class="graf graf--li graf-after--p">Using predecoding</li></ul><p name="0e11" id="0e11" class="graf graf--p graf-after--li graf--trailing">We will see that the processor really contains a cache that stores the instructions fetched from the memory. This works by when on fetching from the memory, we decode enough of the instruction to know whether that is a return or not. This predecoding is quite tricky because it seems like we did a decoding phase when we got the branch instructions from the memory and put them into the cache.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/6e120f0dd4d8"><time class="dt-published" datetime="2021-01-21T13:26:20.835Z">January 21, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-8-branch-prediction-part-3-6e120f0dd4d8" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>