<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 8  | Branch Prediction Part 2</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 8  | Branch Prediction Part 2</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="7f83" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9428" id="9428" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 8 | Branch Prediction Part 2</h3><figure name="039e" id="039e" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*eZApXFLLM84_rmSQ.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*eZApXFLLM84_rmSQ.png"></figure><ol class="postList"><li name="4922" id="4922" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">The Better Predictor Using History</strong></li></ol><p name="5313" id="5313" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Difficulties of Finding Better Predictors</strong></p><p name="4429" id="4429" class="graf graf--p graf-after--p">We have seen that the not-taken predictor computes the next PC based on an increment of the current PC. Generally, when we have a predictor, it should compute the next PC based on a function <em class="markup--em markup--p-em">f</em> of the current PC. This can be written as,</p><figure name="960a" id="960a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*49Fy-Ko35FXeyxX1sNzg3g.png" data-width="906" data-height="64" src="https://cdn-images-1.medium.com/max/800/1*49Fy-Ko35FXeyxX1sNzg3g.png"></figure><p name="111d" id="111d" class="graf graf--p graf-after--figure">If we can find some functions <em class="markup--em markup--p-em">f</em> that better predicts the next PC, then this predictor is going to have better performance. However, because all we know is the current PC, then probably you can not make a better prediction. To make a better prediction, we have to know,</p><ul class="postList"><li name="397c" id="397c" class="graf graf--li graf-after--p">If the instructions is a <strong class="markup--strong markup--li-strong">branch</strong>?</li><li name="e2c7" id="e2c7" class="graf graf--li graf-after--li">Is the branch <strong class="markup--strong markup--li-strong">taken</strong>?</li><li name="4104" id="4104" class="graf graf--li graf-after--li">What is the <strong class="markup--strong markup--li-strong">offset</strong> field of the instruction? Because we want to get the offset to add to the current PC so as to form the next PC.</li></ul><p name="f329" id="f329" class="graf graf--p graf-after--li">It is actually quite a pity that we actually don’t know anything about these after we fetch the instruction. So it seems like it is hopeless for us to get a better predictor. Is this true? Of course not!</p><p name="d2bb" id="d2bb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Better Prediction with History Information</strong></p><p name="1345" id="1345" class="graf graf--p graf-after--p">Even though we don’t know anything about the current PC, however, we do know something about it based on its history. Assume that we have already known that the instruction is a branch and we want to know whether it is taken or not taken, we can use the history behaving to guess its next behavior. This method is based on the assumption that branches stand to behave the same way over and over again and this is actually what really happens. Still, we don’t know what the current branch is going to do, but we can what it did when it was executed a few previous times.</p><p name="eebb" id="eebb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of Branch Target Buffer (BTB)</strong></p><p name="ba62" id="ba62" class="graf graf--p graf-after--p">The simplest predictor that uses the history is called the <strong class="markup--strong markup--p-strong">branch target buffer (BTB)</strong> and what it does is that: it takes the current PC of the branch and uses that to index a table called BTB, and from the table, what will readout is our <strong class="markup--strong markup--p-strong">best guess</strong> for what the next PC will be. So during the <strong class="markup--strong markup--p-strong">fetch</strong> stage, the process seems like the following diagram.</p><figure name="4d66" id="4d66" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Aoy3o-qSgXHgiDgQa7mM3A.png" data-width="1268" data-height="382" src="https://cdn-images-1.medium.com/max/800/1*Aoy3o-qSgXHgiDgQa7mM3A.png"></figure><p name="bf03" id="bf03" class="graf graf--p graf-after--figure">Another problem is how we can write to the table BTB. When we made a true prediction, the <code class="markup--code markup--p-code">PC_pred</code> would be exactly the same as <code class="markup--code markup--p-code">PC_next</code>, so we can just continue. However, if we made a wrong prediction (misprediction), then the current <code class="markup--code markup--p-code">PC_pred</code> value will be rewritten by the <code class="markup--code markup--p-code">PC_next</code> (the true value of this time). Note that the rewriting process requires the current PC <code class="markup--code markup--p-code">PC_now</code> as an index to the BTB. So next time we see this branch, we will get the correct prediction assuming it is going to jump to the same location.</p><figure name="3caa" id="3caa" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*w-cz1iioMJFiTKcvTsEsWg.png" data-width="1504" data-height="672" src="https://cdn-images-1.medium.com/max/800/1*w-cz1iioMJFiTKcvTsEsWg.png"></figure><p name="0fa2" id="0fa2" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) The Size of BTB</strong></p><p name="c0d4" id="c0d4" class="graf graf--p graf-after--p">Because what we want is that in one cycle, we were given the current PC and then predict the PC based on the BTB, so it needs to have a single cycle latency. That means we want the size of BTB to be really <strong class="markup--strong markup--p-strong">small </strong>in order to finish the indexing in a single cycle.</p><p name="c2e7" id="c2e7" class="graf graf--p graf-after--p">However, each entry in the BTB needs to contain an entire instruction address. let’s say we are using 64-bit addressing and each entry takes up to 8 bytes. That means the size of the BTB can actually be really <strong class="markup--strong markup--p-strong">large</strong>!</p><p name="c792" id="c792" class="graf graf--p graf-after--p">So we cannot have a dedicated entry in the BTB for every possible PC address. In reality, it’s enough if we have enough entries for all the instructions that are likely to execute. For example, assume that we have a loop with 100 instructions, and after the first loop, the BTB will include all the instructions in the loop after which point we will keep finding what we need in the BTB.</p><p name="ffb7" id="ffb7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Mapping PCs to BTB Using LSB</strong></p><p name="fe46" id="fe46" class="graf graf--p graf-after--p">Now that we have many PCs and we have to use each PC as an index of the BTB. So the question is how do we map each PC to an entry in the BTB? We have some requirements for this mapping function,</p><ul class="postList"><li name="ee01" id="ee01" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Avoid Conflicts</strong>: or we will get the same entry given different PCs</li><li name="ac5b" id="ac5b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Simple Function</strong>: because any delay in computing the mapping function means that we need an even smaller BTB if we want to finish the whole thing in 1 cycle</li></ul><p name="cf66" id="cf66" class="graf graf--p graf-after--li">The way we mapping the PC is, from the program counter (PC) which we are fetching, let’s say if the PCs are 64-bit values and we have 1024 entities in the BTB, then we can simply use the 10 <strong class="markup--strong markup--p-strong">least significant bits (LSB)</strong> as the index for our BTB. This mapping function is really fast because all we do is take the 10 bits without any calculation.</p><p name="e9c1" id="e9c1" class="graf graf--p graf-after--p">It is also important to know why the least significant 10 bits are used for indexing instead of the most significant 10 bits. Let’s think about an example of common PCs,</p><pre name="7075" id="7075" class="graf graf--pre graf-after--p">0x24A4: ADD<br>0x24A8: MUL<br>0x24AC: SLL<br>0x24B0: BEQ</pre><p name="6666" id="6666" class="graf graf--p graf-after--pre">If we mapping these instructions with the least significant 16 bits of the PC, we can find out that they can avoid conflicts because each of them is unique in the BTB and each of them can be direct to an entry. However, if we use the most significant 16 bits, the indexes will all be <code class="markup--code markup--p-code">24</code> and the entities can not be indexed through this value. So the nearby instructions, in this way, can not be mapping into a BTB.</p><p name="9b0c" id="9b0c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Mapping PCs to BTB: An Example</strong></p><p name="35ec" id="35ec" class="graf graf--p graf-after--p">Let’s see an example now. Suppose our BTB has 1024 entries. If the instructions were 4-byte fixed, word-aligned and the program counters are 32-bit addresses. So which BTB entry is used for <code class="markup--code markup--p-code">PC = 0x0000AB0C</code> in hexadecimal value?</p><p name="6941" id="6941" class="graf graf--p graf-after--p">Note that when we say the instructions were 4-byte fixed, word-aligned, we are meaning that all the instructions should take 4 bytes (4-byte fixed) and all the addresses would be divided by four (word-aligned). When the addresses <strong class="markup--strong markup--p-strong">must be divided by 4</strong>, the least significant two bits of a PC must be <code class="markup--code markup--p-code">00</code>. Here is a reference table shows us the relations between the least significant bits and all the alignments,</p><pre name="79d8" id="79d8" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">Alignments             Least significant bits</strong><br>Byte-alignment                       anything<br>Halfword-alignment                          0 <br>Word-alignment                             00<br>Doubleword-alignment                      000</pre><p name="e0a5" id="e0a5" class="graf graf--p graf-after--pre">Now let’s review our question. <code class="markup--code markup--p-code">0x0000AB0C</code> ends with a binary value of <code class="markup--code markup--p-code">101100001100</code> and we have known that the least significant 2 digits are always <code class="markup--code markup--p-code">00</code> . So in this case, we should ignore these two values and grab the 10 bits before these two bits in order to map into 1024 entries of the BTB. Thus, the index we will have in this case is <code class="markup--code markup--p-code">1011000011</code> and this should be converted to the hexadecimal value <code class="markup--code markup--p-code">0x2C3</code> .</p><p name="fc4f" id="fc4f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. 1BP and 2BP for the BHT Predictor</strong></p><p name="c7f8" id="c7f8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Direction Prediction Through BHT</strong></p><p name="cc83" id="cc83" class="graf graf--p graf-after--p">The BTB is going to tell us when a branch is taken, where should it go based on the historical results. However, we also have to predict whether or not a branch is taken. This is called the direction prediction and we are going to have a table that we will call a <strong class="markup--strong markup--p-strong">branch history table </strong>or a<strong class="markup--strong markup--p-strong"> BHT </strong>to deal with it.</p><p name="1bca" id="1bca" class="graf graf--p graf-after--p">We will take the current PC of the instruction, grab the LSB and then index it into the table BHT. So what you can see here is quite similar to index into a BTB. However, the entry in a BHT is much smaller. The simplest BHT predictor will simply have 1 bit per entry that tells us whether this is a not-taken branch (with <code class="markup--code markup--p-code">bit = 0</code>) or this is a taken branch (with <code class="markup--code markup--p-code">bit = 1</code>).</p><p name="4a58" id="4a58" class="graf graf--p graf-after--p">If <code class="markup--code markup--p-code">0</code> is gotten from this bit, then we can simply increase the PC (<code class="markup--code markup--p-code">PC++</code>) because this branch will not be taken. However, if <code class="markup--code markup--p-code">1</code> is gotten from this bit, then we use the BTB to tell us where to go. Just like we were updating the BTB, we can update this value once we dissolve this branch. If the resolution shows that it is a taken branch, we will put <code class="markup--code markup--p-code">1</code> in the BHT, and then we rewrite the destination address into the BTB if needed. If the resolution shows that it is a not-taken branch, we will put <code class="markup--code markup--p-code">0</code> in the BHT, and the BTB will not be updated.</p><p name="f90b" id="f90b" class="graf graf--p graf-after--p">Because the simplest BHT only requires 1 bit per entry, so the size of the BHT can be quite large. Thus, we can have lots of instructions avoiding conflicts between instructions that commonly execute while still reserving the small BTB which has much fewer entries only for branches in that code.</p><p name="43fe" id="43fe" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Problems With 1-Bit BHT Predictors (1BP)</strong></p><p name="cb6e" id="cb6e" class="graf graf--p graf-after--p">We have said in the last section that the simplest BHT predictor has 1 bit per entry that tells us whether an instruction is a taken branch or not. It seems that this 1-bit BHT works well in some of the situations for,</p><ul class="postList"><li name="df5b" id="df5b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">always taken branches</strong>: without penalty except for the first time. After the first time misprediction, there will be no more mistakes and the BHT will start to predict “taken”.</li><li name="3856" id="3856" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">always not-taken branches</strong>: because the BHT starts from a state of not-taken, then there’s not going to be a misprediction for the first time prediction. So there will be generally no penalty in this situation.</li></ul><p name="cd9a" id="cd9a" class="graf graf--p graf-after--li">However, the problems occur when there’s the following situation,</p><ul class="postList"><li name="cb21" id="cb21" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">taken &gt; not taken</strong> or <strong class="markup--strong markup--li-strong">not taken &gt; taken</strong>: this predictor doesn’t work well when there is an <strong class="markup--strong markup--li-strong">insignificant proportion</strong> pattern of taken (or not taken) against the other one. The penalties appear when the instructions change their taken state. Because one instruction state surpasses the other one with an insignificant scale, the penalty can not be simply ignored.</li></ul><p name="fbf7" id="fbf7" class="graf graf--p graf-after--li">Let’s see an example of this. Suppose we have the following sequential taken state of one branch instruction,</p><pre name="76dd" id="76dd" class="graf graf--pre graf-after--p">Taken State    T T T T N T T T T<br>Prediction     ✓ ✓ ✓ ✓ ✗ ✗ ✓ ✓ ✓</pre><p name="5b53" id="5b53" class="graf graf--p graf-after--pre">From this example, we can find out that each anomaly results in <strong class="markup--strong markup--p-strong">two mispredictions</strong>, one for the anomalous behavior and once more for the normal behavior that follows the anomaly.</p><p name="b500" id="b500" class="graf graf--p graf-after--p">There are more problems with this 1-bit preditor in a <strong class="markup--strong markup--p-strong">short loop </strong>because typically in a short loop, we are going to have two mispredictions while exiting the loop (mispredict the last iteration) and entering the loop (mispredict the very first iteration).</p><p name="ec73" id="ec73" class="graf graf--p graf-after--p">There is even a more server situation and this predictor works pretty bad when the proportion of taken is close to the proportion of not taken (<code class="markup--code markup--p-code">taken ≈ not taken</code>) for a branch instruction. We are going to leave it here and focus more on it later.</p><p name="b509" id="b509" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of 2-Bit BHT Predictors (2BP)</strong></p><p name="a652" id="a652" class="graf graf--p graf-after--p">The predictor that fixes the problems of the 1-bit BHT predictor is called a 2-bit predictor. It can also be written as <strong class="markup--strong markup--p-strong">2BP</strong> or <strong class="markup--strong markup--p-strong">2BC</strong>, which stands for the 2-bit counter.</p><p name="22ba" id="22ba" class="graf graf--p graf-after--p">Literally, there are 2 bits in the 2BP. The more significant bit is called the <strong class="markup--strong markup--p-strong">prediction bit</strong> and a value of <code class="markup--code markup--p-code">1</code> means that we will predict take, while a value of <code class="markup--code markup--p-code">0</code> means that we will predict not taken. The less significant bit is called the <strong class="markup--strong markup--p-strong">hysteresis (or conviction) bit</strong> and it tells us how sure are we when we are making the prediction by the more significant bit. A value of <code class="markup--code markup--p-code">0</code> means we strongly believe that the prediction is right, while a value of <code class="markup--code markup--p-code">1</code> means that we are not so sure with the prediction. Thus,</p><pre name="719d" id="719d" class="graf graf--pre graf-after--p">00      Strong Not Taken<br>01      Weak Not Taken<br>10      Weak Taken<br>11      Strong Taken</pre><p name="7f9d" id="7f9d" class="graf graf--p graf-after--pre">Recall, we can draw the outcome of 1BP as follows,</p><figure name="77e6" id="77e6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PQdtc13rWLiqYVD8UI3xog.png" data-width="1896" data-height="408" src="https://cdn-images-1.medium.com/max/800/1*PQdtc13rWLiqYVD8UI3xog.png"></figure><p name="d2e1" id="d2e1" class="graf graf--p graf-after--figure">While 2BP is more like a <strong class="markup--strong markup--p-strong">double confirmation</strong> when we change the state. The next prediction will not be changed until there’s a double confirmation that tells us it is quite convincing to believe that the taken state is really changed instead of some anomalous outcomes. The workflow is actually like,</p><figure name="dc93" id="dc93" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Wa17KoBeyz28J3hRp3IBOQ.png" data-width="1362" data-height="244" src="https://cdn-images-1.medium.com/max/800/1*Wa17KoBeyz28J3hRp3IBOQ.png"></figure><p name="f4cf" id="f4cf" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Initial State of 2-Bit BHT Predictors (2BP)</strong></p><p name="893d" id="893d" class="graf graf--p graf-after--p">For 1BP, we always start from the not-taken state because there are only 2 states, and also there are more non-taken-branch instructions. So it would be a good idea if we start from the not-taken state (<code class="markup--code markup--p-code">bit = 0</code>).</p><p name="d30f" id="d30f" class="graf graf--p graf-after--p">However, things are more complex when we use 2BP because now we have 4 states. Suppose, similarly, we would like to start from the not-taken state and now we have two choices. We can either start from the strong not-taken state or the weak not-taken state. Which one is better?</p><p name="292d" id="292d" class="graf graf--p graf-after--p">Let’s think about starting from the strong not-taken state first,</p><pre name="3fa4" id="3fa4" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">Start in Strong State:</strong></pre><pre name="9be0" id="9be0" class="graf graf--pre graf-after--pre">- if always not taken<br>00 00 00 00<br>NT NT NT NT<br>✓  ✓  ✓  ✓</pre><pre name="ea24" id="ea24" class="graf graf--pre graf-after--pre">- if always taken<br>00 01 10 11<br>T  T  T  T<br>✗  ✗  ✓  ✓</pre><p name="6bc1" id="6bc1" class="graf graf--p graf-after--pre">Based on the result above, we can know that if we start from the <strong class="markup--strong markup--p-strong">strong</strong> not-taken state, we pay nothing when the branch is always not-taken. However, we will have <strong class="markup--strong markup--p-strong">2 mispredictions </strong>when the branch is always taken.</p><p name="dbe6" id="dbe6" class="graf graf--p graf-after--p">Let’s think about starting from the strong not-taken state first,</p><pre name="ff5f" id="ff5f" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">Start in Weak State:</strong></pre><pre name="f59e" id="f59e" class="graf graf--pre graf-after--pre">- if always not taken<br>01 00 00 00<br>NT NT NT NT<br>✓  ✓  ✓  ✓</pre><pre name="0f60" id="0f60" class="graf graf--pre graf-after--pre">- if always taken<br>01 10 11 11<br>T  T  T  T<br>✗  ✓  ✓  ✓</pre><p name="4f78" id="4f78" class="graf graf--p graf-after--pre">Based on the result above, we can know that if we start from the <strong class="markup--strong markup--p-strong">weak</strong> not-taken state, we pay nothing when the branch is always not-taken. However, we will have only <strong class="markup--strong markup--p-strong">1 misprediction </strong>when the branch is always taken.</p><p name="afa4" id="afa4" class="graf graf--p graf-after--p">Now, it may seem like that we should initialize the 2BP with the weak not-taken state. But there’s actually an expectation that can provide disaster results if we do so. Let’s think about an alternative state,</p><pre name="d5a2" id="d5a2" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">Start in Strong State:</strong><br>00 01 00 01<br>NT T  NT T<br>✓  ✗  ✓  ✗</pre><pre name="832a" id="832a" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">Start in Weak State:</strong><br>01 10 01 10<br>NT T  NT T<br>✗  ✗  ✗  ✗</pre><p name="6e70" id="6e70" class="graf graf--p graf-after--pre">Woah! We can find out that all the predictions are wrong if we start from the weak state and it can really be a disaster for us. However, fortunately, the situation of an alternative state is rare and an always state is much more common. So to initialize the 2BP with the weak not-taken state is still a good idea.</p><p name="aff5" id="aff5" class="graf graf--p graf-after--p">But you can also notice that in reality, it will not influence too much whether we choose to start from a strong state or a weak state. This is because the strong state initialization pays for the always taken state while the weak state initialization pays for the alternate state. So in general, the overall accuracy of the branches is affected very little by the initialization state.</p><p name="f17a" id="f17a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Problems When More Bits of BHT Predictors</strong></p><p name="a659" id="a659" class="graf graf--p graf-after--p">We have seen that we improved the predictor a lot by adding 1 bit to each entry of the BHT predictors. Why don’t we have more bits? Well, it is possible for us to improve the accuracy of the predictors by adding more bits when the anomalous outcomes come in <strong class="markup--strong markup--p-strong">streaks</strong>. However, because each branch will have a corresponding entry in BHT, the more bits we have in the BHT, the higher the <strong class="markup--strong markup--p-strong">cost of memory</strong> would be. Based on the fact that the situation of anomalous outcomes come in streaks is not very often, 2BP is enough for most of the cases.</p><p name="ccf8" id="ccf8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. History-Bit Count Predictor</strong></p><p name="c965" id="c965" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Predictors for the Alternate States</strong></p><p name="47ed" id="47ed" class="graf graf--p graf-after--p">Let’s recall the following problem. When we have alternate states, either 1BP or 2BP works really bad. For example,</p><pre name="1e8f" id="1e8f" class="graf graf--pre graf-after--p">#1: N T N T N T N ...<br>#2: N N T N N T N ...</pre><p name="005d" id="005d" class="graf graf--p graf-after--pre">However, this is predictable for any human being and we can easily capture the pattern of these alternate states. The only problem is that the 1BP and 2BP can not learn from this pattern and guess the next state correctly. In fact, we can predict the next branch through historical patterns. For example, if we set the rules,</p><pre name="a4ab" id="a4ab" class="graf graf--pre graf-after--p">For #1:<br>- N -&gt; T<br>- T -&gt; N</pre><pre name="a0b1" id="a0b1" class="graf graf--pre graf-after--pre">For #2:<br>- NN -&gt; T<br>- NT -&gt; N<br>- TN -&gt; N</pre><p name="ddd1" id="ddd1" class="graf graf--p graf-after--pre">then we can predict the alternate patterns correctly.</p><p name="9eac" id="9eac" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) 1-Bit History With 2-Bit Count Predictor</strong></p><p name="6928" id="6928" class="graf graf--p graf-after--p">Let’s see how we can build a predictor that learns from the historical patterns. Instead of 1 bit or 2 bit for each entry in the BHT, each of these entries is assigned with 5 bits including a history sign, a 2BC for the not-taken branch, and a 2BC for the taken branch,</p><figure name="1121" id="1121" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ef1EhV18bqjP_XtoVjciDQ.png" data-width="1340" data-height="538" src="https://cdn-images-1.medium.com/max/800/1*ef1EhV18bqjP_XtoVjciDQ.png"></figure><p name="0545" id="0545" class="graf graf--p graf-after--figure">When the last branch is taken, then the history sign is assigned by 1, or it will be assigned to 0 if the last branch is not taken. If the last branch is taken (<code class="markup--code markup--p-code">history sign = 1</code>), then we read the 2BC from the “2BC for taken branch”. If the last branch is not taken (<code class="markup--code markup--p-code">history sign = 0</code>), then we read the 2BC from the “2BC for not taken branch”.</p><p name="1bd5" id="1bd5" class="graf graf--p graf-after--p">Let’s see a stable state for predicting the alternate state pattern <code class="markup--code markup--p-code">N T N T N ...</code>,</p><figure name="0ccd" id="0ccd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ivYegNE4FuP2SG8HxC8fVw.png" data-width="1014" data-height="130" src="https://cdn-images-1.medium.com/max/800/1*ivYegNE4FuP2SG8HxC8fVw.png"></figure><p name="12a4" id="12a4" class="graf graf--p graf-after--figure">When the last branch is not taken, then the history sign would be assigned to <code class="markup--code markup--p-code">0</code> and we will use strong taken as our 2BC predictor state. So the next one must be taken. Similarly, when the last branch is taken, then the history sign would be assigned to <code class="markup--code markup--p-code">1</code> and we will use strong not taken as our 2BC predictor state. So the next one must be not taken. By this means, we can finally get a predictor that can work for the alternate states.</p><p name="6f29" id="6f29" class="graf graf--p graf-after--p">However, this can not be working for the alternate state pattern <code class="markup--code markup--p-code">N N T N N T N ...</code> and there will be a misprediction for <code class="markup--code markup--p-code">1/3</code> of all these branch instructions. We are not going to calculate the result here and I am quite sure that you can also achieve this result. So what we can do if we want to build a predictor for this pattern? It is easy to guess that we actually need a 2-bit history with 2-bit count predictor.</p><p name="50bd" id="50bd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) 2-Bit History With 2-Bit Count Predictor</strong></p><p name="35ac" id="35ac" class="graf graf--p graf-after--p">When we have 2 bits for the history sign, we actually have 4 historical states. For each of these historical states, we have to assign a 2BC for tracing the taken information. Thus,</p><figure name="8900" id="8900" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vbZYCr1iZ8Un9HGLPdXEDw.png" data-width="1200" data-height="166" src="https://cdn-images-1.medium.com/max/800/1*vbZYCr1iZ8Un9HGLPdXEDw.png"></figure><p name="5d5b" id="5d5b" class="graf graf--p graf-after--figure">For alternate states <code class="markup--code markup--p-code">N N T N N T N ...</code>, the final stable state is,</p><figure name="14e5" id="14e5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*wncuH-_JuCDNaKeU3NMuAg.png" data-width="1232" data-height="166" src="https://cdn-images-1.medium.com/max/800/1*wncuH-_JuCDNaKeU3NMuAg.png"></figure><p name="c679" id="c679" class="graf graf--p graf-after--figure">We are not going to prove this because it is quite obvious. Note that we can’t generate a historical state of <code class="markup--code markup--p-code">TT</code> , so it doesn’t matter what is the value of the last two bits. Because the last 2-bit BC never gets used but we must have it, we actually wasted some of the memories.</p><p name="b9e7" id="b9e7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) N-Bit History With 2-Bit Count Predictor</strong></p><p name="b7f9" id="b7f9" class="graf graf--p graf-after--p">Now, let’s see some general conclusions. Suppose we have N history bits, then</p><ul class="postList"><li name="8ad2" id="8ad2" class="graf graf--li graf-after--p">It will correctly predict all <strong class="markup--strong markup--li-strong">pattern</strong> of <code class="markup--code markup--li-code">length ≤ N + 1</code> . Note that the number of patterns is the number of iterations in a loop. For example, a branch loop of <code class="markup--code markup--li-code">NNNNNNNNT</code> has 9 patterns and <code class="markup--code markup--li-code">N = 8</code> is enough for predicting these patterns.</li><li name="83ad" id="83ad" class="graf graf--li graf-after--li">There should be <code class="markup--code markup--li-code">2^N</code> <strong class="markup--strong markup--li-strong">2BC predictors</strong></li><li name="32c5" id="32c5" class="graf graf--li graf-after--li">The <strong class="markup--strong markup--li-strong">memory cost</strong> <strong class="markup--strong markup--li-strong">per entry</strong> should be <code class="markup--code markup--li-code">N + 2 * (2^N)</code> per entry, so when N increases, the cost increases exponentially</li><li name="e2c5" id="e2c5" class="graf graf--li graf-after--li">Most of the 2BCs will be <strong class="markup--strong markup--li-strong">wasted</strong> if we have a large N</li></ul><p name="4a54" id="4a54" class="graf graf--p graf-after--li">So the general solution for this kind of problems is that,</p><p name="65cf" id="65cf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 1</strong>. Spot the main loop and count the iterations <code class="markup--code markup--p-code">n</code> for this loop. A loop with <code class="markup--code markup--p-code">n</code> iterations can also be written as <code class="markup--code markup--p-code">(NN...NT)*</code> with <code class="markup--code markup--p-code">n-1</code> N (means branch not taken).</p><p name="1fd6" id="1fd6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 2</strong>. Calculate the # of the patterns by <code class="markup--code markup--p-code">N = n — 1</code>.</p><p name="97e1" id="97e1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 3</strong>. Calculate the number of 2BCs by <code class="markup--code markup--p-code">2^N</code>.</p><p name="4b1b" id="4b1b" class="graf graf--p graf-after--p graf--trailing"><strong class="markup--strong markup--p-strong">Step 4</strong>. Calculate the memory cost per entry by <code class="markup--code markup--p-code">N + 2 * (2^N)</code> .</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/9d44401b26de"><time class="dt-published" datetime="2021-01-21T08:10:37.610Z">January 21, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-8-branch-prediction-part-2-9d44401b26de" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>