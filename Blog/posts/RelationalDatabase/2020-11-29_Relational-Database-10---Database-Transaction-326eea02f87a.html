<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Relational Database 10 | Database Transaction</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Relational Database 10 | Database Transaction</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Relational Database
</section>
<section data-field="body" class="e-content">
<section name="56cf" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6fd4" id="6fd4" class="graf graf--h3 graf--leading graf--title">Relational Database 10 | Database Transaction</h3><figure name="9743" id="9743" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*3IaCF_vbefdstmWFpZxCRw.png" data-width="1600" data-height="1200" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*3IaCF_vbefdstmWFpZxCRw.png"></figure><ol class="postList"><li name="7024" id="7024" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Database Transaction</strong></li></ol><p name="6051" id="6051" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Database Transaction</strong></p><p name="1e7c" id="1e7c" class="graf graf--p graf-after--p">A transaction is a sequence of operations performed (using one or more SQL statements) on a database as a single logical unit of work. One operation can be treated as a transaction (single-operation transaction) and several operations can also be a transaction (transaction block).</p><p name="6a6b" id="6a6b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Recall: Autocommit mode</strong></p><p name="cc40" id="cc40" class="graf graf--p graf-after--p">The auto-commit mode is the default mode for PostgreSQL and each statement is executed in its own transaction and a commit is implicitly performed at the end of the statement. If the execution was successful then there will be a commit automatically, otherwise, a rollback is done.</p><p name="1a4e" id="1a4e" class="graf graf--p graf-after--p">For example, if we run,</p><pre name="5123" id="5123" class="graf graf--pre graf-after--p">UPDATE datatable SET value = 2 WHERE id = 1;</pre><p name="ad41" id="ad41" class="graf graf--p graf-after--pre">This is equivalent to,</p><pre name="77a3" id="77a3" class="graf graf--pre graf-after--p">BEGIN;<br>UPDATE datatable SET value = 2 WHERE id = 1;<br>COMMIT;</pre><p name="e9f5" id="e9f5" class="graf graf--p graf-after--pre">We are going to explain more about this block in the following section.</p><p name="2189" id="2189" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) BEGIN, COMMIT, and ROLLBACK</strong></p><p name="d2df" id="d2df" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">BEGIN</strong> initiates a transaction block, that is, all statements after a BEGIN command will be executed in a single transaction until an explicit <strong class="markup--strong markup--p-strong">COMMIT</strong> or <strong class="markup--strong markup--p-strong">ROLLBACK</strong> is given.</p><p name="b561" id="b561" class="graf graf--p graf-after--p">COMMIT means to save the change of the database after executing the transaction, while ROLLBACK means to abandon the transaction after the BEGIN statement and ignore the changes on the database. Note that if an error occurs when running a transaction, then a COMMIT will then become a ROLLBACK (because the error should not be committed).</p><p name="87e4" id="87e4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. ACID Property of the Transaction</strong></p><p name="316a" id="316a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Atomicity</strong></p><p name="7b9a" id="7b9a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">a. The Definition of Atomicity</strong></p><p name="f352" id="f352" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Atomicity </strong>means either all the operations (insert, update, delete) inside a transaction take place or none. Or we can say, all the statements (insert, update, delete) inside a transaction are either completed or rolled back.</p><p name="85fa" id="85fa" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">b. Example of the Atomicity</strong></p><p name="5722" id="5722" class="graf graf--p graf-after--p">Suppose we have the following operations,</p><pre name="32a8" id="32a8" class="graf graf--pre graf-after--p">DROP VIEW IF EXISTS test1, test2;</pre><pre name="e866" id="e866" class="graf graf--pre graf-after--pre">BEGIN;<br>CREATE VIEW test1 AS (SELECT 1);<br>CREATE VIEW test2 AS (SELECT 1);<br>ROLLBACK;</pre><pre name="fa05" id="fa05" class="graf graf--pre graf-after--pre">SELECT * FROM test1, test2;</pre><p name="83c5" id="83c5" class="graf graf--p graf-after--pre">Then, for the transaction block of this code, the final results are rollbacked. This means that non of the operations inside this transaction would take place. Then we get an error because no view is created.</p><p name="fdf5" id="fdf5" class="graf graf--p graf-after--p">Things will be different if we change the ROLLBACK to COMMIT. See what happens for the following transactions.</p><pre name="a41f" id="a41f" class="graf graf--pre graf-after--p">DROP VIEW IF EXISTS test1, test2;</pre><pre name="c5ca" id="c5ca" class="graf graf--pre graf-after--pre">BEGIN;<br>CREATE VIEW test1 AS (SELECT 1);<br>CREATE VIEW test2 AS (SELECT 1);<br>COMMIT;</pre><pre name="3f74" id="3f74" class="graf graf--pre graf-after--pre">SELECT * FROM test1, test2;</pre><p name="3b45" id="3b45" class="graf graf--p graf-after--pre">We will have an output because these two views are successfully created.</p><p name="ea5a" id="ea5a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Consistency</strong></p><p name="edca" id="edca" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">a. The Definition of Consistency</strong></p><p name="e8a5" id="e8a5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Consistency </strong>means, whatever happens in the middle of the transaction, this acid property will never leave your database in a half-completed state.</p><ul class="postList"><li name="2f66" id="2f66" class="graf graf--li graf-after--p">If the transaction completed successfully, then it will apply all the changes to the database.</li><li name="9a06" id="9a06" class="graf graf--li graf-after--li">If there is an error in a transaction, then all the changes that already made will be rolled back automatically. It means the database will restore to its state that it had before the transaction started.</li><li name="b022" id="b022" class="graf graf--li graf-after--li">If there is a system failure in the middle of the transaction, then also, all the changes made already will automatically rollback.</li></ul><p name="aa02" id="aa02" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">b. Example of the Consistency</strong></p><p name="8b07" id="8b07" class="graf graf--p graf-after--p">If we change the place of the final operation to the middle of the transactions, then,</p><pre name="65a0" id="65a0" class="graf graf--pre graf-after--p">DROP VIEW IF EXISTS test1, test2;</pre><pre name="4ba5" id="4ba5" class="graf graf--pre graf-after--pre">BEGIN;<br>CREATE VIEW test1 AS (SELECT 1);<br>SELECT * FROM test1, test2;<br>CREATE VIEW test2 AS (SELECT 1);<br>COMMIT;</pre><p name="9fcc" id="9fcc" class="graf graf--p graf-after--pre">Of course, there will be an error if we execute the code. Because the test2 VIEW is called because we define it.</p><pre name="563b" id="563b" class="graf graf--pre graf-after--p">ERROR:  relation &quot;test2&quot; does not exist <br>LINE 5: SELECT * FROM test1, test2;</pre><p name="806a" id="806a" class="graf graf--p graf-after--pre">Because the transaction is now suspended, we can not move on to execute other codes after this, or there will be an error of aborted transaction,</p><pre name="3c5b" id="3c5b" class="graf graf--pre graf-after--p">ERROR:  current transaction is aborted, commands ignored until end of transaction block</pre><p name="a5c3" id="a5c3" class="graf graf--p graf-after--pre">Before we continue, we have to do either COMMIT or ROLLBACK for this transaction because they all mean ROLLBACK in this part. Let’s try a COMMIT now, then we can find out the code actually executes a ROLLBACK command.</p><pre name="ca49" id="ca49" class="graf graf--pre graf-after--p">ROLLBACK</pre><p name="da9a" id="da9a" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Isolation</strong></p><p name="11fd" id="11fd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">a. The Definition of Isolation</strong></p><p name="28d3" id="28d3" class="graf graf--p graf-after--p">Every transaction is individual, and one transaction can’t access the result of other transactions until the transaction completed.</p><p name="955e" id="955e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">b. Interleaved Transaction</strong></p><p name="e893" id="e893" class="graf graf--p graf-after--p">When the transactions are interleaved, it means the second transaction is started before the first one could end. And execution can switch between the transactions back and forth. It can also switch between multiple transactions.</p><p name="0b76" id="0b76" class="graf graf--p graf-after--p">Interleaving transactions allows multiple users of the database to access it at the same time. When there are multiple transactions, actions (reading, writing, aborting, or committing) in transactions could be interleaved to improve the performance.</p><p name="8bff" id="8bff" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">e. The Definition of the Transaction Schedule</strong></p><p name="bae4" id="bae4" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">transaction schedule</strong> describes a list of actions from a set of transactions as seen by the DBMS. There are two kinds of transaction schedules.</p><p name="b86f" id="b86f" class="graf graf--p graf-after--p">The first one is the <strong class="markup--strong markup--p-strong">serial schedule</strong>, which means if the actions of different transactions are not interleaved are executed from start to finish. The second one is the <strong class="markup--strong markup--p-strong">serializable schedule</strong> which describes that the actions of different transactions are interleaved. The following diagrams of the transaction schedule show a comparison between those two kinds of schedules.</p><figure name="93b0" id="93b0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*eCBozBxFLDre611u.jpg" data-width="602" data-height="225" src="https://cdn-images-1.medium.com/max/800/0*eCBozBxFLDre611u.jpg"></figure><p name="9892" id="9892" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">d. Example of the Isolation</strong></p><p name="0e53" id="0e53" class="graf graf--p graf-after--p">Let’s first of all, create a new table by,</p><pre name="575f" id="575f" class="graf graf--pre graf-after--p">DROP TABLE IF EXISTS population CASCADE;</pre><pre name="c7e2" id="c7e2" class="graf graf--pre graf-after--pre">CREATE TABLE population<br>(<br>state_id integer,<br>year integer,<br>population integer<br>);<br><br>INSERT INTO population VALUES<br>(1, 2010, 37000000),<br>(2, 2010, 25000000),<br>(3, 2010, 18000000),<br>(4, 2010, 19000000),<br>(5, 2010, 12000000),<br>(1, 2019, 39000000),<br>(2, 2019, 38000000),<br>(3, 2019, 21000000),<br>(4, 2019, 19000000),<br>(5, 2019, 12000000);</pre><p name="1181" id="1181" class="graf graf--p graf-after--pre">Then open two separate query tools for the same database. We can then start two transactions in these two query tools respectively. The first number means the sequence of running the operations, the second number in the parentheses means the output of this operation.</p><p name="c861" id="c861" class="graf graf--p graf-after--p">Then, in the first query tool,</p><pre name="779a" id="779a" class="graf graf--pre graf-after--p">BEGIN; — 1<br>SELECT COUNT(*) FROM population WHERE year = 2010; — 3 (5)<br>SELECT COUNT(*) FROM population WHERE year = 2010; — 6 (5)<br>SELECT COUNT(*) FROM population WHERE year = 2010; — 8 (4)<br>UPDATE population SET year = 2010 WHERE population = 37000000; — 9<br>SELECT COUNT(*) FROM population WHERE year = 2010; — 10 (5)<br>COMMIT; — 11</pre><p name="2073" id="2073" class="graf graf--p graf-after--pre">In the second query tool,</p><pre name="ee28" id="ee28" class="graf graf--pre graf-after--p">BEGIN; -- 2<br>UPDATE population SET year = 2016 WHERE population = 37000000;  -- 4<br>SELECT COUNT(*) FROM population WHERE year = 2010;  -- 5 (4)<br>COMMIT;  -- 7</pre><p name="b223" id="b223" class="graf graf--p graf-after--pre">We can find out that the first transaction won’t access the result of the UPDATE (#6) until the transaction in the second query tool is committed (#8).</p><p name="c3bc" id="c3bc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">e. The Definition of Concurrency</strong></p><p name="4816" id="4816" class="graf graf--p graf-after--p">Although there is never more than one current SQL transaction between your DBMS and your application program at any point in time, the operational problem is that many DBMSs run in multi-tasking or multi-user scenarios (especially possible if we are using AWS RDS), and this will result in collisions of the operations.</p><p name="ba85" id="ba85" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">f. Concurrency Transactions vs. Interleaved Transactions</strong></p><p name="3214" id="3214" class="graf graf--p graf-after--p">The interleaved transactions is executed by one user or a signal task so that one transaction can’t access the result of other transactions until the transaction completed. However, for concurrency transactions, one transaction can access the result of other transactions before the transaction completed.</p><p name="14e4" id="14e4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">g. The Definition of Collisions</strong></p><p name="4503" id="4503" class="graf graf--p graf-after--p">The running together of two transactions, which may access the same database rows during overlapping time periods. Such simultaneous accesses, called <strong class="markup--strong markup--p-strong">collisions</strong>, may result in errors or inconsistencies if not handled properly. The more overlapping that is possible, the greater the concurrency.</p><p name="27cf" id="27cf" class="graf graf--p graf-after--p">There are basically four types of categories, which they call — in order by seriousness — <strong class="markup--strong markup--p-strong">Lost Update</strong>, <strong class="markup--strong markup--p-strong">Dirty Read</strong>, <strong class="markup--strong markup--p-strong">Non-Repeatable Read, </strong>and <strong class="markup--strong markup--p-strong">Phantom Read</strong>.</p><p name="b583" id="b583" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">h. Lost Update (Most serious)</strong></p><p name="ef78" id="ef78" class="graf graf--p graf-after--p">Let’s see the following schedule,</p><pre name="26dd" id="26dd" class="graf graf--pre graf-after--p">-----------------------------------<br><strong class="markup--strong markup--pre-strong">     Txn #1            Txn #2</strong><br>-----------------------------------<br>      Change            ...<br>      ...               Change<br>      Read              ...<br>      Commit            ...<br>      ...               Commit</pre><p name="a49d" id="a49d" class="graf graf--p graf-after--pre">Transaction #1 (Txn #1) updates the database and then transaction #2 (Txn #2) also updates the database right after it. So the updates for Txn #2 supersedes the updates of Txn #1. If Txn #1 then read from the database, it will not get the result of the change in Txn #1.</p><p name="a1d0" id="a1d0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">i. Dirty Read (Highly serious)</strong></p><p name="5297" id="5297" class="graf graf--p graf-after--p">Let’s see the following schedule,</p><pre name="a820" id="a820" class="graf graf--pre graf-after--p">-----------------------------------<br><strong class="markup--strong markup--pre-strong">     Txn #1            Txn #2</strong><br>-----------------------------------<br>      Change            ...<br>      ...               Read<br>      Rollback          ...<br>      ...               Commit</pre><p name="0d7b" id="0d7b" class="graf graf--p graf-after--pre">Transaction #1 (Txn #1) updates the database and then transaction #2 (Txn #2) reads from it. It will get the data after the changes of transaction #1. However, transaction #1 then rollback the changes and that means the changes never really work on the database. Sadly, Txn #2 read the dirty data that may be wrong in someplace.The old name for the Dirty Read phenomenon is “uncommitted dependency”.</p><p name="64b4" id="64b4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">j. Non-Repeatable Read (Not so serious)</strong></p><p name="05a7" id="05a7" class="graf graf--p graf-after--p">Let’s see the following schedule,</p><pre name="6413" id="6413" class="graf graf--pre graf-after--p">-----------------------------------<br><strong class="markup--strong markup--pre-strong">     Txn #1            Txn #2</strong><br>-----------------------------------<br>      Read              ...<br>      ...               Change<br>      Read              ...<br>      ...               Commit<br>      Commit            ...</pre><p name="fbe4" id="fbe4" class="graf graf--p graf-after--pre">The non-repeatable read is the inconsistent results of two reads. It is not so serious because we can detect it from two different results in the sequence. Txn #1 reads from the database and then Txn #2 updates the data right after it. Then Txn #1 conduct a second read and find there’s something different in the result compared with the last read. This is not so serious, but it does certainly break the requirements of an ACID transaction.</p><p name="f017" id="f017" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">k. Phantom Read (Rare and Tolerable)</strong></p><p name="477e" id="477e" class="graf graf--p graf-after--p">Let’s see the following schedule,</p><pre name="aad3" id="aad3" class="graf graf--pre graf-after--p">----------------------------------------<br><strong class="markup--strong markup--pre-strong">     Txn #1            Txn #2</strong><br>----------------------------------------<br>      Search            ...<br>      ...               Insert/Delete<br>      Search            ...<br>      ...               Commit<br>      Commit            ...</pre><p name="2169" id="2169" class="graf graf--p graf-after--pre">This is also called the “now-you-don’t-see-it-now-you-do” phenomenon. This happens only if there are two searches in one transaction and these searches depend on the updated terms in another transaction. It is kind of rare and the results can always be tolerable. This will be fine because it’s like “Oh I can’t find this. I have to refresh it. Aha, now it’s here.”.</p><p name="5ac3" id="5ac3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">l.</em> The Definition of the Lock</strong></p><p name="2cff" id="2cff" class="graf graf--p graf-after--p">The most common and best-known way to eliminate some or all of the transaction concurrency phenomena is locking. A lock is an object that ensures the net effect is identical to executing all transactions in a serial order to minimize collisions. We can lock either a <strong class="markup--strong markup--p-strong">table</strong> or a bunch of <strong class="markup--strong markup--p-strong">rows</strong> in a table. A lock is much like a reservation in a restaurant. If you find that your desired seat has already been taken by someone who came before you, you must either wait or go elsewhere.</p><p name="239b" id="239b" class="graf graf--p graf-after--p">There are two kinds of locks, the shared lock, and the exclusive lock. A <strong class="markup--strong markup--p-strong">shared lock</strong> exists because there is nothing wrong with letting two transactions read the same row; concurrency can only cause trouble if one transaction or the other is updating. The shared lock does not prevent the other transactions from reading the same row. However, when there’s a change (update/insert/ etc.) happens, the shared lock is upgraded to an <strong class="markup--strong markup--p-strong">exclusive lock</strong>, which blocks both reads and writes by other transactions. The exclusive lock will degrade the performance of the code because it has to wait and this adds to the time complexity.</p><p name="29ea" id="29ea" class="graf graf--p graf-after--p">A typical shared locking process is,</p><pre name="c7ff" id="c7ff" class="graf graf--pre graf-after--p">--------------------------------------------------------<br><strong class="markup--strong markup--pre-strong">     Txn #1                   Txn #2</strong><br>--------------------------------------------------------<br>     shared lock row #1       ...<br>     ...                      read row #1<br>     read row #1              ...<br>     ...                      Attempt to Update row #1<br>                              - Wait because locked<br>     Commit                   ...<br>     ...                      Update row #1<br>     ...                      Commit</pre><p name="91d8" id="91d8" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">m</em>. Locking Problem</strong></p><p name="bdc1" id="bdc1" class="graf graf--p graf-after--p">There are several problems with the lock for SQL,</p><ul class="postList"><li name="71f4" id="71f4" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Performance Degradation</strong></li></ul><p name="b43d" id="b43d" class="graf graf--p graf-after--li">To resolve the collisions between the transactions, the lock uses blocking (holds locks and force the other transactions to wait) and aborting (stops and restart the transaction). This can be a problem if there are many transactions that happens at the same time. The time cost of executing a transaction can be unpredictable.</p><figure name="de4e" id="de4e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MC6DDd1R3dIHHKbvwW9s-Q.png" data-width="1516" data-height="430" src="https://cdn-images-1.medium.com/max/800/1*MC6DDd1R3dIHHKbvwW9s-Q.png"></figure><p name="11d6" id="11d6" class="graf graf--p graf-after--figure">There are three solutions to this. Firstly, only lock the smallest side objects. Secondly, reducing the time that transactions hold locks. Thirdly, reducing the hotspots (objects that are frequently accessed or modified).</p><ul class="postList"><li name="8c0a" id="8c0a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">DeadLock Problem</strong></li></ul><p name="8b80" id="8b80" class="graf graf--p graf-after--li">The deadlock (or deadly embrace) problem happens if there are two transactions waiting for each other. Because all of them are waiting, then there’s no way either of them can be executed. The deadlock problem goes like this,</p><pre name="569b" id="569b" class="graf graf--pre graf-after--p">-------------------------------------------------------------<br><strong class="markup--strong markup--pre-strong">     Txn #1                       Txn #2</strong><br>-------------------------------------------------------------<br>     shared lock row #1           ...<br>     ...                          shared lock row #2<br>     ...                          Attempt to Update row #1<br>                                  - Wait because locked<br>     Attempt to Update row #2     ...<br>     - Wait because locked<br>     Wait                         Wait</pre><ul class="postList"><li name="12a0" id="12a0" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">Shared Lock Profusion</strong></li></ul><p name="c273" id="c273" class="graf graf--p graf-after--li">Let’s think about this, most commonly, what we will update for a table are usually a relatively small number of rows. However, the easiest way to set a shared lock is to set a lock for the whole table. Because most of the database guys are lazy and they don’t want to do lock to every specific row. Then this will result in a profusion of the shared locks. (i.e. people always choose SERIALIZABLE because they are lazy, we will explain this in the following section)</p><p name="bc2c" id="bc2c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">n</em>. Lock for PostgreSQL</strong></p><p name="d735" id="d735" class="graf graf--p graf-after--p">To set a lock for the PostgreSQL, we have to declare the isolation level in the BEGIN statement. The isolation level can be chosen from SERIALIZABLE, REPEATABLE READ, READ COMMITTED, READ UNCOMMITTED.</p><pre name="6832" id="6832" class="graf graf--pre graf-after--p">BEGIN TRANSACTION ISOLATION LEVEL &lt;isolevel&gt;;</pre><ul class="postList"><li name="8eb2" id="8eb2" class="graf graf--li graf-after--pre">SERIALIZABLE: the safest lock, which will lock everything related to the transaction. This can cause the lock profusion problem and the performance can be bad.</li><li name="db25" id="db25" class="graf graf--li graf-after--li">REPEATABLE READ: the shared lock. The data related to the transaction can only be read or write after the transaction is committed (or the lock is terminated). REPEATABLE READ is a level in addition to the guarantees of the READ COMMITTED level (not vice versa), it also guarantees that any data read cannot change, if the transaction reads the same data again, it will find the previously read data in place, unchanged, and available to read.</li><li name="ccdc" id="ccdc" class="graf graf--li graf-after--li">READ COMMITTED: (default) the shared lock. The data related to the transaction can only be read or write after the transaction is committed (or the lock is terminated). It simply restricts the reader from seeing any intermediate, uncommitted, ‘dirty’ read. However, data is free to change after it was read.</li><li name="a7aa" id="a7aa" class="graf graf--li graf-after--li">READ UNCOMMITTED: No lock.</li></ul><figure name="1bbb" id="1bbb" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*rHHxFMaIHLSv0JILO_Nuew.png" data-width="2008" data-height="390" src="https://cdn-images-1.medium.com/max/800/1*rHHxFMaIHLSv0JILO_Nuew.png"></figure><p name="eb1e" id="eb1e" class="graf graf--p graf-after--figure">Note that in PostgreSQL, the READ UNCOMMITTED is treated as the READ COMMITTED and phantom reads are not possible in the PostgreSQL implementation of Repeatable Read, so the actual isolation level might be stricter than what you select.</p><p name="46ae" id="46ae" class="graf graf--p graf-after--p">Also note that PostgreSQL <strong class="markup--strong markup--p-strong">doesn’t support the dirty read</strong> so that no lock will also, not cause a dirty read problem.</p><p name="665e" id="665e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Durability</strong></p><p name="1915" id="1915" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">a. The Definition of Durability</strong></p><p name="b81f" id="b81f" class="graf graf--p graf-after--p">Once the transaction completed, then the changes it has made to the database will be permanent. Even if there is a system failure or any abnormal changes.</p><p name="429c" id="429c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">b. Write-Ahead Logging Files for Durability</strong></p><p name="522a" id="522a" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Write-Ahead Logging</em> (WAL) is a standard method for ensuring data integrity. And they are the way that PostgreSQL reaches the property of durability. To find the WAL files, we can run the following code,</p><pre name="c72d" id="c72d" class="graf graf--pre graf-after--p graf--trailing">$ cd /usr/local/var/postgres/pg_wal/<br>$ cat `ls | head -1` | head -1</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/326eea02f87a"><time class="dt-published" datetime="2020-11-29T11:05:11.103Z">November 29, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/relational-database-10-database-transaction-326eea02f87a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>