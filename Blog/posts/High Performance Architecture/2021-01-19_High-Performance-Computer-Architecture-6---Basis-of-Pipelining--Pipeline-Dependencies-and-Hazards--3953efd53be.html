<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 6 | Basis of Pipelining, Pipeline Dependencies and Hazards…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 6 | Basis of Pipelining, Pipeline Dependencies and Hazards…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="bf89" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="335e" id="335e" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 6 | <strong class="markup--strong markup--h3-strong">Basis of Pipelining, Pipeline Dependencies and Hazards, and Pipeline Stages</strong></h3><figure name="f63a" id="f63a" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*uLdvcwDdxt3CvZQZ.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*uLdvcwDdxt3CvZQZ.png"></figure><ol class="postList"><li name="e030" id="e030" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Basis of Pipelining</strong></li></ol><p name="7e8c" id="7e8c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Introduction to Pipelining</strong></p><p name="5ee2" id="5ee2" class="graf graf--p graf-after--p">There are several key concepts that are used in many ways in computer architecture. One of these concepts is called pipelining and it is used in several ways in pretty much every computer nowadays.</p><p name="d327" id="d327" class="graf graf--p graf-after--p">Pipelining is crucial to improving performance in processors; it increases throughput and reduces cycle time. The downside of pipelines is the increase in hazards for both controls and data.</p><p name="cf9c" id="cf9c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Real Oil Pipeline</strong></p><p name="a60f" id="a60f" class="graf graf--p graf-after--p">So how do pipelining works? Let’s think about the following metaphor. Suppose we want to transport oil between a filling station and an oil production plant and we have two methods to do that. One is to transport the oil through a tank truck, while the other one is through an oil pipeline.</p><figure name="059b" id="059b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IoEFmJDBhP-B1fkCuTjKWg.png" data-width="1896" data-height="496" src="https://cdn-images-1.medium.com/max/800/1*IoEFmJDBhP-B1fkCuTjKWg.png"></figure><p name="19f2" id="19f2" class="graf graf--p graf-after--figure">As we have already known that the oil needs three days to flow from one side to the other side, and the truck also needs three days to drive from the plant to the station. Let’s say the throughput of the pipeline can fill the trunk in 1 hour and suppose that this is a new pipeline (not filled with oil by the starting time). If we want to transport 2 trucks of oil and we have only 1 tank truck, which method is more time-efficient? Note that the time for a truck to fill in the station can be ignored.</p><p name="75b2" id="75b2" class="graf graf--p graf-after--p">The answer is by pipeline! For the first truck of oil, the pipeline needs 3 days (from one side to another) plus 1 hour (fill in the station) and the truck only needs 3 hours to get it transported. However, if we want the second truck of oil, we have to wait another 6 days for truck transportation, while the pipeline only needs an extra hour. So generally,</p><pre name="a1b5" id="a1b5" class="graf graf--pre graf-after--p">   by truck:  9 days<br>by pipeline:  3 days and 2 hours</pre><p name="0f6f" id="0f6f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Processor Pipelining</strong></p><p name="2d4c" id="2d4c" class="graf graf--p graf-after--p">In a traditional simple processor, we have a <strong class="markup--strong markup--p-strong">program counter</strong> and we use it to access the <strong class="markup--strong markup--p-strong">instruction memory</strong> (IMEM). We will get instructions from IMEM and then we <strong class="markup--strong markup--p-strong">decode</strong> the instructions to figure out which type of instruction it is. Meanwhile, we could be reading the <strong class="markup--strong markup--p-strong">registers</strong> (REGS). Once we have read from the register, we can feed them to the <strong class="markup--strong markup--p-strong">arithmetic-logic unit</strong> (ALU) where we are going to do the add or subtract or XOR or whatever the instruction wants us to do based on the logic from the decoded instructions. Once we get the result from ALU, we could be done and write the results to the register, or we could have a <strong class="markup--strong markup--p-strong">LOAD</strong> or <strong class="markup--strong markup--p-strong">STORE</strong> instruction, in which case, what the ALU computed is really the address that we use to access our <strong class="markup--strong markup--p-strong">data memory </strong>(DMEM). And what comes out from the data memory is what we end up writing to our registers.</p><p name="8c95" id="8c95" class="graf graf--p graf-after--p">Basically, we can do 1 instruction per cycle by starting at the PC, fetching the instruction, accessing the registers, doing the operation, accessing the data memory, and then write the result back to registers. Note that there is also some branching stuff that we are not going to pay attention to now.</p><p name="5188" id="5188" class="graf graf--p graf-after--p">So you can see that the instructions kind of go through these <strong class="markup--strong markup--p-strong">5 phases </strong>and normally, each of these phases takes 1 cycle to finish,</p><ul class="postList"><li name="4ae5" id="4ae5" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">FETCH</strong>: fetch instructions from IMEM</li><li name="ae0d" id="ae0d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">READ/DECODE</strong>: read registers and decode instructions</li><li name="dc0b" id="dc0b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">ALU</strong>: do the calculation</li><li name="dbea" id="dbea" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">MEM</strong>: access the memory</li><li name="bc67" id="bc67" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">WRITE</strong>: write the registers</li></ul><p name="db1f" id="db1f" class="graf graf--p graf-after--li">Suppose the running time for doing these 5 phases may take 20 nanoseconds (ns), so now we can do one instruction every 20 ns. Now, we have the following diagrams that show us the situations with or without pipelining,</p><figure name="72bc" id="72bc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Seao4Wi9n-JN4SxjU8LAyw.png" data-width="1760" data-height="538" src="https://cdn-images-1.medium.com/max/800/1*Seao4Wi9n-JN4SxjU8LAyw.png"></figure><p name="ea33" id="ea33" class="graf graf--p graf-after--figure">Suppose each phase takes equal time (20/5 = 4ns). Let’s calculate the latency and the throughput for these two different situations,</p><pre name="9507" id="9507" class="graf graf--pre graf-after--p">Without Pipelining,<br>- Latency: 20 ns<br>- Throughput: 1 / 20ns = 0.05 instructions per ns</pre><pre name="1baa" id="1baa" class="graf graf--pre graf-after--pre">With Pipelining,<br>- Latency: 20 ns<br>- Throughput: 1 / 4ns = 0.25 instructions per ns</pre><p name="1652" id="1652" class="graf graf--p graf-after--pre">This is quite similar to the oil pipeline.</p><p name="0876" id="0876" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Pipeline Stalls and Flushes</strong></p><p name="9380" id="9380" class="graf graf--p graf-after--p">We have mentioned that each of the 5 phases in a pipelining process takes 1 cycle to finish, so the CPI of the pipeline can be naturally calculated through <code class="markup--code markup--p-code">1 / 1 = 1 cycle per instruction</code>. However, this value is not true in practice, and the CPIs are always larger than 1. There are 3 reasons for this,</p><ul class="postList"><li name="440a" id="440a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Initial Fill</strong>: we have talked that we have to full-fill the pipeline for the best performance initially because it will take longer for the first instruction compared with the others.</li><li name="63e4" id="63e4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Pipeline Stalls</strong>: even the pipeline is full-filled initially, the CPIs can still be larger than 1. In the design of pipelined computer processors, a <strong class="markup--strong markup--li-strong">pipeline stall</strong> is injected into the pipeline by the processor to resolve <strong class="markup--strong markup--li-strong">data hazards</strong> where the data required to process an instruction is not yet available. When a hazard occurs in a phase, the processor suspends the pipelining process for 1 cycle and redo this phase with a second cycle.</li></ul><p name="2081" id="2081" class="graf graf--p graf-after--li">Let’s see an example of the following assembly code,</p><pre name="6a06" id="6a06" class="graf graf--pre graf-after--p">LW R1, 8(R3)<br>ADD R2, R1, 1<br>ADD R3, R2, 1</pre><p name="c765" id="c765" class="graf graf--p graf-after--pre">Because <code class="markup--code markup--p-code">LW</code> means to load from the memory, thus <code class="markup--code markup--p-code">ADD R2, R1, 1</code> should wait until the <code class="markup--code markup--p-code">LW</code> command writes the data from the memory to the register (the W phase). There fore, <code class="markup--code markup--p-code">ADD R2, R1, 1</code> has to wait for two cycles and this adds to the overall CPI.</p><figure name="6125" id="6125" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*lyh3e0VZFRGwOnC9YvVlxg.png" data-width="1712" data-height="374" src="https://cdn-images-1.medium.com/max/800/1*lyh3e0VZFRGwOnC9YvVlxg.png"></figure><p name="67d0" id="67d0" class="graf graf--p graf-after--figure">In modern processors, pipeline stalls are all figured out in hardware. The hardware logic for figuring out forwarding and stalls looks at the instruction in the Decode stage. Note that a <code class="markup--code markup--p-code">NOP</code> is just an instruction with no side-effect, and this is different from the pipeline stalls.</p><ul class="postList"><li name="bca5" id="bca5" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Pipeline Flushes</strong>: The pipeline flush is another source that will cause the CPI higher than 1. Pipeline flushes are quite similar to the pipeline stalls, but it occurs when there’s a JUMP instruction. Let’s see the following assembly code,</li></ul><pre name="d789" id="d789" class="graf graf--pre graf-after--li">J skip</pre><pre name="42d2" id="42d2" class="graf graf--pre graf-after--pre">SUB R2, R1, 1<br>ADD R3, R2, 1</pre><pre name="905a" id="905a" class="graf graf--pre graf-after--pre">skip:<br>    SLL R0, R0, 2</pre><p name="2522" id="2522" class="graf graf--p graf-after--pre">After we fetch a JUMP instruction, during the F/D/A phases, we don’t know the location that we are going to jump to. So the processor fetches the following two instructions <code class="markup--code markup--p-code">SUB</code> and <code class="markup--code markup--p-code">ADD</code> . After the <code class="markup--code markup--p-code">ALU</code> phase, we can then know where we are going to jump to, and this tells us that we should have fetched the instructions from somewhere else. So what happens now is called a <strong class="markup--strong markup--p-strong">pipeline flush</strong>. What we do is to convert these fetched instructions <code class="markup--code markup--p-code">SUB</code> and <code class="markup--code markup--p-code">ADD</code> into pipeline bubbles and then as the jump moves on, these two bubbles will also move on and cause a CPI larger than 1.</p><figure name="0e88" id="0e88" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dTqL8WCUHCW6_lzum2Gfqw.png" data-width="1712" data-height="374" src="https://cdn-images-1.medium.com/max/800/1*dTqL8WCUHCW6_lzum2Gfqw.png"></figure><p name="5750" id="5750" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">2. Pipeline Dependencies And Hazards</strong></p><p name="3dc2" id="3dc2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Control Dependencies</strong></p><p name="8ec2" id="8ec2" class="graf graf--p graf-after--p">Let’s say we have a program like this,</p><pre name="beb5" id="beb5" class="graf graf--pre graf-after--p">ADD R1, R1, R2<br>BEQ R1, R3, label<br>ADD R2, R3, R4<br>SUB R5, R6, R8<br>...</pre><pre name="d828" id="d828" class="graf graf--pre graf-after--pre">label:<br>    MUL R5, R6, R8&#39;<br>    ...</pre><p name="6c9e" id="6c9e" class="graf graf--p graf-after--pre">The definition of <strong class="markup--strong markup--p-strong">control dependencies</strong> is that we can say the <code class="markup--code markup--p-code">ADD</code> and <code class="markup--code markup--p-code">SUB …</code> instructions after the <code class="markup--code markup--p-code">BEQ</code> have a control dependence of the branch instruction <code class="markup--code markup--p-code">BEQ</code>, because whether these instructions should be executed or not depend on the result of the <code class="markup--code markup--p-code">BEQ</code> instruction. Similarly, the <code class="markup--code markup--p-code">MUL …</code> instructions also have a dependence on the branch. So when we have a branch, all subsequent instructions that we execute have a control dependence on the branch. What this really means is that we don’t know whether we should be able to fetch these instructions until we figure out the branch.</p><p name="3a12" id="3a12" class="graf graf--p graf-after--p">let’s now see an example of the influence of the control dependencies. Suppose we have a 5-stage CPI with 20% branch/jump instructions, and it is estimated that slightly more than 50% of these branch/jump instructions are taken (meaning that they go somewhere else instead of just continuing). So what is the general overall CPI in this case?</p><p name="6e78" id="6e78" class="graf graf--p graf-after--p">Putting together all the information, we can know that about 10% (20% * 50%) of instructions in the program work as the branch/jump instructions. And based on our previous discussions of the pipeline flushes, each of these branch/jump instructions takes 2 idle cycles. Thus, the cycles per instruction can be then calculated by <code class="markup--code markup--p-code">CPI = 1 + 10% * 2 = 1.2</code> .</p><p name="32f4" id="32f4" class="graf graf--p graf-after--p">In reality, most CPI is more than 5 stages (which means the <strong class="markup--strong markup--p-strong">CPI depth</strong> is larger than 5), this means the penalty of the idle cycles is larger than 2. However, we also have a technique that we are going to introduce called the <strong class="markup--strong markup--p-strong">branch prediction</strong>, which significantly reduces the branches or jumps that take the flushes. Thus, the percentage of this penalty will be reduced. Notice that the CPI depth can the branch prediction are related because when we have deeper CPIs, we have to use better branch predictions to reduce the penalty.</p><p name="c8e1" id="c8e1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Data Dependencies</strong></p><p name="ae0b" id="ae0b" class="graf graf--p graf-after--p">The data dependency can also cause the pipeline stalls. Consider the following two instructions,</p><pre name="960e" id="960e" class="graf graf--pre graf-after--p">ADD R1, R2, R3<br>SUB R7, R1, R8</pre><p name="fec3" id="fec3" class="graf graf--p graf-after--pre">We can find out that the <code class="markup--code markup--p-code">SUB</code> instruction has a data dependence on the <code class="markup--code markup--p-code">ADD</code> instruction because its value of R1 is dependent on the result of the <code class="markup--code markup--p-code">ADD</code> instruction. This kind of relationship is called <strong class="markup--strong markup--p-strong">data dependence</strong> and it means that we can not just do the instructions as they have nothing to do with each other. There are many kinds of data dependencies,</p><ul class="postList"><li name="63d3" id="63d3" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">RAW (Read After Write) data dependency (or Flow data dependency)</strong>: we read something after it has been written. So we have to wait for the written instruction and the order of these instructions need to be preserved. For example,</li></ul><pre name="5806" id="5806" class="graf graf--pre graf-after--li">ADD R1, R2, R3<br>SUB R7, R1, R8</pre><ul class="postList"><li name="5bb4" id="5bb4" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">WAW (Write After Write) data dependency (or Output data dependency)</strong>: because we want to maintain the final value of a register, so we must keep the order of the instructions in case the value is rewritten by the other writing instructions. For example,</li></ul><pre name="f74e" id="f74e" class="graf graf--pre graf-after--li">ADD R1, R2, R3<br>SUB R1, R7, R8</pre><ul class="postList"><li name="c1bc" id="c1bc" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">WAR </strong>(<strong class="markup--strong markup--li-strong">Write After Read</strong>) <strong class="markup--strong markup--li-strong">data dependency (or Anti-data dependency)</strong>: because we don’t want a write instruction to impact a read instruction right before it, so the order of these two instructions should be maintained. For example,</li></ul><pre name="66e1" id="66e1" class="graf graf--pre graf-after--li">ADD R2, R1, R3<br>SUB R1, R7, R8</pre><ul class="postList"><li name="008c" id="008c" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">True data dependency</strong>: Because the data in one register doesn’t exist until the previous instruction finished, so the order of these instructions must be preserved. The RAW dependency is actually a true dependency. For example,</li></ul><pre name="5340" id="5340" class="graf graf--pre graf-after--li">LW R1, 0(R0)<br>SUB R7, R1, R8</pre><ul class="postList"><li name="6af2" id="6af2" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">False data dependency</strong>: the WAW and WAR dependencies are also called the false dependency due to some reasons that we are going to introduce later.</li></ul><p name="a8dc" id="a8dc" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Dependencies and Hazards</strong></p><p name="032e" id="032e" class="graf graf--p graf-after--p">We have known that the <strong class="markup--strong markup--p-strong">dependency</strong> is the property of the program alone and we can check whether two instructions have dependence between them without any regard to what the pipeline looks like. In a particular pipeline <strong class="markup--strong markup--p-strong">without bubbles</strong> in it, some dependencies will cause problems potentially and some dependencies cannot cause problems whatever. The situation when a dependence can cause a problem in the pipeline is called a <strong class="markup--strong markup--p-strong">hazard</strong>.</p><p name="1298" id="1298" class="graf graf--p graf-after--p">Our conclusion is that the false data dependency will not cause a hazard, while the true dependency can cause a hazard when there’s no bubble in a pipeline. Let’s see three examples of how it works. Suppose we have a 5-stage CPI,</p><p name="fcb8" id="fcb8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">#1. False WAW Dependency</strong></p><pre name="2162" id="2162" class="graf graf--pre graf-after--p">ADD R1, R2, R3<br>MUL R1, R4, R5</pre><figure name="8663" id="8663" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*mKAfQHR5TSSKBso8pkDMPQ.png" data-width="1712" data-height="374" src="https://cdn-images-1.medium.com/max/800/1*mKAfQHR5TSSKBso8pkDMPQ.png"></figure><ul class="postList"><li name="1ad6" id="1ad6" class="graf graf--li graf-after--figure">In Cycle 1, the <code class="markup--code markup--li-code">MUL</code> is decoded and the sum of R2 and R3 is calculated</li><li name="86dd" id="86dd" class="graf graf--li graf-after--li">In Cycle 2, the product of R4 and R5 is calculated</li><li name="128f" id="128f" class="graf graf--li graf-after--li">In Cycle 3, the value of sum is written to R1</li><li name="5b1e" id="5b1e" class="graf graf--li graf-after--li">In Cycle 4, the value of product is written to R1</li></ul><p name="722a" id="722a" class="graf graf--p graf-after--li">We can actually find out that, when there’s no bubble, the order of two writing instructions are maintained automatically. Thus, the WAW dependency won’t be a hazard.</p><p name="e334" id="e334" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">#2. False WAR Dependency</strong></p><pre name="0efe" id="0efe" class="graf graf--pre graf-after--p">MUL R1, R4, R5<br>SUB R4, R6, R7</pre><figure name="f0a6" id="f0a6" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*GiAU18wgtoQG1eR8bI0tDg.png" data-width="1712" data-height="374" src="https://cdn-images-1.medium.com/max/800/1*GiAU18wgtoQG1eR8bI0tDg.png"></figure><ul class="postList"><li name="2d52" id="2d52" class="graf graf--li graf-after--figure">In Cycle 1, the <code class="markup--code markup--li-code">SUB</code> is decoded and the product of R4 and R5 is calculated</li><li name="bf20" id="bf20" class="graf graf--li graf-after--li">In Cycle 2, the subtraction of R6 and R7 is calculated</li><li name="0468" id="0468" class="graf graf--li graf-after--li">In Cycle 3, the value of product is written to R1</li><li name="4f71" id="4f71" class="graf graf--li graf-after--li">In Cycle 4, the value of subtraction is written to R4</li></ul><p name="7c2a" id="7c2a" class="graf graf--p graf-after--li">Similarly, when there’s no bubble, the order of the reading and then writing instructions is maintained automatically. Thus, the WAR dependency won’t be a hazard.</p><p name="67f6" id="67f6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">#3. True RAW Dependency</strong></p><pre name="22c0" id="22c0" class="graf graf--pre graf-after--p">SUB R4, R6, R7<br>DIV R10, R4, R8</pre><figure name="ae30" id="ae30" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*YdFKQ7GKgEGyqliNl2jchA.png" data-width="1712" data-height="374" src="https://cdn-images-1.medium.com/max/800/1*YdFKQ7GKgEGyqliNl2jchA.png"></figure><ul class="postList"><li name="3033" id="3033" class="graf graf--li graf-after--figure">In Cycle 1, the <code class="markup--code markup--li-code">DIV</code> is decoded and the subtraction of R6 and R7 is calculated</li><li name="8796" id="8796" class="graf graf--li graf-after--li">In Cycle 2, the division of R4 and R8 is calculated</li><li name="5b19" id="5b19" class="graf graf--li graf-after--li">In Cycle 3, the value of subtraction is written to R4</li><li name="7260" id="7260" class="graf graf--li graf-after--li">In Cycle 4, the value of division is written to R10</li></ul><p name="5a6d" id="5a6d" class="graf graf--p graf-after--li">Woah! We have a hazard here. In the cycle 2 and 3, the value in R4 is read at the first place, and then it is rewritten by the <code class="markup--code markup--p-code">SUB</code> instruction. However, what we want is that we want to use the result of R4 after the subtraction. This hazard occurs when a dependency results in the incorrect execution order of one or more instructions.</p><p name="f6f4" id="f6f4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Hazard Expectation for True Dependencies</strong></p><p name="c4fd" id="c4fd" class="graf graf--p graf-after--p">You may consider that the true dependencies can cause hazards when there are no bubbles. However, when there are no bubbles, does the true dependencies necessarily cause the hazards? The answer is no and let’s see an expectation. Suppose we have the following program,</p><pre name="d994" id="d994" class="graf graf--pre graf-after--p">ADD R1, R2, R3<br>MUL R7, R4, R5<br>SUB R4, R6, R7<br>DIV R10, R5, R8<br>XOR R11, R1, R7</pre><p name="76ae" id="76ae" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">XOR</code> has 2 <strong class="markup--strong markup--p-strong">true data dependencies</strong> of <code class="markup--code markup--p-code">R1</code> from the <code class="markup--code markup--p-code">ADD</code> instruction, and <code class="markup--code markup--p-code">R7</code> from the <code class="markup--code markup--p-code">MUL</code> instruction. However, in this case, there will no hazards caused by <code class="markup--code markup--p-code">R1</code> but there <strong class="markup--strong markup--p-strong">may be</strong> a hazard caused by <code class="markup--code markup--p-code">R7</code>. Why?</p><figure name="a311" id="a311" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*QvFSzW_ZGy9x2khiAxmxUA.png" data-width="1400" data-height="456" src="https://cdn-images-1.medium.com/max/800/1*QvFSzW_ZGy9x2khiAxmxUA.png"></figure><ul class="postList"><li name="300a" id="300a" class="graf graf--li graf-after--figure">In cycle 1, the <code class="markup--code markup--li-code">ADD</code> instruction writes to R1 before R1 is read by <code class="markup--code markup--li-code">XOR</code> , so the R1 cannot cause any hazards in this case.</li><li name="8103" id="8103" class="graf graf--li graf-after--li">In cycle 2, the <code class="markup--code markup--li-code">MUL</code> instruction writes to R7 when the <code class="markup--code markup--li-code">XOR</code> is reading from R7, so it is possible that <code class="markup--code markup--li-code">XOR</code> reads R7 after R7 is written by <code class="markup--code markup--li-code">MUL</code> , then there will be no hazards. However, it can also be possible that <code class="markup--code markup--li-code">XOR</code> reads R7 before R7 is written by <code class="markup--code markup--li-code">MUL</code> , then there will be a hazard. Thus, we can conclude that there <strong class="markup--strong markup--li-strong">may be</strong> a hazard caused by R7.</li></ul><p name="53cf" id="53cf" class="graf graf--p graf-after--li">From the expectation instance above, we can conclude that, in a 5-stage pipeline, if there are <strong class="markup--strong markup--p-strong">3 or more</strong> instructions between the writing (producing) instruction and the reading (consuming) instruction, then consuming instruction reads the register after the producing one has already written it. However, when there are <strong class="markup--strong markup--p-strong">no more than 2</strong> instructions between the producing instruction and the consuming instruction, then it is possible that this RAW dependency is going to cause a hazard.</p><p name="47db" id="47db" class="graf graf--p graf-after--p">Note that we have to notice the process of reading the registers occurs during whether the DECODE stage or the ALU stage. In our conclusion above, we have assumed that this is during the DECODE stage. However, when the process of reading the registers happens during the ALU stage (or some other), the conclusion will be different.</p><p name="f671" id="f671" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Handling the Hazards</strong></p><p name="4778" id="4778" class="graf graf--p graf-after--p">Because we do not allow the pipelines to produce incorrect results, we need to handle only the situations that are hazards. Actually, we don’t really care about dependencies that can never become hazards. To handling a hazard, we have to do,</p><ul class="postList"><li name="6bb5" id="6bb5" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Step 1</strong>. <strong class="markup--strong markup--li-strong">Detect</strong> the hazard situations</li><li name="55c8" id="55c8" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 2</strong>. Find out whether it is caused by a control dependency or a data dependency</li><li name="79cd" id="79cd" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 3–1</strong>. For <strong class="markup--strong markup--li-strong">control dependency</strong>, we use pipeline <strong class="markup--strong markup--li-strong">flushes</strong> to handle the hazard because the pipeline stall will not work for branching or jumping.</li><li name="caa7" id="caa7" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 3–2</strong>. For <strong class="markup--strong markup--li-strong">data dependency</strong>, we can use <strong class="markup--strong markup--li-strong">stalls</strong> for handling the hazards instead of flushes (actually, we never use flushing for the data dependency). For some of the data dependencies, we can even <strong class="markup--strong markup--li-strong">fix</strong> the value read by the dependent instructions, and this is called <strong class="markup--strong markup--li-strong">forwarding</strong>. The forwarding means that instead of reading from the register, we directly use the result from the ALU in the last step because the value has already been calculated by the last instruction by ALU and it is just not written to the register. However, this method can be invalid if there are some instructions between them and the result of the ALU is replace by some other calculations. So if we want to use forwarding, we have to make sure our value exists somewhere in the pipeline, or we may have to choose the pipeline stalls and the cost is our CPI.</li></ul><p name="7637" id="7637" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">3. Pipeline Stages</strong></p><p name="6e4d" id="6e4d" class="graf graf--p graf-after--p">We have used the 5-stage pipeline in most of the examples above. However, let’s talk about how many stages a pipeline should have. In the pipeline we have seen so far, the ideal CPI is 1. Actually, we are going to see that the ideal CPI should be <strong class="markup--strong markup--p-strong">smaller</strong> than 1 later in this series because they try to do more than 1 instruction per cycle.</p><p name="245b" id="245b" class="graf graf--p graf-after--p">What if we have more stages for our pipeline?</p><ul class="postList"><li name="4b93" id="4b93" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">More hazards</strong>: more instructions to be flushing, more stalls should be added, so the CPI increases because of the increasing penalty</li><li name="5ed1" id="5ed1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Less work per stage</strong>: if we have less work per cycle, then the cycle clock time (CCT) can be decreased. Thus, our clock can be speeded up.</li></ul><p name="5688" id="5688" class="graf graf--p graf-after--li">Based on the Iron law, the have known that,</p><figure name="4ed8" id="4ed8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*GwrKQd25CdvzlFbQ.png" data-width="1178" data-height="60" src="https://cdn-images-1.medium.com/max/800/0*GwrKQd25CdvzlFbQ.png"></figure><p name="5bdd" id="5bdd" class="graf graf--p graf-after--figure">Let’s say that we have the same amount of instructions and our CPI goes up, but the cycle clock time drops. So the number of stages has to be chosen in a way that <strong class="markup--strong markup--p-strong">balances the CPI and the CCT</strong>.</p><figure name="b815" id="b815" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NtBAdHokdwVgSaK_bP3YrQ.png" data-width="1838" data-height="674" src="https://cdn-images-1.medium.com/max/800/1*NtBAdHokdwVgSaK_bP3YrQ.png"></figure><p name="1dbf" id="1dbf" class="graf graf--p graf-after--figure">For modern processors, the optimized number of stages would be like 30 to 40 and this number of stages provides the best performance (<strong class="markup--strong markup--p-strong">speed</strong>). However, there are other concerns about the <strong class="markup--strong markup--p-strong">power</strong>. When we increase the frequency of our clock when decreases the clock time, the power consumption increases rapidly. So take both the performance and the power consumption into consideration, we will finally end up with a result of 10 to 15 stages in modern processors.</p><p name="c254" id="c254" class="graf graf--p graf-after--p graf--trailing">Sometimes you may find someone that is <strong class="markup--strong markup--p-strong">overclocking</strong> the processor, which means this guy wants to ignore the power concerns to achieve better performance with more stages.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/3953efd53be"><time class="dt-published" datetime="2021-01-19T17:49:14.161Z">January 19, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-6-basis-of-pipelining-pipeline-dependencies-and-hazards-3953efd53be" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>