<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 13 | Tomasulo’s Algorithm Part 1</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 13 | Tomasulo’s Algorithm Part 1</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="3476" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a720" id="a720" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 13 | Tomasulo’s Algorithm Part 1</h3><figure name="5da9" id="5da9" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*pP0M3paITOSktAF8.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*pP0M3paITOSktAF8.png"></figure><ol class="postList"><li name="c4de" id="c4de" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">A Brief Review</strong></li></ol><p name="397a" id="397a" class="graf graf--p graf-after--li">For an ideal processor, we have known that the ILP can be significantly greater than 1. However, the IPC of any given processor can not be as large as ILP. To improve the performance of the IPC for a given processor, we need to handle,</p><ul class="postList"><li name="34c3" id="34c3" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">the control dependencies</strong> by branch prediction</li><li name="4f4a" id="4f4a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">the WAR or WAW data dependencies</strong> (false data dependencies) by register renaming</li><li name="6fad" id="6fad" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">the RAW data dependencies</strong> (true data dependencies) by out-of-order execution</li><li name="96cc" id="96cc" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">the structural dependencies</strong> by invest in a processor that has a wider issue</li></ul><p name="e743" id="e743" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">2. Tomasulo’s Algorithm and Out-of-order Implementation</strong></p><p name="3ab6" id="3ab6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) An Introduction to the Tomasulo’s Algorithm</strong></p><p name="a2ba" id="a2ba" class="graf graf--p graf-after--p">Robert Marco Tomasulo (October 31, 1934 — April 3, 2008) was a computer scientist and the inventor of the Tomasulo algorithm (1967). Tomasulo was the recipient of the 1997 Eckert–Mauchly Award “for the ingenious Tomasulo algorithm, which enabled <strong class="markup--strong markup--p-strong">out-of-order execution</strong> processors to be implemented.”.</p><p name="d2cf" id="d2cf" class="graf graf--p graf-after--p">Tomasulo’s Algorithm is actually one of the first techniques for out-of-order execution and now it has more than 50 years old. It was used in the IBM 360 machine which is delivered between 1965 and 1978.</p><figure name="7360" id="7360" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XSrSNixVrU6Z6YBoN4mvyw.png" data-width="1724" data-height="674" src="https://cdn-images-1.medium.com/max/800/1*XSrSNixVrU6Z6YBoN4mvyw.png"><figcaption class="imageCaption">IBM 360 Machine</figcaption></figure><p name="8ac9" id="8ac9" class="graf graf--p graf-after--figure">Tomasulo’s algorithm determines which instructions have inputs so that they are able to go into the next cycle and which instructions still have to wait for their inputs to be produced. It also includes a formal register renaming and it is surprisingly similar to what we actually use today as far as out-of-order execution is concerned.</p><p name="1ba4" id="1ba4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Tomasulo’s Algorithm in History and for Today</strong></p><p name="c1bc" id="c1bc" class="graf graf--p graf-after--p">There are actually some sorts of differences between how Tomasulo’s algorithm was used originally and how it is used now.</p><p name="c8ba" id="c8ba" class="graf graf--p graf-after--p">In the olden days,</p><ul class="postList"><li name="2749" id="2749" class="graf graf--li graf-after--p">Tomasulo’s algorithm is designed only for floating-point instructions</li><li name="bf4a" id="bf4a" class="graf graf--li graf-after--li">Tomasulo’s algorithm has relatively fewer instructions in the window that they are looking at</li><li name="f74a" id="f74a" class="graf graf--li graf-after--li">Exception handling for the floating points is not a big problem</li></ul><p name="0c15" id="0c15" class="graf graf--p graf-after--li">For today,</p><ul class="postList"><li name="7d68" id="7d68" class="graf graf--li graf-after--p">Tomasulo’s algorithm is updated for even all instructions</li><li name="2041" id="2041" class="graf graf--li graf-after--li">Tomasulo’s algorithm looks at hundreds of the instructions when we are executing</li><li name="53b2" id="53b2" class="graf graf--li graf-after--li">Processors include explicit support for exception handling</li></ul><p name="16dd" id="16dd" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Tomasulo’s Algorithm: The Whole Picture</strong></p><p name="ff38" id="ff38" class="graf graf--p graf-after--p">Let’s begin the whole picture from the instructions queue. We have known that we need to fetch the instructions in our pipeline (fetching stage). After fetching, the instruction is actually pushed into the <strong class="markup--strong markup--p-strong">instruction queue </strong>(a FIFO queue).</p><figure name="43fa" id="43fa" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZmBbUutNefaaXAkc_WXh4A.png" data-width="1724" data-height="576" src="https://cdn-images-1.medium.com/max/800/1*ZmBbUutNefaaXAkc_WXh4A.png"></figure><p name="c774" id="c774" class="graf graf--p graf-after--figure">Suppose now we are having only the floating-point instructions. Then to Tomasulo’s algorithm machine, we often grab the next available instruction in the order they came (a property of the queue) and then put it into one of the <strong class="markup--strong markup--p-strong">reservation stations</strong> (there are a number of reservation stations). We can only put an instruction to the reservation station when there is an empty space in this reservation station. The reservation stations are where instructions basically wait for the parameters to become ready.</p><figure name="7d01" id="7d01" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*hzu3pKm7K7HS5RNCCoNe_g.png" data-width="1724" data-height="728" src="https://cdn-images-1.medium.com/max/800/1*hzu3pKm7K7HS5RNCCoNe_g.png"></figure><p name="d6aa" id="d6aa" class="graf graf--p graf-after--figure">We also have a <strong class="markup--strong markup--p-strong">register file</strong> that can be used to store the floating-point numbers. A register file is an array of processor registers in a central processing unit. When an instruction is inserted into a reservation station, the values that are already in the registers are going to be simply entered into the reservation station from the register file.</p><figure name="8f18" id="8f18" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*I1vHVUYF98RmHCU3kK3ncA.png" data-width="1724" data-height="728" src="https://cdn-images-1.medium.com/max/800/1*I1vHVUYF98RmHCU3kK3ncA.png"></figure><p name="c344" id="c344" class="graf graf--p graf-after--figure">Once an instruction in the reservation is ready to execute, it goes to an execution unit. In fact, we can have different types of execution units, for example, a unit for adder <code class="markup--code markup--p-code">ADD</code> or a unit for multiplier <code class="markup--code markup--p-code">MUL</code>.</p><figure name="6482" id="6482" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OFfOWr2T-Ov2FtzBxI10vw.png" data-width="1724" data-height="890" src="https://cdn-images-1.medium.com/max/800/1*OFfOWr2T-Ov2FtzBxI10vw.png"></figure><p name="28f7" id="28f7" class="graf graf--p graf-after--figure">Once such a unit has produced a result, the result will be broadcast on a bus. This bus is called the <strong class="markup--strong markup--p-strong">common data bus (CDB)</strong>.</p><figure name="ab34" id="ab34" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*I4-ctScBpTTM2lnrw14Qaw.png" data-width="1844" data-height="920" src="https://cdn-images-1.medium.com/max/800/1*I4-ctScBpTTM2lnrw14Qaw.png"></figure><p name="fd73" id="fd73" class="graf graf--p graf-after--figure">Of course, the results will <strong class="markup--strong markup--p-strong">go to the register file</strong> so all the results that are output would be available in the register file. So the instructions that <strong class="markup--strong markup--p-strong">newly</strong> come in can directly grab them the register file.</p><figure name="6fe9" id="6fe9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-XbwK2qHQiEMwuPi3E8puQ.png" data-width="1844" data-height="920" src="https://cdn-images-1.medium.com/max/800/1*-XbwK2qHQiEMwuPi3E8puQ.png"></figure><p name="7285" id="7285" class="graf graf--p graf-after--figure">These results will also be <strong class="markup--strong markup--p-strong">broadcast to the reservation station</strong> because there are some instructions in the reservation station still waiting for the values that they need to be produced. As these values are produced, these instructions can move forward to execute.</p><figure name="8969" id="8969" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*L6w64z1_fD_RbdIY_YOPkg.png" data-width="1844" data-height="920" src="https://cdn-images-1.medium.com/max/800/1*L6w64z1_fD_RbdIY_YOPkg.png"></figure><p name="df3c" id="df3c" class="graf graf--p graf-after--figure">Finally, if the instruction is not an arithmetic instruction, instead if it is a <strong class="markup--strong markup--p-strong">load</strong> (load from memory to the floating-point register file) or a <strong class="markup--strong markup--p-strong">store</strong> instruction (store from the floating-point register file to the memory), then the instruction will go to the <strong class="markup--strong markup--p-strong">address generation unit</strong>. The address generation unit is an integer operation unit so it won’t go through the floating-point ALU.</p><figure name="cd0c" id="cd0c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*s3OhN9MmM0p4c7Y5EWfcsg.png" data-width="1844" data-height="920" src="https://cdn-images-1.medium.com/max/800/1*s3OhN9MmM0p4c7Y5EWfcsg.png"></figure><p name="d8a5" id="d8a5" class="graf graf--p graf-after--figure">After we compute the address we would like to load/store, then we insert our instruction into a <strong class="markup--strong markup--p-strong">load buffer</strong> or a <strong class="markup--strong markup--p-strong">store buffer</strong>. So the instructions will be queued up before they going to the memory. The load buffer only provides a data address to memory, while the store buffer provides both the data and the address to the memory.</p><figure name="fbc2" id="fbc2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*9Esl3XmsRn2iNOpdsAMThg.png" data-width="1844" data-height="920" src="https://cdn-images-1.medium.com/max/800/1*9Esl3XmsRn2iNOpdsAMThg.png"></figure><p name="e54c" id="e54c" class="graf graf--p graf-after--figure">When a load comes back from the memory, its value will be broadcast on the CDB and goes to an appropriate register in the register file. Also, the values that are broadcasted on the bus are going to go to the store buffer so the store instruction can get their value when they are available.</p><figure name="2815" id="2815" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NV538-xuH__lHKiyrMGw0Q.png" data-width="1844" data-height="920" src="https://cdn-images-1.medium.com/max/800/1*NV538-xuH__lHKiyrMGw0Q.png"></figure><p name="9be1" id="9be1" class="graf graf--p graf-after--figure">The part when we send the instructions from the instruction queue to the reservation station is called an <strong class="markup--strong markup--p-strong">issue</strong>. The part when the instruction is finally sent to execution units from the reservation station is called <strong class="markup--strong markup--p-strong">dispatch</strong>. The part when the instruction is ready to broadcast its result is called <strong class="markup--strong markup--p-strong">write result</strong> (or simply<strong class="markup--strong markup--p-strong"> broadcast</strong>).</p><figure name="e958" id="e958" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*x18_yiL6HnQxmiRUSaVWKw.png" data-width="1844" data-height="920" src="https://cdn-images-1.medium.com/max/800/1*x18_yiL6HnQxmiRUSaVWKw.png"></figure><p name="74c3" id="74c3" class="graf graf--p graf-after--figure">This is the whole picture of Tomasulo’s algorithm. Now we are going further into the details of this algorithm.</p><p name="c133" id="c133" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Issue Phase in Tomasulo’s Algorithm</strong></p><ul class="postList"><li name="ae15" id="ae15" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Step 1.</strong> <strong class="markup--strong markup--li-strong">Take</strong> the next instruction in program order from the instruction queue. This has to be done in order for register renaming to work correctly.</li><li name="75fb" id="75fb" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 2.</strong> <strong class="markup--strong markup--li-strong">Determine</strong> where the inputs of the instructions come from. They can come from the <strong class="markup--strong markup--li-strong">register file</strong> or are they produced by some other instructions that still haven’t bought us the result. Also, if we have to <strong class="markup--strong markup--li-strong">wait for a result</strong>, which is the instruction we are waiting for.</li><li name="ca80" id="ca80" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 3.</strong> <strong class="markup--strong markup--li-strong">Get a free/available reservation station</strong> of the correct kind (some reservation stations are for <code class="markup--code markup--li-code">MUL</code>, while the others are for <code class="markup--code markup--li-code">ADD</code>, etc.)</li><li name="f9dc" id="f9dc" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 4. Put</strong> instruction in the reservation station.</li><li name="0f44" id="0f44" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 5. Tag</strong> the destination register so that the produced result goes to this corresponding register so that the instructions that want that register in the future will know which instruction is going to produce this value if it has already not been produced</li></ul><p name="7b6b" id="7b6b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Issue: An Example</strong></p><p name="0fc2" id="0fc2" class="graf graf--p graf-after--p">Suppose we have the following program,</p><pre name="8c69" id="8c69" class="graf graf--pre graf-after--p">ADD F2, F4, F1<br>DIV F1, F2, F3<br>SUB F4, F1, F2<br>ADD F1, F2, F3</pre><p name="fa9c" id="fa9c" class="graf graf--p graf-after--pre">and if we are given a processor with the initial register file,</p><pre name="6e6e" id="6e6e" class="graf graf--pre graf-after--p">Register File =======<br>F1    3.14<br>F2   -1.00<br>F3    2.72<br>F4    0.71</pre><p name="aa88" id="aa88" class="graf graf--p graf-after--pre">and register station <code class="markup--code markup--p-code">RS1</code>, <code class="markup--code markup--p-code">RS2</code>, <code class="markup--code markup--p-code">RS3</code> link to the <code class="markup--code markup--p-code">ADD</code> ALU and register station <code class="markup--code markup--p-code">RS4</code>, <code class="markup--code markup--p-code">RS5</code> link to the <code class="markup--code markup--p-code">MUL</code> ALU. The RAT is empty at the beginning and this means that we can directly grab the data from the register file. Then, initially,</p><pre name="c9d0" id="c9d0" class="graf graf--pre graf-after--p">==== Inst Queue ====<br>+------------------+   &lt;- top in<br>|  ADD F1, F2, F3  |<br>|  SUB F4, F1, F2  |<br>|  DIV F1, F2, F3  |<br>|  ADD F2, F4, F1  |<br>+------------------+   &lt;- bottom out</pre><pre name="13a7" id="13a7" class="graf graf--pre graf-after--pre">======== RAT =======<br>+------------------+<br>|   F1   |         |<br>+------------------+<br>|   F2   |         |<br>+------------------+<br>|   F3   |         |<br>+------------------+<br>|   F4   |         |<br>+------------------+</pre><pre name="8934" id="8934" class="graf graf--pre graf-after--pre">======== RF ========<br>+------------------+<br>|   F1   |   3.14  |<br>+------------------+<br>|   F2   |  -1.00  |<br>+------------------+<br>|   F3   |   2.72  |<br>+------------------+<br>|   F4   |   0.71  |<br>+------------------+</pre><pre name="481a" id="481a" class="graf graf--pre graf-after--pre">================= ADD RS ================<br>+---------------------------------------+<br>|   RS1   |         |         |         |<br>+---------------------------------------+<br>|   RS2   |         |         |         |<br>+---------------------------------------+<br>|   RS3   |         |         |         |<br>+---------------------------------------+</pre><pre name="c47b" id="c47b" class="graf graf--pre graf-after--pre">================= MUL RS ================<br>+---------------------------------------+<br>|   RS4   |         |         |         |<br>+---------------------------------------+<br>|   RS5   |         |         |         |<br>+---------------------------------------+</pre><p name="874d" id="874d" class="graf graf--p graf-after--pre">After issuing the 1st instruction,</p><pre name="e396" id="e396" class="graf graf--pre graf-after--p">==== Inst Queue ====<br>+------------------+   &lt;- top in<br>|                  |<br>|  ADD F1, F2, F3  |<br>|  SUB F4, F1, F2  |<br>|  DIV F1, F2, F3  |<br>+------------------+   &lt;- bottom out</pre><pre name="6700" id="6700" class="graf graf--pre graf-after--pre">======== RAT =======<br>+------------------+<br>|   F1   |         |<br>+------------------+<br>|   F2   |   RS1   |<br>+------------------+<br>|   F3   |         |<br>+------------------+<br>|   F4   |         |<br>+------------------+</pre><pre name="aa97" id="aa97" class="graf graf--pre graf-after--pre">======== RF ========<br>+------------------+<br>|   F1   |   3.14  |<br>+------------------+<br>|   F2   |  -1.00  |<br>+------------------+<br>|   F3   |   2.72  |<br>+------------------+<br>|   F4   |   0.71  |<br>+------------------+</pre><pre name="bc43" id="bc43" class="graf graf--pre graf-after--pre">================= ADD RS ================<br>+---------------------------------------+<br>|   RS1   |   ADD   |   0.71  |   3.14  |<br>+---------------------------------------+<br>|   RS2   |         |         |         |<br>+---------------------------------------+<br>|   RS3   |         |         |         |<br>+---------------------------------------+</pre><pre name="bd38" id="bd38" class="graf graf--pre graf-after--pre">================= MUL RS ================<br>+---------------------------------------+<br>|   RS4   |         |         |         |<br>+---------------------------------------+<br>|   RS5   |         |         |         |<br>+---------------------------------------+</pre><p name="c366" id="c366" class="graf graf--p graf-after--pre">After issuing the 2nd instruction,</p><pre name="105a" id="105a" class="graf graf--pre graf-after--p">==== Inst Queue ====<br>+------------------+   &lt;- top in<br>|                  |<br>|                  |<br>|  ADD F1, F2, F3  |<br>|  SUB F4, F1, F2  |<br>+------------------+   &lt;- bottom out</pre><pre name="3d89" id="3d89" class="graf graf--pre graf-after--pre">======== RAT =======<br>+------------------+<br>|   F1   |   RS4   |<br>+------------------+<br>|   F2   |   RS1   |<br>+------------------+<br>|   F3   |         |<br>+------------------+<br>|   F4   |         |<br>+------------------+</pre><pre name="fc20" id="fc20" class="graf graf--pre graf-after--pre">======== RF ========<br>+------------------+<br>|   F1   |   3.14  |<br>+------------------+<br>|   F2   |  -1.00  |<br>+------------------+<br>|   F3   |   2.72  |<br>+------------------+<br>|   F4   |   0.71  |<br>+------------------+</pre><pre name="9088" id="9088" class="graf graf--pre graf-after--pre">================= ADD RS ================<br>+---------------------------------------+<br>|   RS1   |   ADD   |   0.71  |   3.14  |<br>+---------------------------------------+<br>|   RS2   |         |         |         |<br>+---------------------------------------+<br>|   RS3   |         |         |         |<br>+---------------------------------------+</pre><pre name="524b" id="524b" class="graf graf--pre graf-after--pre">================= MUL RS ================<br>+---------------------------------------+<br>|   RS4   |   DIV   |   RS1   |   2.72  |<br>+---------------------------------------+<br>|   RS5   |         |         |         |<br>+---------------------------------------+</pre><p name="7ac1" id="7ac1" class="graf graf--p graf-after--pre">After issuing the 3rd instruction,</p><pre name="8ed7" id="8ed7" class="graf graf--pre graf-after--p">==== Inst Queue ====<br>+------------------+   &lt;- top in<br>|                  |<br>|                  |<br>|                  |<br>|  ADD F1, F2, F3  |<br>+------------------+   &lt;- bottom out</pre><pre name="fff1" id="fff1" class="graf graf--pre graf-after--pre">======== RAT =======<br>+------------------+<br>|   F1   |   RS4   |<br>+------------------+<br>|   F2   |   RS1   |<br>+------------------+<br>|   F3   |         |<br>+------------------+<br>|   F4   |   RS2   |<br>+------------------+</pre><pre name="f91e" id="f91e" class="graf graf--pre graf-after--pre">======== RF ========<br>+------------------+<br>|   F1   |   3.14  |<br>+------------------+<br>|   F2   |  -1.00  |<br>+------------------+<br>|   F3   |   2.72  |<br>+------------------+<br>|   F4   |   0.71  |<br>+------------------+</pre><pre name="a18a" id="a18a" class="graf graf--pre graf-after--pre">================= ADD RS ================<br>+---------------------------------------+<br>|   RS1   |   ADD   |   0.71  |   3.14  |<br>+---------------------------------------+<br>|   RS2   |   SUB   |   RS4   |   RS1   |<br>+---------------------------------------+<br>|   RS3   |         |         |         |<br>+---------------------------------------+</pre><pre name="6938" id="6938" class="graf graf--pre graf-after--pre">================= MUL RS ================<br>+---------------------------------------+<br>|   RS4   |   DIV   |   RS1   |   2.72  |<br>+---------------------------------------+<br>|   RS5   |         |         |         |<br>+---------------------------------------+</pre><p name="5fe5" id="5fe5" class="graf graf--p graf-after--pre">After issuing the last instruction, there will be no more instructions in the instruction queue. So the final state is,</p><pre name="1714" id="1714" class="graf graf--pre graf-after--p">==== Inst Queue ====<br>+------------------+   &lt;- top in<br>|                  |<br>|                  |<br>|                  |<br>|                  |<br>+------------------+   &lt;- bottom out</pre><pre name="9ba8" id="9ba8" class="graf graf--pre graf-after--pre">======== RAT =======<br>+------------------+<br>|   F1   |   RS3   |<br>+------------------+<br>|   F2   |   RS1   |<br>+------------------+<br>|   F3   |         |<br>+------------------+<br>|   F4   |   RS2   |<br>+------------------+</pre><pre name="9609" id="9609" class="graf graf--pre graf-after--pre">======== RF ========<br>+------------------+<br>|   F1   |   3.14  |<br>+------------------+<br>|   F2   |  -1.00  |<br>+------------------+<br>|   F3   |   2.72  |<br>+------------------+<br>|   F4   |   0.71  |<br>+------------------+</pre><pre name="8273" id="8273" class="graf graf--pre graf-after--pre">================= ADD RS ================<br>+---------------------------------------+<br>|   RS1   |   ADD   |   0.71  |   3.14  |<br>+---------------------------------------+<br>|   RS2   |   SUB   |   RS4   |   RS1   |<br>+---------------------------------------+<br>|   RS3   |   ADD   |   RS1   |   2.72  |<br>+---------------------------------------+</pre><pre name="d6a6" id="d6a6" class="graf graf--pre graf-after--pre">================= MUL RS ================<br>+---------------------------------------+<br>|   RS4   |   DIV   |   RS1   |   2.72  |<br>+---------------------------------------+<br>|   RS5   |         |         |         |<br>+---------------------------------------+</pre><p name="1dc5" id="1dc5" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(6) Dispatch Phase in Tomasulo’s Algorithm</strong></p><figure name="d9f6" id="d9f6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*RhaN9t6KbRDqS7O-nF8mTg.png" data-width="1844" data-height="568" src="https://cdn-images-1.medium.com/max/800/1*RhaN9t6KbRDqS7O-nF8mTg.png"></figure><p name="0845" id="0845" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Step 1. Find</strong> the instructions in the reservation station that can be directly executed.</p><p name="b168" id="b168" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 2. Execute</strong> the instruction and <strong class="markup--strong markup--p-strong">broadcast</strong> the returned value of this instruction to all the two operands.</p><p name="6fec" id="6fec" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 3. Replace</strong> the waiting operands with the result if the broadcasted value matches the value we want to achieve (for example, the broadcasted value is RS1 and we are waiting for the RS1).</p><p name="90e2" id="90e2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 4. Loop</strong> step 1 to step 3 until all the instructions are dispatched</p><p name="6535" id="6535" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Dispatch: An Example</strong></p><p name="6466" id="6466" class="graf graf--p graf-after--p">Let’s continue with the example of issuing. Now, after the 1st dispatching,</p><pre name="0958" id="0958" class="graf graf--pre graf-after--p">================= ADD RS ================<br>+---------------------------------------+<br>|   RS1   |   ADD   |         |         |      // RS1 = 3.85<br>+---------------------------------------+<br>|   RS2   |   SUB   |   RS4   |   3.85  |<br>+---------------------------------------+<br>|   RS3   |   ADD   |   3.85  |   2.72  |<br>+---------------------------------------+</pre><pre name="84ab" id="84ab" class="graf graf--pre graf-after--pre">================= MUL RS ================<br>+---------------------------------------+<br>|   RS4   |   DIV   |   3.85  |   2.72  |<br>+---------------------------------------+<br>|   RS5   |         |         |         |<br>+---------------------------------------+</pre><p name="03b6" id="03b6" class="graf graf--p graf-after--pre">After the 2nd dispatching,</p><pre name="0849" id="0849" class="graf graf--pre graf-after--p">================= ADD RS ================<br>+---------------------------------------+<br>|   RS1   |   ADD   |         |         |      <br>+---------------------------------------+<br>|   RS2   |   SUB   |   1.90  |   3.85  |<br>+---------------------------------------+<br>|   RS3   |   ADD   |         |         |        // RS3 = 3.85<br>+---------------------------------------+</pre><pre name="0195" id="0195" class="graf graf--pre graf-after--pre">================= MUL RS ================<br>+---------------------------------------+<br>|   RS4   |   DIV   |         |         |        // RS4 = 1.90<br>+---------------------------------------+<br>|   RS5   |         |         |         |<br>+---------------------------------------+</pre><p name="a0bc" id="a0bc" class="graf graf--p graf-after--pre">After the 3rd dispatching,</p><pre name="a0db" id="a0db" class="graf graf--pre graf-after--p">================= ADD RS ================<br>+---------------------------------------+<br>|   RS1   |   ADD   |         |         |      <br>+---------------------------------------+<br>|   RS2   |   SUB   |         |         |         // RS2 = -1.95<br>+---------------------------------------+<br>|   RS3   |   ADD   |         |         | <br>+---------------------------------------+</pre><pre name="a03e" id="a03e" class="graf graf--pre graf-after--pre">================= MUL RS ================<br>+---------------------------------------+<br>|   RS4   |   DIV   |         |         |<br>+---------------------------------------+<br>|   RS5   |         |         |         |<br>+---------------------------------------+</pre><p name="48be" id="48be" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(8) Dispatch More than 1 Ready</strong></p><p name="aaf1" id="aaf1" class="graf graf--p graf-after--p">There’s another situation of dispatching that we have to consider. Suppose we have the following register stations for an ADD execution unit,</p><pre name="450f" id="450f" class="graf graf--pre graf-after--p">================= ADD RS ================<br>+---------------------------------------+<br>|   RS1   |   ADD   |   0.71  |   3.14  |<br>+---------------------------------------+<br>|   RS2   |   SUB   |   1.90  |   RS1   |<br>+---------------------------------------+<br>|   RS3   |   ADD   |   RS1   |   2.72  |<br>+---------------------------------------+</pre><p name="4e83" id="4e83" class="graf graf--p graf-after--pre">Then after the first dispatch, we can have 2 instructions <code class="markup--code markup--p-code">RS2</code> and <code class="markup--code markup--p-code">RS3</code> ready for execution.</p><pre name="c0ad" id="c0ad" class="graf graf--pre graf-after--p">================= ADD RS ================<br>+---------------------------------------+<br>|   RS1   |   ADD   |         |         |     // RS1 = 3.85<br>+---------------------------------------+<br>|   RS2   |   SUB   |   1.90  |   3.85  |<br>+---------------------------------------+<br>|   RS3   |   ADD   |   3.85  |   2.72  |<br>+---------------------------------------+</pre><p name="09ec" id="09ec" class="graf graf--p graf-after--pre">But meanwhile, because we have only one ALU for these instructions and the ALU can only execute 1 instruction per cycle. So we have to decide which one to dispatch next.</p><p name="4f15" id="4f15" class="graf graf--p graf-after--p">Normally, we want to choose the one that leads to the best performance, which means that if many following instructions depending on <code class="markup--code markup--p-code">RS2</code> and only a few instructions depending on <code class="markup--code markup--p-code">RS3</code>, then we have to choose <code class="markup--code markup--p-code">RS2</code> to be executed first for better performance. However, this can not be possible for a processor because the processor does a really bad job in predicting future instructions.</p><p name="be3d" id="be3d" class="graf graf--p graf-after--p">There are actually some heuristics even though we can not do a perfect job of this. One choice is to make the <strong class="markup--strong markup--p-strong">oldest first</strong>. So whichever instruction that has been sitting in the register station longer will be allowed to go first. This is because, for an older instruction with all other things being equal, it is more likely that more instructions are by now waiting for it.</p><p name="3568" id="3568" class="graf graf--p graf-after--p">Another one is typically is to make the <strong class="markup--strong markup--p-strong">most dependencies first</strong>, where we will check how many instructions in the register station needs one of these and then use the one. This means that we are going to execute the one that can free up most of the other instructions. The downside of this approach is that it requires us to search for a lot of stuff and this can be power-hungry.</p><p name="5858" id="5858" class="graf graf--p graf-after--p">The last heuristic is to make a <strong class="markup--strong markup--p-strong">random</strong> execution. Normally, we will choose the <strong class="markup--strong markup--p-strong">oldest first</strong>, because it is a compromise between the most dependencies first (cares about effectiveness but no power consumption) and random (cares about the power consumption but no effectiveness).</p><p name="3139" id="3139" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Write Result (Broadcast) Phase in Tomasulo’s Algorithm</strong></p><p name="c3f6" id="c3f6" class="graf graf--p graf-after--p">So what will happen if we successfully executed an instruction in the ALU. Then possibly we will get a result of this instruction attached with a tag (i.e. <code class="markup--code markup--p-code">RS1</code>, <code class="markup--code markup--p-code">RS2</code>, etc.). Thus,</p><p name="f6fd" id="f6fd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 1. </strong>Put the <strong class="markup--strong markup--p-strong">tag</strong> and the <strong class="markup--strong markup--p-strong">result</strong> on the <strong class="markup--strong markup--p-strong">bus</strong> (common data bus or CDB) so it can be broadcasted to all the other parts.</p><figure name="fda5" id="fda5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PydLDn6xOe55j_CyflR9TA.png" data-width="1884" data-height="970" src="https://cdn-images-1.medium.com/max/800/1*PydLDn6xOe55j_CyflR9TA.png"></figure><p name="84b6" id="84b6" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Step 2</strong>. Write to <strong class="markup--strong markup--p-strong">register file (RF)</strong> based on the <strong class="markup--strong markup--p-strong">register address table</strong> (RAT). And then <strong class="markup--strong markup--p-strong">update the RAT</strong> by changing the corresponding entry to empty in order to make it point to the register file.</p><figure name="7a50" id="7a50" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*uBoZR8n4Lpz2tiiqKJ0dhA.png" data-width="1884" data-height="970" src="https://cdn-images-1.medium.com/max/800/1*uBoZR8n4Lpz2tiiqKJ0dhA.png"></figure><p name="4acc" id="4acc" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Step 3. Free</strong> the register station (RS).</p><figure name="ffa0" id="ffa0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*zWjB_pquBpheV6t6nfX1tQ.png" data-width="1884" data-height="970" src="https://cdn-images-1.medium.com/max/800/1*zWjB_pquBpheV6t6nfX1tQ.png"></figure><p name="c34f" id="c34f" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(10) Broadcast More than 1 Result</strong></p><p name="4278" id="4278" class="graf graf--p graf-after--p">This can happen if we have several ALUs. Let’s say that we have two ALUs, one is for <code class="markup--code markup--p-code">ADD</code> and the other is for <code class="markup--code markup--p-code">DIV</code>.</p><figure name="f15d" id="f15d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jnEBcDEjGdEaK7kzbhgImA.png" data-width="2018" data-height="970" src="https://cdn-images-1.medium.com/max/800/1*jnEBcDEjGdEaK7kzbhgImA.png"></figure><p name="46b7" id="46b7" class="graf graf--p graf-after--figure">So now we have two tag-result pairs waiting for broadcasting. One is <code class="markup--code markup--p-code">(RS3) 2.43</code> and the other is <code class="markup--code markup--p-code">(RS4) -0.11</code>. So which one will we broadcast in the first place? One common <strong class="markup--strong markup--p-strong">heuristic</strong> is that if one of the units is known to be slower than the other, then we will first broadcast the slower one. Let’s say the multiplication or division operations are usually slower than the addition or subtraction operations which is usually the case, then what we are going to do is given the priority to the slower unit. This is because the slower unit dispatches in the first because it takes longer to execute and this also means there can usually be more instructions waiting for the result of this unit. Thus, the result we are going to broadcast in the first place is <code class="markup--code markup--p-code">(RS4) -0.11</code> and then <code class="markup--code markup--p-code">(RS3) 2.43</code>.</p><p name="ed2b" id="ed2b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) Broadcast Stale Result</strong></p><p name="1e41" id="1e41" class="graf graf--p graf-after--p">So before we begin, let’s see what’s a stale result. At the beginning point, suppose we have,</p><figure name="47e6" id="47e6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*k67MrckZUpILTfy7fv__jA.png" data-width="2018" data-height="970" src="https://cdn-images-1.medium.com/max/800/1*k67MrckZUpILTfy7fv__jA.png"></figure><p name="9f0d" id="9f0d" class="graf graf--p graf-after--figure">Then <code class="markup--code markup--p-code">(RS2) 2.00</code> is going to be broadcasted to all the other parts. Meanwhile, we are going to issue the next instruction (suppose it is issued to <code class="markup--code markup--p-code">RS2</code>), which is,</p><pre name="572f" id="572f" class="graf graf--pre graf-after--p">ADD F4, F2, F3</pre><p name="b22e" id="b22e" class="graf graf--p graf-after--pre">After issuing this instruction, the entry value of F4 in the RAT will be replaced by the new <code class="markup--code markup--p-code">RS2</code>,</p><figure name="47b4" id="47b4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*U6Wbcuu-jioiFhMFJbkC4Q.png" data-width="2018" data-height="970" src="https://cdn-images-1.medium.com/max/800/1*U6Wbcuu-jioiFhMFJbkC4Q.png"></figure><p name="3764" id="3764" class="graf graf--p graf-after--figure">After dispatching, we have,</p><figure name="1259" id="1259" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Ds1g7Zi-Y1gLbQI6ddpLUA.png" data-width="2018" data-height="970" src="https://cdn-images-1.medium.com/max/800/1*Ds1g7Zi-Y1gLbQI6ddpLUA.png"></figure><p name="acfe" id="acfe" class="graf graf--p graf-after--figure">Based on the <strong class="markup--strong markup--p-strong">slower broadcast heuristic</strong>, we have to broadcast <code class="markup--code markup--p-code">RS4</code> in the first place. But it is quite strange that we haven’t got a tag <code class="markup--code markup--p-code">RS4</code> in the RAT because it has already been replaced by <code class="markup--code markup--p-code">ADD F4, F2, F3</code>. So we call the <code class="markup--code markup--p-code">(RS4) 0.74</code> a <strong class="markup--strong markup--p-strong">stale result</strong>.</p><p name="0acf" id="0acf" class="graf graf--p graf-after--p">But our question is that what will happen if we broadcast this result.</p><p name="3891" id="3891" class="graf graf--p graf-after--p">For filling the reservation stations, it is going to be done normally. So the operands with a <code class="markup--code markup--p-code">RS4</code> will be replaced by our broadcasted result.</p><p name="1893" id="1893" class="graf graf--p graf-after--p">However, for the register file and RAT, we actually do nothing. We don’t have to update this result to the RF and RAT not only because it does not exist in the RAT, but also because that the instructions come later will not use this value. Instead, when they refer to <code class="markup--code markup--p-code">F4</code>, they are actually calling <code class="markup--code markup--p-code">RS2</code>. The instructions that need the results of <code class="markup--code markup--p-code">RS4</code> have already been pushed into the reservation stations and after this broadcasting, the operand <code class="markup--code markup--p-code">RS4</code> will all be replaced by the result. So <code class="markup--code markup--p-code">RS4</code> will have no other usages in this case.</p><figure name="6d67" id="6d67" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*I4VPb39MHYSNvdpLby587Q.png" data-width="2018" data-height="992" src="https://cdn-images-1.medium.com/max/800/1*I4VPb39MHYSNvdpLby587Q.png"></figure><p name="9eab" id="9eab" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(12) Review of Tomasulo’s Algorithm</strong></p><p name="bb2c" id="bb2c" class="graf graf--p graf-after--p">For one instruction,</p><ul class="postList"><li name="3d40" id="3d40" class="graf graf--li graf-after--p">Take this instruction from the instruction queue</li><li name="1bea" id="1bea" class="graf graf--li graf-after--li">Issue this instruction to the register station</li><li name="e7f2" id="e7f2" class="graf graf--li graf-after--li">Rename the operands by RAT</li><li name="585e" id="585e" class="graf graf--li graf-after--li">If empty, get the register value from RF</li><li name="ccda" id="ccda" class="graf graf--li graf-after--li">Capture the broadcasted result from the other executed instruction</li><li name="e63b" id="e63b" class="graf graf--li graf-after--li">Check all the operands that we need is existing</li><li name="24b7" id="24b7" class="graf graf--li graf-after--li">Dispatch the instruction to the execution unit</li><li name="1859" id="1859" class="graf graf--li graf-after--li">After the execution, write the result to the common data bus</li><li name="5a0e" id="5a0e" class="graf graf--li graf-after--li">Broadcast the result to the reservation station</li><li name="253e" id="253e" class="graf graf--li graf-after--li">Free the reservation station corresponding to the current instruction</li><li name="410d" id="410d" class="graf graf--li graf-after--li">Broadcast the result to the RAT</li><li name="ca86" id="ca86" class="graf graf--li graf-after--li">If no corresponding tag in the RAT, abandon this result and finish</li><li name="43e7" id="43e7" class="graf graf--li graf-after--li">If there’s a corresponding tag, update the value in RF with respect to RAT</li><li name="d4a7" id="d4a7" class="graf graf--li graf-after--li">Then empty this tag in the RAT and finish</li></ul><p name="a76c" id="a76c" class="graf graf--p graf-after--li">Note that these are what happens for 1 instruction. However, in practice, during a particular cycle, some instructions might be issued, some instructions are waiting to capture their operands, some instructions are trying to be dispatched, and finally, some instructions are trying to write their results.</p><p name="6ba3" id="6ba3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(13) Multiple Phases for Tomasulo’s Algorithm</strong></p><p name="58d9" id="58d9" class="graf graf--p graf-after--p">Because all of these things can happen every cycle, there are some interesting things that we need to consider,</p><ul class="postList"><li name="3d55" id="3d55" class="graf graf--li graf-after--p">Can we dispatch an instruction immediately after issuing it if it doesn’t need to capture any results? The answer is typically <strong class="markup--strong markup--li-strong">no</strong> because we have to check which one to dispatch because there can be many instructions waiting for dispatching (see<strong class="markup--strong markup--li-strong"> dispatch more than 1 ready</strong>). However, it can be possible but we are not going to discuss it now.</li><li name="91d7" id="91d7" class="graf graf--li graf-after--li">Can we dispatch an instruction immediately after it captures the value it needs from the broadcasted result? The answer is typically <strong class="markup--strong markup--li-strong">no</strong> because also we have to check which one to dispatch and this must happen in the next cycle. But again, it can be possible but we are not going to discuss it now.</li><li name="0093" id="0093" class="graf graf--li graf-after--li">Can we update the RAT when there is an issuing and a writing result happen simultaneously? We have known that we can update the RAT during the renaming (part of issuing) and we can also update the RAT when we broadcast a result. If these things happen simultaneously, then it is possible that RAT will be written twice in turn. The answer is typically yes for this problem, but we have to keep in mind that we have to do result writing first and then issuing. This is because we want to keep the issuing result in the RAT, not the value after the result writing so that the later instructions will rename with the newly issued tag instead of the old one.</li></ul><p name="2e62" id="2e62" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">3. What’s Next?</strong></p><p name="4400" id="4400" class="graf graf--p graf-after--p graf--trailing">In this section, we have discussed how does Tomasulo’s Algorithm deal with the floating-point instructions. In the next section, we are going to continue with Tomasulo’s algorithm and see what will happen for load &amp; store instructions.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/8c65788dec07"><time class="dt-published" datetime="2021-01-28T06:11:40.343Z">January 28, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-13-tomasulos-algorithm-part-1-8c65788dec07" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>