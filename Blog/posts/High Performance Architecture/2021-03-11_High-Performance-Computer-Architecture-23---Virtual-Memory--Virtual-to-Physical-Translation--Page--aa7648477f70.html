<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 23 | Virtual Memory, Virtual to Physical Translation, Page…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 23 | Virtual Memory, Virtual to Physical Translation, Page…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="7214" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="753d" id="753d" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 23 | <strong class="markup--strong markup--h3-strong">Virtual Memory, Virtual to Physical Translation, Page Table, and Translation Look-Aside Buffer</strong></h3><figure name="0be6" id="0be6" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*m9KH39yOJkq80bAM.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*m9KH39yOJkq80bAM.png"></figure><ol class="postList"><li name="09af" id="09af" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Virtual Memory</strong></li></ol><p name="258a" id="258a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Processor’s View of Memory</strong></p><p name="cbba" id="cbba" class="graf graf--p graf-after--p">The processor sees what we called the <strong class="markup--strong markup--p-strong">physical memory</strong>, which is the memory contained in the <strong class="markup--strong markup--p-strong">actual memory modules</strong> that we bought and put on the system.</p><figure name="e6b1" id="e6b1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PxF5fSxWmkxd2IS-tinjDQ.png" data-width="1442" data-height="332" src="https://cdn-images-1.medium.com/max/800/1*PxF5fSxWmkxd2IS-tinjDQ.png"></figure><p name="fc06" id="fc06" class="graf graf--p graf-after--figure">The amount of the memory sometimes is even lower than 4 GB and it is almost never 4 GB per process we have in the system because we can have tens or hundreds of processes. Even though the memory address is 64 bits, which can be mapped to at most 16 EB per process, we will never have that much memory.</p><p name="6682" id="6682" class="graf graf--p graf-after--p">So the amount of physical memory we have is usually less than what all the programs can access. Actually, the addresses the processor uses for the physical memory have a <strong class="markup--strong markup--p-strong">1:1 mapping</strong> to the bytes or words in the physical memory. Thus, a given address always goes to the same physical location and a physical location always has exactly one physical address.</p><p name="d2ca" id="d2ca" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Program’s View of Memory</strong></p><p name="3372" id="3372" class="graf graf--p graf-after--p">The program usually sees a huge amount of memory and some continuous memory regions are actually used by the program. But there’s also an enormous region in the middle between the stack and the heap that the program will never access unless the stack and the heap keep growing. However, the heap is relatively small compared to how much space we have here because it’s a huge amount of memory.</p><p name="a85c" id="a85c" class="graf graf--p graf-after--p">As a result, although the program thinks that it has a lot of memory, what it really accesses when executing is actually a relatively small proportion.</p><p name="33b2" id="33b2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of Virtual Memory</strong></p><p name="1e39" id="1e39" class="graf graf--p graf-after--p">We have discussed that the program thinks that it virtually has a lot of memory, but in practice, there isn’t that much memory. Thus, this technique to deceive the programs is called <strong class="markup--strong markup--p-strong">virtual memory</strong>.</p><p name="b6c9" id="b6c9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Virtual to Physical Mapping</strong></p><p name="141a" id="141a" class="graf graf--p graf-after--p">When a program generates a virtual address, the processor needs to access some physical address. So how does the processor map what the program is trying to access to what the processor should be accessed?</p><p name="a1ff" id="a1ff" class="graf graf--p graf-after--p">The simplest idea is to build <strong class="markup--strong markup--p-strong">a large table</strong> that contains all the mapping rules for each program. However, we will not implement this in practice because these tables would consume a lot of our memory and it is quite hard to search a rule in a table.</p><p name="d52f" id="d52f" class="graf graf--p graf-after--p">A more advanced idea is to divide that virtual memory into small blocks (called <strong class="markup--strong markup--p-strong">pages</strong>) so that we can reduce the size of the mapping table. In addition, the physical memory will also be divided to small blocks (called <strong class="markup--strong markup--p-strong">frames</strong>) in order to adapt to the pages. Commonly, the size of a page/frame is 4 kB and the OS decides how to do the mapping.</p><figure name="a95a" id="a95a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*I1VmIdSLGZhLwc7FMUMcGg.png" data-width="1660" data-height="650" src="https://cdn-images-1.medium.com/max/800/1*I1VmIdSLGZhLwc7FMUMcGg.png"></figure><p name="8227" id="8227" class="graf graf--p graf-after--figure">Note that the actual mapping mechanism is called a page table that says for each page of a process, which frame will it be mapped in the physical memory.</p><p name="9b45" id="9b45" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Location of the Missing Memory</strong></p><p name="58af" id="58af" class="graf graf--p graf-after--p">In the example above, we can find out there are 4 pages being mapped to the physical memory. But where are the rest of these pages? The answer to this problem is that these pages are on the hard <strong class="markup--strong markup--p-strong">disk</strong>.</p><figure name="5dd8" id="5dd8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*HbAiE8WOrE70OQh_o1qt9g.png" data-width="1864" data-height="650" src="https://cdn-images-1.medium.com/max/800/1*HbAiE8WOrE70OQh_o1qt9g.png"></figure><p name="efd2" id="efd2" class="graf graf--p graf-after--figure">Because these pages are store in the disk, they can not be directly accessed by the processor and the processor can only load/store from the physical memory.</p><p name="a054" id="a054" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Virtual Address</strong></p><p name="6887" id="6887" class="graf graf--p graf-after--p">Similar to the cache memory, the virtual can be divided into two parts. Some least significant digits are called the <strong class="markup--strong markup--p-strong">page offset</strong>, which is used to identify which data we need in a frame of the physical memory. If we have a page size of 4 kB (i.e. 4*1024 Bytes), then the size of a page offset is 12 bits (because <code class="markup--code markup--p-code">log2(4*1024) = 12</code>).</p><p name="363b" id="363b" class="graf graf--p graf-after--p">The rest of the virtual address is called the <strong class="markup--strong markup--p-strong">virtual page number</strong>.</p><figure name="e8e3" id="e8e3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mqzzPrqMrx4Ha0vKYQrLBQ.png" data-width="1572" data-height="178" src="https://cdn-images-1.medium.com/max/800/1*mqzzPrqMrx4Ha0vKYQrLBQ.png"></figure><p name="37b7" id="37b7" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(7) Virtual Address: An Example</strong></p><p name="3b8c" id="3b8c" class="graf graf--p graf-after--p">Now, let’s see an example about the virtual address. Suppose we have a 32-bit virtual address and the page size is 4 kB,</p><pre name="d74a" id="d74a" class="graf graf--pre graf-after--p">0xFC51908B</pre><p name="f9dc" id="f9dc" class="graf graf--p graf-after--pre">Then the least significant 12 bits are telling us the page offset, which should be,</p><pre name="0ba8" id="0ba8" class="graf graf--pre graf-after--p">0x08B</pre><p name="6096" id="6096" class="graf graf--p graf-after--pre">The rest of this address is called the virtual page number,</p><pre name="3b38" id="3b38" class="graf graf--pre graf-after--p">0xFC519</pre><p name="a6d8" id="a6d8" class="graf graf--p graf-after--pre">Now, we will use this value to index into the <strong class="markup--strong markup--p-strong">page table</strong>. In this case, the index into the page table will be <code class="markup--code markup--p-code">0xFC519</code> and we will find an entry corresponding to this index in the page table.</p><figure name="22d8" id="22d8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jQmTubfYoUnzPeF66U1s3g.png" data-width="1614" data-height="664" src="https://cdn-images-1.medium.com/max/800/1*jQmTubfYoUnzPeF66U1s3g.png"></figure><p name="f801" id="f801" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(8) Page Table</strong></p><p name="6bee" id="6bee" class="graf graf--p graf-after--p">The page table tells us what the <strong class="markup--strong markup--p-strong">frame number</strong> corresponds to the given virtual page number.</p><figure name="dc56" id="dc56" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*hPryrqf96Jqko5Mj0xo73Q.png" data-width="1342" data-height="466" src="https://cdn-images-1.medium.com/max/800/1*hPryrqf96Jqko5Mj0xo73Q.png"></figure><p name="b975" id="b975" class="graf graf--p graf-after--figure">So generally, now the diagram will become,</p><figure name="a11e" id="a11e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*avM-HMdfEKx_jMrRwCEgGw.png" data-width="1498" data-height="660" src="https://cdn-images-1.medium.com/max/800/1*avM-HMdfEKx_jMrRwCEgGw.png"></figure><p name="9679" id="9679" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(9) Virtual to Physical Address Translation</strong></p><p name="e7be" id="e7be" class="graf graf--p graf-after--p">Now that we have the corresponding frame number based on our virtual page number, and what we need to do now is to generate the physical address that we need. This operation is called a virtual to physical <strong class="markup--strong markup--p-strong">address translation</strong>.</p><p name="f5ac" id="f5ac" class="graf graf--p graf-after--p">After we retrieve the physical frame number from the page table, the page offset and the physical frame number will be put together to generate the <strong class="markup--strong markup--p-strong">physical address</strong>. Then this physical address is what we use to actually access the physical memory.</p><figure name="dd14" id="dd14" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WQMm8MGWKTKdaR_u6T0ejw.png" data-width="1836" data-height="712" src="https://cdn-images-1.medium.com/max/800/1*WQMm8MGWKTKdaR_u6T0ejw.png"></figure><p name="1607" id="1607" class="graf graf--p graf-after--figure">In our example above, the physical address would be,</p><pre name="edde" id="edde" class="graf graf--pre graf-after--p">0x0051208B</pre><p name="5129" id="5129" class="graf graf--p graf-after--pre">Note that the page offset is present in both the virtual and physical address, so during the virtual to physical address translation, the least significant bits of the virtual address does not change.</p><p name="1795" id="1795" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) Virtual to Physical Address Translation: An Example</strong></p><p name="539a" id="539a" class="graf graf--p graf-after--p">Now, let’s see an example of the virtual to physical address translation. Suppose we have a 4-entry page table as follows,</p><pre name="c345" id="c345" class="graf graf--pre graf-after--p">Page Table <br>-------------<br>0x1F<br>0x3F<br>0x23<br>0x17</pre><p name="da8c" id="da8c" class="graf graf--p graf-after--pre">Also, the virtual address takes 16 bits, and the physical address takes 20 bits. And let’s translate the following virtual addresses to the physical addresses,</p><pre name="2022" id="2022" class="graf graf--pre graf-after--p">0xF0F0<br>0x001F</pre><p name="4dbf" id="4dbf" class="graf graf--p graf-after--pre">Because we only have 4 entries in the page table, the size of the virtual page number that we will use for indexing the page table will be 2 bits. Then because the virtual address takes 16 bits, the page offset takes 14 bits. The binary forms of these virtual addresses are,</p><pre name="cec1" id="cec1" class="graf graf--pre graf-after--p">11<strong class="markup--strong markup--pre-strong">11 0000 1111 0000</strong><br>00<strong class="markup--strong markup--pre-strong">00 0000 0001 1111</strong></pre><p name="5009" id="5009" class="graf graf--p graf-after--pre">The offset will not be changed and we grab the corresponding physical frame number based on the page table. So the physical frame number we are going to have, are</p><pre name="e46f" id="e46f" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">Index   Frame Number   Binary</strong><br>-----   ------------   ------------<br>11      0x17           0001 0111<br>00      0x1F           0001 1111</pre><p name="351a" id="351a" class="graf graf--p graf-after--pre">Then we replace the virtual page number with the physical frame number (note that we should keep the offsets), so,</p><pre name="9226" id="9226" class="graf graf--pre graf-after--p">0001 0111 <strong class="markup--strong markup--pre-strong">11 0000 1111 0000<br></strong>0001 1111 <strong class="markup--strong markup--pre-strong">00 0000 0001 1111</strong></pre><p name="d2b5" id="d2b5" class="graf graf--p graf-after--pre">Reorganize these two addresses, we will have,</p><pre name="e403" id="e403" class="graf graf--pre graf-after--p">00 0101 11<strong class="markup--strong markup--pre-strong">11 0000 1111 0000<br></strong>00 0111 11<strong class="markup--strong markup--pre-strong">00 0000 0001 1111</strong></pre><p name="941c" id="941c" class="graf graf--p graf-after--pre">Because each physical address takes 20 bits, we can remove the most significant 2 bits because they are 0s. So the physical addresses are,</p><pre name="1a3f" id="1a3f" class="graf graf--pre graf-after--p">0101 11<strong class="markup--strong markup--pre-strong">11 0000 1111 0000<br></strong>0111 11<strong class="markup--strong markup--pre-strong">00 0000 0001 1111</strong></pre><p name="5e9e" id="5e9e" class="graf graf--p graf-after--pre">This is also,</p><pre name="fe22" id="fe22" class="graf graf--pre graf-after--p">0x5F010<br>0x7C01F</pre><p name="897d" id="897d" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Page Table Optimization</strong></p><p name="b307" id="b307" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of the Flat Page Table</strong></p><p name="9648" id="9648" class="graf graf--p graf-after--p">What we have discussed is so-called the <strong class="markup--strong markup--p-strong">flat page table</strong> where for every page number, there is an entry corresponding to it.</p><p name="28e0" id="28e0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Size of Flat Page Table</strong></p><p name="6286" id="6286" class="graf graf--p graf-after--p">Based on the definition of the flat page table, we can know that,</p><ul class="postList"><li name="db27" id="db27" class="graf graf--li graf-after--p">1 entry (of the page table) per page (in the virtual address space)</li></ul><p name="0435" id="0435" class="graf graf--p graf-after--li">An entry in the page table contains <strong class="markup--strong markup--p-strong">frame numbers</strong> and a few bits (e.g. the protection bits) that can be used to tell us if the page is <strong class="markup--strong markup--p-strong">accessible</strong>. So even though some pages in the page table are never accessed, the table keeps them, and thus the table can become unnecessarily large.</p><p name="0998" id="0998" class="graf graf--p graf-after--p">The size of a flat page table can be calculated as,</p><figure name="925a" id="925a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*iR6D3L-fhfptpNab0j36MQ.png" data-width="1422" data-height="76" src="https://cdn-images-1.medium.com/max/800/1*iR6D3L-fhfptpNab0j36MQ.png"></figure><p name="4986" id="4986" class="graf graf--p graf-after--figure">Because the number of the entries equals the number of the pages, the expression can be written as,</p><figure name="8ce4" id="8ce4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*7DdLFxTemdRvfNNNf6RLxg.png" data-width="1422" data-height="106" src="https://cdn-images-1.medium.com/max/800/1*7DdLFxTemdRvfNNNf6RLxg.png"></figure><p name="6d40" id="6d40" class="graf graf--p graf-after--figure">Imagine that we have a virtual memory of 4 GB and each page has a size of 4 KB. Also, the size per entry is 4 bytes. Then we can calculate the page table size for this virtual address space as,</p><pre name="0f19" id="0f19" class="graf graf--pre graf-after--p">PT_size = 4GB/4KB * 4B = 1024*1024*4 = 2^22 Bytes = 4 MB</pre><p name="260e" id="260e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Flat Page Table Evaluation</strong></p><p name="800c" id="800c" class="graf graf--p graf-after--p">If we have a large virtual address space, the size of a flat page table can be enormous. For example, the modern addresses will be 64 bits and if the application thinks that it can use all these memories, the size of address space it would have should be <code class="markup--code markup--p-code">2^64</code> bytes. Then for a 4 KB per page and 4 B per entry table, the page table size would be,</p><pre name="9a20" id="9a20" class="graf graf--pre graf-after--p">PT_size = 2^64B/4KB * 4B = 2^14 TB = 16 PB</pre><p name="12ba" id="12ba" class="graf graf--p graf-after--pre">For modern computers, this can be impossible because we can not have a memory of 16 petabytes. So the main problem with the flat page table is the size of it.</p><p name="824f" id="824f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Multi-Level Page Tables Idea</strong></p><p name="28e7" id="28e7" class="graf graf--p graf-after--p">We have seen that the flat page table can be quite large even for 32-bit addresses, and it will be nearly impossible to implement for 64-bit addresses. Let’s see the multi-level page table that answers how we reduce the size of the page table when we have a large address space.</p><p name="956e" id="956e" class="graf graf--p graf-after--p">Let’s first recall the structure of virtual memory space. Suppose we have a 64-bit system (means that all the virtual addresses are 64 bits), then the virtual memory space should be,</p><figure name="e606" id="e606" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*H4G1VoFve361pKjPPyPbRw.png" data-width="1984" data-height="1048" src="https://cdn-images-1.medium.com/max/800/1*H4G1VoFve361pKjPPyPbRw.png"></figure><p name="2197" id="2197" class="graf graf--p graf-after--figure">At the beginning of the virtual memory, there is the <strong class="markup--strong markup--p-strong">code</strong>, the static variables (<strong class="markup--strong markup--p-strong">data</strong>), and the <strong class="markup--strong markup--p-strong">heap</strong> that grows to the top. At the top of the virtual address space, there is the <strong class="markup--strong markup--p-strong">stack</strong> that grows to the bottom. So what is actually useful for us are two contiguous regions of virtual memory that actually used by the application.</p><figure name="bc9c" id="bc9c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*2eFNUGGPLvPAZ7G3GYUUVA.png" data-width="1782" data-height="1048" src="https://cdn-images-1.medium.com/max/800/1*2eFNUGGPLvPAZ7G3GYUUVA.png"></figure><p name="6b40" id="6b40" class="graf graf--p graf-after--figure">For a multi-level page table, even though we will also use some bits of the virtual addresses for indexing, we want to avoid the use of the table entries that correspond to the huge unused space. So the basic idea is to try to <strong class="markup--strong markup--p-strong">omit the unused space</strong> in the virtual space.</p><p name="12bb" id="12bb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Two-Level Page Table Implementation</strong></p><p name="da6a" id="da6a" class="graf graf--p graf-after--p">The virtual memory also consists of the virtual page number and the page offset. The difference is that the virtual page number will be divided into the <strong class="markup--strong markup--p-strong">outer page number</strong> (more significant bits) and the <strong class="markup--strong markup--p-strong">inner page number</strong> (less significant bits). These two numbers will index to different tables.</p><figure name="ae74" id="ae74" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*uDm_ay2J76Pf_Z-XACq51Q.png" data-width="1474" data-height="248" src="https://cdn-images-1.medium.com/max/800/1*uDm_ay2J76Pf_Z-XACq51Q.png"></figure><p name="8209" id="8209" class="graf graf--p graf-after--figure">In the previous example, the outer page number tells us which part of the large page table we will be using and the inner page number tells us which specific entry in that large page table we would be using.</p><p name="5431" id="5431" class="graf graf--p graf-after--p">However, instead of having a large page table, the outer page number is now used to index into the <strong class="markup--strong markup--p-strong">outer page table</strong>. And each entry in the outer page table tells us which <strong class="markup--strong markup--p-strong">inner page table</strong> do we need to find. The inner page number is then used to index into the inner page table and what we can find there is the actual frame number to access.</p><figure name="b001" id="b001" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MoGGb1mBri2BwBhWsYGEAQ.png" data-width="1958" data-height="966" src="https://cdn-images-1.medium.com/max/800/1*MoGGb1mBri2BwBhWsYGEAQ.png"></figure><p name="fa94" id="fa94" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) Two-Level Page Table: An Example</strong></p><p name="9826" id="9826" class="graf graf--p graf-after--p">Now, let’s see a really simple example of the two-level page table. Suppose we have a virtual address with 8 bits. The least significant 4 bits are the offset and the most significant 4 bits are the page number (with a 2-bit outer page number and a 2-bit inner page number).</p><figure name="a8ad" id="a8ad" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*43SePPmBsgcuyC5RwSWCdQ.png" data-width="1958" data-height="1172" src="https://cdn-images-1.medium.com/max/800/1*43SePPmBsgcuyC5RwSWCdQ.png"></figure><p name="dde4" id="dde4" class="graf graf--p graf-after--figure">In this case, the cost for a flat page table is 16 entries, while the cost for the outer page table and inner page tables is 20 entries (i.e. <code class="markup--code markup--p-code">5*4 = 20</code> entries). We can observe that the implementation has an even higher cost compared with the flat page table. So where are the savings?</p><p name="6407" id="6407" class="graf graf--p graf-after--p">The saving is that if there is an unused large part of the address space (e.g. like the unused space between the heap and stack), the corresponding part in the outer page table will be marked as <strong class="markup--strong markup--p-strong">unnecessary</strong>, and the corresponding inner page table will be eliminated. For example,</p><figure name="5811" id="5811" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*AXpLz6mIwKzpM7ODusbwmQ.png" data-width="1958" data-height="1190" src="https://cdn-images-1.medium.com/max/800/1*AXpLz6mIwKzpM7ODusbwmQ.png"></figure><p name="c508" id="c508" class="graf graf--p graf-after--figure">And now, the cost for all the outer/inner page tables will be 12 entries (i.e. <code class="markup--code markup--p-code">3*4 = 12</code>). In a larger address space, the outer page table will have many pointers and most of these pointers will point to an unused inner page table. So we can simply eliminate these pointers from the outer page table.</p><p name="8c76" id="8c76" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Size of Two-Level Page Table</strong></p><p name="e5e1" id="e5e1" class="graf graf--p graf-after--p">Now, let’s discuss a real case about the size of a two-level page table. Suppose we have a <strong class="markup--strong markup--p-strong">32-bit address space</strong> with a <strong class="markup--strong markup--p-strong">page size of 4 KB</strong>. Each of the outer page table and the inner page tables will have 1024 entries, and each entry takes 8 bytes.</p><p name="5c3f" id="5c3f" class="graf graf--p graf-after--p">Assume that we have a program that uses the virtual memory from <code class="markup--code markup--p-code">0x0</code> to <code class="markup--code markup--p-code">0x1000</code> and from <code class="markup--code markup--p-code">0xffff0000</code> to <code class="markup--code markup--p-code">0xffffffff</code>. Calculate the size of a <strong class="markup--strong markup--p-strong">flat page table</strong> and the size of a <strong class="markup--strong markup--p-strong">two-level page table</strong>.</p><p name="19ca" id="19ca" class="graf graf--p graf-after--p">According to the definition of a flat page table, each of the addresses will be mapped to an entry. So the flat page table size will be 8 MB (i.e. 2³²/2¹² * 8 = 8 MB).</p><p name="8dbb" id="8dbb" class="graf graf--p graf-after--p">For the two-level page table, because the outer page table and the inner page tables each have 1024 entries, so both the outer page number and the inner page number are 10 bits long. Because the virtual address is 32 bits, then the offset is 12 bits (i.e. <code class="markup--code markup--p-code">32 - 10 - 10 = 12</code>). So for the virtual addresses,</p><pre name="9c2b" id="9c2b" class="graf graf--pre graf-after--p">No    VA              Offset      Inner             Outer<br>---   -----------     -------     -------------     -------------<br>VA1   0x00000000      0x000       00 0000 0000      0000 0000 00<br>VA2   0x00001000      0x000       00 0000 0001      0000 0000 00 <br>VA3   0xffff0000      0x000       11 1111 0000      1111 1111 11<br>VA4   0xffffffff      0xfff       11 1111 1111      1111 1111 11</pre><p name="6bf3" id="6bf3" class="graf graf--p graf-after--pre">We can find out that the VA1 and VA2 have the same outer page number and the VA3 and VA4 have the same outer page number. Thus, VA1 and VA2 will be mapped to the same inner page table (№ 0), while VA3 and VA4 will also be mapped to the same inner page table (№ 1023). Because all the other memories are not used by the program, we will not assign inner page tables to the corresponding pointers.</p><p name="666b" id="666b" class="graf graf--p graf-after--p">Thus, for this two-level page table, we have used 1 outer page table and 2 inner page tables. So the overall cost is 24 KB (i.e. <code class="markup--code markup--p-code">3*1024*8 = 24 KB</code>), and we can observe a huge saving compared with the flat page table.</p><p name="4379" id="4379" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Size of Four-Level Page Table</strong></p><p name="4c1c" id="4c1c" class="graf graf--p graf-after--p">In the case above, we have discussed how to calculate the size of a 2LPT. Now let’s see how we can calculate the size of a 4LPT. Suppose we have a 64-bit virtual address space with 64 KB per page. The size of an entry in the page table is 8 bytes, and the program only uses the addresses from 0 to 4GB.</p><p name="5951" id="5951" class="graf graf--p graf-after--p">Assume we have a 4LPT with the page number split equally, then calculate the size of this 4LP table.</p><p name="5b88" id="5b88" class="graf graf--p graf-after--p">In this case, we can know that the offset should be 16 bits (i.e. <code class="markup--code markup--p-code">log2(64*1024) = 16</code>), and because the page number is split equally, they should have 12 bits each (i.e. <code class="markup--code markup--p-code">(64 - 16)/3 = 12</code>). So for the beginning VA to the ending VA, we will then have,</p><pre name="fce8" id="fce8" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">VA </strong>        0x0000 0000 0000 0000       0x0000 0001 0000 0000<br>------     ---------------------       ----------------------<strong class="markup--strong markup--pre-strong"><br>Offset </strong>    0x0000                      0x0000<br><strong class="markup--strong markup--pre-strong">Outer1 </strong>    0x000                       0x000<br><strong class="markup--strong markup--pre-strong">Outer2</strong>     0x000                       0x000<br><strong class="markup--strong markup--pre-strong">Outer3 </strong>    0x000                       0x010<br><strong class="markup--strong markup--pre-strong">Inner </strong>     0x000                       0x000</pre><p name="2761" id="2761" class="graf graf--p graf-after--pre">Based on this table, we can know that all the pages we need will be on the same outer page table 1, the same outer page table 2, and the same outer page table 3. But they will be in the different inner page tables. The outer 3 have a range from <code class="markup--code markup--p-code">0x000</code> to <code class="markup--code markup--p-code">0x010</code>, which contains 16 inner page tables in this range. Thus, we can have the following diagram,</p><figure name="dd91" id="dd91" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fMe3ITIN2H_eX431uERxNg.png" data-width="1958" data-height="624" src="https://cdn-images-1.medium.com/max/800/1*fMe3ITIN2H_eX431uERxNg.png"></figure><p name="f2d8" id="f2d8" class="graf graf--p graf-after--figure">As a result, in total, we will have 19 tables (i.e. 3 outers and 16 inners) and each of them has 4096 entries (i.e. 2¹²). Because we have known that each entry takes 8 bytes, the overall size of this 4LPT will be 608 KB (i.e. 19* 4096*8 B = 608 KB).</p><p name="ef47" id="ef47" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Page Size: Large or Small</strong></p><p name="8467" id="8467" class="graf graf--p graf-after--p">We have known that the page size decides how many addresses we can have on a page. When we have a large page size, we will have more bits for page offsets. When we have a smaller page size, we will have fewer bits for page offsets. So should we have a large page size or a small page size? Here are some concerns,</p><ul class="postList"><li name="0557" id="0557" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Size of page table</strong></li></ul><p name="b67d" id="b67d" class="graf graf--p graf-after--li">Because when we have a smaller page size, we will have more addresses on a page. Then the page table would be larger. Normally, a smaller page table will be preferred because the cost will be lower for us. So we may want to choose a <strong class="markup--strong markup--p-strong">larger</strong> page size.</p><ul class="postList"><li name="b535" id="b535" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Internal Fragmentation</strong></li></ul><p name="f55d" id="f55d" class="graf graf--p graf-after--li">Internal fragmentation is a situation that happens when the application requests some amount of space but we can only allocate space more than the amount it requests. For example, in the following diagram, we end up giving a page with some wasted space if we have a larger table.</p><figure name="a314" id="a314" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*8PeIvm-csZxowRnaSSz-Mg.png" data-width="1514" data-height="362" src="https://cdn-images-1.medium.com/max/800/1*8PeIvm-csZxowRnaSSz-Mg.png"></figure><p name="f980" id="f980" class="graf graf--p graf-after--figure">In terms of this situation, we may want to choose a smaller page table, and thus, a <strong class="markup--strong markup--p-strong">smaller</strong> page size is preferred.</p><p name="a926" id="a926" class="graf graf--p graf-after--p">So just like the block size of caches, what we finally want is a <strong class="markup--strong markup--p-strong">compromise</strong>.</p><p name="464f" id="464f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Translation Look-Aside Buffer</strong></p><p name="70dc" id="70dc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Steps of Virtual to Physical Translation</strong></p><p name="fffd" id="fffd" class="graf graf--p graf-after--p">Suppose we have the following operation,</p><pre name="a16d" id="a16d" class="graf graf--pre graf-after--p">LW R1, 4(R2)</pre><p name="d57c" id="d57c" class="graf graf--p graf-after--pre">Then the <code class="markup--code markup--p-code">4(R2)</code> is actually the virtual memory. So for a load/store operation, we need to follow the following steps:</p><ul class="postList"><li name="a4c0" id="a4c0" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Step 1</strong>. Compute virtual address</li><li name="6f75" id="6f75" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 2</strong>. Compute page number (take some bits from the VA)</li><li name="710c" id="710c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 3</strong>. Compute the physical address and the page table entry. This is done by adding the page number we computed to the beginning address of the page table.</li><li name="0bda" id="0bda" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 4</strong>. Read actual page table entry (slow, because the page table is actually in the memory and it is treated as a cache miss)</li><li name="b732" id="b732" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 5</strong>. Compute the physical address (fast, because this is only a bit operation)</li><li name="6fef" id="6fef" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 6</strong>. Access cache or memory (if there’s a cache miss)</li></ul><p name="0577" id="0577" class="graf graf--p graf-after--li">When we have an NLPT (aka. N-Level Page Table), we need to operate step 3 to step 5 for N times. So we need N memory accesses to read N page entries until we get the actual translation. So the virtual to physical translation is sometimes costing us more than the memory accesses that we try to avoid by having the caches.</p><p name="68ca" id="68ca" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Memory Access Time for Virtual to Physical Translation</strong></p><p name="eddb" id="eddb" class="graf graf--p graf-after--p">Let’s see an example. Suppose we need,</p><ul class="postList"><li name="4469" id="4469" class="graf graf--li graf-after--p">1 cycle to compute the physical address</li><li name="63dd" id="63dd" class="graf graf--li graf-after--li">1 cycle to access cache</li><li name="9a44" id="9a44" class="graf graf--li graf-after--li">10 cycles to access memory</li><li name="f52d" id="f52d" class="graf graf--li graf-after--li">90% cache hit rate for data</li></ul><p name="61c3" id="61c3" class="graf graf--p graf-after--li">Assume that the page table entries can not be cached, how many cycles we should pay for the instruction <code class="markup--code markup--p-code">LW R1, 4(R2)</code> if we have a 3PLT?</p><p name="4bfc" id="4bfc" class="graf graf--p graf-after--p">The answer to this question is that we need to have 33 cycles. In order to read from the virtual address <code class="markup--code markup--p-code">4(R2)</code>, we have to do a virtual to physical translation at the beginning. Because all the table entries are not in the cache, we have to access the memory each time we need to access a page table. Because we have a three-level page table model, we need to access the page tables three times. This means that we have to access the memory three times.</p><p name="a940" id="a940" class="graf graf--p graf-after--p">So the overall cycles have to be,</p><pre name="16b6" id="16b6" class="graf graf--pre graf-after--p">Cycles = 3 * (access memory) + (compute PA) + (check cache) + (miss rate)*(miss penality)</pre><p name="2c32" id="2c32" class="graf graf--p graf-after--pre">Thus, we have,</p><pre name="0698" id="0698" class="graf graf--pre graf-after--p">Cycles = 3*10 + 1 + 1 + (1-90%)*10 = 33</pre><p name="fd07" id="fd07" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Translation Look-Aside Buffer (TLB)</strong></p><p name="9542" id="9542" class="graf graf--p graf-after--p">To speed up the virtual to physical translation, which, as we have seen, is the most time-consuming part, the processor includes a structure called the <strong class="markup--strong markup--p-strong">translation look-aside buffer (aka. TLB)</strong>.</p><p name="4179" id="4179" class="graf graf--p graf-after--p">The TLB is a cache for translations and it doesn’t contain the data. This makes the TLB relatively <strong class="markup--strong markup--p-strong">small</strong> compared with the cache, and the TLB can be also very <strong class="markup--strong markup--p-strong">fast</strong> to access.</p><p name="3833" id="3833" class="graf graf--p graf-after--p">TLB is a buffer that stores the mappings of the virtual page number to the physical frame number regardless of the intermediate page tables we need to access the physical frame number. For example, if we have a program that accesses data of 16 KB, and the page size should be 4 KB. Then in the TLB, there will only be 4 entries that show how to translate the virtual address.</p><p name="811a" id="811a" class="graf graf--p graf-after--p">You can consider that TLB is a reduced 1 level page table with all the unused spaces ignored.</p><p name="d400" id="d400" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) TLB Properties</strong></p><p name="14a3" id="14a3" class="graf graf--p graf-after--p">There are several properties of the TLB that provide us convenience,</p><ul class="postList"><li name="099c" id="099c" class="graf graf--li graf-after--p">TLB is<strong class="markup--strong markup--li-strong"> small</strong> compared with the cache</li><li name="93b2" id="93b2" class="graf graf--li graf-after--li">TLB is<strong class="markup--strong markup--li-strong"> fast</strong> to access. This means we can operate the virtual to physical translation in 1 or 2 cycles if we have a TLB hit</li><li name="4a11" id="4a11" class="graf graf--li graf-after--li">TLB only stores the <strong class="markup--strong markup--li-strong">final translation</strong>, so we can ignore the intermediate stages</li></ul><p name="d2d9" id="d2d9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) TLB Miss and</strong></p><p name="7624" id="7624" class="graf graf--p graf-after--p">We have talked about the TLB hit. Now let’s consider what will happen if we have a <strong class="markup--strong markup--p-strong">TLB miss</strong>. A TLB miss means that we don’t have the mapping rule of a virtual page number in the TLB.</p><p name="268e" id="268e" class="graf graf--p graf-after--p">In that case, we need to,</p><ul class="postList"><li name="b438" id="b438" class="graf graf--li graf-after--p">perform the translation using the <strong class="markup--strong markup--li-strong">page tables</strong></li><li name="ec44" id="ec44" class="graf graf--li graf-after--li">After we find the physical frame number, it will be <strong class="markup--strong markup--li-strong">put back to the TLB</strong> so that it can be used later when we access the same page again.</li></ul><p name="f37a" id="f37a" class="graf graf--p graf-after--li">For our computer, both the <strong class="markup--strong markup--p-strong">OS</strong> and the <strong class="markup--strong markup--p-strong">processor</strong> itself can do the two steps above. If the OS is used for handling a TLB miss, it is then called a <strong class="markup--strong markup--p-strong">software TLB miss handling</strong>. Instead of using a real page table, the OS can use something more interesting like a binary tree or a hash table.</p><p name="58ca" id="58ca" class="graf graf--p graf-after--p">If the processor is used to handle the TLB misses, it is called the <strong class="markup--strong markup--p-strong">hardware TLB miss handling</strong>. In this case, the page tables need to be in a form that can be easily accessed by the hardware (e.g. a flat page table or an MLPT). Even though the page tables are more complicated, it is <strong class="markup--strong markup--p-strong">faster</strong> than the software handling.</p><p name="4c2c" id="4c2c" class="graf graf--p graf-after--p">Because the hardware is cheaper today, most high-performance processors like x86 will use the hardware TLB miss handling approach. While some embedded processors that are restricted on the hardware performance may choose to use the software TLB miss handling approach because they are more concerned about the hardware cost.</p><p name="5b65" id="5b65" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Multi-Level TLB</strong></p><p name="f22f" id="f22f" class="graf graf--p graf-after--p">We have known that the TLB is very small and fast to access. But what if we want to reduce the TLB miss rate and have more entries in the TLB. We can not simply add more entries in the TLB because by doing so, the TLB will be slower.</p><p name="bde6" id="bde6" class="graf graf--p graf-after--p graf--trailing">One way to deal with that is to use a <strong class="markup--strong markup--p-strong">multi-level TLB</strong>. The level-1 TLB will be small and fast and the level-2 TLB can be large and slow. If we have a TLB miss in the L1 TLB, we will then go to the L2 TLB to search for the physical frame number we need.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/aa7648477f70"><time class="dt-published" datetime="2021-03-11T18:13:19.828Z">March 11, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-23-virtual-memory-virtual-to-physical-translation-page-aa7648477f70" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>