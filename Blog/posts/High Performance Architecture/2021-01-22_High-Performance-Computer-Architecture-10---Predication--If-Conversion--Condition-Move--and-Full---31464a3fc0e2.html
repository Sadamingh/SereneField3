<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 10 | Predication, If-Conversion, Condition Move, and Full …</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 10 | Predication, If-Conversion, Condition Move, and Full …</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="7116" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="98a9" id="98a9" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 10 | <strong class="markup--strong markup--h3-strong">Predication, If-Conversion, Condition Move, and Full </strong>Predication</h3><figure name="07e7" id="07e7" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*40xkHMRntM_UtIE1.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*40xkHMRntM_UtIE1.png"></figure><p name="0a4d" id="0a4d" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">1. The Definition of Predication</strong></p><p name="7e87" id="7e87" class="graf graf--p graf-after--p">We already know about the branch predictors, but we also know some of the branches are really difficult to predict even when we have a sophisticated branch predictor. So it is a good idea to avoid branches that are hard to predict by the compiler.</p><p name="7321" id="7321" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Predication</strong> is another way that we can try to deal with control hazards. Recall that we have used the branch predictions to guess the branch direction and the target, while predication is another method for dealing with the control dependencies. The problem with the branch predications is mainly that we have to pay a <strong class="markup--strong markup--p-strong">huge penalty</strong> if we mispredict the result for the modern processors.</p><p name="1eb0" id="1eb0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Predication</strong> is about doing the work in <strong class="markup--strong markup--p-strong">both directions</strong>, which means that we have to do both the taken branch and not the taken branch. In this way, the <strong class="markup--strong markup--p-strong">waste is up to 50%</strong> of the work we have been doing because we simply throw away the work from the wrong path. Therefore, the predication actually gives a penalty of waste for all the branches.</p><p name="24e1" id="24e1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Prediction Vs. Predication: Which one to choose?</strong></p><p name="9dc5" id="9dc5" class="graf graf--p graf-after--p">Let’s see how the <strong class="markup--strong markup--p-strong">branch prediction</strong> and <strong class="markup--strong markup--p-strong">predication </strong>compare on different types of conditional branches that we may want to predict.</p><ul class="postList"><li name="9343" id="9343" class="graf graf--li graf-after--p">For a <strong class="markup--strong markup--li-strong">loop</strong>, we usually want to do branch <strong class="markup--strong markup--li-strong">prediction</strong> because the iterations are often quite predictable. The predication will waste too much for getting the true result.</li><li name="d4b1" id="d4b1" class="graf graf--li graf-after--li">For a <strong class="markup--strong markup--li-strong">function call</strong> or <strong class="markup--strong markup--li-strong">return</strong>, we should also use <strong class="markup--strong markup--li-strong">prediction</strong> because predication actually makes no sense. Because the calls or returns are always taken branches, so it makes no sense if we waste something on the not taken state.</li><li name="3f15" id="3f15" class="graf graf--li graf-after--li">For a <strong class="markup--strong markup--li-strong">large if-then-else</strong>, we are also going to choose the <strong class="markup--strong markup--li-strong">prediction</strong>. In most cases, the if-then-else shows a pattern that can have only a few mispredictions. So the penalty of waste is even larger than the penalty for misprediction when it is large.</li><li name="775a" id="775a" class="graf graf--li graf-after--li">For a <strong class="markup--strong markup--li-strong">small if-then-else</strong>, surprisingly, the<strong class="markup--strong markup--li-strong"> predication</strong> will be better especially for a relatively low predictor accuracy. Let’s see an example to understand this. Suppose we have 5 instructions for taken and another 5 instructions for not taken branch. If we mispredict the branch, we will lose 50 instructions (HUGE penalty).</li></ul><pre name="9808" id="9808" class="graf graf--pre graf-after--li">If predication: cost 10 instructions (5 are wasted)<br>If prediction: <br>- if we have right prediction: cost 5 instructions with 0 penalty <br>- if we have misprediction: cost 55 instructions with 50 penalty</pre><p name="0d1b" id="0d1b" class="graf graf--p graf-after--pre">So now this problem seems like gambling. If you choose to predicate, you will lose 10 anyway. If you choose to predict, you may lose 55 or nothing. What actually determines whether or not you will take this risk of losing 55? The answer is the accuracy of the predictor.</p><p name="f37d" id="f37d" class="graf graf--p graf-after--p">Let’s say if we have a perfect predictor that never mispredicts the result, then of course we will choose to predict. However, when we have a normal 2BC predictor with 88% accuracy, we will then expect to lose <code class="markup--code markup--p-code">12% * 50 = 6</code> as our penalty, while the predication must lose <code class="markup--code markup--p-code">5</code> , which is smaller than <code class="markup--code markup--p-code">6</code>. Therefore, the predication now seems like a good idea.</p><p name="3747" id="3747" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. If-Conversion Technique</strong></p><p name="a89e" id="a89e" class="graf graf--p graf-after--p">The if-conversion is important for understanding how the predication works in the hardware. The <strong class="markup--strong markup--p-strong">if-conversion </strong>talks about how the compiler creates the code that will be executed along both paths. Let’s see an example. Suppose we have the following C code,</p><pre name="a7f7" id="a7f7" class="graf graf--pre graf-after--p">if (cond) {<br>    x = arr[i];<br>    y += 1;<br>} else {<br>    x = arr[j];<br>    y -= 1;<br>}</pre><p name="d628" id="d628" class="graf graf--p graf-after--pre">The if-conversion means that the compiler will compile the work on both paths, then,</p><pre name="f2b7" id="f2b7" class="graf graf--pre graf-after--p">x1 = arr[i];<br>x2 = arr[j];<br>y1 = y + 1;<br>y2 = y + 2;<br>x = cond?x1:x2;<br>y = cond?y1:y2;</pre><p name="1ad0" id="1ad0" class="graf graf--p graf-after--pre">But there is still a question on how do we compile the decision-making tool <code class="markup--code markup--p-code">cond?A:B;</code>. Someone may think that this is going to be like,</p><pre name="7019" id="7019" class="graf graf--pre graf-after--p">BEQ ..., Label<br>MOV x, x2<br>B Done<br>Label: <br>    MOV x, x1<br>Done:</pre><p name="d90e" id="d90e" class="graf graf--p graf-after--pre">Well, this is <strong class="markup--strong markup--p-strong">WRONG</strong>. The reason is that we want to use the predication for not predicting anything. However, the conversion above still has one conditional branch that we must guess the direction and the target. Because we have two decision-making tools in our program so there will be 2 branches that we need to guess. Let’s say if we have a GShare predictor, now we are going to have 2 mispredictions. Meanwhile, we still do both paths so there is also a 50% waste. However, if you look back to the C code, you will find that there may be only 1 misprediction without wastes. Therefore, the <code class="markup--code markup--p-code">cond?A:B;</code> can not be converted in that way and we must not add branches to our conversion.</p><p name="9e32" id="9e32" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. Conditional Move Technique</strong></p><p name="a831" id="a831" class="graf graf--p graf-after--p">So the technique that we are going to use for a decision-making tool is the conditional move. For <strong class="markup--strong markup--p-strong">MIPS</strong>, the conditional move should be,</p><pre name="d5b1" id="d5b1" class="graf graf--pre graf-after--p">MOVZ Rd, Rs, Rt</pre><p name="9ec7" id="9ec7" class="graf graf--p graf-after--pre">which means,</p><pre name="dc13" id="dc13" class="graf graf--pre graf-after--p">if (Rt == 0) {<br>    Rd = Rs;<br>}</pre><p name="3dfc" id="3dfc" class="graf graf--p graf-after--pre">Or,</p><pre name="de85" id="de85" class="graf graf--pre graf-after--p">MOVN Rd, Rs, Rt</pre><p name="7d3f" id="7d3f" class="graf graf--p graf-after--pre">which means,</p><pre name="2e54" id="2e54" class="graf graf--pre graf-after--p">if (Rt != 0) {<br>    Rd = Rs;<br>}</pre><p name="2fc2" id="2fc2" class="graf graf--p graf-after--pre">For <strong class="markup--strong markup--p-strong">x86</strong>, we have a whole set of the conditional move (CMOV) instructions such as, <code class="markup--code markup--p-code">CMOVZ</code> (move when zero), <code class="markup--code markup--p-code">CMOVNZ</code> (move when not zero), <code class="markup--code markup--p-code">CMOVGT</code> (move when greater than), etc. The condition is determined by the <strong class="markup--strong markup--p-strong">flags</strong> or we called the <strong class="markup--strong markup--p-strong">conditional codes</strong>.</p><p name="dfe9" id="dfe9" class="graf graf--p graf-after--p">Let’s see the pseudocode for the decision-making tool <code class="markup--code markup--p-code">x=cond?x1:x2;</code> by MIPS,</p><pre name="ad82" id="ad82" class="graf graf--pre graf-after--p">R3 = cond;<br>MOV R1, x1<br>MOV R2, x2<br>MOVN x, R1, cond<br>MOVZ x, R2, cond</pre><p name="8b58" id="8b58" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">5. Performance of </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">MOVZ</strong></code><strong class="markup--strong markup--p-strong"> and </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">MOVN</strong></code></p><p name="4c62" id="4c62" class="graf graf--p graf-after--p">Let’s say we have the following program with branches,</p><pre name="a9c8" id="a9c8" class="graf graf--pre graf-after--p">BEQZ R1, Else<br>ADDI R2, R2, 1<br>B End<br>Else:<br>    ADDI R3, R3, 1<br>End:</pre><p name="24a2" id="24a2" class="graf graf--p graf-after--pre">After <strong class="markup--strong markup--p-strong">if-conversion</strong>, this should be,</p><pre name="3edc" id="3edc" class="graf graf--pre graf-after--p">ADDI R4, R2, 1<br>ADDI R5, R3, 1<br>MOVN R2, R4, R1<br>MOVZ R3, R5, R1</pre><p name="e961" id="e961" class="graf graf--p graf-after--pre">Let’s see we have a predictor for the <strong class="markup--strong markup--p-strong">original program</strong> with 80% accuracy and there’s a 40-instruction penalty if misprediction. According to the code, if the branch is taken, we will have 2 instructions, however, if the branch is not taken, we will have 3 instructions. So on average, we will have 2.5 instructions. So the expected overall number of instructions for this program is,</p><pre name="73b4" id="73b4" class="graf graf--pre graf-after--p">2.5 + (1 - 80%) * 40 = 10.5</pre><p name="4da2" id="4da2" class="graf graf--p graf-after--pre">If we consider the <strong class="markup--strong markup--p-strong">program after the if-conversion</strong>, there will be 4 instructions without branches, so we don’t have to worry about the misprediction problem. Thus the overall number of instructions for this program is <code class="markup--code markup--p-code">4</code>. And we can find out that the predications actually have better performance.</p><p name="037f" id="037f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">6. Requirements for Conditional Move Instruction</strong></p><p name="412e" id="412e" class="graf graf--p graf-after--p">For utilizing the conditional move instruction,</p><ul class="postList"><li name="f00b" id="f00b" class="graf graf--li graf-after--p">we need the <strong class="markup--strong markup--li-strong">compiler’s support</strong></li><li name="044a" id="044a" class="graf graf--li graf-after--li">we will <strong class="markup--strong markup--li-strong">remove the hard-to-predict branches</strong></li><li name="65db" id="65db" class="graf graf--li graf-after--li">we need <strong class="markup--strong markup--li-strong">more registers</strong> than the original code because the results from both paths should be kept</li><li name="2d8e" id="2d8e" class="graf graf--li graf-after--li">we should execute <strong class="markup--strong markup--li-strong">more instructions</strong> because we take both paths and we have to add additional instructions to select the results</li></ul><p name="465d" id="465d" class="graf graf--p graf-after--li">Note that we can use the technique to <strong class="markup--strong markup--p-strong">make all the instructions conditional</strong> in order to deal with the problems of more registers and additional instructions for result selection. This technique is called a <strong class="markup--strong markup--p-strong">full predication</strong>.</p><p name="ccd2" id="ccd2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">7. Condition Move Vs. Full Predication</strong></p><p name="f5e5" id="f5e5" class="graf graf--p graf-after--p">Now let’s compare what we need for the condition move and what we need for the full predication.</p><p name="9f66" id="9f66" class="graf graf--p graf-after--p">For condition move,</p><ul class="postList"><li name="b67d" id="b67d" class="graf graf--li graf-after--p">We need a separate <strong class="markup--strong markup--li-strong">operation code</strong> (opcode) to tell us this is a conditional instruction. we usually have a separate opcode for each particular condition, so we need a number of opcodes.</li></ul><p name="bb04" id="bb04" class="graf graf--p graf-after--li">For full predication,</p><ul class="postList"><li name="da00" id="da00" class="graf graf--li graf-after--p">We add <strong class="markup--strong markup--li-strong">conditional bits </strong>to every instruction so every instruction word contains some bits that tell us what is the condition.</li></ul><p name="96ba" id="96ba" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">8. Full Predication: An Example</strong></p><p name="f8c2" id="f8c2" class="graf graf--p graf-after--p">Let’s say we have the following program with branches,</p><pre name="fb91" id="fb91" class="graf graf--pre graf-after--p">BEQZ R1, Else<br>ADDI R2, R2, 1<br>B End<br>Else:<br>    ADDI R3, R3, 1<br>End:</pre><p name="6d02" id="6d02" class="graf graf--p graf-after--pre">If we convert this program to full predication (i.e. the Itanium), we get</p><pre name="fb23" id="fb23" class="graf graf--pre graf-after--p">MP.EQZ P1, P2, R1    // if R1 == 0, P1 = True, P2 = False<br>(P2) ADDI R2, R2, 1  // if P2 == True, do the ADDI<br>(P1) ADDI R3, R3, 1  // if P1 == True, do the ADDI</pre><p name="a2ed" id="a2ed" class="graf graf--p graf-after--pre graf--trailing">You can easily find out that the code above is much simplified than the if-conversion code. We can also use the <strong class="markup--strong markup--p-strong">same registers</strong> and there is now<strong class="markup--strong markup--p-strong"> no additional work</strong> for moving the results into the destination registers.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/31464a3fc0e2"><time class="dt-published" datetime="2021-01-22T04:01:48.811Z">January 22, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-10-predication-if-conversion-condition-move-and-full-31464a3fc0e2" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>