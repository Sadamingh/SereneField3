<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>High-Performance Computer Architecture 26 | An Introduction to Memory, DRAM, SRAM</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">High-Performance Computer Architecture 26 | An Introduction to Memory, DRAM, SRAM</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: High-Performance Computer Architecture
</section>
<section data-field="body" class="e-content">
<section name="41ec" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2947" id="2947" class="graf graf--h3 graf--leading graf--title">High-Performance Computer Architecture 26 | <strong class="markup--strong markup--h3-strong">An Introduction to Memory, DRAM, SRAM</strong></h3><figure name="051d" id="051d" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*M9wX4oV8T8VT2i9j.png" data-width="1446" data-height="864" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*M9wX4oV8T8VT2i9j.png"></figure><ol class="postList"><li name="e7de" id="e7de" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">An Introduction to Memory</strong></li></ol><p name="6c46" id="6c46" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Random Access Memory (RAM)</strong></p><p name="d433" id="d433" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Random-access memory (RAM)</strong> simply refers to the fact that we can access any memory location by address without going through all the memory locations. The opposite definition is a <strong class="markup--strong markup--p-strong">sequential access</strong> tape, where we have to scan through the whole tape to get a memory location.</p><p name="683e" id="683e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Types of RAM</strong></p><p name="c171" id="c171" class="graf graf--p graf-after--p">There are mainly two types of RAM,</p><ul class="postList"><li name="90ed" id="90ed" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Statistic Random Access Memory (SRAM)</strong>: the term “statistic” refers to the fact that SRAM retains its data while the power is supplied. So you are not going to lose any data if you are connected to the power. However, to implement an SRAM, we need to have several transistors per bit. This causes the SRAM to become expensive.</li><li name="f488" id="f488" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Dynamic Random Access Memory (DRAM)</strong>: “dynamic” means that we will lose data unless we refresh the data. Although we will lose data when we have DRAM, we only need to have 1 transistor per bit. Thus, we can get a lot more DRAM per unit area than SRAM.</li></ul><p name="44c0" id="44c0" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Inverters</strong></p><p name="46ad" id="46ad" class="graf graf--p graf-after--p">Before we talk about the organizations of SRAM and DRAM, let’s first introduce the inverters. The inverters are also called the NOT gate which implements logical negation. It is denoted by,</p><figure name="97b6" id="97b6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*CcwwkMvgDU_7SbYXiOncsg.png" data-width="1490" data-height="142" src="https://cdn-images-1.medium.com/max/800/1*CcwwkMvgDU_7SbYXiOncsg.png"></figure><p name="7cd9" id="7cd9" class="graf graf--p graf-after--figure">Basically, there are 3 common ways to implement this NOT gate. We can use a PMOS (P-type Metal Oxide Semiconductor, P-type MOS), an NMOS (N-type MOS), or a CMOS (complementary MOS). The transistors we have introduced before are BJTs, which are less commonly used in electronic digital circuits. You can find an explanation about BJT vs. MOSFET from <a href="https://www.elprocus.com/difference-between-bjt-and-mosfet/#:~:text=The%20BJT%20is%20a%20bipolar,oxide%20semiconductor%20field%2Deffect%20transistor.&amp;text=BJT%27s%20are%20used%20for%20low,more%20commonly%20used%20than%20BJTS." data-href="https://www.elprocus.com/difference-between-bjt-and-mosfet/#:~:text=The%20BJT%20is%20a%20bipolar,oxide%20semiconductor%20field%2Deffect%20transistor.&amp;text=BJT&#39;s%20are%20used%20for%20low,more%20commonly%20used%20than%20BJTS." class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>.</p><ul class="postList"><li name="6391" id="6391" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">NMOS Inverter</strong></li></ul><p name="4f35" id="4f35" class="graf graf--p graf-after--li">We can easily create an inverter with an NMOS and a pull-up resistor. This design has a low manufacture cost but it will have disadvantages on the power consumption and processing speed.</p><figure name="d673" id="d673" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*hKZsQBd5V-oTewN9v6x9hg.png" data-width="1736" data-height="548" src="https://cdn-images-1.medium.com/max/800/1*hKZsQBd5V-oTewN9v6x9hg.png"></figure><ul class="postList"><li name="fb51" id="fb51" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">PMOS Inverter</strong></li></ul><p name="8a3d" id="8a3d" class="graf graf--p graf-after--li">Similar to the NMOS inverter, we can also create an inverter with a PMOS resister, which also has problems with power consumption and processing speed.</p><figure name="bea1" id="bea1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*agaw2dOWYCAUGJl2eeUkdA.png" data-width="1736" data-height="548" src="https://cdn-images-1.medium.com/max/800/1*agaw2dOWYCAUGJl2eeUkdA.png"></figure><ul class="postList"><li name="3276" id="3276" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">CMOS Inverter</strong></li></ul><p name="bcdb" id="bcdb" class="graf graf--p graf-after--li">To deal with the problems on the power consumption and processing speed, we can use two MOSFETs instead of just one with a resister. This is called the CMOS inverter design.</p><figure name="8a48" id="8a48" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tu9GTnj14_Nz3PMkB6JJRA.png" data-width="1736" data-height="494" src="https://cdn-images-1.medium.com/max/800/1*tu9GTnj14_Nz3PMkB6JJRA.png"></figure><p name="ce42" id="ce42" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) The Organization of the SRAM</strong></p><p name="2827" id="2827" class="graf graf--p graf-after--p">In the SRAM structure, remember what we have to do is that the SRAM should always keep the data in the memory cell until it is overwritten or the power is no longer supplied. This means that the <strong class="markup--strong markup--p-strong">memory cell</strong> should be able to keep the data.</p><p name="7617" id="7617" class="graf graf--p graf-after--p">Also, each memory cell has a <strong class="markup--strong markup--p-strong">word line </strong>that acts to control the cell. The signal that accesses the cell to either read or write data is applied to the word line.</p><p name="2ee8" id="2ee8" class="graf graf--p graf-after--p">Perpendicular to the word lines is<em class="markup--em markup--p-em"> </em><strong class="markup--strong markup--p-strong">bit lines</strong>. The data that is being written into or read from the memory is found on the bit lines. So our memory is actually a matrix of cells.</p><figure name="5511" id="5511" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*n5SetEu0zVBd8vHd_IkZ2A.png" data-width="1624" data-height="640" src="https://cdn-images-1.medium.com/max/800/1*n5SetEu0zVBd8vHd_IkZ2A.png"></figure><p name="69a4" id="69a4" class="graf graf--p graf-after--figure">A transistor should be used to connect the word line, the bit line, and the memory cell. If we want to access the memory cell, we should activate the word line, which opens the transistor and the transistor connects the bit line to the memory cell. Then if we want to write to the memory cell, we put the data we want to write at the bit line and the cell gets the value. If we want to read the data, we will get the value at the bit line to go away so that we can get a new value from the memory cell.</p><figure name="9342" id="9342" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OAwDPREtFuxJtsvXniS7Zw.png" data-width="1632" data-height="638" src="https://cdn-images-1.medium.com/max/800/1*OAwDPREtFuxJtsvXniS7Zw.png"></figure><p name="7efa" id="7efa" class="graf graf--p graf-after--figure">In SRAM, the actual memory cell consists of two CMOS inverters as we have talked about above.</p><figure name="e284" id="e284" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*1_HiIpYQDH18USGp1sRKhw.png" data-width="1632" data-height="638" src="https://cdn-images-1.medium.com/max/800/1*1_HiIpYQDH18USGp1sRKhw.png"></figure><p name="8560" id="8560" class="graf graf--p graf-after--figure">Actually, each CMOS inverter has two CMOS transistors. The basic idea is that if you write a to the memory cell, the inverter on the right-hand side will flip it to 0. However, another inverter will then flip it to 1. So once the control transistor writes a value to the memory cell, the cell will keep its value until it is power-off.</p><figure name="88d5" id="88d5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*oFsvVKpxux7rpavAsk-1YA.png" data-width="1508" data-height="652" src="https://cdn-images-1.medium.com/max/800/1*oFsvVKpxux7rpavAsk-1YA.png"></figure><p name="3fec" id="3fec" class="graf graf--p graf-after--figure">But this can also lead to another problem. When we want to change the value of the cell, the existing value in the cell will against the new value we would like to write. For example, suppose the cell keeps the value 0 and we would like to write a 1, which means we must write an amplified 1 so that it can defeat the value of 0.</p><figure name="f86d" id="f86d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dpIDTcGAq49D8FBj6f7Wmg.png" data-width="1508" data-height="652" src="https://cdn-images-1.medium.com/max/800/1*dpIDTcGAq49D8FBj6f7Wmg.png"></figure><p name="85a6" id="85a6" class="graf graf--p graf-after--figure">To make this defeating process easier, typically we have 2 of the control transistors and two bit lines for the same cell that have the opposite values (i.e. BL and BL-bar).</p><figure name="a693" id="a693" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZvZmh5Xfx5fyLo6UDIKFbw.png" data-width="1508" data-height="652" src="https://cdn-images-1.medium.com/max/800/1*ZvZmh5Xfx5fyLo6UDIKFbw.png"></figure><p name="f393" id="f393" class="graf graf--p graf-after--figure">You can find out that for the SRAM, in order to maintain a bit of memory, we have to use 6 transistors, and this can be expensive.</p><p name="0db2" id="0db2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) The Organization of the DRAM</strong></p><p name="c520" id="c520" class="graf graf--p graf-after--p">Instead of using multiple transistors for storing the data as we have discussed for the SRAM, the main difference for the DRAM is that we only use 1 control transistor for 1 bit. The memory cell only consists of a capacitor that is used to keep the value of the data.</p><figure name="24be" id="24be" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*t4dcp8deT_tCbqKNxb5hRg.png" data-width="1508" data-height="652" src="https://cdn-images-1.medium.com/max/800/1*t4dcp8deT_tCbqKNxb5hRg.png"></figure><p name="5844" id="5844" class="graf graf--p graf-after--figure">However, the main problem for this organization is that the control transistor is not a perfect switch so that there will be a little bit of leak from the transistor. Thus, the capacitor will slowly leak to the bit line and eventually, it gets empty, and we will lose this bit over time. To prevent this <strong class="markup--strong markup--p-strong">leakage</strong>, we have to periodically update the data in the capacitor.</p><figure name="da20" id="da20" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*W0mPkld5q0sXnrDuqU4-5Q.png" data-width="1508" data-height="652" src="https://cdn-images-1.medium.com/max/800/1*W0mPkld5q0sXnrDuqU4-5Q.png"></figure><p name="c44e" id="c44e" class="graf graf--p graf-after--figure">There is another problem called <strong class="markup--strong markup--p-strong">destructive read</strong>. This happens because when we read from the bit line, the capacitor drains into the bit line but it is no longer fully charged.</p><p name="c0d9" id="c0d9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Trench Cell</strong></p><p name="c613" id="c613" class="graf graf--p graf-after--p">In the example above, we have built a DRAM memory cell by a transistor and a capacitor. However, this is not how we build a DRAM cell in reality. In fact, the transistor and the capacitor are built as a signal transistor in a technology called <strong class="markup--strong markup--p-strong">trench cell</strong>. By this means, we save the area of a capacitor.</p><p name="7394" id="7394" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) The Organization of Memory Chip</strong></p><p name="8f3d" id="8f3d" class="graf graf--p graf-after--p">In a real memory chip, we have</p><ul class="postList"><li name="0ef3" id="0ef3" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Word lines</strong> that used to activate cells</li><li name="696d" id="696d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Row decoder</strong> decides which word line gets activated</li><li name="5c4f" id="5c4f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Row address</strong> to the row decoder that implies which word line to be activated</li><li name="641d" id="641d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Bit lines</strong> used to input the data to the memory cell</li><li name="a94d" id="a94d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Memory cells</strong> that are either relatively weak SRAM cells or DRAM cells with relatively small capacitors</li><li name="1482" id="1482" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Sense amplifier </strong>connects all the bit lines. It senses the small changes on the bit lines and amplifies them</li><li name="c8f7" id="c8f7" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Row buffer</strong> is a storage element that stores the correct values read from the whole row of cells after amplified by the sense amplifier</li><li name="28b3" id="28b3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Column decoder</strong> selects the correct bits smong the bit lines using the <strong class="markup--strong markup--li-strong">column address</strong> and then it outputs a single bit</li></ul><p name="38e9" id="38e9" class="graf graf--p graf-after--li">For example, the diagram of a 16-bit memory storage is as follows,</p><figure name="c062" id="c062" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kkXGPmrh6xHsqddzpzCheg.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*kkXGPmrh6xHsqddzpzCheg.png"></figure><p name="cd16" id="cd16" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(8) The Organization of Memory Chip: An Example</strong></p><p name="2be9" id="2be9" class="graf graf--p graf-after--p">Now, let’s see an example about the organization of the memory chip. Suppose we have a 16-bit memory storage chip with the data as follows,</p><figure name="c10f" id="c10f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qpFMrOrn1p2nAy29PTjAmw.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*qpFMrOrn1p2nAy29PTjAmw.png"></figure><p name="761f" id="761f" class="graf graf--p graf-after--figure">Suppose the row address is <code class="markup--code markup--p-code">00</code> and the column address is <code class="markup--code markup--p-code">01</code>, let’s see the process of getting a 1-bit data from the memory. After decode the row address, we will choose the 0th row and then output the data of that row to the bit line. Note that the data we read may not be exactly the same as 1 before the amplifier.</p><figure name="d4f8" id="d4f8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*I7r6MyTHY8uhx2qwggQj-w.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*I7r6MyTHY8uhx2qwggQj-w.png"></figure><p name="c7b3" id="c7b3" class="graf graf--p graf-after--figure">After the amplifier, the correct value on each of the bit lines will be stored in the row buffer waiting for the column decoder.</p><figure name="1cce" id="1cce" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*erhWA3uxKQmU3kQwbu7qyA.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*erhWA3uxKQmU3kQwbu7qyA.png"></figure><p name="4358" id="4358" class="graf graf--p graf-after--figure">After decoding the column address, we can know that the data in the second bit line should be extract. Then we will get a value of 0.</p><figure name="f31f" id="f31f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tBa0_-8khWvLY393sfheOA.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*tBa0_-8khWvLY393sfheOA.png"></figure><p name="6323" id="6323" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(9) The Organization of Memory Chip: A Problem</strong></p><p name="5df8" id="5df8" class="graf graf--p graf-after--p">However, in the example above, there is a problem. When we get the data from the DRAM memory cell, the capacitor will no longer hold the data. This means,</p><figure name="d755" id="d755" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fcdcNrR0fVARFxwi1toUsw.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*fcdcNrR0fVARFxwi1toUsw.png"></figure><p name="4fa4" id="4fa4" class="graf graf--p graf-after--figure">In order to deal with this problem, after the sense amplifier amplifies the voltages, it will also drive the correct values back into the cells and so that the cells can get their values again.</p><figure name="c4ef" id="c4ef" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*9BQEzozXyf3hAwwbdcp0GQ.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*9BQEzozXyf3hAwwbdcp0GQ.png"></figure><p name="1dda" id="1dda" class="graf graf--p graf-after--figure">We have talked about the destructive read of DRAM actually means that we have to have a <strong class="markup--strong markup--p-strong">read-then-write pattern</strong>. So we can not just wait long enough to get the value. What we should also do is to put the value back to the cell. This is a reason why DRAM is slower than SRAM.</p><p name="6498" id="6498" class="graf graf--p graf-after--p">Also, note that the cell doesn’t not strongly put the bit lines so that the sense amplifier needs more time to figure out what it has. After this read-then-write approach, the data in the capacitor have also been <strong class="markup--strong markup--p-strong">refreshed</strong>. The refresh process is really make sure that each of the rows is read every once in a while.</p><p name="11a9" id="11a9" class="graf graf--p graf-after--p">When we have a cache, the refreshes will become even more important. Because the most frequently accessed data will be stored in the cache and it will not be update automatically by the read-then-write approach. Suppose we have a DRAM memory cell that will automatically lose the data in time T, then in order to keep all the data in the memory, we have to read and write to every row (assume we have N rows) within this amount of time. We can not rely on the processor to read-then-write all the rows in time T, so we have to use a <strong class="markup--strong markup--p-strong">refresh row counter</strong> to trace which row should be refreshed.</p><p name="40e7" id="40e7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) Write to DRAM Memory Chip</strong></p><p name="88b1" id="88b1" class="graf graf--p graf-after--p">In the previous example, we have discussed how to read from the DRAM memory chip. The read-then-write approach is used to keep the data in the memory cell. But how to write to the memory? Let’s see an example. Suppose we want to write 1 to the second cell in the first row,</p><figure name="1aab" id="1aab" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*VDFvgNYFWJFiJsvEbjxkow.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*VDFvgNYFWJFiJsvEbjxkow.png"></figure><p name="f5ff" id="f5ff" class="graf graf--p graf-after--figure">First of all, the data in the first row will be read to the row buffer as what we have done in the reading process.</p><figure name="f2c9" id="f2c9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*lqck4KxYkMpPIH94q5Go6Q.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*lqck4KxYkMpPIH94q5Go6Q.png"></figure><p name="575b" id="575b" class="graf graf--p graf-after--figure">Then in the row buffer, the corresponding value we would like to write will be updated to the new value that we would like to assign.</p><figure name="dd87" id="dd87" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*B261S03B2ZB7iSdPM3DUxw.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*B261S03B2ZB7iSdPM3DUxw.png"></figure><p name="b71b" id="b71b" class="graf graf--p graf-after--figure">Then the data in the row buffer will be sent back to the cells because the first row is empty after we read from it.</p><figure name="0c04" id="0c04" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6MD993mbnN-zoIpQ0msfNw.png" data-width="1812" data-height="1176" src="https://cdn-images-1.medium.com/max/800/1*6MD993mbnN-zoIpQ0msfNw.png"></figure><p name="8cc0" id="8cc0" class="graf graf--p graf-after--figure">You can find out that the writing process also follows the <strong class="markup--strong markup--p-strong">read-then-write</strong> approach.</p><p name="525d" id="525d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) Fast-Page Mode</strong></p><p name="969b" id="969b" class="graf graf--p graf-after--p">Once we have done a reading or writing process from the memory, the row buffer can retain the entire row. So then if we want to read from <strong class="markup--strong markup--p-strong">the same row</strong>, we don’t have to go through the row decoder, the sense amplifier, and row buffer mechanism again. What we can do is to directly read from the row buffer and just change the column address and get the data we want. This approaching of reading the data is called the <strong class="markup--strong markup--p-strong">fast-page mode</strong>. It is so-called with the term page because some people would like to call a row by page. And this page has nothing to do with the term page we have used for the virtual memory.</p><p name="ba20" id="ba20" class="graf graf--p graf-after--p">The fast-page mode has the following steps,</p><ul class="postList"><li name="ba41" id="ba41" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Step 1. Opening a page</strong>: this is the first read from a row, which contains getting the row address, selecting the row, dispatching to the sense amplification, latching to the row buffer</li><li name="4290" id="4290" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 2. Read/Write</strong>: if we then read or write to the same row, we can simply retrieve the data from the row buffer</li><li name="4372" id="4372" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 3. Closing a page</strong>: if we finally decide to do something on another memory, we do something called closing the page. We will now write the values in the row buffer back to the row.</li></ul><p name="ab49" id="ab49" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(11) Connecting DRAM to the Processor Chip</strong></p><p name="d1a1" id="d1a1" class="graf graf--p graf-after--p">Suppose we have a three-level-cache processor, and if we have a cache miss in the L3 cache, we have to go to the memory to find the data. To find the data in the memory, and the L3 cache will send the address to the <strong class="markup--strong markup--p-strong">memory controller</strong> through the <strong class="markup--strong markup--p-strong">front-side bus</strong>. The memory controller is then used to analyze the address and send the address to the corresponding DRAM (because we can have multiple DRAMs connected to the processor) through the <strong class="markup--strong markup--p-strong">memory channel</strong>.</p><figure name="6d29" id="6d29" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jjUUsUIX-wrp4VdWtUE7ig.png" data-width="1940" data-height="1226" src="https://cdn-images-1.medium.com/max/800/1*jjUUsUIX-wrp4VdWtUE7ig.png"></figure><p name="522e" id="522e" class="graf graf--p graf-after--figure">Thus, the L3 cache latency includes sending the request to the front-side bus, sending the page operations to the apporate DRAM channels, sending a request to read/write based on the column addresses, getting the data back to the memory channel, and finally the memory controller sends the data over the front side bus to the L3 cache.</p><p name="f8eb" id="f8eb" class="graf graf--p graf-after--p">This organization can be improved when we put the memory controller on the processor chip and then we can simply eliminate the front-side bus by using lots of on-chip wires, which saves the latency of L3 cache.</p><figure name="6102" id="6102" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*hbxRkOrt4B-CQnBQaT3S8Q.png" data-width="1940" data-height="1226" src="https://cdn-images-1.medium.com/max/800/1*hbxRkOrt4B-CQnBQaT3S8Q.png"></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/18647b73f8b2"><time class="dt-published" datetime="2021-04-01T11:02:07.631Z">April 1, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/high-performance-computer-architecture-26-an-introduction-to-memory-dram-sram-18647b73f8b2" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>