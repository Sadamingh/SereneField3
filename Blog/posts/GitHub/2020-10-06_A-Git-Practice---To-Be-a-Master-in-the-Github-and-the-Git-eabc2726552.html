<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>A Git Practice | To Be a Master in the Github and the Git</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">A Git Practice | To Be a Master in the Github and the Git</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Git and GitHub
</section>
<section data-field="body" class="e-content">
<section name="fa27" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8e6c" id="8e6c" class="graf graf--h3 graf--leading graf--title">A Git Practice | To Be a Master in the Github and the Git</h3><figure name="6b8f" id="6b8f" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*UsD33DTlPJRrGjSmV-gthw.png" data-width="774" data-height="402" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*UsD33DTlPJRrGjSmV-gthw.png"><figcaption class="imageCaption">by Kim Estoesta for GitHub</figcaption></figure><p name="85fa" id="85fa" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">0. Before We Start</strong></p><p name="ea1d" id="ea1d" class="graf graf--p graf-after--p">We assume that you know nothing about Git and GitHub. But we do assume that you know some sorts of the basic command lines. First of all, you have to register a GitHub account.</p><p name="f533" id="f533" class="graf graf--p graf-after--p">So in order to create a remote repository, we have to go to <a href="https://github.com/" data-href="https://github.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">github.com</a> and if you haven’t got a GitHub account, please sign up an account by going to the signing webpage <a href="https://github.com/join" data-href="https://github.com/join" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">github.com/join</a>.</p><p name="ad80" id="ad80" class="graf graf--p graf-after--p">Then we have to create an ssh connection from our personal computer to the GitHub so that we don’t have to type in the password every time we push. You can refer to <a href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" data-href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this document</a> about how to create an ssh-key and then add it to the ssh-agent.</p><p name="42ef" id="42ef" class="graf graf--p graf-after--p">Then in the terminal, we set our user name and the user email to global so that GitHub can know who is pushing (we are going to explain git push later).</p><pre name="be9a" id="be9a" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ git config --global user.name &lt;username&gt;</code><br><code class="markup--code markup--pre-code">$ git config --global user.email &lt;primary email address&gt;</code></pre><p name="e4c7" id="e4c7" class="graf graf--p graf-after--pre">Note that we have to replace the <code class="markup--code markup--p-code">&lt;username&gt;</code> to our GitHub username and the <code class="markup--code markup--p-code">&lt;primary email address&gt;</code> to out primary email address in the GitHub settings.</p><ol class="postList"><li name="c2e3" id="c2e3" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Basic Setups</strong></li></ol><p name="709c" id="709c" class="graf graf--p graf-after--li">First of all, let’s create a folder called GitPractice in the home directory.</p><pre name="d08f" id="d08f" class="graf graf--pre graf-after--p">$ mkdir GitPractice</pre><p name="34c8" id="34c8" class="graf graf--p graf-after--pre">To go into this folder by,</p><pre name="2b4f" id="2b4f" class="graf graf--pre graf-after--p">$ cd GitPractice/</pre><p name="3671" id="3671" class="graf graf--p graf-after--pre">Add a file called HelloGit.txt by,</p><pre name="7c17" id="7c17" class="graf graf--pre graf-after--p">$ touch HelloGit.txt</pre><p name="55e4" id="55e4" class="graf graf--p graf-after--pre">Write Hello Git! into this file,</p><pre name="cc9c" id="cc9c" class="graf graf--pre graf-after--p">$ echo &#39;Hello Git!&#39; &gt; HelloGit.txt</pre><p name="fcaa" id="fcaa" class="graf graf--p graf-after--pre">Check out the result</p><pre name="6d08" id="6d08" class="graf graf--pre graf-after--p">$ cat HelloGit.txt</pre><p name="fd6f" id="fd6f" class="graf graf--p graf-after--pre">Check the git status of this folder</p><pre name="fa8b" id="fa8b" class="graf graf--pre graf-after--p">$ git status</pre><p name="384f" id="384f" class="graf graf--p graf-after--pre">If you are not doing anything wrong, you are able to get,</p><pre name="86f9" id="86f9" class="graf graf--pre graf-after--p">fatal: not a git repository (or any of the parent directories): .git</pre><p name="2ebc" id="2ebc" class="graf graf--p graf-after--pre">Initialize this folder to a local git repository</p><pre name="ea48" id="ea48" class="graf graf--pre graf-after--p">$ git init</pre><p name="3b00" id="3b00" class="graf graf--p graf-after--pre">Now, it is going to create a .git file in our folder. We can check this by,</p><pre name="49e6" id="49e6" class="graf graf--pre graf-after--p">$ ls -a</pre><p name="8d61" id="8d61" class="graf graf--p graf-after--pre">Check out the git status again,</p><pre name="a968" id="a968" class="graf graf--pre graf-after--p">$ git status</pre><p name="3669" id="3669" class="graf graf--p graf-after--pre">this will give us,</p><pre name="abcf" id="abcf" class="graf graf--pre graf-after--p">On branch master</pre><pre name="5c5e" id="5c5e" class="graf graf--pre graf-after--pre">No commits yet</pre><pre name="a225" id="a225" class="graf graf--pre graf-after--pre">Untracked files:<br>   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</pre><pre name="b970" id="b970" class="graf graf--pre graf-after--pre">          HelloGit.txt</pre><pre name="0c4c" id="0c4c" class="graf graf--pre graf-after--pre">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</pre><p name="9aa7" id="9aa7" class="graf graf--p graf-after--pre">this is telling us the HelloGit.txt file is not added and committed to the local git repository. Then we do,</p><pre name="ad79" id="ad79" class="graf graf--pre graf-after--p">$ git add HelloGit.txt</pre><p name="c852" id="c852" class="graf graf--p graf-after--pre">Check out the git status once again,</p><pre name="a020" id="a020" class="graf graf--pre graf-after--p">$ git status</pre><p name="1e3a" id="1e3a" class="graf graf--p graf-after--pre">then we can find out that the git status of this file actually changes, with</p><pre name="82c8" id="82c8" class="graf graf--pre graf-after--p">On branch master</pre><pre name="60e2" id="60e2" class="graf graf--pre graf-after--pre">No commits yet</pre><pre name="7184" id="7184" class="graf graf--pre graf-after--pre">Changes to be committed:<br>  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</pre><pre name="ab0b" id="ab0b" class="graf graf--pre graf-after--pre">       new file:   HelloGit.txt<br><br></pre><p name="7394" id="7394" class="graf graf--p graf-after--pre">Then we are able to commit this file by,</p><pre name="eb2b" id="eb2b" class="graf graf--pre graf-after--p">$ git commit -m &quot;Update HelloGit&quot;</pre><p name="11b7" id="11b7" class="graf graf--p graf-after--pre">So far, we have already created our local repository.</p><p name="7109" id="7109" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Go Remote</strong></p><p name="ca35" id="ca35" class="graf graf--p graf-after--p">If we want to push our local repository to remote now, we will get an error,</p><pre name="9f99" id="9f99" class="graf graf--pre graf-after--p">$ git push -u origin main</pre><p name="a0af" id="a0af" class="graf graf--p graf-after--pre">Output is,</p><pre name="abff" id="abff" class="graf graf--pre graf-after--p">error: failed to push some refs to &#39;origin&#39;</pre><p name="aa05" id="aa05" class="graf graf--p graf-after--pre">This is because we haven’t linked any remote repo URL to this and the git can not know where to push. We can verify this reason by,</p><pre name="bfff" id="bfff" class="graf graf--pre graf-after--p">$ git remote</pre><p name="3665" id="3665" class="graf graf--p graf-after--pre">This will give us nothing back.</p><p name="5e59" id="5e59" class="graf graf--p graf-after--p">On the <a href="https://github.com/dashboard" data-href="https://github.com/dashboard" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub home page</a>, do one of the following:</p><ul class="postList"><li name="ad9e" id="ad9e" class="graf graf--li graf-after--p">In <strong class="markup--strong markup--li-strong">Your repositories</strong>, choose <strong class="markup--strong markup--li-strong">New repository</strong>.</li><li name="9e5c" id="9e5c" class="graf graf--li graf-after--li">On the navigation bar, choose to <strong class="markup--strong markup--li-strong">Create new</strong> (<strong class="markup--strong markup--li-strong">+</strong>), and then choose <strong class="markup--strong markup--li-strong">New repository</strong>.</li></ul><p name="68ef" id="68ef" class="graf graf--p graf-after--li">Type in the <strong class="markup--strong markup--p-strong">Repository name</strong>,</p><pre name="8b01" id="8b01" class="graf graf--pre graf-after--p">GitPractice</pre><p name="ec8f" id="ec8f" class="graf graf--p graf-after--pre">Don’t select anything else, just click the green button “Create repository”. Then we are able to get a quick setting-up instructions for the repo.</p><p name="f51f" id="f51f" class="graf graf--p graf-after--p">Look at these instructions,</p><h4 name="9d5e" id="9d5e" class="graf graf--h4 graf-after--p">…or push an existing repository from the command line</h4><pre name="4d64" id="4d64" class="graf graf--pre graf-after--h4">$ git remote add origin git@github.com:&lt;username&gt;/GitPractice.git<br>$ git branch -M main<br>$ git push -u origin main</pre><p name="4793" id="4793" class="graf graf--p graf-after--pre">Ok, so now let’s go back to our command line.</p><p name="bb11" id="bb11" class="graf graf--p graf-after--p">First of all, we type in (remember to change the &lt;username&gt; to your own),</p><pre name="9e71" id="9e71" class="graf graf--pre graf-after--p">$ git remote add origin git@github.com:&lt;username&gt;/GitPractice.git</pre><p name="e455" id="e455" class="graf graf--p graf-after--pre">then we go to the main branch,</p><pre name="f8c3" id="f8c3" class="graf graf--pre graf-after--p">$ git branch -M main</pre><p name="8066" id="8066" class="graf graf--p graf-after--pre">finally, we can push our result to the GitHub</p><pre name="efb5" id="efb5" class="graf graf--pre graf-after--p">$ git push -u origin main</pre><p name="14ae" id="14ae" class="graf graf--p graf-after--pre">After this, we can then refresh the GitHub webpage of the GitPractice repo, so then we are able to find a HelloGit.txt in this remote repository.</p><p name="e3a2" id="e3a2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Pull Back</strong></p><p name="a231" id="a231" class="graf graf--p graf-after--p">Now we have two repositories, one is a local repo (on your PC) and another is a remote repo (on the cloud server of Github). We can directly change the remote repo through the User Interface of the GitHub.</p><p name="658c" id="658c" class="graf graf--p graf-after--p">To do this, we then go to our Github repo webpage, then we wanna create a README.md file to help people understand what we are doing right now. Select Add file &gt; Create a new file to create a markdown file.</p><p name="9c86" id="9c86" class="graf graf--p graf-after--p">Type in the file name as Readme.md, and write in the file with,</p><pre name="e021" id="e021" class="graf graf--pre graf-after--p"># This is a git practice repo.</pre><p name="631f" id="631f" class="graf graf--p graf-after--pre">Then we go to the bottom and find the commit part. We type in the commit message as,</p><pre name="fc89" id="fc89" class="graf graf--pre graf-after--p">Create Readme.md</pre><p name="b63b" id="b63b" class="graf graf--p graf-after--pre">Then select Commit new file, then we are able to see the newly created file in our remote repo. Now let’s go back to our local repo.</p><pre name="eb74" id="eb74" class="graf graf--pre graf-after--p">$ ls</pre><p name="2b2c" id="2b2c" class="graf graf--p graf-after--pre">The output should be,</p><pre name="b36f" id="b36f" class="graf graf--pre graf-after--p">HelloGit.txt</pre><p name="76d9" id="76d9" class="graf graf--p graf-after--pre">This means that the local is not automatically changed when the remote repo changed. So what we have to do now is to pull the files from the remote repo back to the local repo by,</p><pre name="296f" id="296f" class="graf graf--pre graf-after--p">$ git pull origin main</pre><p name="5d76" id="5d76" class="graf graf--p graf-after--pre">then we check out the files again by,</p><pre name="69e5" id="69e5" class="graf graf--pre graf-after--p">$ ls</pre><p name="e985" id="e985" class="graf graf--p graf-after--pre">Now we are able to find a new Readme.md file that is exactly the same as our remote repo.</p><pre name="bdc2" id="bdc2" class="graf graf--pre graf-after--p">HelloGit.txt Readme.md</pre><p name="ab76" id="ab76" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4. Managing Branches</strong></p><p name="2501" id="2501" class="graf graf--p graf-after--p">In our local repo, now we would like to create two new branches, one is called testing, the other is called checking,</p><pre name="2e22" id="2e22" class="graf graf--pre graf-after--p">$ git branch testing<br>$ git branch checking</pre><p name="fa09" id="fa09" class="graf graf--p graf-after--pre">We can then use the git branch to see the change,</p><pre name="8ff6" id="8ff6" class="graf graf--pre graf-after--p">$ git branch</pre><p name="a62c" id="a62c" class="graf graf--p graf-after--pre">we will get,</p><pre name="e8eb" id="e8eb" class="graf graf--pre graf-after--p">  checking<br>* main<br>  testing</pre><p name="d84d" id="d84d" class="graf graf--p graf-after--pre">by this result, we know that the git branch command only creates new branches, but not actually switch to the newly created branch. To switch the branch to the testing branch, that is,</p><pre name="74f8" id="74f8" class="graf graf--pre graf-after--p">$ git checkout testing</pre><p name="5972" id="5972" class="graf graf--p graf-after--pre">we will get,</p><pre name="3bbe" id="3bbe" class="graf graf--pre graf-after--p">  checking<br>  main<br>* testing</pre><p name="71ee" id="71ee" class="graf graf--p graf-after--pre">Now let’s see our remote repo, and there is still one main branch. In order to add these two new branches to the remote repo, we go back to our local repo and type in,</p><pre name="825b" id="825b" class="graf graf--pre graf-after--p">$ git push origin testing</pre><p name="9243" id="9243" class="graf graf--p graf-after--pre">This will push the testing branch in the local repo to the remote repo. Similarly, we can also do this to the checking branch,</p><pre name="3c9f" id="3c9f" class="graf graf--pre graf-after--p">$ git checkout checking</pre><p name="cdbd" id="cdbd" class="graf graf--p graf-after--pre">then,</p><pre name="b02a" id="b02a" class="graf graf--pre graf-after--p">$ git push origin checking</pre><p name="f0a6" id="f0a6" class="graf graf--p graf-after--pre">refresh our remote repo webpage, we can find that now we have three branches here.</p><p name="e388" id="e388" class="graf graf--p graf-after--p">So now we are in the checking branch and we want to do something here. We add a file called CheckList.txt by,</p><pre name="942c" id="942c" class="graf graf--pre graf-after--p">$ echo &#39;Things to check here...&#39; &gt; CheckList.txt</pre><p name="ca5f" id="ca5f" class="graf graf--p graf-after--pre">check out this file by,</p><pre name="f26b" id="f26b" class="graf graf--pre graf-after--p">$ cat CheckList.txt</pre><p name="c87c" id="c87c" class="graf graf--p graf-after--pre">in the checking branch, we can then add and commit this file and then push it to the remote checking branch,</p><pre name="7862" id="7862" class="graf graf--pre graf-after--p">$ git add CheckList.txt</pre><p name="f5a7" id="f5a7" class="graf graf--p graf-after--pre">then,</p><pre name="5979" id="5979" class="graf graf--pre graf-after--p">$ git commit -m &quot;Add CheckList&quot;</pre><p name="529c" id="529c" class="graf graf--p graf-after--pre">then,</p><pre name="dc89" id="dc89" class="graf graf--pre graf-after--p">$ git push origin checking</pre><p name="eca4" id="eca4" class="graf graf--p graf-after--pre">we can check the result by,</p><pre name="81fa" id="81fa" class="graf graf--pre graf-after--p">$ ls</pre><p name="b1ed" id="b1ed" class="graf graf--p graf-after--pre">we will have,</p><pre name="a96f" id="a96f" class="graf graf--pre graf-after--p">CheckList.txt HelloGit.txt Readme.md</pre><p name="b61d" id="b61d" class="graf graf--p graf-after--pre">If we switch to other branches, for example, the testing branch by</p><pre name="beab" id="beab" class="graf graf--pre graf-after--p">$ git checkout testing</pre><p name="5679" id="5679" class="graf graf--p graf-after--pre">then check out the files</p><pre name="a8ad" id="a8ad" class="graf graf--pre graf-after--p">$ ls</pre><p name="eb94" id="eb94" class="graf graf--p graf-after--pre">we will have,</p><pre name="bcf5" id="bcf5" class="graf graf--pre graf-after--p">HelloGit.txt Readme.md</pre><p name="0a52" id="0a52" class="graf graf--p graf-after--pre">we can have the same result in the remote repo.</p><p name="fa0d" id="fa0d" class="graf graf--p graf-after--p">Then if we want to merge the checking branch with the main branch, what should we do? First, we have to go back to the main branch,</p><pre name="6ded" id="6ded" class="graf graf--pre graf-after--p">$ git checkout main</pre><p name="f08a" id="f08a" class="graf graf--p graf-after--pre">secondly, we are able to merge these two branches by,</p><pre name="43da" id="43da" class="graf graf--pre graf-after--p">$ git merge checking</pre><p name="2aa5" id="2aa5" class="graf graf--p graf-after--pre">finally, we have to use git push to push the result to the remote repo,</p><pre name="aea4" id="aea4" class="graf graf--pre graf-after--p">$ git push origin main</pre><p name="504a" id="504a" class="graf graf--p graf-after--pre">By these means, we are able to merge the checking branch back to the main branch. But now it’s been a problem because the testing branch is still not being updated. It is a good idea if we use a pull request to pull the files from the main branch to testing. To do this, we have to go back to the testing branch,</p><pre name="7686" id="7686" class="graf graf--pre graf-after--p">$ git checkout testing</pre><p name="2545" id="2545" class="graf graf--p graf-after--pre">in this branch, we use the git pull command to pull from main,</p><pre name="c394" id="c394" class="graf graf--pre graf-after--p">$ git pull origin main</pre><p name="c07a" id="c07a" class="graf graf--p graf-after--pre">after that, we are successfully pulling the files from main to testing locally, then we have to make it happens for the remote repo,</p><pre name="4300" id="4300" class="graf graf--pre graf-after--p">$ git push origin testing</pre><p name="5452" id="5452" class="graf graf--p graf-after--pre">So far, all the branches are on the same version. Congratulations!</p><p name="4b3f" id="4b3f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">5. Resolve Conflicts</strong></p><p name="08bc" id="08bc" class="graf graf--p graf-after--p">In the testing branch, suppose we modify the CheckList.txt file by,</p><pre name="e42a" id="e42a" class="graf graf--pre graf-after--p">$ echo &#39;Successfully Checked!&#39; &gt; CheckList.txt</pre><p name="d988" id="d988" class="graf graf--p graf-after--pre">also we add, commit, and push it to the remote repo,</p><pre name="ea2f" id="ea2f" class="graf graf--pre graf-after--p">$ git add --all<br>$ git commit -m &#39;Successfully Checked!&#39;<br>$ git push origin testing</pre><p name="d1e4" id="d1e4" class="graf graf--p graf-after--pre">Then we switch to the main branch, also, we modify the CheckList.txt file by,</p><pre name="c411" id="c411" class="graf graf--pre graf-after--p">echo &#39;Failed&#39; &gt; CheckList.txt</pre><p name="742b" id="742b" class="graf graf--p graf-after--pre">Similarly, we add, commit, and push it to the remote repo,</p><pre name="33d0" id="33d0" class="graf graf--pre graf-after--p">$ git add --all<br>$ git commit -m &#39;Failed&#39;<br>$ git push origin main</pre><p name="a4d1" id="a4d1" class="graf graf--p graf-after--pre">In the main branch, if we want to merge with the testing branch, we are going to cause a merge conflict.</p><pre name="e665" id="e665" class="graf graf--pre graf-after--p">$ git merge testing</pre><p name="ce12" id="ce12" class="graf graf--p graf-after--pre">We will get,</p><pre name="51ba" id="51ba" class="graf graf--pre graf-after--p">Auto-merging CheckList.txt<br>CONFLICT (content): Merge conflict in CheckList.txt<br>Automatic merge failed; fix conflicts and then commit the result.</pre><p name="bb53" id="bb53" class="graf graf--p graf-after--pre">By git status, we can see that there’s actually a dual modify in CheckList.txt.</p><pre name="851e" id="851e" class="graf graf--pre graf-after--p">$ git status</pre><p name="a9fa" id="a9fa" class="graf graf--p graf-after--pre">we will have,</p><pre name="a5c1" id="a5c1" class="graf graf--pre graf-after--p">On branch main<br>Your branch is up to date with &#39;origin/main&#39;.<br><br>You have unmerged paths.<br>  (fix conflicts and run &quot;git commit&quot;)<br>  (use &quot;git merge --abort&quot; to abort the merge)<br><br>Unmerged paths:<br>  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)<br><br>   both modified:   CheckList.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</pre><p name="8e90" id="8e90" class="graf graf--p graf-after--pre">so we then open the path,</p><pre name="10dc" id="10dc" class="graf graf--pre graf-after--p">$ open ./</pre><p name="8646" id="8646" class="graf graf--p graf-after--pre">then we choose an editor to open the CheckList.txt file, we are going the Sublime here. After opening it, we can see that,</p><pre name="869a" id="869a" class="graf graf--pre graf-after--p">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>Failed<br>=======<br>Successfully Checked!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; testing</pre><p name="4f4e" id="4f4e" class="graf graf--p graf-after--pre">To resolve this conflict, we have to delete:</p><pre name="43dc" id="43dc" class="graf graf--pre graf-after--p">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>=======<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; testing</pre><p name="9e55" id="9e55" class="graf graf--p graf-after--pre">and choose which one to keep. In our case, we are going to keep the successful one.</p><pre name="c8c0" id="c8c0" class="graf graf--pre graf-after--p">Successfully Checked!</pre><p name="634d" id="634d" class="graf graf--p graf-after--pre">Save and close the file.</p><p name="4631" id="4631" class="graf graf--p graf-after--p">Finally, we have to add this file to both the local repo and the remote repo,</p><pre name="6ba5" id="6ba5" class="graf graf--pre graf-after--p">$ git add .<br>$ git commit -m &#39;Resolve Conflict By Using Successful&#39;<br>$ git push origin main</pre><p name="07ee" id="07ee" class="graf graf--p graf-after--pre">In the end, we pull this to update the other two branches,</p><pre name="81a8" id="81a8" class="graf graf--pre graf-after--p">$ git checkout testing<br>$ git pull origin main<br>$ git push origin testing<br>$ git checkout checking<br>$ git pull origin main<br>$ git push origin checking</pre><p name="fa71" id="fa71" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">6. Version Control</strong></p><p name="ff8f" id="ff8f" class="graf graf--p graf-after--p">Now we go back to the main branch and make a new file called account,</p><pre name="3e48" id="3e48" class="graf graf--pre graf-after--p">$ git checkout main<br>$ touch account</pre><p name="0478" id="0478" class="graf graf--p graf-after--pre">then we use nano to edit this file (vim and emacs are also okay).</p><pre name="e8b4" id="e8b4" class="graf graf--pre graf-after--p">$ nano account</pre><p name="634e" id="634e" class="graf graf--p graf-after--pre">In this file, we type in,</p><pre name="e0f6" id="e0f6" class="graf graf--pre graf-after--p">Username: Whoami<br>Password: 0ef186ac70e04ea33b4c1853d2526fa2</pre><p name="2bdf" id="2bdf" class="graf graf--p graf-after--pre">then we press ^o, ^x to write and close nano.</p><p name="cd38" id="cd38" class="graf graf--p graf-after--p">After this, we do git push process to the remote with the previous steps,</p><pre name="11ba" id="11ba" class="graf graf--pre graf-after--p">$ git add .<br>$ git commit -m &quot;add account&quot;<br>$ git push origin main</pre><p name="0e82" id="0e82" class="graf graf--p graf-after--pre">then we edit this file by,</p><pre name="7a5e" id="7a5e" class="graf graf--pre graf-after--p">$ nano account</pre><p name="b18d" id="b18d" class="graf graf--p graf-after--pre">in this file, we rewrite this by,</p><pre name="6a6e" id="6a6e" class="graf graf--pre graf-after--p">Username: Whoami<br>Password: ******************************</pre><p name="f25c" id="f25c" class="graf graf--p graf-after--pre">then we press ^o, ^x to write and close nano. Also, we can do the git push process to the remote with the previous steps,</p><pre name="681c" id="681c" class="graf graf--pre graf-after--p">$ git add .<br>$ git commit -m &quot;add account&quot;<br>$ git push origin main</pre><p name="1927" id="1927" class="graf graf--p graf-after--pre">So now, suppose we forget the password (that is barely impossible to remember), what can we do now? We have already changed the account file and the password is all *****s now. What we want to do is to go back to the previous versions of this file so that we can retrieve the password.</p><p name="f443" id="f443" class="graf graf--p graf-after--p">First of all, we can check all the commits by,</p><pre name="9596" id="9596" class="graf graf--pre graf-after--p">$ git log</pre><p name="f9b8" id="f9b8" class="graf graf--p graf-after--pre">we can also show all the changes through the -p option,</p><pre name="3211" id="3211" class="graf graf--pre graf-after--p">$ git log -p</pre><p name="2384" id="2384" class="graf graf--p graf-after--pre">but sometimes, this can be annoying because we don’t want to show all the infos, then we can use the — pretty=oneline option,</p><pre name="a944" id="a944" class="graf graf--pre graf-after--p">$ git log --pretty=oneline</pre><p name="27c3" id="27c3" class="graf graf--p graf-after--pre">In the git, the HEAD file in the .git folder gives us the information of the current commit, and we can use the following command to show the hash of the current commit,</p><pre name="e3ec" id="e3ec" class="graf graf--pre graf-after--p">$ git reset --hard HEAD</pre><p name="ec91" id="ec91" class="graf graf--p graf-after--pre">the output of this command will be the value of the hash current commit,</p><pre name="1d58" id="1d58" class="graf graf--pre graf-after--p">HEAD is now at &lt;ShortHash&gt; modify</pre><p name="e870" id="e870" class="graf graf--p graf-after--pre">So how can we go back to the previous version? We can use HEAD^ to show that we would like to transfer to the last version,</p><pre name="20c6" id="20c6" class="graf graf--pre graf-after--p">$ git reset --hard HEAD^</pre><p name="7faf" id="7faf" class="graf graf--p graf-after--pre">it is clear to see that the hash value of the current commit changes after running this command, now let’s check our account file by,</p><pre name="5cc2" id="5cc2" class="graf graf--pre graf-after--p">$ cat account</pre><p name="f6a4" id="f6a4" class="graf graf--p graf-after--pre">we can then have,</p><pre name="b47c" id="b47c" class="graf graf--pre graf-after--p">Username: Whoami<br>Password: 0ef186ac70e04ea33b4c1853d2526fa2</pre><p name="00c9" id="00c9" class="graf graf--p graf-after--pre">this shows that we have successfully go back to the last version and we can retrieve our password. Before this command, we have,</p><pre name="c817" id="c817" class="graf graf--pre graf-after--p">HEAD  ---&gt; c784464 (<strong class="markup--strong markup--pre-strong">HEAD -&gt; main</strong>, <strong class="markup--strong markup--pre-strong">origin/main</strong>) modify<br>           97d029c add account<br>           3214178 Resolve Conflict By Using Successful<br>           ...</pre><p name="6aad" id="6aad" class="graf graf--p graf-after--pre">after that, we have</p><pre name="48a5" id="48a5" class="graf graf--pre graf-after--p">HEAD -┐    c784464 (<strong class="markup--strong markup--pre-strong">HEAD -&gt; main</strong>, <strong class="markup--strong markup--pre-strong">origin/main</strong>) modify<br>      └--&gt; 97d029c add account<br>           3214178 Resolve Conflict By Using Successful<br>           ...</pre><p name="3c61" id="3c61" class="graf graf--p graf-after--pre">So what if we want to push this change to remote? Let’s try,</p><pre name="b34c" id="b34c" class="graf graf--pre graf-after--p">$ git push origin main</pre><p name="6cc8" id="6cc8" class="graf graf--p graf-after--pre">Oops, we have an error,</p><pre name="2e50" id="2e50" class="graf graf--pre graf-after--p">error: failed to push some refs to &#39;git@github.com&#39;</pre><p name="05b7" id="05b7" class="graf graf--p graf-after--pre">The reason why we have this error is that the remote repo is treated by git as a future version and the local treated by git as a past version. The git only allows us to push from future to past or to pull from past to future, but not vice versa. To force a push, we have to use the -f option,</p><pre name="643b" id="643b" class="graf graf--pre graf-after--p">$ git push -f origin main</pre><p name="0cf0" id="0cf0" class="graf graf--p graf-after--pre">This will force the remote repo to go back to the last version. However, this can be a disaster if we mistakenly push the pervious version to remote because we can hardly get this version back (we indeed can get it back, but why don’t we use a more clear way?). Let’s try to get it back now. We can see the history of our git commands by,</p><pre name="16b8" id="16b8" class="graf graf--pre graf-after--p">$ git reflog</pre><p name="6bca" id="6bca" class="graf graf--p graf-after--pre">in the output, we find out the future one that we move to the HEAD (instead of HEAD^). Copy its hash value, for example, in this case, it is c784464,</p><pre name="8198" id="8198" class="graf graf--pre graf-after--p">c784464 HEAD@{1}: reset: moving to c784464</pre><p name="97ed" id="97ed" class="graf graf--p graf-after--pre">then we use the reset command to go to the future,</p><pre name="a256" id="a256" class="graf graf--pre graf-after--p">$ git reset --hard c784464</pre><p name="c4e2" id="c4e2" class="graf graf--p graf-after--pre">We don’t have to add anything because this commit (modify) will automatically being added to our git stage. What we have to do now is to push it directly,</p><pre name="054b" id="054b" class="graf graf--pre graf-after--p">$ git push origin main</pre><p name="6e54" id="6e54" class="graf graf--p graf-after--pre">Now it is clear to see we get our version back both locally and remotely.</p><p name="ca14" id="ca14" class="graf graf--p graf-after--p">However, sometimes, we don’t want to go back because when we do more things, it seems that we can hardly find out our abandoned versions. What if we create a new commit of the past version without getting rid of the current version?</p><p name="be64" id="be64" class="graf graf--p graf-after--p">First, we revert to the last version (by using current commit hash),</p><pre name="0f52" id="0f52" class="graf graf--pre graf-after--p">$ git revert c784464</pre><p name="ef95" id="ef95" class="graf graf--p graf-after--pre">This will automatically create a new commit to the future. We can use git log and git status to check this,</p><pre name="b946" id="b946" class="graf graf--pre graf-after--p">$ git log --pretty=oneline<br>$ git status</pre><p name="08f1" id="08f1" class="graf graf--p graf-after--pre">Finally, we push this to the remote by,</p><pre name="f9e9" id="f9e9" class="graf graf--pre graf-after--p">$ git push origin main</pre><p name="7fe5" id="7fe5" class="graf graf--p graf-after--pre">The difference between revert and reset is that, before the revert command, we have,</p><pre name="671a" id="671a" class="graf graf--pre graf-after--p">HEAD  ---&gt; c784464 (<strong class="markup--strong markup--pre-strong">HEAD -&gt; main</strong>, <strong class="markup--strong markup--pre-strong">origin/main</strong>) modify<br>           97d029c add account<br>           3214178 Resolve Conflict By Using Successful<br>           ...</pre><p name="572f" id="572f" class="graf graf--p graf-after--pre">After the command, we then have,</p><pre name="35ca" id="35ca" class="graf graf--pre graf-after--p">      ┌--&gt; bc7c6e4 (<strong class="markup--strong markup--pre-strong">HEAD -&gt; main</strong>) Revert &quot;modify&quot;<br>HEAD -┘    c784464 (<strong class="markup--strong markup--pre-strong">HEAD -&gt; main</strong>, <strong class="markup--strong markup--pre-strong">origin/main</strong>) modify<br>           97d029c add account<br>           3214178 Resolve Conflict By Using Successful<br>           ...</pre><p name="5025" id="5025" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">7. Add tags</strong></p><p name="af72" id="af72" class="graf graf--p graf-after--p">Suppose we have a new publish v0.1, how can we link a tag named v1.0 to this commit? Firstly, let’s create a file named PUBv1.0.</p><pre name="c0b5" id="c0b5" class="graf graf--pre graf-after--p">$ touch PUBv1.0</pre><p name="8756" id="8756" class="graf graf--p graf-after--pre">then we add, commit, and push this file to the remote repo,</p><pre name="1c6f" id="1c6f" class="graf graf--pre graf-after--p">$ git add .<br>$ git commit -m &quot;release v1.0&quot;<br>$ git push origin main</pre><p name="2031" id="2031" class="graf graf--p graf-after--pre">Now, we can add a tag to this commit by git tag command, this will add a tag to the latest commit,</p><pre name="f78c" id="f78c" class="graf graf--pre graf-after--p">$ git tag v1.0</pre><p name="c432" id="c432" class="graf graf--p graf-after--pre">then we use git tag to check the tags,</p><pre name="eae3" id="eae3" class="graf graf--pre graf-after--p">$ git tag</pre><p name="9ef8" id="9ef8" class="graf graf--p graf-after--pre">we can also use git show to show this commit,</p><pre name="f078" id="f078" class="graf graf--pre graf-after--p">$ git show v1.0</pre><p name="5a8c" id="5a8c" class="graf graf--p graf-after--pre">This is the same as we directly use git show to the short hash of this commit,</p><pre name="06b8" id="06b8" class="graf graf--pre graf-after--p">$ git show 1332a2b</pre><p name="5ad4" id="5ad4" class="graf graf--p graf-after--pre">The tag will not automatically be pushed to the remote repo, we have to use git in order to push this tag,</p><pre name="60ab" id="60ab" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ git push origin v1.0</code></pre><p name="5468" id="5468" class="graf graf--p graf-after--pre">If we want to delete a tag, we can use -d option to delete it locally,</p><pre name="114f" id="114f" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ git tag -d v1.0</code></pre><p name="285c" id="285c" class="graf graf--p graf-after--pre">Then we use the push command to delete it remotely.</p><pre name="d235" id="d235" class="graf graf--pre graf-after--p graf--trailing"><code class="markup--code markup--pre-code">$ git push origin :refs/tags/v1.0</code></pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/eabc2726552"><time class="dt-published" datetime="2020-10-06T20:24:18.757Z">October 6, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/a-git-practice-to-be-a-master-in-the-github-and-the-git-eabc2726552" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>