<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>PWN导论2 汇编，调用函数，以及保护机制</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">PWN导论2 汇编，调用函数，以及保护机制</h1>
</header>
<section data-field="subtitle" class="p-summary">
系列：PWN导论
</section>
<section data-field="body" class="e-content">
<section name="3b90" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9a20" id="9a20" class="graf graf--h3 graf--leading graf--title">PWN导论2 汇编，调用函数，以及保护机制</h3><figure name="774e" id="774e" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*Yh4M1RzwSec_Kngxa1DdKg.jpeg" data-width="800" data-height="510" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Yh4M1RzwSec_Kngxa1DdKg.jpeg"></figure><p name="2352" id="2352" class="graf graf--p graf-after--figure">大部分的PWN题目提供的都是没有源码的二进制文件，虽然可以通过IDA等工具反汇编得到伪C代码，但是有的时候仍然需要手写Shellcode，所以对汇编的能力有一定的需求。</p><p name="a177" id="a177" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">一、寄存器</strong></p><ol class="postList"><li name="1b6b" id="1b6b" class="graf graf--li graf-after--p">通用寄存器</li></ol><p name="3f78" id="3f78" class="graf graf--p graf-after--li">寄存器是CPU用来暂时性储存数据的单元。常见的通用寄存器有：</p><ul class="postList"><li name="e922" id="e922" class="graf graf--li graf-after--p">64bit：rax，rbx，rcx，rdx，rsi，rdi</li><li name="e226" id="e226" class="graf graf--li graf-after--li">32bit：eax，ebx，ecx，edx，esi，edi</li><li name="e03e" id="e03e" class="graf graf--li graf-after--li">16bit：ax，bx，cx，dx，si，di</li></ul><p name="26bc" id="26bc" class="graf graf--p graf-after--li">寄存器之间的对应关系如下：</p><figure name="abe8" id="abe8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WnMHxAmgLFSLycUgL0YteA.png" data-width="1378" data-height="166" src="https://cdn-images-1.medium.com/max/800/1*WnMHxAmgLFSLycUgL0YteA.png"></figure><p name="3653" id="3653" class="graf graf--p graf-after--figure">还有很多其他的寄存器，例如r8～r15可以不需要特别在意。</p><p name="4506" id="4506" class="graf graf--p graf-after--p">2. 重要的寄存器</p><ul class="postList"><li name="d549" id="d549" class="graf graf--li graf-after--p">rsp寄存器：栈顶寄存器</li><li name="58ff" id="58ff" class="graf graf--li graf-after--li">rbp寄存器：栈基址寄存器</li><li name="8504" id="8504" class="graf graf--li graf-after--li">rip寄存器：指令寄存器</li></ul><p name="99c8" id="99c8" class="graf graf--p graf-after--li">一般来说，栈是由高地址项低地址生长的，所以整个栈的结构如下图所示：</p><figure name="8b12" id="8b12" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qJKxTR4fysMDuPQXphsMSw.png" data-width="1360" data-height="642" src="https://cdn-images-1.medium.com/max/800/1*qJKxTR4fysMDuPQXphsMSw.png"></figure><p name="1bbe" id="1bbe" class="graf graf--p graf-after--figure">32位和64位的参数传递上存在区别，具体区别是：32位的参数是通过栈传递的，而64位的参数是先通过寄存器传递，当寄存器不够用的时候再通过栈传递。对于64位寄存器来说，储存参数的寄存器的调用顺序是：rdi，rsi，rdx ……。例如下面的代码：</p><pre name="aef8" id="aef8" class="graf graf--pre graf-after--p">puts(&quot;hello world&quot;);</pre><ul class="postList"><li name="48ab" id="48ab" class="graf graf--li graf-after--pre">32位寄存器：先将”hello world”字符串地址储存在栈上，调用的时候从栈中读取</li><li name="6657" id="6657" class="graf graf--li graf-after--li">64位寄存器：将”hello world”字符串地址直接存储在rdi寄存器中</li></ul><p name="42de" id="42de" class="graf graf--p graf-after--li">二. 汇编语言基础</p><ol class="postList"><li name="f904" id="f904" class="graf graf--li graf-after--p">基本的汇编指令</li></ol><ul class="postList"><li name="fbe5" id="fbe5" class="graf graf--li graf-after--li">push：入栈指令，rsp减小</li><li name="6754" id="6754" class="graf graf--li graf-after--li">pop：出栈指令，rsp增大</li><li name="bb3b" id="bb3b" class="graf graf--li graf-after--li">栈帧保存：函数开始的时候会将rbp的数值入栈（push rbp）</li><li name="1bec" id="1bec" class="graf graf--li graf-after--li">栈帧恢复：函数结束的时候会将rbp的数值出栈（pop rbp）</li><li name="6186" id="6186" class="graf graf--li graf-after--li">mov：赋值指令，例如下面的指令将rdi的参数值赋值给栈基址前（+表示向栈底方向）参数部分104字节处：</li></ul><pre name="bdd6" id="bdd6" class="graf graf--pre graf-after--li">mov [ebp+104], rdi</pre><ul class="postList"><li name="3d00" id="3d00" class="graf graf--li graf-after--pre">运算指令：包括add，sub，mul，xor等等。例如，常用的是通过sub开辟栈空间，下面的代码表示将rsp向下移动0x20字节，从而开辟出0x20字节的栈空间：</li></ul><pre name="4fd3" id="4fd3" class="graf graf--pre graf-after--li">sub rsp, 0x20</pre><ul class="postList"><li name="4555" id="4555" class="graf graf--li graf-after--pre">lea：取地址指令</li><li name="a3eb" id="a3eb" class="graf graf--li graf-after--li">jmp：跳转指令</li><li name="3c93" id="3c93" class="graf graf--li graf-after--li">call：调用函数指令，分为两步，先在栈中push返回地址，然后jmp到目标函数</li><li name="5739" id="5739" class="graf graf--li graf-after--li">leave：维护栈帧指令，相当于：</li></ul><pre name="c874" id="c874" class="graf graf--pre graf-after--li">mov rsp, rbp; <br>pop rbp;</pre><ul class="postList"><li name="327c" id="327c" class="graf graf--li graf-after--pre">ret：从栈中弹出返回地址并跳转</li><li name="17a9" id="17a9" class="graf graf--li graf-after--li">syscall：64位系统中断指令</li><li name="dc83" id="dc83" class="graf graf--li graf-after--li">int：32位系统中断指令</li></ul><p name="4dfb" id="4dfb" class="graf graf--p graf-after--li">2. 函数调用栈</p><p name="4aa4" id="4aa4" class="graf graf--p graf-after--p">（1）当函数开始的时候，我们先进行三步操作：</p><ul class="postList"><li name="4b43" id="4b43" class="graf graf--li graf-after--p">保存上一个栈帧的信息</li></ul><pre name="c6e0" id="c6e0" class="graf graf--pre graf-after--li">push rbp</pre><ul class="postList"><li name="5c60" id="5c60" class="graf graf--li graf-after--pre">移动栈基址到栈顶</li></ul><pre name="6630" id="6630" class="graf graf--pre graf-after--li">mov rbp, rsp</pre><ul class="postList"><li name="cf8b" id="cf8b" class="graf graf--li graf-after--pre">开辟栈空间</li></ul><pre name="1678" id="1678" class="graf graf--pre graf-after--li">sub rsp, 0x30</pre><p name="2727" id="2727" class="graf graf--p graf-after--pre">（2）当函数结束前，我们只需要进行两步操作：</p><ul class="postList"><li name="8385" id="8385" class="graf graf--li graf-after--p">栈帧维护</li></ul><pre name="09c7" id="09c7" class="graf graf--pre graf-after--li">leave</pre><p name="af35" id="af35" class="graf graf--p graf-after--pre">这个步骤相当于下面两步：</p><p name="a2bf" id="a2bf" class="graf graf--p graf-after--p">a. 移动栈顶到栈基址</p><pre name="3c9e" id="3c9e" class="graf graf--pre graf-after--p">mov rsp, rbp</pre><p name="23ee" id="23ee" class="graf graf--p graf-after--pre">b. 弹出栈顶信息赋值给栈基址，相当于弹出之前保存的栈基址信息</p><pre name="faa1" id="faa1" class="graf graf--pre graf-after--p">pop rbp</pre><ul class="postList"><li name="8a26" id="8a26" class="graf graf--li graf-after--pre">通过返回地址跳转</li></ul><pre name="2501" id="2501" class="graf graf--pre graf-after--li">ret</pre><p name="e82c" id="e82c" class="graf graf--p graf-after--pre">（3）下面的演示展示了调用foo函数（包括0x1234和0x5678两个参数）的情况。</p><p name="07a0" id="07a0" class="graf graf--p graf-after--p">我们有如下所示的汇编程序：</p><pre name="be16" id="be16" class="graf graf--pre graf-after--p"> 1    mov rdi, 0x1234<br> 2    mov rsi, 0x5678<br> 3    call foo<br> 4    ...</pre><pre name="a097" id="a097" class="graf graf--pre graf-after--pre"> 5    foo:<br> 6    push rbp<br> 7    mov rbp, rsp<br> 8    sub rsp, 0x20<br> 9    leave<br>10    ret</pre><p name="8277" id="8277" class="graf graf--p graf-after--pre">首先，执行1~2行，程序将两个立即数赋值给rdi和rsi。</p><figure name="a11f" id="a11f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*VChbO8zILUEWTViSRKFWIQ.png" data-width="866" data-height="368" src="https://cdn-images-1.medium.com/max/800/1*VChbO8zILUEWTViSRKFWIQ.png"></figure><p name="7e7b" id="7e7b" class="graf graf--p graf-after--figure">执行3行，程序调用call指令，该指令将第四行所在的地址入栈，作为返回地址。同时rip指令寄存器内部的值被替换为foo函数所在的地址，下一步就可以开始运行foo函数中的指令。其中，第一步相当于：</p><pre name="c110" id="c110" class="graf graf--pre graf-after--p">push 0x400825          # 假设call指令后面的指令地址为0x400825</pre><figure name="a9da" id="a9da" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*CSrp6wGLR8sdwXq9IvMQtg.png" data-width="866" data-height="368" src="https://cdn-images-1.medium.com/max/800/1*CSrp6wGLR8sdwXq9IvMQtg.png"></figure><p name="7f13" id="7f13" class="graf graf--p graf-after--figure">执行6行，将rbp的值入栈。</p><figure name="c9e6" id="c9e6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*HDzCRTOe0aa9vSuPfVuwVg.png" data-width="866" data-height="368" src="https://cdn-images-1.medium.com/max/800/1*HDzCRTOe0aa9vSuPfVuwVg.png"></figure><p name="0416" id="0416" class="graf graf--p graf-after--figure">执行7行，将栈顶的值赋给栈底。</p><figure name="371e" id="371e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3Lq9dgHIXejDirHvphQJww.png" data-width="866" data-height="368" src="https://cdn-images-1.medium.com/max/800/1*3Lq9dgHIXejDirHvphQJww.png"></figure><p name="0183" id="0183" class="graf graf--p graf-after--figure">执行8行，开辟0x20的栈空间。</p><figure name="f0bd" id="f0bd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*b_eLvqbOTBcYrXveVJoucw.png" data-width="866" data-height="368" src="https://cdn-images-1.medium.com/max/800/1*b_eLvqbOTBcYrXveVJoucw.png"></figure><p name="a40b" id="a40b" class="graf graf--p graf-after--figure">执行9行，相当于下面两步：</p><pre name="d262" id="d262" class="graf graf--pre graf-after--p">mov rsp, rbp<br>pop rbp</pre><figure name="0a74" id="0a74" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*OUvxXaCCapXsP1kWk6w7tw.png" data-width="866" data-height="368" src="https://cdn-images-1.medium.com/max/800/1*OUvxXaCCapXsP1kWk6w7tw.png"></figure><p name="ac0a" id="ac0a" class="graf graf--p graf-after--figure">执行10行，相当于下面的指令：</p><pre name="f02f" id="f02f" class="graf graf--pre graf-after--p">pop rip</pre><figure name="34a2" id="34a2" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*VPyoHnfmXD1-VbMsrgCi3w.png" data-width="866" data-height="368" src="https://cdn-images-1.medium.com/max/800/1*VPyoHnfmXD1-VbMsrgCi3w.png"></figure><p name="fde3" id="fde3" class="graf graf--p graf-after--figure">由此我们发现，如下面的对比图所示，调用foo函数前后，rbp和rsp的数值并没有变化，这保留了正常的栈帧和指令体系，所以可以继续其他操作。因此函数的调用栈的本质是在调用前后维持栈帧不变。</p><figure name="a108" id="a108" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_zQjDw3uKT4ssk8Rcl6pBA.png" data-width="1410" data-height="368" src="https://cdn-images-1.medium.com/max/800/1*_zQjDw3uKT4ssk8Rcl6pBA.png"></figure><p name="8c14" id="8c14" class="graf graf--p graf-after--figure">三、基本的保护机制</p><p name="5dfa" id="5dfa" class="graf graf--p graf-after--p">操作系统和编译器提供了一些基本的安全机制来降低被攻击的风险。通过checksec指令可以检查二进制文件开启了那些保护机制。</p><ol class="postList"><li name="4362" id="4362" class="graf graf--li graf-after--p">ASLR</li></ol><p name="2d7c" id="2d7c" class="graf graf--p graf-after--li">实际上是来自于操作系统的保护机制，在每次执行代码的时候，stack，heap，以及libc的位置都不一样，但是代码段的顺序可以保持不变。在调试的过程中，栈的位置会变动，有时会给调试的过程造成麻烦。</p><ul class="postList"><li name="a3c2" id="a3c2" class="graf graf--li graf-after--p">查看ASLR状态</li></ul><pre name="bd4e" id="bd4e" class="graf graf--pre graf-after--li">cat /proc/sys/kernel/randomize_va_space</pre><ul class="postList"><li name="28fe" id="28fe" class="graf graf--li graf-after--pre">开启ASLR</li></ul><pre name="7ac1" id="7ac1" class="graf graf--pre graf-after--li">echo 2 &gt; /proc/sys/kernel/randomize_va_space</pre><ul class="postList"><li name="fe21" id="fe21" class="graf graf--li graf-after--pre">关闭ASLR</li></ul><pre name="384d" id="384d" class="graf graf--pre graf-after--li">echo 0 &gt; /proc/sys/kernel/randomize_va_space</pre><p name="442e" id="442e" class="graf graf--p graf-after--pre">2. NX</p><p name="9dbf" id="9dbf" class="graf graf--p graf-after--p">NX指的是堆栈不可执行保护。当NX保护关闭的时候，NX上的数据是可以被当作代码执行的。这种时候就可以直接找到rxw段，写入shellcode之后跳转到shellcode从而执行任意代码。</p><p name="d00b" id="d00b" class="graf graf--p graf-after--p">当NX开启的时候，我们就不能直接写入shellcode，需要考虑ROP方法，这和我们上一章节中最后说到的ret2text例子是一样的。</p><p name="bc94" id="bc94" class="graf graf--p graf-after--p">3. PIE</p><p name="7fcc" id="7fcc" class="graf graf--p graf-after--p">PIE指的是地址随机化保护，默认在gcc中不开启，开启之后code段和data段都会变动。IDA中解析的也不再是真实地址，而是偏移的量。</p><p name="0052" id="0052" class="graf graf--p graf-after--p">4. Canary</p><p name="5e37" id="5e37" class="graf graf--p graf-after--p">本意为金丝雀，指的是金丝雀对于瓦斯泄漏更加敏感，所以工人会带金丝雀下到矿井中。Canary利用了类似的想法，在函数调用的时候保存一个随机值，在函数返回的时候看这个随机值有没有被覆盖（使用溢出的方法一定会触碰到canary随机值），如果覆盖就丢弃整个程序。一般来说，在Canary保护开启的情况下，就可以直接放弃栈溢出的方法了。一般来说，为了防止泄露，Canary的低字节是’\x00’。</p><p name="25a1" id="25a1" class="graf graf--p graf-after--p">5. RELRO</p><p name="4a1d" id="4a1d" class="graf graf--p graf-after--p">分为三种情况：</p><ul class="postList"><li name="519f" id="519f" class="graf graf--li graf-after--p">Disabled：指的是GOT表和plt表都可以写入，fini_array也是可以写入的</li><li name="627f" id="627f" class="graf graf--li graf-after--li">Partial（默认）：只有GOT表可写，可以考虑劫持GOT表</li><li name="de59" id="de59" class="graf graf--li graf-after--li graf--trailing">Fulled：在这种状态下GOT表和plt表都是不可写的</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/6626da950e29"><time class="dt-published" datetime="2020-08-11T12:26:39.308Z">August 11, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/pwn%E5%AF%BC%E8%AE%BA2-%E6%B1%87%E7%BC%96-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0-%E4%BB%A5%E5%8F%8A%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6-6626da950e29" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>