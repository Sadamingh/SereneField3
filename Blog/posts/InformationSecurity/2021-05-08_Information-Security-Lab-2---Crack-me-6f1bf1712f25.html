<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Information Security Lab 2 | Crack me</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Information Security Lab 2 | Crack me</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Information Security Lab
</section>
<section data-field="body" class="e-content">
<section name="7b2d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a880" id="a880" class="graf graf--h3 graf--leading graf--title">Information Security Lab 2 | Crack me</h3><figure name="a725" id="a725" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*GsIvgdQNSxTCwyRx.png" data-width="1738" data-height="952" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*GsIvgdQNSxTCwyRx.png"></figure><ol class="postList"><li name="798b" id="798b" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Basic Setups</strong></li></ol><p name="7a78" id="7a78" class="graf graf--p graf-after--li">Let’s now play with a binary. In this lab, we have 4 binary files. Before you check these files, you have to make sure that you are in the VM environment.</p><pre name="a147" id="a147" class="graf graf--pre graf-after--p">$ vagrant ssh<br>$ seclab tut01</pre><p name="7de8" id="7de8" class="graf graf--p graf-after--pre">We can check these files by,</p><pre name="4adb" id="4adb" class="graf graf--pre graf-after--p">$ cd ~/tuts/lab01/tut01-crackme<br>$ ls<br>README  crackme0x00  crackme0x01  crackme0x02  crackme0x03</pre><p name="e442" id="e442" class="graf graf--p graf-after--pre">What are these files? Let’s try the first one <code class="markup--code markup--p-code">crackme0x00</code> as an example. Suppose we run this executable file and enter the password 1234, we can not access it because the password is not correct.</p><pre name="9d17" id="9d17" class="graf graf--pre graf-after--p">$ ./crackme0x00<br>IOLI Crackme Level 0x00<br>Password: 1234<br>Invalid Password!</pre><p name="15b3" id="15b3" class="graf graf--p graf-after--pre">The question is that how can we bypass the password and get the file content? This is called to crack the file.</p><p name="0839" id="0839" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. File Compilation</strong></p><p name="d61c" id="d61c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">gdb</code> or <strong class="markup--strong markup--p-strong">GNU Debugger</strong> (well, actually, we are going to use the PWN debugger because it is supported on the VM) is a command-line debugger meaning that you interact with it on the command line using text-based commands. It shares many similarities with debuggers you might have already used, and it also allows you to set breakpoints, step through your code, and see variable values.</p><p name="1b77" id="1b77" class="graf graf--p graf-after--p">To continue learning <code class="markup--code markup--p-code">gdb</code> , we will use the following code,</p><figure name="2383" id="2383" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/219343e4905d8ff924e15444a8a8926d.js"></script></figure><p name="3b44" id="3b44" class="graf graf--p graf-after--figure">We can download this file by,</p><pre name="6675" id="6675" class="graf graf--pre graf-after--p">$ mkdir test<br>$ cd test<br>$ curl https://gist.githubusercontent.com/Sadamingh/219343e4905d8ff924e15444a8a8926d/raw/7b3a0d327fe720dbb52ed8032d555a6c717dcf75/gdb_example.c &gt; gdb_example.c</pre><p name="5f0e" id="5f0e" class="graf graf--p graf-after--pre">Let’s see what will this code do. Let’s first compile it by using <code class="markup--code markup--p-code">gcc</code>,</p><pre name="9a85" id="9a85" class="graf graf--pre graf-after--p">$ gcc gdb_example.c</pre><p name="514c" id="514c" class="graf graf--p graf-after--pre">Then we can run the output binary file by,</p><pre name="889a" id="889a" class="graf graf--pre graf-after--p">$ ./a.out<br>This program will square an integer.<br>Useage:<br>         ./square number</pre><p name="baa2" id="baa2" class="graf graf--p graf-after--pre">Oops! It seems that this program is used to square an integer and we need to add an argument. Let’s try integer 4, and we can find out that the program squared this integer 4 and get an output of 16.</p><pre name="7abc" id="7abc" class="graf graf--pre graf-after--p">$ ./a.out 4<br>This program will square an integer.<br>4 squared is 16</pre><p name="6a59" id="6a59" class="graf graf--p graf-after--pre">To make <code class="markup--code markup--p-code">gdb</code> work correctly, we will use the following command to recompile the C script file,</p><pre name="445e" id="445e" class="graf graf--pre graf-after--p">$ gcc -g -Og gdb_example.c -o square</pre><p name="22dd" id="22dd" class="graf graf--p graf-after--pre">where,</p><ul class="postList"><li name="af7b" id="af7b" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">-g</code> means to produce debugging information in the operating system’s native format (stabs, COFF, XCOFF, or DWARF). GDB can work with this debugging information.</li><li name="c6d0" id="c6d0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">-Og</code> means to optimize the debugging experience.</li><li name="43eb" id="43eb" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">-o</code> means where to place the primary output.</li></ul><p name="38ea" id="38ea" class="graf graf--p graf-after--li">Then let’s run,</p><pre name="c42b" id="c42b" class="graf graf--pre graf-after--p">$ ./square 4 <br>This program will square an integer.<br>4 squared is 16</pre><p name="45e2" id="45e2" class="graf graf--p graf-after--pre">We can find out that this has the same output as <code class="markup--code markup--p-code">a.out</code> file. Now, let’s try <code class="markup--code markup--p-code">gdb</code> on this file. By default, when we use <code class="markup--code markup--p-code">gdb</code> on our machine, we will be using <code class="markup--code markup--p-code">pwndbg</code>, which is a more advanced debugger than <code class="markup--code markup--p-code">gdb</code>.</p><pre name="bdc4" id="bdc4" class="graf graf--pre graf-after--p">$ gdb square<br>...<br>Reading symbols from square...done.<br>pwndbg&gt;</pre><p name="5c86" id="5c86" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. PWN Debugger (</strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">pwndbg</strong></code><strong class="markup--strong markup--p-strong">)</strong></p><p name="c6ad" id="c6ad" class="graf graf--p graf-after--p">Now, let’s try the <code class="markup--code markup--p-code">gdb</code>. The first <code class="markup--code markup--p-code">gdb</code> command we are going to talk about is the <code class="markup--code markup--p-code">list</code> command, which is used to list specified functions or lines. We can directly list the lines without specifying anything,</p><pre name="cfee" id="cfee" class="graf graf--pre graf-after--p">pwndbg&gt; l</pre><p name="e27d" id="e27d" class="graf graf--p graf-after--pre">Then this command will list the first 10 lines of our C code. If we try it again,</p><pre name="6fb7" id="6fb7" class="graf graf--pre graf-after--p">pwndbg&gt; l</pre><p name="8c5b" id="8c5b" class="graf graf--p graf-after--pre">Then we are able to get the next 10 lines. Let’s try it two more times, we can find out the <code class="markup--code markup--p-code">list</code> command exceeds the total line number and we can not fetch more lines.</p><pre name="1350" id="1350" class="graf graf--pre graf-after--p">pwndbg&gt; l<br>pwndbg&gt; l<br>Line number 28 out of range; gdb_example.c has 27 lines.</pre><p name="613c" id="613c" class="graf graf--p graf-after--pre">To specify some lines of a function like <code class="markup--code markup--p-code">main</code> or <code class="markup--code markup--p-code">square</code> , we can directly specify the function name after the <code class="markup--code markup--p-code">list</code> command like,</p><pre name="10b6" id="10b6" class="graf graf--pre graf-after--p">pwndbg&gt; l main</pre><p name="39d8" id="39d8" class="graf graf--p graf-after--pre">or,</p><pre name="0ef1" id="0ef1" class="graf graf--pre graf-after--p">pwndbg&gt; l square</pre><p name="d708" id="d708" class="graf graf--p graf-after--pre">Another useful command is the info command that can be used to show the information of the current program. For example, we can check the current breakpoints by,</p><pre name="02ce" id="02ce" class="graf graf--pre graf-after--p">pwndbg&gt; i b</pre><p name="64dc" id="64dc" class="graf graf--p graf-after--pre">or we can check the current stack by,</p><pre name="22d5" id="22d5" class="graf graf--pre graf-after--p">pwndbg&gt; i s</pre><p name="53a0" id="53a0" class="graf graf--p graf-after--pre">or we can check the current registers by,</p><pre name="db53" id="db53" class="graf graf--pre graf-after--p">pwndbg&gt; i r</pre><p name="fd8d" id="fd8d" class="graf graf--p graf-after--pre">Because we have no program running now, we are not expecting anything on the stack or registers, and also there should be no breaking points. We will check them later. However, we can check the functions in this program by,</p><pre name="d5cf" id="d5cf" class="graf graf--pre graf-after--p">pwndbg&gt; i func</pre><p name="1521" id="1521" class="graf graf--p graf-after--pre">the output should be,</p><pre name="debe" id="debe" class="graf graf--pre graf-after--p">All defined functions:</pre><pre name="2e96" id="2e96" class="graf graf--pre graf-after--pre">File gdb_example.c:<br>int main(int, char **);<br>int square(int);</pre><pre name="7c11" id="7c11" class="graf graf--pre graf-after--pre">Non-debugging symbols:<br>0x0000000000000580  _init<br>0x00000000000005b0  puts@plt<br>0x00000000000005c0  strtol@plt<br>0x00000000000005d0  __printf_chk@plt<br>0x00000000000005e0  __cxa_finalize@plt<br>0x00000000000005f0  _start<br>0x0000000000000620  deregister_tm_clones<br>0x0000000000000660  register_tm_clones<br>0x00000000000006b0  __do_global_dtors_aux<br>0x00000000000006f0  frame_dummy<br>0x0000000000000770  __libc_csu_init<br>0x00000000000007e0  __libc_csu_fini<br>0x00000000000007e4  _fini</pre><p name="368e" id="368e" class="graf graf--p graf-after--pre">And we can find out that we have two functions in line 6 (main) and line 24 (square).</p><p name="94e1" id="94e1" class="graf graf--p graf-after--p">If we want to execute the program, we can use <code class="markup--code markup--p-code">run</code> command. If we directly type <code class="markup--code markup--p-code">r</code> as our command, we will get an error because we didn’t specify the argument of this function.</p><pre name="e22b" id="e22b" class="graf graf--pre graf-after--p">pwndbg&gt;<strong class="markup--strong markup--pre-strong"> </strong>r<br>Starting program: /home/vagrant/test/square<br>ERROR: Could not find ELF base!<br>This program will square an integer.<br>Useage:<br>        ./square number<br>[Inferior 1 (process 3797) exited normally]</pre><p name="2ead" id="2ead" class="graf graf--p graf-after--pre">Instead, we can specify the argument by adding it after the <code class="markup--code markup--p-code">r</code> command like,</p><pre name="dae4" id="dae4" class="graf graf--pre graf-after--p">pwndbg&gt;<strong class="markup--strong markup--pre-strong"> </strong>r 4<br>Starting program: /home/vagrant/test/square 4<br>This program will square an integer.<br>4 squared is 16<br>[Inferior 1 (process 3804) exited normally]</pre><p name="349d" id="349d" class="graf graf--p graf-after--pre">If we would like to make the program stop before it exits normally, we have to make some breakpoints and specify some locations. For example, we can make this program break at the function <code class="markup--code markup--p-code">main</code>,</p><pre name="0cec" id="0cec" class="graf graf--pre graf-after--p">pwndbg&gt; b main<br>Breakpoint 1 at 0x555555554700: file gdb_example.c, line 6.</pre><p name="7e27" id="7e27" class="graf graf--p graf-after--pre">Or we can directly break at a line number (e.g. line 10),</p><pre name="4756" id="4756" class="graf graf--pre graf-after--p">pwndbg&gt; b 10<br>Breakpoint 2 at 0x555555554717: file gdb_example.c, line 10.</pre><p name="8dc9" id="8dc9" class="graf graf--p graf-after--pre">If we have another file, we can break at that file by <code class="markup--code markup--p-code">b filename:linenum</code> , but we are not going to do this in the current program.</p><p name="96ab" id="96ab" class="graf graf--p graf-after--p">Now, let’s check all the breakpoints we have by <code class="markup--code markup--p-code">info</code> ,</p><pre name="fbb8" id="fbb8" class="graf graf--pre graf-after--p">pwndbg&gt;<strong class="markup--strong markup--pre-strong"> </strong>i b<br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x0000555555554700 in main at gdb_example.c:6<br>2       breakpoint     keep y   0x0000555555554717 in main at gdb_example.c:10</pre><p name="c345" id="c345" class="graf graf--p graf-after--pre">To delete a breakpoint, we have to use the <code class="markup--code markup--p-code">clear</code> command. For example, if we want to delete the breakpoint at line 10, we have to use,</p><pre name="7e64" id="7e64" class="graf graf--pre graf-after--p">pwndbg&gt; clear 10<br>Deleted breakpoint 2</pre><p name="f787" id="f787" class="graf graf--p graf-after--pre">Note that if we are in the line with a breakpoint we want to delete, we can directly use the <code class="markup--code markup--p-code">clear</code> command without specifying the line number. After that, we can use the <code class="markup--code markup--p-code">info</code> command to check the breakpoints now,</p><pre name="e50c" id="e50c" class="graf graf--pre graf-after--p">pwndbg&gt; i b<br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x0000555555554700 in main at gdb_example.c:6<br>        breakpoint already hit 1 time</pre><p name="b173" id="b173" class="graf graf--p graf-after--pre">Okay, it seems like everything is okay. Now if we type <code class="markup--code markup--p-code">r 4</code> again, we will stop the program at line 6 because this is our first breakpoint. Also, the PWN debugger is going to give us all the information about the register values, the disassembler instructions, the source code, the stack, and the backtrace information.</p><pre name="5820" id="5820" class="graf graf--pre graf-after--p">pwndbg&gt; r 4</pre><figure name="a0b4" id="a0b4" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*_L_i2D_t8YE0Flz-U0agFg.png" data-width="1280" data-height="1502" src="https://cdn-images-1.medium.com/max/800/1*_L_i2D_t8YE0Flz-U0agFg.png"></figure><figure name="5186" id="5186" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*sXtFyccboInBV6ExTcKQlw.png" data-width="1364" data-height="382" src="https://cdn-images-1.medium.com/max/800/1*sXtFyccboInBV6ExTcKQlw.png"></figure><p name="6672" id="6672" class="graf graf--p graf-after--figure">Now, after the breakpoint, we have two options to continue. We can use the <code class="markup--code markup--p-code">next</code> command to go to the next line in the code. But this command will not go into functions. If we run,</p><pre name="72a9" id="72a9" class="graf graf--pre graf-after--p">pwndbg&gt; n</pre><p name="d5fe" id="d5fe" class="graf graf--p graf-after--pre">Then we will locate in line 7, which is the <code class="markup--code markup--p-code">printf</code> function. We can use the command <code class="markup--code markup--p-code">where</code> or <code class="markup--code markup--p-code">bt</code> (means backtrace, and this is commonly used) for checking our location,</p><pre name="90c7" id="90c7" class="graf graf--pre graf-after--p">pwndbg&gt; bt<br>#0  main (argc=argc@entry=2, argv=argv@entry=0x7fffffffe548) at gdb_example.c:7<br>#1  0x00007ffff7a03bf7 in __libc_start_main (main=0x555555554700 &lt;main&gt;, argc=2, argv=0x7fffffffe548, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe538) at ../csu/libc-start.c:310<br>#2  0x000055555555461a in _start ()</pre><p name="7d13" id="7d13" class="graf graf--p graf-after--pre">If we run <code class="markup--code markup--p-code">next</code> command again, we will result in the next line of the current file, which would be line 10. However, we may want to go into the <code class="markup--code markup--p-code">printf</code> function to see what’s happening, and therefore, we can not use the <code class="markup--code markup--p-code">next</code> command. Instead, the <code class="markup--code markup--p-code">step</code> command will look into the functions. We can run,</p><pre name="9cae" id="9cae" class="graf graf--pre graf-after--p">pwndbg&gt; s<br>printf (__fmt=&lt;synthetic pointer&gt;) at /usr/include/x86_64-linux-gnu/bits/stdio2.h:104<br>...</pre><p name="cb59" id="cb59" class="graf graf--p graf-after--pre">Again, we can check where we are located by <code class="markup--code markup--p-code">bt</code> command and the result shows that we are in line 104 of <code class="markup--code markup--p-code">stdio2.h</code>, because we step through the <code class="markup--code markup--p-code">printf</code> function.</p><pre name="a6ad" id="a6ad" class="graf graf--pre graf-after--p">pwndbg&gt; bt<br>#0  printf (__fmt=&lt;synthetic pointer&gt;) at /usr/include/x86_64-linux-gnu/bits/stdio2.h:104<br>#1  main (argc=argc@entry=2, argv=argv@entry=0x7fffffffe548) at gdb_example.c:7<br>#2  0x00007ffff7a03bf7 in __libc_start_main (main=0x555555554700 &lt;main&gt;, argc=2, argv=0x7fffffffe548, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe538) at ../csu/libc-start.c:310<br>#3  0x000055555555461a in _start ()</pre><p name="c79a" id="c79a" class="graf graf--p graf-after--pre">If we want to jump out of this function and go back to the original binary file, we can use the <code class="markup--code markup--p-code">finish</code> command,</p><pre name="5a89" id="5a89" class="graf graf--pre graf-after--p">pwndbg&gt; finish</pre><p name="4bbd" id="4bbd" class="graf graf--p graf-after--pre">And then if we check where we are, we will be fine in the <code class="markup--code markup--p-code">gdb_example.c</code> file,</p><pre name="98a5" id="98a5" class="graf graf--pre graf-after--p">pwndbg&gt; bt<br>#0  main (argc=argc@entry=1, argv=argv@entry=0x7fffffffe568) at gdb_example.c:10<br>#1  0x00007ffff7a03bf7 in __libc_start_main (main=0x555555554700 &lt;main&gt;, argc=1, argv=0x7fffffffe568, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe558) at ../csu/libc-start.c:310<br>#2  0x000055555555461a in _start ()</pre><p name="18f2" id="18f2" class="graf graf--p graf-after--pre">So whenever you step in a function that is not yours, it may look a little scary but there’s nothing to be worried about because we can <code class="markup--code markup--p-code">finish</code> this function whenever we want.</p><p name="8dd7" id="8dd7" class="graf graf--p graf-after--p">Now, let’s add another breakpoint at line 17 and <code class="markup--code markup--p-code">continue</code> execution to that line,</p><pre name="0616" id="0616" class="graf graf--pre graf-after--p">pwndbg&gt; b 17<br>pwndbg&gt; c<br>...<br>► 17  int squaredNum = square(numToSquare);<br>...</pre><p name="0bad" id="0bad" class="graf graf--p graf-after--pre">In this line, we can try to print the value of the variable <code class="markup--code markup--p-code">squaredNum</code> and <code class="markup--code markup--p-code">numToSquare</code> by <code class="markup--code markup--p-code">print</code> command,</p><pre name="e20d" id="e20d" class="graf graf--pre graf-after--p">pwndbg&gt; p <code class="markup--code markup--pre-code">squaredNum<br></code>$1 = &lt;optimized out&gt;<br>pwndbg&gt; p <code class="markup--code markup--pre-code">numToSquare<br></code>$2 = &lt;optimized out&gt;</pre><p name="48fe" id="48fe" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">&lt;optimized out&gt;</code> means the compiler optimized the result of the output and we can not access the value of this variable at the current time. Then, let’s step to the next next line by,</p><pre name="91f9" id="91f9" class="graf graf--pre graf-after--p">pwndbg&gt; s<br>pwndbg&gt; s<br>...<br>  24 int square(int x) {<br>  25   int sq = x * x;<br>  26   return sq;<br><strong class="markup--strong markup--pre-strong">► 27 }<br></strong>...</pre><p name="a798" id="a798" class="graf graf--p graf-after--pre">We can print the value of the <code class="markup--code markup--p-code">sq</code> variable by,</p><pre name="ba5a" id="ba5a" class="graf graf--pre graf-after--p">pwndbg&gt; p sq<br>$3 = 16</pre><p name="c28c" id="c28c" class="graf graf--p graf-after--pre">If we try to print <code class="markup--code markup--p-code">x</code>, we will get,</p><pre name="66eb" id="66eb" class="graf graf--pre graf-after--p">pwndbg&gt; p x<br>$4 = &lt;optimized out&gt;</pre><p name="df7e" id="df7e" class="graf graf--p graf-after--pre">If we want to print the value of <code class="markup--code markup--p-code">squaredNum</code> in this function, it will not be possible because we are already in the <code class="markup--code markup--p-code">square</code> function and we do not have this variable as a local variable.</p><pre name="3649" id="3649" class="graf graf--pre graf-after--p">pwndbg&gt; p squaredNum<br>No symbol &quot;squaredNum&quot; in current context.</pre><p name="f898" id="f898" class="graf graf--p graf-after--pre">But it can be useful if we can read a variable of the parent function. The method to do so is by going up to the parent function by <code class="markup--code markup--p-code">up</code> command,</p><pre name="c4ae" id="c4ae" class="graf graf--pre graf-after--p">pwndbg&gt; up<br>  f 0   0x5555555546fd square+3<br>► f 1   0x555555554751 main+81<br>  f 2   0x7ffff7a03bf7 __libc_start_main+231</pre><p name="f58b" id="f58b" class="graf graf--p graf-after--pre">Then we are able to print this variable because we can now access the stack of the parent function,</p><pre name="398d" id="398d" class="graf graf--pre graf-after--p">pwndbg&gt; p squaredNum<br>$5 = &lt;optimized out&gt;</pre><p name="3a98" id="3a98" class="graf graf--p graf-after--pre">However, we can not access the variable <code class="markup--code markup--p-code">sq</code> because it is the child stack,</p><pre name="8b66" id="8b66" class="graf graf--pre graf-after--p">pwndbg&gt; p sq<br>No symbol &quot;sq&quot; in current context.</pre><p name="cd60" id="cd60" class="graf graf--p graf-after--pre">We can use the <code class="markup--code markup--p-code">down</code> command to go back to the <code class="markup--code markup--p-code">square</code> function and then access the variable <code class="markup--code markup--p-code">sq</code>,</p><pre name="95ed" id="95ed" class="graf graf--pre graf-after--p">pwndbg&gt; down<br>► f 0   0x5555555546fd square+3<br>  f 1   0x555555554751 main+81<br>  f 2   0x7ffff7a03bf7 __libc_start_main+231</pre><p name="2db8" id="2db8" class="graf graf--p graf-after--pre">Then, finally, we can print <code class="markup--code markup--p-code">sq</code> by,</p><pre name="537c" id="537c" class="graf graf--pre graf-after--p">pwndbg&gt; p sq<br>$6 = 16</pre><p name="fd81" id="fd81" class="graf graf--p graf-after--pre">After debugging the code, we can quit the PWN debugger by <code class="markup--code markup--p-code">quit</code> command,</p><pre name="a5a8" id="a5a8" class="graf graf--pre graf-after--p">pwndbg&gt; q</pre><p name="2a78" id="2a78" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4. Crackme 0x00</strong></p><p name="cc48" id="cc48" class="graf graf--p graf-after--p">Now, let’s go back to <code class="markup--code markup--p-code">lab01</code> directory and see how we can crack these binary files,</p><pre name="ce3c" id="ce3c" class="graf graf--pre graf-after--p">$ cd /home/vagrant/tuts/lab01/tut01-crackme<br>$ ls<br>$ clear</pre><p name="023b" id="023b" class="graf graf--p graf-after--pre">Then, let’s look into the first binary file by PWN debugger,</p><pre name="c418" id="c418" class="graf graf--pre graf-after--p">$ gdb crackme0x00<br>$ r</pre><p name="e7c7" id="e7c7" class="graf graf--p graf-after--pre">And then we press ctrl+c when we have to type in the password. The program will then break at this place,</p><pre name="b1cb" id="b1cb" class="graf graf--pre graf-after--p">Starting program: /home/vagrant/tuts/lab01/tut01-crackme/crackme0x00<br>IOLI Crackme Level 0x00<br>Password: ^C</pre><p name="382c" id="382c" class="graf graf--p graf-after--pre">At this break, we can use <code class="markup--code markup--p-code">bt</code> command to see where we are in the program,</p><pre name="b296" id="b296" class="graf graf--pre graf-after--p">pwndbg&gt; bt<br>#0  0xf7fd5079 in __kernel_vsyscall ()<br>#1  0xf7ecdd87 in __GI___libc_read (fd=0, buf=0x804b570, nbytes=1024) at ../sysdeps/unix/sysv/linux/read.c:27<br>#2  0xf7e5a318 in _IO_new_file_underflow (fp=&lt;optimized out&gt;) at fileops.c:531<br>#3  0xf7e5b43b in __GI__IO_default_uflow (fp=0xf7fbf5c0 &lt;_IO_2_1_stdin_&gt;) at genops.c:380<br>#4  0xf7e3ed41 in _IO_vfscanf_internal (s=&lt;optimized out&gt;, format=&lt;optimized out&gt;, argptr=&lt;optimized out&gt;, errp=&lt;optimized out&gt;) at vfscanf.c:630<br>#5  0xf7e49eb5 in __scanf (format=0x80487f1 &quot;%s&quot;) at scanf.c:33<br>#6  0x080486d1 in main (argc=1, argv=0xffffd614) at crackme0x00.c:14<br>#7  0xf7dfff21 in __libc_start_main (main=0x80486a3 &lt;main&gt;, argc=1, argv=0xffffd614, init=0x8048720 &lt;__libc_csu_init&gt;, fini=0x8048780 &lt;__libc_csu_fini&gt;, rtld_fini=0xf7fe5970 &lt;_dl_fini&gt;, stack_end=0xffffd60c) at ../csu/libc-start.c:310<br>#8  0x08048512 in _start ()</pre><p name="4209" id="4209" class="graf graf--p graf-after--pre">This can be scary but the only relevant one to us is the <code class="markup--code markup--p-code">#6</code> one,</p><pre name="fa18" id="fa18" class="graf graf--pre graf-after--p">#6  0x080486d1 in main (argc=1, argv=0xffffd614) at crackme0x00.c:14</pre><p name="078c" id="078c" class="graf graf--p graf-after--pre">And it shows us that we break <code class="markup--code markup--p-code">crackme0x00.c</code> at line 14 at the address <code class="markup--code markup--p-code">0x080486d1</code>. Now, to see the code, we can first set a breakpoint at this location, run again, and then disassemble the code to find the password. To do so, we have to first add a new breakpoint,</p><pre name="aa51" id="aa51" class="graf graf--pre graf-after--p">pwndbg&gt; b *0x080486d1</pre><p name="6902" id="6902" class="graf graf--p graf-after--pre">Then we run the program again. When we meet the password, we can type in some random numbers like <code class="markup--code markup--p-code">111111</code>. After we press enter, the program will break at the breakpoint we have set,</p><pre name="a847" id="a847" class="graf graf--pre graf-after--p">Breakpoint 1, 0x080486d1 in main (argc=1, argv=0xffffd614) at crackme0x00.c:14<br>...</pre><p name="c9fe" id="c9fe" class="graf graf--p graf-after--pre">And now we can try to disassemble the binary by command <code class="markup--code markup--p-code">disassemble</code>,</p><pre name="c031" id="c031" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">pwndbg&gt; </strong>disassemble<br>Dump of assembler code for function main:<br>   0x080486a3 &lt;+0&gt;: push   ebp<br>   0x080486a4 &lt;+1&gt;: mov    ebp,esp<br>   0x080486a6 &lt;+3&gt;: sub    esp,0x10<br>   0x080486a9 &lt;+6&gt;: push   0x80487f4<br>   0x080486ae &lt;+11&gt;: call   0x8048470 &lt;puts@plt&gt;<br>   0x080486b3 &lt;+16&gt;: add    esp,0x4<br>   0x080486b6 &lt;+19&gt;: push   0x804880c<br>   0x080486bb &lt;+24&gt;: call   0x8048430 &lt;printf@plt&gt;<br>   0x080486c0 &lt;+29&gt;: add    esp,0x4<br>   0x080486c3 &lt;+32&gt;: lea    eax,[ebp-0x10]<br>   0x080486c6 &lt;+35&gt;: push   eax<br>   0x080486c7 &lt;+36&gt;: push   0x80487f1<br>   0x080486cc &lt;+41&gt;: call   0x8048480 &lt;scanf@plt&gt;<br>=&gt; 0x080486d1 &lt;+46&gt;: add    esp,0x8<br>   0x080486d4 &lt;+49&gt;: push   0x8048817<br>   0x080486d9 &lt;+54&gt;: lea    eax,[ebp-0x10]<br>   0x080486dc &lt;+57&gt;: push   eax<br>   0x080486dd &lt;+58&gt;: call   0x8048420 &lt;strcmp@plt&gt;<br>   0x080486e2 &lt;+63&gt;: add    esp,0x8<br>   0x080486e5 &lt;+66&gt;: test   eax,eax<br>   0x080486e7 &lt;+68&gt;: jne    0x8048705 &lt;main+98&gt;<br>   0x080486e9 &lt;+70&gt;: push   0x804881e<br>   0x080486ee &lt;+75&gt;: call   0x8048470 &lt;puts@plt&gt;<br>   0x080486f3 &lt;+80&gt;: add    esp,0x4<br>   0x080486f6 &lt;+83&gt;: push   0x804882d<br>   0x080486fb &lt;+88&gt;: call   0x80485f6 &lt;print_key&gt;<br>   0x08048700 &lt;+93&gt;: add    esp,0x4<br>   0x08048703 &lt;+96&gt;: jmp    0x8048712 &lt;main+111&gt;<br>   0x08048705 &lt;+98&gt;: push   0x804883c<br>   0x0804870a &lt;+103&gt;: call   0x8048470 &lt;puts@plt&gt;<br>   0x0804870f &lt;+108&gt;: add    esp,0x4<br>   0x08048712 &lt;+111&gt;: mov    eax,0x0<br>   0x08048717 &lt;+116&gt;: leave  <br>   0x08048718 &lt;+117&gt;: ret    <br>End of assembler dump.</pre><p name="be88" id="be88" class="graf graf--p graf-after--pre">A common sense is that, when we have some local data, we have to push it into the stack. So whenever we have a <code class="markup--code markup--p-code">push</code> instruction, we had better look into the code to see if there’s something related to the password. We can use the command <code class="markup--code markup--p-code">x/1s</code> to print the data in an address. Now, let’s see the first push instruction,</p><pre name="39b6" id="39b6" class="graf graf--pre graf-after--p">pwndbg&gt; x/1s 0x80487f4<br>0x80487f4: &quot;IOLI Crackme Level 0x00&quot;</pre><p name="d5cc" id="d5cc" class="graf graf--p graf-after--pre">We can find out that this is the data of string <code class="markup--code markup--p-code">“IOLI Crackme Level 0x00”</code> and this is definitely not what we want to find.</p><p name="2cb0" id="2cb0" class="graf graf--p graf-after--p">A quicker way to find the password is that we can look into the functions and we can guess which function we will use to check the password. In the disassembled code, we can find out that whenever we call something, this means that we will have another function. These include,</p><pre name="ba2e" id="ba2e" class="graf graf--pre graf-after--p">0x080486ae &lt;+11&gt;: call   0x8048470 &lt;puts@plt&gt;<br>0x080486bb &lt;+24&gt;: call   0x8048430 &lt;printf@plt&gt;<br>0x080486cc &lt;+41&gt;: call   0x8048480 &lt;scanf@plt&gt;<br>0x080486dd &lt;+58&gt;: call   0x8048420 &lt;strcmp@plt&gt;<br>0x080486ee &lt;+75&gt;: call   0x8048470 &lt;puts@plt&gt;<br>0x080486fb &lt;+88&gt;: call   0x80485f6 &lt;print_key&gt;<br>0x0804870a &lt;+103&gt;: call   0x8048470 &lt;puts@plt&gt;</pre><p name="084f" id="084f" class="graf graf--p graf-after--pre">When we need to check the password, the most useful function of them is definitely the <code class="markup--code markup--p-code">strcmp</code> function in C, which is used to compare two strings. Before we call this function, we must prepare the arguments earlier. So we can find the password before this line. The latest one is the line,</p><pre name="bb1c" id="bb1c" class="graf graf--pre graf-after--p">0x080486d4 &lt;+49&gt;: push   0x8048817</pre><p name="6c99" id="6c99" class="graf graf--p graf-after--pre">And we can try to see what’s in the address <code class="markup--code markup--p-code">0x8048817</code> by,</p><pre name="eea4" id="eea4" class="graf graf--pre graf-after--p">pwndbg&gt; x/1s 0x8048817<br>0x8048817: &quot;250381&quot;</pre><p name="140f" id="140f" class="graf graf--p graf-after--pre">Okay, seems like we have found our first password! Let’s try it in binary,</p><pre name="1425" id="1425" class="graf graf--pre graf-after--p">$ ./crackme0x00<br>IOLI Crackme Level 0x00<br>Password: 250381<br>Password OK :)<br>This is your flag:</pre><pre name="48a5" id="48a5" class="graf graf--pre graf-after--pre">F38FE749E36CD0437AD0062D6836C393618FCC4A412FDE666C89EB41AC0814D5<br>B734EBE71127B13BFE569599D6521FF424CEBDF34F07A91CF70B8CB12E324283<br>788E593AF6DED9DC41A86AB64EA9A7D9A2EF718EB8B6ACFEF7A195EF241649E1<br>E392715E0E0E936D46E3048A1AA22ADAD0874F6A25092B87D834E2E1E95E20AE<br>BE020DC6D44A858FA33063F6EDCE7AFFDB858583255CA09CFAC73D73E6AD8A9D<br>B284D6E905DCBE49D0E24D844B28CEE909A91515E97883A744A854BB60BB50A5<br>3AFE33A987FC897A39218C553951E87D2E5FEF0D312500DD936A9A0A2F59C450<br>                      &gt;&gt;&gt; FOR TESTING  &lt;&lt;&lt;                      <br>D4F31AC01E20589A6D7E1EE3026881F3B01F791B425198A9B0468B094C58797E<br>EC266EA25DE5EC175CB1E01B4E92830E6CDFA8FB36C8EC58B37B400D4F75B0F9<br>59CB724D7681B69F5D3A485F0DF03C23AB4B58D566D6849471554FEC5BB76D90<br>7DB098B8A60C23C81F41923CBF6CB3C23511C258A3BD04DB1FF697A7070E03E8<br>2747CB047C92E27232B4050A3B6D8A6E8377D939933AD921C6B14BA1FCD2BEA2<br>3199EC6E3C817041CD61B7B1394CAB1EBB01ACD74D4F1A7E857D22FDA227B834<br>2AF0AEC61229004D9E8CF6F4E3622419A37F6D410526951D6EB2F639DBEA49AD</pre><p name="f0c5" id="f0c5" class="graf graf--p graf-after--pre">Okay. Now, let’s continue to the next level.</p><p name="defc" id="defc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">5. Crackme 0x01</strong></p><p name="364d" id="364d" class="graf graf--p graf-after--p">We can disassemble the code with the same procedure of the first binary,</p><pre name="176f" id="176f" class="graf graf--pre graf-after--p">$ gdb crackme0x01<br>pwndbg&gt; r<br>...<br>Password: ^C<br>...<br>pwndbg&gt; bt<br>pwndbg&gt; b *0x080484b4<br>pwndbg&gt; r<br>...<br>Password: 111111<br>...<br>pwndbg&gt; disassemble</pre><p name="cae3" id="cae3" class="graf graf--p graf-after--pre">Then we can get the disassembled code,</p><pre name="ae07" id="ae07" class="graf graf--pre graf-after--p">Dump of assembler code for function main:<br>   0x08048486 &lt;+0&gt;:  push   ebp<br>   0x08048487 &lt;+1&gt;:  mov    ebp,esp<br>   0x08048489 &lt;+3&gt;:  sub    esp,0x4<br>   0x0804848c &lt;+6&gt;:  push   0x8048570<br>   0x08048491 &lt;+11&gt;: call   0x8048330 &lt;puts@plt&gt;<br>   0x08048496 &lt;+16&gt;: add    esp,0x4<br>   0x08048499 &lt;+19&gt;: push   0x8048588<br>   0x0804849e &lt;+24&gt;: call   0x8048320 &lt;printf@plt&gt;<br>   0x080484a3 &lt;+29&gt;: add    esp,0x4<br>   0x080484a6 &lt;+32&gt;: lea    eax,[ebp-0x4]<br>   0x080484a9 &lt;+35&gt;: push   eax<br>   0x080484aa &lt;+36&gt;: push   0x8048593<br>   0x080484af &lt;+41&gt;: call   0x8048340 &lt;scanf@plt&gt;<br>=&gt; 0x080484b4 &lt;+46&gt;: add    esp,0x8<br>   0x080484b7 &lt;+49&gt;: mov    eax,DWORD PTR [ebp-0x4]<br>   0x080484ba &lt;+52&gt;: cmp    eax,0xc8e<br>   0x080484bf &lt;+57&gt;: jne    0x80484d0 &lt;main+74&gt;<br>   0x080484c1 &lt;+59&gt;: push   0x8048596<br>   0x080484c6 &lt;+64&gt;: call   0x8048330 &lt;puts@plt&gt;<br>   0x080484cb &lt;+69&gt;: add    esp,0x4<br>   0x080484ce &lt;+72&gt;: jmp    0x80484dd &lt;main+87&gt;<br>   0x080484d0 &lt;+74&gt;: push   0x80485a5<br>   0x080484d5 &lt;+79&gt;: call   0x8048330 &lt;puts@plt&gt;<br>   0x080484da &lt;+84&gt;: add    esp,0x4<br>   0x080484dd &lt;+87&gt;: mov    eax,0x0<br>   0x080484e2 &lt;+92&gt;: leave  <br>   0x080484e3 &lt;+93&gt;: ret    <br>End of assembler dump.</pre><p name="b551" id="b551" class="graf graf--p graf-after--pre">In the last binary, we find the <code class="markup--code markup--p-code">strcmp</code> function, but in this binary, we can not find a C function that is used to check the string. Instead, what we can find is a <code class="markup--code markup--p-code">cmp</code> instruction that can be used to make the decision of the branches. This instruction compares the value of the register <code class="markup--code markup--p-code">eax</code> and a hexadecimal <code class="markup--code markup--p-code">0xc8e</code>. By reading the code after <code class="markup--code markup--p-code">scanf</code>, we can know that something is actually the string we type in and then we can guess something is our password, which is,</p><pre name="8d37" id="8d37" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">???? == ????</code></pre><p name="dbd1" id="dbd1" class="graf graf--p graf-after--pre">Finally, let’s try this password for binary <code class="markup--code markup--p-code">crackme0x01</code>,</p><pre name="470d" id="470d" class="graf graf--pre graf-after--p">$ ./crackme0x01<br>IOLI Crackme Level 0x01<br>Password: ????<br>Password OK :)</pre><p name="2924" id="2924" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">6. Crackme 0x02</strong></p><p name="9094" id="9094" class="graf graf--p graf-after--p">This binary has a similar structure of <code class="markup--code markup--p-code">crackme0x01</code>, but the disassembled code is,</p><pre name="db0a" id="db0a" class="graf graf--pre graf-after--p">pwndbg&gt; disassemble <br>Dump of assembler code for function main:<br>   0x08048486 &lt;+0&gt;:  push   ebp<br>   0x08048487 &lt;+1&gt;:  mov    ebp,esp<br>   0x08048489 &lt;+3&gt;:  sub    esp,0x4<br>   0x0804848c &lt;+6&gt;:  push   0x8048570<br>   0x08048491 &lt;+11&gt;: call   0x8048330 &lt;puts@plt&gt;<br>   0x08048496 &lt;+16&gt;: add    esp,0x4<br>   0x08048499 &lt;+19&gt;: push   0x8048588<br>   0x0804849e &lt;+24&gt;: call   0x8048320 &lt;printf@plt&gt;<br>   0x080484a3 &lt;+29&gt;: add    esp,0x4<br>   0x080484a6 &lt;+32&gt;: lea    eax,[ebp-0x4]<br>   0x080484a9 &lt;+35&gt;: push   eax<br>   0x080484aa &lt;+36&gt;: push   0x8048593<br>   0x080484af &lt;+41&gt;: call   0x8048340 &lt;scanf@plt&gt;<br>=&gt; 0x080484b4 &lt;+46&gt;: add    esp,0x8<br>   0x080484b7 &lt;+49&gt;: mov    eax,DWORD PTR [ebp-0x4]<br>   0x080484ba &lt;+52&gt;: imul   eax,eax,0x159<br>   0x080484c0 &lt;+58&gt;: cmp    eax,0x122c1c<br>   0x080484c5 &lt;+63&gt;: jne    0x80484d6 &lt;main+80&gt;<br>   0x080484c7 &lt;+65&gt;: push   0x8048596<br>   0x080484cc &lt;+70&gt;: call   0x8048330 &lt;puts@plt&gt;<br>   0x080484d1 &lt;+75&gt;: add    esp,0x4<br>   0x080484d4 &lt;+78&gt;: jmp    0x80484e3 &lt;main+93&gt;<br>   0x080484d6 &lt;+80&gt;: push   0x80485a5<br>   0x080484db &lt;+85&gt;: call   0x8048330 &lt;puts@plt&gt;<br>   0x080484e0 &lt;+90&gt;: add    esp,0x4<br>   0x080484e3 &lt;+93&gt;: mov    eax,0x0<br>   0x080484e8 &lt;+98&gt;: leave  <br>   0x080484e9 &lt;+99&gt;: ret    <br>End of assembler dump.</pre><p name="e9ef" id="e9ef" class="graf graf--p graf-after--pre">Again, we can find the <code class="markup--code markup--p-code">cmp</code> instruction here. But does the password equal <code class="markup--code markup--p-code">0x122c1c</code>? Well, the answer is no! Because you can find out some calculations before this <code class="markup--code markup--p-code">cmp</code> instruction and the <code class="markup--code markup--p-code">eax</code> is not the value we read by <code class="markup--code markup--p-code">scanf</code>. Reading the data, we can know that the <code class="markup--code markup--p-code">scanf</code> value is multiplied by ???? and its result will be compared with ????. Therefore, we can calculate the password by,</p><pre name="f729" id="f729" class="graf graf--pre graf-after--p">???? / ???? == ???? == ????</pre><p name="13e1" id="13e1" class="graf graf--p graf-after--pre">Finally, let’s try this password for binary <code class="markup--code markup--p-code">crackme0x02</code>,</p><pre name="89e0" id="89e0" class="graf graf--pre graf-after--p">$ ./crackme0x02<br>IOLI Crackme Level 0x02<br>Password: ????<br>Password OK :)</pre><p name="1083" id="1083" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">7. Crackme 0x03</strong></p><p name="20a3" id="20a3" class="graf graf--p graf-after--p">So finally, let’s play with the last one. The disassembled code is,</p><pre name="fa89" id="fa89" class="graf graf--pre graf-after--p">Dump of assembler code for function main:<br>   0x08048546 &lt;+0&gt;:  push   ebp<br>   0x08048547 &lt;+1&gt;:  mov    ebp,esp<br>   0x08048549 &lt;+3&gt;:  sub    esp,0x4<br>   0x0804854c &lt;+6&gt;:  push   0x8048638<br>   0x08048551 &lt;+11&gt;: call   0x8048350 &lt;puts@plt&gt;<br>   0x08048556 &lt;+16&gt;: add    esp,0x4<br>   0x08048559 &lt;+19&gt;: push   0x8048650<br>   0x0804855e &lt;+24&gt;: call   0x8048340 &lt;printf@plt&gt;<br>   0x08048563 &lt;+29&gt;: add    esp,0x4<br>   0x08048566 &lt;+32&gt;: lea    eax,[ebp-0x4]<br>   0x08048569 &lt;+35&gt;: push   eax<br>   0x0804856a &lt;+36&gt;: push   0x804865b<br>   0x0804856f &lt;+41&gt;: call   0x8048360 &lt;scanf@plt&gt;<br>=&gt; 0x08048574 &lt;+46&gt;: add    esp,0x8<br>   0x08048577 &lt;+49&gt;: mov    eax,DWORD PTR [ebp-0x4]<br>   0x0804857a &lt;+52&gt;: push   0x52b23<br>   0x0804857f &lt;+57&gt;: push   eax<br>   0x08048580 &lt;+58&gt;: call   0x8048511 &lt;test&gt;<br>   0x08048585 &lt;+63&gt;: add    esp,0x8<br>   0x08048588 &lt;+66&gt;: mov    eax,0x0<br>   0x0804858d &lt;+71&gt;: leave  <br>   0x0804858e &lt;+72&gt;: ret    <br>End of assembler dump.</pre><p name="a6d5" id="a6d5" class="graf graf--p graf-after--pre">So now, in this case, we have no <code class="markup--code markup--p-code">strcmp</code>, and we also have no <code class="markup--code markup--p-code">cmp</code> instructions. What should we do? Note that we now have a new function called <code class="markup--code markup--p-code">test</code> and probably this is the function we will use to check the password. Let’s try to print the data before it. Of course, the <code class="markup--code markup--p-code">eax</code> will be the data we read from <code class="markup--code markup--p-code">scanf</code> , but what about something strange in the code? Actually, this is not an address and we can guess this is exactly the password we need,</p><pre name="75ee" id="75ee" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">???? == ????</code></pre><p name="13c3" id="13c3" class="graf graf--p graf-after--pre">Finally, let’s try this password for binary <code class="markup--code markup--p-code">crackme0x03</code>,</p><pre name="5fc3" id="5fc3" class="graf graf--pre graf-after--p graf--trailing">$ ./crackme0x03<br>IOLI Crackme Level 0x03<br>Password: ????<br>Password OK!!! :)</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/6f1bf1712f25"><time class="dt-published" datetime="2021-05-08T12:15:06.679Z">May 8, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/information-security-lab-2-crack-me-6f1bf1712f25" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>