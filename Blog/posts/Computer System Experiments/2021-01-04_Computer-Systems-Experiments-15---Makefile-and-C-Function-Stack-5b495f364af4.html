<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Computer Systems Experiments 15 | Makefile and C Function Stack</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Computer Systems Experiments 15 | Makefile and C Function Stack</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Computer Systems Experiments
</section>
<section data-field="body" class="e-content">
<section name="80ab" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a356" id="a356" class="graf graf--h3 graf--leading graf--title">Computer Systems Experiments 15 | Makefile and C Function Stack</h3><figure name="23be" id="23be" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*sa53BiKxfhE7fsBN.png" data-width="1530" data-height="1104" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*sa53BiKxfhE7fsBN.png"></figure><ol class="postList"><li name="3d1c" id="3d1c" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Makefile</strong></li></ol><p name="3165" id="3165" class="graf graf--p graf-after--li">Before we begin to learn how the C compiles the function, let’s first go through the <code class="markup--code markup--p-code">Makefile</code> file from the last experiment. The content of this file is,</p><pre name="8adf" id="8adf" class="graf graf--pre graf-after--p">NAME = blink<br>CFLAGS = -Og -Wall -std=c99 -ffreestanding<br>LDFLAGS = -nostdlib -e main</pre><pre name="7c51" id="7c51" class="graf graf--pre graf-after--pre">.PRECIOUS: %.elf %.o</pre><pre name="c16b" id="c16b" class="graf graf--pre graf-after--pre">all : $(NAME).bin</pre><pre name="6a14" id="6a14" class="graf graf--pre graf-after--pre">%.bin: %.elf<br>  arm-none-eabi-objcopy $&lt; -O binary $@</pre><pre name="21db" id="21db" class="graf graf--pre graf-after--pre">%.elf: %.o<br>  arm-none-eabi-ld $(LDFLAGS) $&lt; -o $@</pre><pre name="d49f" id="d49f" class="graf graf--pre graf-after--pre">%.o: %.c<br>  arm-none-eabi-gcc $(CFLAGS) -c $&lt; -o $@</pre><pre name="5543" id="5543" class="graf graf--pre graf-after--pre">install: $(NAME).bin<br>  rpi-install.py $&lt;</pre><pre name="7ca7" id="7ca7" class="graf graf--pre graf-after--pre">clean:<br>  rm -f *.o *.elf *.bin</pre><p name="1beb" id="1beb" class="graf graf--p graf-after--pre">After we type the <code class="markup--code markup--p-code">$ make</code> command, the command we are actually running is,</p><pre name="d989" id="d989" class="graf graf--pre graf-after--p">$ arm-none-eabi-gcc -Og -Wall -std=c99 -ffreestanding -c blink.c -o blink.o<br>$ arm-none-eabi-ld -nostdlib -e main blink.o -o blink.elf<br>$ arm-none-eabi-objcopy blink.elf -O binary blink.bin</pre><p name="ca15" id="ca15" class="graf graf--p graf-after--pre">By this result, we can start to discover what’s the meaning of each part of this makefile,</p><ul class="postList"><li name="0087" id="0087" class="graf graf--li graf-after--p">The first three lines assign three variables: <code class="markup--code markup--li-code">NAME</code> , <code class="markup--code markup--li-code">CFLAGS</code> , and <code class="markup--code markup--li-code">LDFLAGS</code> . The first one is the name for our file, well, in this case, it should be <code class="markup--code markup--li-code">blink</code> (we can change the value of this variable for some other files). The variables <code class="markup--code markup--li-code">CFLAGS</code> and <code class="markup--code markup--li-code">LDFLAGS</code> are the options (flags) of the <code class="markup--code markup--li-code">gcc</code> command and the <code class="markup--code markup--li-code">ld</code> command, respectively.</li><li name="db10" id="db10" class="graf graf--li graf-after--li">The word after <code class="markup--code markup--li-code">make</code> means where we start and end the makefile script. For example,</li></ul><pre name="4ff4" id="4ff4" class="graf graf--pre graf-after--li">$ make all</pre><p name="e209" id="e209" class="graf graf--p graf-after--pre">where <code class="markup--code markup--p-code">all</code> can be omitted starts the command from <code class="markup--code markup--p-code">all:</code> and ends the command before <code class="markup--code markup--p-code">install:</code>.</p><pre name="fa75" id="fa75" class="graf graf--pre graf-after--p">all : $(NAME).bin</pre><pre name="0aa5" id="0aa5" class="graf graf--pre graf-after--pre">%.bin: %.elf<br>  arm-none-eabi-objcopy $&lt; -O binary $@</pre><pre name="c644" id="c644" class="graf graf--pre graf-after--pre">%.elf: %.o<br>  arm-none-eabi-ld $(LDFLAGS) $&lt; -o $@</pre><pre name="0431" id="0431" class="graf graf--pre graf-after--pre">%.o: %.c<br>  arm-none-eabi-gcc $(CFLAGS) -c $&lt; -o $@</pre><p name="1f0a" id="1f0a" class="graf graf--p graf-after--pre">Similarly,</p><pre name="26a9" id="26a9" class="graf graf--pre graf-after--p">$ make install</pre><p name="4c79" id="4c79" class="graf graf--p graf-after--pre">will run,</p><pre name="c19a" id="c19a" class="graf graf--pre graf-after--p">install: $(NAME).bin<br>  rpi-install.py $&lt;</pre><p name="363b" id="363b" class="graf graf--p graf-after--pre">And also,</p><pre name="834e" id="834e" class="graf graf--pre graf-after--p">$ make clean</pre><p name="593c" id="593c" class="graf graf--p graf-after--pre">will run,</p><pre name="02fb" id="02fb" class="graf graf--pre graf-after--p">clean:<br>  rm -f *.o *.elf *.bin</pre><ul class="postList"><li name="1ba5" id="1ba5" class="graf graf--li graf-after--pre">If we want to cite the value of a variable, we have to add the <code class="markup--code markup--li-code">$()</code> symbol to show that this is the value of a variable. For example,</li></ul><pre name="05de" id="05de" class="graf graf--pre graf-after--li">$(CFLAGS)</pre><ul class="postList"><li name="1d37" id="1d37" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">%</code> acts as a wildcard for anything. For example,</li></ul><pre name="571b" id="571b" class="graf graf--pre graf-after--li">%.o</pre><p name="13f1" id="13f1" class="graf graf--p graf-after--pre">means any file ending with <code class="markup--code markup--p-code">.o</code> .</p><ul class="postList"><li name="d77f" id="d77f" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">$@</code> is the name of the target being generated, and <code class="markup--code markup--li-code">$&lt;</code> the first prerequisite (usually a source file). For example, for</li></ul><pre name="89d1" id="89d1" class="graf graf--pre graf-after--li">%.elf: %.o</pre><p name="0436" id="0436" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">$&lt;</code> means the source file <code class="markup--code markup--p-code">%.o</code> and <code class="markup--code markup--p-code">$@</code> means the target file <code class="markup--code markup--p-code">%.elf</code>. Thus, the statement above actually determines how to compile a file ending with <code class="markup--code markup--p-code">.o</code> to a file ending with <code class="markup--code markup--p-code">.elf</code> .</p><ul class="postList"><li name="56c2" id="56c2" class="graf graf--li graf-after--p">Let’s now find out what does <code class="markup--code markup--li-code">.PRECIOUS: %.elf %.o</code> do for us. We can actually delete this line and then retry the compiling process by,</li></ul><pre name="83a8" id="83a8" class="graf graf--pre graf-after--li">$ make clean<br>$ make</pre><p name="2cd2" id="2cd2" class="graf graf--p graf-after--pre">Now, the commands we actually ran are,</p><pre name="12ca" id="12ca" class="graf graf--pre graf-after--p">$ arm-none-eabi-gcc -Og -Wall -std=c99 -ffreestanding -c blink.c -o blink.o<br>$ arm-none-eabi-ld -nostdlib -e main blink.o -o blink.elf<br>$ arm-none-eabi-objcopy blink.elf -O binary blink.bin<br>$ rm blink.elf blink.o</pre><p name="9860" id="9860" class="graf graf--p graf-after--pre">We can notice that the last command automatically deletes all the intermediate files for us. So the <code class="markup--code markup--p-code">.PRECIOUS: %.elf %.o</code> is the command for us to keep the intermediate files.</p><p name="065e" id="065e" class="graf graf--p graf-after--p">Now, let’s continue to analyze how does the compiler constructs the functions.</p><p name="f676" id="f676" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. C Function Stack</strong></p><p name="517e" id="517e" class="graf graf--p graf-after--p">Let’s see the simplest function in C,</p><pre name="0c78" id="0c78" class="graf graf--pre graf-after--p">void main(){}</pre><p name="8444" id="8444" class="graf graf--p graf-after--pre">This main function is useless but it will show us how does the compiler work. Let’s go to <a href="https://godbolt.org/" data-href="https://godbolt.org/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">godbolt.org</a> to check our code. Remember you must choose <code class="markup--code markup--p-code">C</code>, <code class="markup--code markup--p-code">ARM gcc 5.4.1 (none)</code> and <code class="markup--code markup--p-code">-g0</code> as the options,</p><figure name="983e" id="983e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MsF_z7PMAMA00Qg9wbMMcA.png" data-width="2602" data-height="448" src="https://cdn-images-1.medium.com/max/800/1*MsF_z7PMAMA00Qg9wbMMcA.png"></figure><pre name="d9b0" id="d9b0" class="graf graf--pre graf-after--figure">main:<br>   str     fp, [sp, #-4]!<br>   add     fp, sp, #0<br>   mov     r0, r0<br>   sub     sp, fp, #0<br>   ldr     fp, [sp], #4<br>   bx      lr</pre><p name="50f6" id="50f6" class="graf graf--p graf-after--pre">Before we analyze this assembly code, we have to know the meaning of <code class="markup--code markup--p-code">sp</code> and <code class="markup--code markup--p-code">fp</code> . <code class="markup--code markup--p-code">sp</code> is the <strong class="markup--strong markup--p-strong">stack pointer</strong> register which contains the address of the last written value. Actually, it is pointing to the last written value (or the top of that stack) on the stack. While <code class="markup--code markup--p-code">fp</code> stands for the <strong class="markup--strong markup--p-strong">frame pointer</strong> register which is used as a base pointer to local variables on the stack. It is also treated as the pointer pointing to the bottom of a stack.</p><p name="1276" id="1276" class="graf graf--p graf-after--p">Let’s now try this code in the VisUAL. You should know that the VisUAL doesn’t support <code class="markup--code markup--p-code">sp</code> and <code class="markup--code markup--p-code">fp</code>, so we have to replace them with the <code class="markup--code markup--p-code">r0</code> and <code class="markup--code markup--p-code">r1</code> register.</p><p name="1370" id="1370" class="graf graf--p graf-after--p">Because <code class="markup--code markup--p-code">r0</code> and <code class="markup--code markup--p-code">r1</code> have initial value <code class="markup--code markup--p-code">0x0</code> in the first place and this is obviously not the case that’s going to happen in the real world, so we have to assign the values of them firstly. Note that the <code class="markup--code markup--p-code">r1</code> is used to represent <code class="markup--code markup--p-code">fp</code>, so the value of <code class="markup--code markup--p-code">r0</code> should be no more than <code class="markup--code markup--p-code">r1</code>. In our case, we create a fake stack with its <code class="markup--code markup--p-code">sp</code> pointing towards <code class="markup--code markup--p-code">0x3f000000</code> and its <code class="markup--code markup--p-code">fp</code> pointing to <code class="markup--code markup--p-code">0x3f000008</code>.</p><pre name="3f32" id="3f32" class="graf graf--pre graf-after--p">ldr  r0, =0x3f000000<br>ldr  r1, =0x3f000008</pre><p name="ca87" id="ca87" class="graf graf--p graf-after--pre">Then, we use the following code to test the stack and this code can also be found from my <a href="https://github.com/Sadamingh/ComputerSysE/tree/main/function" data-href="https://github.com/Sadamingh/ComputerSysE/tree/main/function" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">repo</a>.</p><pre name="a2bb" id="a2bb" class="graf graf--pre graf-after--p">ldr  r0, =0x3f000000<br>ldr  r1, =0x3f000008<br>  <br>str  r1, [r0, #-4]!<br>add  r1, r0, #0<br>sub  r0, r1, #0<br>ldr  r1, [r0], #4</pre><p name="8a98" id="8a98" class="graf graf--p graf-after--pre">After the first two assignment, the register <code class="markup--code markup--p-code">r0</code> and <code class="markup--code markup--p-code">r1</code> is assigned with the given address,</p><figure name="4a0f" id="4a0f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*--aSwpDYbIkU3b30OV-jog.png" data-width="2016" data-height="448" src="https://cdn-images-1.medium.com/max/800/1*--aSwpDYbIkU3b30OV-jog.png"></figure><p name="8b02" id="8b02" class="graf graf--p graf-after--figure">Then,</p><pre name="c77f" id="c77f" class="graf graf--pre graf-after--p">str  r1, [r0, #-4]!</pre><p name="8c57" id="8c57" class="graf graf--p graf-after--pre">means to store the present address in <code class="markup--code markup--p-code">r1</code> (or <code class="markup--code markup--p-code">fp</code>) to the <code class="markup--code markup--p-code">r0-4</code> (or <code class="markup--code markup--p-code">sp-4</code>) address. This is called the base-register addressing and the <code class="markup--code markup--p-code">!</code> in the end, means that the value of <code class="markup--code markup--p-code">r0</code> (or <code class="markup--code markup--p-code">sp</code>) will also be changed.</p><figure name="ed47" id="ed47" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*O9C4fsP7EjdLlET9kgI_-A.png" data-width="2016" data-height="448" src="https://cdn-images-1.medium.com/max/800/1*O9C4fsP7EjdLlET9kgI_-A.png"></figure><p name="9365" id="9365" class="graf graf--p graf-after--figure">Then,</p><pre name="b4be" id="b4be" class="graf graf--pre graf-after--p">add  r1, r0, #0</pre><p name="927f" id="927f" class="graf graf--p graf-after--pre">replaces the value in <code class="markup--code markup--p-code">r1</code> with the value of <code class="markup--code markup--p-code">r0</code> . This command shift to a new stack above the previous stack. Since this moment, a new stack for this <code class="markup--code markup--p-code">main</code> function is now created. The following commands are used to remove this stack,</p><pre name="8339" id="8339" class="graf graf--pre graf-after--p">sub  r0, r1, #0</pre><p name="bdfd" id="bdfd" class="graf graf--p graf-after--pre">is the opposite operation of the <code class="markup--code markup--p-code">add</code> command and,</p><pre name="6561" id="6561" class="graf graf--pre graf-after--p">ldr  r1, [r0], #4</pre><p name="2a58" id="2a58" class="graf graf--p graf-after--pre">gets the value from the value that <code class="markup--code markup--p-code">r0</code> (sp) is pointing to and then add 4 to the <code class="markup--code markup--p-code">r0</code> to retain the original condition.</p><figure name="d2a4" id="d2a4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*a8DsCszNuoV8ODQhoBytSw.png" data-width="2016" data-height="448" src="https://cdn-images-1.medium.com/max/800/1*a8DsCszNuoV8ODQhoBytSw.png"></figure><p name="64e7" id="64e7" class="graf graf--p graf-after--figure graf--trailing">In the next experiment, we are going to create a counter from 0 to 9 based on the C language.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/5b495f364af4"><time class="dt-published" datetime="2021-01-04T11:01:32.745Z">January 4, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/computer-systems-experiments-15-makefile-and-c-function-stack-5b495f364af4" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>