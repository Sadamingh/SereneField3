<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 3 | Process and Process Management, Process Control Block, Process Lifecycle…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 3 | Process and Process Management, Process Control Block, Process Lifecycle…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="a0d9" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d6d2" id="d6d2" class="graf graf--h3 graf--leading graf--title">Operating System 3 | Process and Process Management, Process Control Block, Process Lifecycle, Process Scheduling, and Process Communication</h3><figure name="3b54" id="3b54" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*pvX403KYxMklPqIF.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*pvX403KYxMklPqIF.png"></figure><ol class="postList"><li name="9b21" id="9b21" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Process</strong></li></ol><p name="331d" id="331d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Applications</strong></p><p name="0086" id="0086" class="graf graf--p graf-after--p">The application is a program on disk, in flash memory, or even in the cloud. But it is not executing and it can be treated as a <strong class="markup--strong markup--p-strong">static entity</strong>.</p><p name="e778" id="e778" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Process</strong></p><p name="0024" id="0024" class="graf graf--p graf-after--p">One of the most important abstractions of the operating system is a process. In the simplest terms, a <strong class="markup--strong markup--p-strong">process</strong> is an instance of an executing program. Sometimes it makes sense to use a <strong class="markup--strong markup--p-strong">task</strong> or <strong class="markup--strong markup--p-strong">job</strong> to represent a process. We have talked that the application is a static entity, while, once an application is launched, it is loaded into the memory and it starts executing, and then it becomes a process. So in conclusion, the process is an <strong class="markup--strong markup--p-strong">active entity</strong>.</p><p name="7c37" id="7c37" class="graf graf--p graf-after--p">A process has its<strong class="markup--strong markup--p-strong"> state of execution</strong> which described with the program counter (PC), the stack pointer (SP), and all this information is used by the operating system to decide how to <strong class="markup--strong markup--p-strong">schedule</strong> the process, how to <strong class="markup--strong markup--p-strong">swap</strong> between multiple processes, and for other management of tasks.</p><p name="c260" id="c260" class="graf graf--p graf-after--p">A process also has its parts or as we called the <strong class="markup--strong markup--p-strong">temporary holding area</strong>. In order to execute, the process needs some <strong class="markup--strong markup--p-strong">data</strong> and some <strong class="markup--strong markup--p-strong">states</strong> in the register.</p><p name="de14" id="de14" class="graf graf--p graf-after--p">A processor also requires some special <strong class="markup--strong markup--p-strong">hardware</strong>, like I/O devices, disks, or network devices.</p><p name="6639" id="6639" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Program Vs. Process</strong></p><p name="6c69" id="6c69" class="graf graf--p graf-after--p">If the <strong class="markup--strong markup--p-strong">same</strong> program (static) is launched more than once, then <strong class="markup--strong markup--p-strong">multiple</strong> processes (active) will be created. These processes will be executing the same program, but they are very likely to have very different states.</p><p name="b6c8" id="b6c8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) The Definition of Address Space</strong></p><p name="49d4" id="49d4" class="graf graf--p graf-after--p">A process encapsulates all of the data for running applications, and this includes the code, the data, the variables, etc. Every single element of the process state has to be uniquely identified by its address. So an OS abstraction used to encapsulate all of the process states is <strong class="markup--strong markup--p-strong">address space</strong>.</p><p name="b3f1" id="b3f1" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">address space</strong> is defined by a range of address from <code class="markup--code markup--p-code">V0</code> to <code class="markup--code markup--p-code">Vmax</code> and different types of process states will appear in different regions in this address space.</p><p name="657e" id="657e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Different Types of States</strong></p><p name="52ef" id="52ef" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Static State</strong>: available when the process first loads</p><ul class="postList"><li name="80a0" id="80a0" class="graf graf--li graf-after--p">Text</li><li name="d358" id="d358" class="graf graf--li graf-after--li">Data</li></ul><p name="a7a4" id="a7a4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Heap</strong>: heap is an area of dynamically-allocated memory. the heap doesn’t have to be a continuous portion of the address space (right after the static state). during the execution, the process dynamically</p><ul class="postList"><li name="898d" id="898d" class="graf graf--li graf-after--p">creates some state</li><li name="47b8" id="47b8" class="graf graf--li graf-after--li">allocates memory</li><li name="929a" id="929a" class="graf graf--li graf-after--li">store the temporary results</li><li name="a506" id="a506" class="graf graf--li graf-after--li">reads data from files</li><li name="f7e1" id="f7e1" class="graf graf--li graf-after--li">etc.</li></ul><p name="6439" id="6439" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Stack</strong>: a dynamic part of the address space and it grows and shrinks during the execution with a last-in, first-out (LIFO) order. The stack can be used to store and retrieve the state of a process</p><ul class="postList"><li name="926e" id="926e" class="graf graf--li graf-after--p">restore states</li><li name="33b8" id="33b8" class="graf graf--li graf-after--li">swap states</li></ul><p name="70c4" id="70c4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) Virtual Address Vs. Physical Address</strong></p><p name="bbd9" id="bbd9" class="graf graf--p graf-after--p">Recall we have said that the potential address of the address space (<code class="markup--code markup--p-code">V0</code> to <code class="markup--code markup--p-code">Vmax</code>) represents the <strong class="markup--strong markup--p-strong">maximum size</strong> of the process address space. We call these addresses <strong class="markup--strong markup--p-strong">virtual addresses</strong> because the process uses these addresses to reference some of its states and these addresses don’t have to correspond to the actual locations in the physical memory (<strong class="markup--strong markup--p-strong">physical addresses, DRAM</strong>).</p><blockquote name="a17f" id="a17f" class="graf graf--blockquote graf-after--p">Physical addressing means that your program actually knows the real layout of RAM. With virtual addressing, all application memory accesses go to a page table, which then maps from the virtual to the physical address. So every application has its own “private” address space, and no program can read or write to another program’s memory. This is called segmentation.</blockquote><blockquote name="8057" id="8057" class="graf graf--blockquote graf-after--blockquote">— — Borealid, from <a href="https://stackoverflow.com/questions/3243610/difference-betBorealideen-physical-addressing-and-virtual-addressing-concept" data-href="https://stackoverflow.com/questions/3243610/difference-betBorealideen-physical-addressing-and-virtual-addressing-concept" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">StackOverflow</a></blockquote><p name="1f7a" id="1f7a" class="graf graf--p graf-after--blockquote">However, it is necessary for the progress to access physical addresses or it will not find the exact space of the data in the memory. Actually, the memory management hardware and the operating system components responsible for memory management by <strong class="markup--strong markup--p-strong">mapping</strong> between each virtual address and each physical address. This separation between application and physical memory will allow us to maintain physical memory management simple and not in any way dictated by the data layout that all processes are executing.</p><p name="6fbb" id="6fbb" class="graf graf--p graf-after--p">First of all, the process requests some memory to be allocated by the operating system to it at a particular virtual address. Then the address of the physical memory that the operating system actually allocates will be mapped to the virtual address and this map will be stored as an entry in the <strong class="markup--strong markup--p-strong">page table</strong>. When the process tries to access the virtual address, the operating system finds the physical address according to the mapping rules in the page table. Therefore, even the processes have the <strong class="markup--strong markup--p-strong">exact</strong> <strong class="markup--strong markup--p-strong">same</strong> virtual address space, they can work with no conflicts.</p><p name="fafc" id="fafc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Concerns About Insufficient Memory</strong></p><p name="faa7" id="faa7" class="graf graf--p graf-after--p">It seems possible that if we have the same virtual space for all the processes, our memory can become full easily. For example, let’s suppose we have to execute a program 4 times and this program has a virtual space of 4GB. However, our memory has 8GB in total and for some worst cases, the 4 processes will request memory for more than 8GB (max = 4*4 = 16GB), and then it is possible for the memory to be full.</p><p name="e030" id="e030" class="graf graf--p graf-after--p">However, the modern operating system will request some space on the disk to avoid this problem. When these data stored on the disk are needed, they will be reloaded to the memory.</p><p name="6976" id="6976" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Process Control Block</strong></p><p name="2b1a" id="2b1a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Program Counter</strong></p><p name="7553" id="7553" class="graf graf--p graf-after--p">Before the execution of an application, its source code must be compiled in binary (assembly code). At any given time, the CPU needs to know where the process currently is in this binary sequence and it uses the <strong class="markup--strong markup--p-strong">program counter</strong> (PC), which is maintained in a <strong class="markup--strong markup--p-strong">register</strong> of the CPU while the program is executing.</p><p name="7975" id="7975" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Stack Pointer</strong></p><p name="a2d0" id="a2d0" class="graf graf--p graf-after--p">Another piece of state that defines what a process is doing is the <strong class="markup--strong markup--p-strong">process stack</strong> and the top of this stack is determined by the <strong class="markup--strong markup--p-strong">stack pointer</strong>. A stack pointer is a small register on the CPU that stores the address of the last program request in a stack.</p><p name="d649" id="d649" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of Process Control Block</strong></p><p name="ed43" id="ed43" class="graf graf--p graf-after--p">To maintain all the useful information for every single process, the operating system uses a <strong class="markup--strong markup--p-strong">process control block</strong> (PCB) to store all the state information for a process. The process control block is a data structure that the operating system uses for maintaining every one of the processes. The PCB is created when the process is created and it also initialized at that time and certain fields are updated when the process states changes.</p><p name="ed9b" id="ed9b" class="graf graf--p graf-after--p">A process control block is likely to contain the following information,</p><ul class="postList"><li name="b2df" id="b2df" class="graf graf--li graf-after--p">process number</li><li name="d178" id="d178" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">program counter</strong></li><li name="9552" id="9552" class="graf graf--li graf-after--li">registers (i.e. the stack pointer)</li><li name="c37e" id="c37e" class="graf graf--li graf-after--li">memory limits: various memory mappings</li><li name="a185" id="a185" class="graf graf--li graf-after--li">list of open files</li><li name="4096" id="4096" class="graf graf--li graf-after--li">priority</li><li name="4e5b" id="4e5b" class="graf graf--li graf-after--li">signal mask</li><li name="1a0d" id="1a0d" class="graf graf--li graf-after--li">CPU scheduling information: how much time this process has executed in the CPU and how much time it should be allocated in the future</li><li name="955b" id="955b" class="graf graf--li graf-after--li">etc.</li></ul><p name="4802" id="4802" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Interactions Between PCB and CPU</strong></p><p name="9979" id="9979" class="graf graf--p graf-after--p">Now, let’s see how PCB interacts with the CPU. Suppose we only have two processes <code class="markup--code markup--p-code">P1</code> and <code class="markup--code markup--p-code">P2</code>, and the CPU schedule is as follows. The green bar means that the corresponding process is executing, while the white bar means that it is an ideal process at the moment.</p><figure name="0aa7" id="0aa7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*EiO9DDk3geb0z5DrdIHrQw.png" data-width="1764" data-height="394" src="https://cdn-images-1.medium.com/max/800/1*EiO9DDk3geb0z5DrdIHrQw.png"></figure><p name="3dda" id="3dda" class="graf graf--p graf-after--figure">At the time <code class="markup--code markup--p-code">T1</code>, both of the processes <code class="markup--code markup--p-code">P1</code> and <code class="markup--code markup--p-code">P2</code> are created and initialized. Because CPU will execute <code class="markup--code markup--p-code">P1</code> first so that the state of <code class="markup--code markup--p-code">P1</code> is loaded to CPU and the state of <code class="markup--code markup--p-code">P2</code> is saved. At the time <code class="markup--code markup--p-code">T2</code>, the CPU is going to switch the process from <code class="markup--code markup--p-code">P1</code> to <code class="markup--code markup--p-code">P2</code>. So it saves the current CPU states to <code class="markup--code markup--p-code">PCB_P1</code> in the memory and then restores the state of <code class="markup--code markup--p-code">P2</code> from the <code class="markup--code markup--p-code">PCB_P2</code> . Finally at the time <code class="markup--code markup--p-code">T3</code>, the CPU is going to switch the process from <code class="markup--code markup--p-code">P2</code> to <code class="markup--code markup--p-code">P1</code>. So it saves the current CPU states to <code class="markup--code markup--p-code">PCB_P2</code> in the memory and then restores the state of <code class="markup--code markup--p-code">P1</code> from the <code class="markup--code markup--p-code">PCB_P1</code> .</p><figure name="c1b7" id="c1b7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*c8WreQHugDvt4mFVHpGsHg.png" data-width="1764" data-height="604" src="https://cdn-images-1.medium.com/max/800/1*c8WreQHugDvt4mFVHpGsHg.png"></figure><p name="b6e7" id="b6e7" class="graf graf--p graf-after--figure">Note that the state in the PCB is updated while the processes switching. So we don’t have to update the state of the PCB whenever the PC counts or it will cost a lot for the L/W instructions. We are going to explain more about this in the following section.</p><p name="c32b" id="c32b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Context Switch</strong></p><p name="7726" id="7726" class="graf graf--p graf-after--p">The context switch is a mechanism used by the operating system to switch the execution from the context of one process to the context of another process. This operation can be expensive because of the following two reasons,</p><ul class="postList"><li name="afe7" id="afe7" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Direct Costs</strong>: the number of cycles that have to be executed to load/store all the values from the process control blocks to/from memory.</li><li name="8837" id="8837" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Indirect Costs</strong>: when the process <code class="markup--code markup--li-code">P1</code> is running on the CPU, lots of its data is going to be stored in the processor’s <strong class="markup--strong markup--li-strong">cache</strong> and this is called a <strong class="markup--strong markup--li-strong">hot cache</strong>. The cash is a place for the CPU to access some data (tens of instructions) and it is much faster than accessing the memory (hundreds of instructions). However, when the context switch happens, all of the data in the cache belonging to <code class="markup--code markup--li-code">P1</code> will be replaced to make room for the new data. So next time when <code class="markup--code markup--li-code">P1</code> is scheduled to execute, its data can only be accessed from the memory and we call this situation a <strong class="markup--strong markup--li-strong">cache missing problem.</strong> And also, the cache now without the data of the process we want to execute is called a <strong class="markup--strong markup--li-strong">cold cache</strong>.</li></ul><p name="d170" id="d170" class="graf graf--p graf-after--li">Therefore, it is significant for us to limit the frequency of the context switching.</p><p name="3509" id="3509" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Process Lifecycle</strong></p><p name="9b2c" id="9b2c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Process Id</strong></p><p name="9ffb" id="9ffb" class="graf graf--p graf-after--p">In most operating systems, the <strong class="markup--strong markup--p-strong">process id</strong> (or process identity or pid) is used to <strong class="markup--strong markup--p-strong">uniquely</strong> identify an active process.</p><p name="2050" id="2050" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Process States</strong></p><p name="2f26" id="2f26" class="graf graf--p graf-after--p">As we have said, processes can be <strong class="markup--strong markup--p-strong">idle (ready)</strong> or <strong class="markup--strong markup--p-strong">running</strong>. These are two of the commonest states for any given process. When the process is running, it can be interrupted or context-switched and then become an idle process (also called the <strong class="markup--strong markup--p-strong">ready state</strong>). This is also called a ready state because it is ready to execute but it is not the current context that is running on the CPU. At some other moment, the scheduler will schedule this process again and then it will start executing on the CPU so it becomes a <strong class="markup--strong markup--p-strong">running state</strong>.</p><p name="6252" id="6252" class="graf graf--p graf-after--p">Moreover, there are some other states of the process that we have to know.</p><p name="ff9f" id="ff9f" class="graf graf--p graf-after--p">When the process is created initially, it enters the <strong class="markup--strong markup--p-strong">new</strong> state. Then the OS will perform admission control and it will determine if the process can be allocated and initialized. When it is at the <strong class="markup--strong markup--p-strong">ready</strong> state, it can be executed at any time if it is dispatched to the CPU. After the scheduler moves this process to the CPU, it then becomes the <strong class="markup--strong markup--p-strong">running</strong> state. From here, a number of things can happen,</p><ul class="postList"><li name="5b45" id="5b45" class="graf graf--li graf-after--p">If the running state is interrupted by some other process, the OS will move the running state of the current process back to the <strong class="markup--strong markup--li-strong">ready state</strong>.</li><li name="53f8" id="53f8" class="graf graf--li graf-after--li">If the running state is pending for some operations that take a long time like I/O or event (i.e. timer or keyboard), then the process enters the <strong class="markup--strong markup--li-strong">waiting state</strong> until these operations are finished.</li><li name="828b" id="828b" class="graf graf--li graf-after--li">If the running state finishes all the operations of the program or encounters some kind of error, then it will exit. It will return the appropriate exit code and then the process is <strong class="markup--strong markup--li-strong">terminated</strong>.</li></ul><figure name="b00a" id="b00a" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*j_KnWqxuYUtjI7JXA9Fnag.png" data-width="1720" data-height="514" src="https://cdn-images-1.medium.com/max/800/1*j_KnWqxuYUtjI7JXA9Fnag.png"></figure><p name="aa8a" id="aa8a" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) Process Creation</strong></p><p name="bd65" id="bd65" class="graf graf--p graf-after--p">Actually, all the processes come from a single root process and they will have some of the relationships to one and another where the creating process is the <strong class="markup--strong markup--p-strong">parent</strong> and the created process is the <strong class="markup--strong markup--p-strong">child</strong>. You can imagine that because all the processes come from a single root process and all of them could have new children. Thus, the process is more like a tree for its data structure. This is called a <strong class="markup--strong markup--p-strong">process tree</strong>. We can view the current process tree by,</p><pre name="170b" id="170b" class="graf graf--pre graf-after--p">$ ps -e</pre><p name="f118" id="f118" class="graf graf--p graf-after--pre">Then you can find that we have many processes and the root for all of them is the process with <code class="markup--code markup--p-code">pid = 1</code> and name <code class="markup--code markup--p-code">launchd</code>(For Mac OS), or name <code class="markup--code markup--p-code">init</code> (for UNIX-like), or name <code class="markup--code markup--p-code">zygote</code> (For Android OS). You can also find the process related only to the current terminal by,</p><pre name="ba2e" id="ba2e" class="graf graf--pre graf-after--p">$ ps -a</pre><p name="8d7f" id="8d7f" class="graf graf--p graf-after--pre">So how can a process create more processes? Well, the use of <code class="markup--code markup--p-code">fork</code> and <code class="markup--code markup--p-code">exec</code> provide a very simple way to create new processes. Both the <code class="markup--code markup--p-code">fork</code> and <code class="markup--code markup--p-code">exec</code> are system calls of the operating system and their meanings are,</p><ul class="postList"><li name="c12a" id="c12a" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">fork</code> will create a copy of the current process as its child process. The values from the PCB of the current process will be copied. At that point, <strong class="markup--strong markup--li-strong">both</strong> the parent and the child will be continuing immediately after the fork because both of them have almost the same values in their process control block.</li><li name="9251" id="9251" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">exec</code> will take the created PCB by fork and rewrite the value of it with some other programs. Thus a new program will be load and the child PCB will now be different from the parent PCB. The child process now contains the values from the new programs. A more accurate definition given by <a href="https://medium.com/u/56cb88d11d17" data-href="https://medium.com/u/56cb88d11d17" data-anchor-type="2" data-user-id="56cb88d11d17" data-action-value="56cb88d11d17" data-action="show-user-card" data-action-type="hover" class="markup--user markup--li-user" target="_blank">Yemaosen</a> is that the <code class="markup--code markup--li-code">exec</code> call is a way to replace the entire current process with a new program. It loads the program into the current process space and runs it from the entry point.</li></ul><p name="951b" id="951b" class="graf graf--p graf-after--li">Now, let’s have a try. Let’s open two terminals and execute the command <code class="markup--code markup--p-code">ps</code> in one of these 2 terminals,</p><pre name="4f1e" id="4f1e" class="graf graf--pre graf-after--p">$ ps</pre><p name="7ec9" id="7ec9" class="graf graf--p graf-after--pre">The output should be as follows (note that the <code class="markup--code markup--p-code">PID</code>, <code class="markup--code markup--p-code">TTY</code>, and <code class="markup--code markup--p-code">TIME</code> can be different),</p><pre name="9579" id="9579" class="graf graf--pre graf-after--p">PID   TTY           TIME CMD<br>25867 ttys000    0:00.38 -bash<br>32580 ttys001    0:00.24 -bash</pre><p name="01fe" id="01fe" class="graf graf--p graf-after--pre">Now, let’s run the following command in another terminal (for me, <code class="markup--code markup--p-code">pid = 32580</code>),</p><pre name="1e8e" id="1e8e" class="graf graf--pre graf-after--p">$ cat</pre><p name="bbab" id="bbab" class="graf graf--p graf-after--pre">And from the first terminal, we now run,</p><pre name="a06e" id="a06e" class="graf graf--pre graf-after--p">$ ps</pre><p name="5944" id="5944" class="graf graf--p graf-after--pre">Then we can find a new process of <code class="markup--code markup--p-code">cat</code> ,</p><pre name="8790" id="8790" class="graf graf--pre graf-after--p">  PID TTY           TIME CMD<br>25867 ttys000    0:00.38 -bash<br>32580 ttys001    0:00.24 -bash<br>33681 ttys001    0:00.00 cat</pre><p name="adc1" id="adc1" class="graf graf--p graf-after--pre">This process is actually the child process (for me, <code class="markup--code markup--p-code">pid = 33681</code>) of the second process (for me, <code class="markup--code markup--p-code">pid = 32580</code>). Then we can use <code class="markup--code markup--p-code">^c</code> to kill the process of <code class="markup--code markup--p-code">33681</code> . After killing this process, we can find out that there is no <code class="markup--code markup--p-code">cat</code> process.</p><pre name="d6e8" id="d6e8" class="graf graf--pre graf-after--p">$ ps</pre><p name="5565" id="5565" class="graf graf--p graf-after--pre">So what really happens? In fact, when we run the command <code class="markup--code markup--p-code">cat</code> , the terminal actually uses both the <code class="markup--code markup--p-code">fork</code> system call and the <code class="markup--code markup--p-code">exec</code> system call. The <code class="markup--code markup--p-code">fork</code> is called (shown in <code class="markup--code markup--p-code">1.</code>) in the first place to create a copy of the process <code class="markup--code markup--p-code">32580</code> . Then the <code class="markup--code markup--p-code">exec</code> is called to replace the PCB of the process <code class="markup--code markup--p-code">33681</code> with the context of the command <code class="markup--code markup--p-code">cat</code> . After we killed the process <code class="markup--code markup--p-code">33681</code> by <code class="markup--code markup--p-code">^c</code>, the CPU will restore the state of its parent process <code class="markup--code markup--p-code">32580</code>. This is shown by the following diagram.</p><pre name="0707" id="0707" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">+------------+<br>| pid=32580  |<br>| bash       |<br>|            |<br>+------------+<br>    |<br>    | 1. calls <strong class="markup--strong markup--pre-strong">fork</strong><br>    V<br>+------------+             +-----------+<br>| pid=32580  |    forks    | pid=33681 |<br>| bash       | ----------&gt; | bash      |<br>|            |             |           |<br>+------------+             +-----------+<br>    |                            |<br>    | waits for pid 33681        | 2. calls <strong class="markup--strong markup--pre-strong">exec</strong> to run cat<br>    |                            V<br>    |                      +-----------+<br>    |                      | pid=33681 |<br>    |                      | cat       |<br>    |                      |           |<br>    V                      +-----------+<br>+------------+                   |<br>| pid=32580  |                   | exits<br>| bash       | &lt;-----------------+<br>|            |<br>+------------+<br>    |<br>    | continues<br>    V</code></pre><p name="4999" id="4999" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4. CPU Scheduling</strong></p><p name="2bfe" id="2bfe" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of CPU Scheduler</strong></p><p name="72b9" id="72b9" class="graf graf--p graf-after--p">The CPU scheduler is an operating system component that manages how processes use the CPU resources. A <strong class="markup--strong markup--p-strong">CPU scheduler</strong> defines <strong class="markup--strong markup--p-strong">which</strong> one of the currently ready processes will be dispatched to the CPU to start running, and <strong class="markup--strong markup--p-strong">how long</strong> it should run for.</p><p name="505b" id="505b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of the Ready Queue</strong></p><p name="1f3b" id="1f3b" class="graf graf--p graf-after--p">At a time we may have several processes that are in the ready state. And the <strong class="markup--strong markup--p-strong">ready queue</strong> is defined as the combination of all of these ready processes.</p><p name="fa69" id="fa69" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of Preemption</strong></p><p name="c651" id="c651" class="graf graf--p graf-after--p">To act the role of the scheduler, the operating system must be able to <strong class="markup--strong markup--p-strong">preempt</strong>,<strong class="markup--strong markup--p-strong"> </strong>which means to<strong class="markup--strong markup--p-strong"> </strong>interrupt and save the context of the current process. This is called <strong class="markup--strong markup--p-strong">preemption</strong>.</p><p name="7a73" id="7a73" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Steps of Scheduling</strong></p><p name="db4d" id="db4d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 1.</strong> Preemption: interrupt &amp; save</p><p name="392b" id="392b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 2.</strong> Schedule: by running some scheduling algorithms</p><p name="930a" id="930a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Step 3.</strong> Dispatch: dispatch process &amp; switch context</p><p name="ecce" id="ecce" class="graf graf--p graf-after--p">Because these steps can happen very frequently, we have to carefully design them in order to make them efficient.</p><p name="9fdb" id="9fdb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Scheduling Performance</strong></p><p name="7e74" id="7e74" class="graf graf--p graf-after--p">Before we continue, we have to design a measurement for analyzing the performance of a scheduler. Suppose we define the processing time is <code class="markup--code markup--p-code">Tp</code> (this is also called the <strong class="markup--strong markup--p-strong">time slice</strong>) and the scheduling time is <code class="markup--code markup--p-code">T_sched</code> , then the <strong class="markup--strong markup--p-strong">useful CPU work</strong> can be defined as,</p><figure name="fc43" id="fc43" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*bNN7v6BRejcbCy0qI0_s_g.png" data-width="1412" data-height="118" src="https://cdn-images-1.medium.com/max/800/1*bNN7v6BRejcbCy0qI0_s_g.png"></figure><p name="6e3e" id="6e3e" class="graf graf--p graf-after--figure">Note that there are also some other metrics that we can use to measure the performance of a scheduler and we are not going to focus on them now.</p><p name="926d" id="926d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Sources of the Ready Queue</strong></p><p name="568b" id="568b" class="graf graf--p graf-after--p">A process can make its way to the ready queue in a number of ways.</p><ul class="postList"><li name="788b" id="788b" class="graf graf--li graf-after--p">A process that after the <strong class="markup--strong markup--li-strong">I/O</strong> event</li><li name="bbdb" id="bbdb" class="graf graf--li graf-after--li">A process with its <strong class="markup--strong markup--li-strong">time slice expired</strong></li><li name="8d21" id="8d21" class="graf graf--li graf-after--li">A new process created via the <code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">fork</strong></code> call</li><li name="ea9d" id="ea9d" class="graf graf--li graf-after--li">A process after an <strong class="markup--strong markup--li-strong">interruption</strong></li></ul><figure name="18f0" id="18f0" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*rlWEW7jXN162eSVrGFlxeg.png" data-width="1672" data-height="518" src="https://cdn-images-1.medium.com/max/800/1*rlWEW7jXN162eSVrGFlxeg.png"></figure><p name="c65b" id="c65b" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">5. Inter-Process Communication (IPC)</strong></p><p name="a759" id="a759" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) IPC Mechanisms</strong></p><p name="d625" id="d625" class="graf graf--p graf-after--p">To make better use of our operating system, we also have to communicate between different processes. Inter-process communications (IPC) mechanisms help to <strong class="markup--strong markup--p-strong">transfer data and information</strong> between address spaces of different processes, and they also have to maintain <strong class="markup--strong markup--p-strong">isolation</strong> and <strong class="markup--strong markup--p-strong">protection</strong>. The IPC mechanisms also need to provide <strong class="markup--strong markup--p-strong">flexibility</strong> and <strong class="markup--strong markup--p-strong">good performance</strong> for different processes.</p><p name="7e12" id="7e12" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Message-Passing IPC</strong></p><p name="ca13" id="ca13" class="graf graf--p graf-after--p">One mechanism that the operating system support is the message-passing IPC. The operating system establishes a <strong class="markup--strong markup--p-strong">communication channel</strong> like a shared buffer for instance. Then the processes communicate by one process writing or sending a message to this buffer and the other reading or receiving a message from this channel.</p><p name="0dac" id="0dac" class="graf graf--p graf-after--p">The advantage of this is that this IPC is <strong class="markup--strong markup--p-strong">controlled</strong> by the OS so the OS can manage the channel by the API. However, the downside is the <strong class="markup--strong markup--p-strong">overheads</strong> because every single piece of information has to be transferred between the user space and the kernel memory.</p><p name="91a3" id="91a3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Shared Memory IPC</strong></p><p name="708f" id="708f" class="graf graf--p graf-after--p">The operating system establishes a shared memory channel and maps it into each process address space. Then each process is allowed to read and write from this shared memory as any other addresses in their virtual space.</p><p name="4968" id="4968" class="graf graf--p graf-after--p graf--trailing">The advantage of this is that the OS is out of the way so we don’t have to worry about the overheads. However, because the OS no longer works for controlling this IPC, we can not use any APIs provided by the OS. Sometimes we have to reimplement the code in order to use the shared memory in the correct way.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/66bbf73ee3f6"><time class="dt-published" datetime="2021-01-25T11:04:53.367Z">January 25, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-3-process-and-process-management-process-control-block-process-lifecycle-66bbf73ee3f6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>