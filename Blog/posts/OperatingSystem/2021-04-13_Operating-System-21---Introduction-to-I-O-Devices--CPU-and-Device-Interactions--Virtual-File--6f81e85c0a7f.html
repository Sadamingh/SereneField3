<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 21 | Introduction to I/O Devices, CPU and Device Interactions, Virtual File…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 21 | Introduction to I/O Devices, CPU and Device Interactions, Virtual File…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="88f4" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5374" id="5374" class="graf graf--h3 graf--leading graf--title">Operating System 21 | <strong class="markup--strong markup--h3-strong">Introduction to I/O Devices, CPU and Device Interactions, Virtual File System Abstractions, and Understanding Inode</strong></h3><figure name="9663" id="9663" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*IQZLnXfn7Rknh81_.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*IQZLnXfn7Rknh81_.png"></figure><ol class="postList"><li name="ebe0" id="ebe0" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Introduction to I/O Devices</strong></li></ol><p name="2971" id="2971" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of I/O Devices</strong></p><p name="7a9a" id="7a9a" class="graf graf--p graf-after--p">As we can see, the execution of applications doesn’t rely only on the CPU and the memory, but it relies on many other different types of hardware components. Some of these components are specifically tied to provide inputs or outputs, or both are called <strong class="markup--strong markup--p-strong">I/O devices</strong>.</p><p name="6db6" id="6db6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Types of I/O Devices</strong></p><p name="3050" id="3050" class="graf graf--p graf-after--p">There are a number of I/O devices that the operating system integrated into the overall computer system. The common I/O devices include,</p><ul class="postList"><li name="7b43" id="7b43" class="graf graf--li graf-after--p">keyboards</li><li name="85b5" id="85b5" class="graf graf--li graf-after--li">microphones</li><li name="e705" id="e705" class="graf graf--li graf-after--li">displays</li><li name="3513" id="3513" class="graf graf--li graf-after--li">speakers</li><li name="8585" id="8585" class="graf graf--li graf-after--li">mice</li><li name="a35f" id="a35f" class="graf graf--li graf-after--li">network interface card (NIC)</li><li name="bfc4" id="bfc4" class="graf graf--li graf-after--li">hard disk</li><li name="1bcc" id="1bcc" class="graf graf--li graf-after--li">USB flashcard</li><li name="05e6" id="05e6" class="graf graf--li graf-after--li">etc.</li></ul><p name="d2dd" id="d2dd" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Key Features of Any I/O Devices</strong></p><p name="89ea" id="89ea" class="graf graf--p graf-after--p">Any device can be abstracted to have the following set of features,</p><ul class="postList"><li name="75bd" id="75bd" class="graf graf--li graf-after--p">a set of <strong class="markup--strong markup--li-strong">control registers</strong>: includes status registers (for showing the CPU what’s happening on the device), command registers (what does the device do), data transfer registers (CPU controlled data transfer), etc. that can be accessed by the CPU and that permit the CPU device interactions</li><li name="2653" id="2653" class="graf graf--li graf-after--li">a <strong class="markup--strong markup--li-strong">micro-controller</strong>: this is like a device’s CPU, and this is what controls all of the operations that actually take place on the device</li><li name="3fff" id="3fff" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">on-device memory</strong> (DRAM or SRAM or both): there will be some amount of memory for the device</li><li name="f130" id="f130" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">other logic</strong>: there will also be some other types of processing logic, special chips, or specialized hardware that is needed on the device</li></ul><figure name="eaa4" id="eaa4" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*XX3pbvhozrk6yJnOZkhijQ.png" data-width="1139" data-height="201" src="https://cdn-images-1.medium.com/max/800/1*XX3pbvhozrk6yJnOZkhijQ.png"><figcaption class="imageCaption"><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/file-devices.pdf" data-href="https://pages.cs.wisc.edu/~remzi/OSTEP/file-devices.pdf" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Operating Systems: Three Easy Pieces</a>, Figure 36.3</figcaption></figure><p name="566a" id="566a" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) The Definition of Peripheral Component Interconnect (PCI)</strong></p><p name="4387" id="4387" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">PCI bus</strong> stands for the peripheral component interconnect bus, and it is one of the standard methods for connecting devices to the CPU. Today’s platforms typically support <strong class="markup--strong markup--p-strong">PCI express interconnect</strong> (aka. <strong class="markup--strong markup--p-strong">PCIe</strong>), which are technologically more advanced than the original PCI or <strong class="markup--strong markup--p-strong">PCI-X</strong> (i.e. <strong class="markup--strong markup--p-strong">PCI extend</strong>) bus.</p><p name="b970" id="b970" class="graf graf--p graf-after--p">So PCIe has more bandwidth, lower access latency, faster speed, and it supports more devices compared with PCI-X standard. However, for compatibility concerns, today’s platform will also include some of these older technologies, typically PCI-X.</p><p name="094e" id="094e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Other Types of Interconnects</strong></p><p name="7057" id="7057" class="graf graf--p graf-after--p">There are actually other interconnects in the computer system. There are some other interconnects like,</p><ul class="postList"><li name="d573" id="d573" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">SCSI Bus</strong>: connects SCSI disks</li><li name="4d4e" id="4d4e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Expansion/Perpherial Bus</strong>: connects keyboards, parallel port, serial port, etc.</li><li name="9280" id="9280" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Bridge Controller</strong>: handle differences between different types of interconnects</li></ul><figure name="cad2" id="cad2" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*ZloGa-Vmo9gD-NxclM9zkQ.png" data-width="1618" data-height="1060" src="https://cdn-images-1.medium.com/max/800/1*ZloGa-Vmo9gD-NxclM9zkQ.png"></figure><p name="778c" id="778c" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) The Definition of Device Drivers</strong></p><p name="06a6" id="06a6" class="graf graf--p graf-after--p">The operating system supports devices via device drivers. Here’s a chart that shows where device drivers sit with respect to the rest of the operating system and the actual hardware they manage.</p><figure name="b171" id="b171" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ssYu6N3ZipN3nSzX2p9IfQ.png" data-width="1452" data-height="568" src="https://cdn-images-1.medium.com/max/800/1*ssYu6N3ZipN3nSzX2p9IfQ.png"></figure><p name="c246" id="c246" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Device drivers</strong> are device-specific <strong class="markup--strong markup--p-strong">software</strong> components provided by the designers or the manufactures of the hardware, and the OS has to include a device driver for every type of device that is incorporated into the system. What’s more, they are also responsible for all aspects of</p><ul class="postList"><li name="f2ec" id="f2ec" class="graf graf--li graf-after--p">device access</li><li name="8807" id="8807" class="graf graf--li graf-after--li">device management</li><li name="13b2" id="13b2" class="graf graf--li graf-after--li">device control</li></ul><p name="d1c7" id="d1c7" class="graf graf--p graf-after--li">The drivers include logic that determines how can requests be passed from the higher-level applications to the device, and there will be standardized interfaced both in terms of the interaction of those devices, as well as in terms of the development and integration of the device drivers. In this way, we will achieve both <strong class="markup--strong markup--p-strong">device independence</strong> (i.e. the OS doesn’t have to be specialized) and <strong class="markup--strong markup--p-strong">device diversity</strong> (i.e. easy for OS to support different types of devices).</p><p name="151b" id="151b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Types of Devices</strong></p><p name="29a2" id="29a2" class="graf graf--p graf-after--p">To deal with device diversity, different devices are grouped into several categories. These include,</p><ul class="postList"><li name="2550" id="2550" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Block Devices</strong>: For example, <strong class="markup--strong markup--li-strong">disks</strong>. These devices will bring an <strong class="markup--strong markup--li-strong">entire block</strong> of data in/out of the device from/to the CPU complex on the other end. The key property is that the blocks can be <strong class="markup--strong markup--li-strong">directly accessed</strong> instead of serializing.</li><li name="8bb1" id="8bb1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Character Devices</strong>: For example, <strong class="markup--strong markup--li-strong">keyboard</strong>. The devices should work with a sequence of characters and they will support something like get-a-character, or put-a-character type of interface.</li><li name="e8a7" id="e8a7" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Network Devices</strong>: The network devices are able to deliver more than a character at a time but their granularity is not necessarily to be a fixed block size as block devices. These devices will be more <strong class="markup--strong markup--li-strong">flexible</strong> and they will look like a <strong class="markup--strong markup--li-strong">stream of data</strong> chunks of potentially different sizes.</li></ul><p name="92cb" id="92cb" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) Device Abstraction: Special Device Files</strong></p><p name="1585" id="1585" class="graf graf--p graf-after--p">Internally, the OS maintains these devices available on the platform by using a <strong class="markup--strong markup--p-strong">file abstraction</strong>. In that way, the OS can use any of the other mechanisms that are already part of the OS to manipulate these files. On Unix-like systems, all device files appear in the <code class="markup--code markup--p-code">/dev</code> directory and these files are treaded as a special files system, not the real file system.</p><p name="c3c8" id="c3c8" class="graf graf--p graf-after--p">For example, we can have a check of all the disk device files by,</p><pre name="4cad" id="4cad" class="graf graf--pre graf-after--p">$ ls /dev | grep disk</pre><p name="815d" id="815d" class="graf graf--p graf-after--pre">If we have a printer device connected to our Linux system, then this printer has a device file named <code class="markup--code markup--p-code">lp0</code> (means the first line printer). Then the following command can be used to print <code class="markup--code markup--p-code">Hello, World</code> to this printer device.</p><pre name="a000" id="a000" class="graf graf--pre graf-after--p">$ echo &quot;<code class="markup--code markup--pre-code">Hello, World</code>&quot; &gt; /dev/lp0</pre><p name="5139" id="5139" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(9) Pseudo Device</strong></p><p name="1b24" id="1b24" class="graf graf--p graf-after--p">Linux also supports what is called <strong class="markup--strong markup--p-strong">pseudo</strong> or <strong class="markup--strong markup--p-strong">virtual devices</strong>. These devices do not represent actual hardware and they are not critical in I/O management but they are quite useful.</p><p name="f6a6" id="f6a6" class="graf graf--p graf-after--p">The pseudo-device <code class="markup--code markup--p-code">/dev/null</code> simply accept all the outputs and then discard them, so it is acting as a black hole.</p><pre name="bb13" id="bb13" class="graf graf--pre graf-after--p">$ echo Hello, World &gt; /dev/null</pre><p name="4088" id="4088" class="graf graf--p graf-after--pre">Another pseudo device <code class="markup--code markup--p-code">/dev/random</code> produces a variable-length string of pseudo-random numbers.</p><pre name="bc7b" id="bc7b" class="graf graf--pre graf-after--p">$ cat /dev/random | head -1</pre><p name="27cd" id="27cd" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(10) Common Device Names</strong></p><p name="fd0a" id="fd0a" class="graf graf--p graf-after--p">Now let’s see some names of the common devices,</p><ul class="postList"><li name="b9cb" id="b9cb" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">tty</code> : special devices representing terminal stations</li><li name="cfe9" id="cfe9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sda</code> / <code class="markup--code markup--li-code">hda</code>: disks like hard drives, SSDs, CD-ROMs, etc.</li><li name="957e" id="957e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">lp</code> : for printers</li><li name="82f0" id="82f0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">mem</code> : access to the physical memory</li><li name="c8bc" id="c8bc" class="graf graf--li graf-after--li">etc.</li></ul><p name="5bb0" id="5bb0" class="graf graf--p graf-after--li">You can check some of them by,</p><pre name="c156" id="c156" class="graf graf--pre graf-after--p">$ ls /dev | grep sda<br>$ ls /dev | grep tty</pre><p name="f536" id="f536" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. CPU and Device Interactions</strong></p><p name="0bd2" id="0bd2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) CPU-to-Device Interactions #1: Memory Mapped I/O</strong></p><p name="2aab" id="2aab" class="graf graf--p graf-after--p">One way the CPU interacts with the devices is by the <strong class="markup--strong markup--p-strong">memory-mapped I/O</strong>. When the CPU writes to these physical locations where the device file locates, the integrated memory PCI controller will figure out that this access should be routed to the appropriate device because this memory location is dedicated to interactions with the device. This is called <strong class="markup--strong markup--p-strong">memory-mapped I/O</strong>. The portion of the memory that is reserved for these interactions is called by a set of registers called the <strong class="markup--strong markup--p-strong">base address registers</strong> (aka. <strong class="markup--strong markup--p-strong">BAR</strong>).</p><p name="608e" id="608e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) CPU-to-Device Interactions #2: I/O Port Model</strong></p><p name="30c0" id="30c0" class="graf graf--p graf-after--p">The other way the CPU can access the devices is via special instructions. For instance, in x86 platforms, there are special in/out instructions that are used for accessing devices. To use these instructions, we have to specify the <strong class="markup--strong markup--p-strong">I/O ports</strong> for the target device. This is called the <strong class="markup--strong markup--p-strong">I/O port model</strong>.</p><p name="3a98" id="3a98" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Device-to-CPU Interactions: Interrupts and Polls</strong></p><p name="d95d" id="d95d" class="graf graf--p graf-after--p">There are two paths for a device to the CPUs. One option is to generate an <strong class="markup--strong markup--p-strong">interrupt</strong> to the CPU. The other option is for the CPU to <strong class="markup--strong markup--p-strong">poll</strong> the device by reading its status registers in order to determine whether the device needs an interaction.</p><p name="d2fe" id="d2fe" class="graf graf--p graf-after--p">There are overheads associated with both of these methods and there are some trade-offs between these two options. The interrupt option requires more interrupt handling overheads but we can generate them as soon as we want. For polling, the OS can choose when is the convenient time for us to poll but this will also cause a delay or some CPU overheads.</p><p name="2d7d" id="2d7d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Programmed I/O (PIO)</strong></p><p name="6418" id="6418" class="graf graf--p graf-after--p">The OS can access or request an operation from a device using the <strong class="markup--strong markup--p-strong">programmed I/O</strong> (aka. <strong class="markup--strong markup--p-strong">PIO</strong>) method. This method requires no additional hardware support and it involves the CPU issuing construction by writing into the corresponding registers like the command registers and the data registers, and then check the status register to decide what to do next.</p><figure name="b7dc" id="b7dc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*TYHhn4PUbSIJvcGhrNLSVw.png" data-width="1318" data-height="406" src="https://cdn-images-1.medium.com/max/800/1*TYHhn4PUbSIJvcGhrNLSVw.png"></figure><p name="d715" id="d715" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Programmed I/O: An Example</strong></p><p name="dfe4" id="dfe4" class="graf graf--p graf-after--p">Let’s see an example about the NIC. For transferring data through the network, we have to follow some steps,</p><ul class="postList"><li name="8e85" id="8e85" class="graf graf--li graf-after--p">CPU writes to the <strong class="markup--strong markup--li-strong">command register</strong> to request a packet transmission</li><li name="8d22" id="8d22" class="graf graf--li graf-after--li">CPU copies the packet information into the <strong class="markup--strong markup--li-strong">data register</strong>, and this will repeat until the entire package is sent</li></ul><p name="ef8c" id="ef8c" class="graf graf--p graf-after--li">Let’s say if we have a 1,500 B packet to transmit and the data register can only support 8 bytes at a time. Then the whole operation of a programmed I/O will require one write out for the command, and another 188 (i.e. <code class="markup--code markup--p-code">1500/8 = 188</code>) accesses to the data register. In total, there will be 189 CPU accesses to the device-specific registers.</p><p name="b9d6" id="b9d6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Direct Memory Access (DMA)</strong></p><p name="e6a7" id="e6a7" class="graf graf--p graf-after--p">An alternative to the programmed I/O is to use a <strong class="markup--strong markup--p-strong">direct-memory access</strong> (aka. <strong class="markup--strong markup--p-strong">DMA</strong>) supported device. The DMA relies on special hardware support called the <strong class="markup--strong markup--p-strong">DMA controller</strong>. So although the CPU will still write commands into the command registers on the device, the data movement will be controlled by configuring the DMA controller.</p><figure name="5c16" id="5c16" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*RhMgPr0HJdHzgxv1nvDbdg.png" data-width="1318" data-height="406" src="https://cdn-images-1.medium.com/max/800/1*RhMgPr0HJdHzgxv1nvDbdg.png"></figure><p name="1671" id="1671" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(7) Direct Memory Access (DMA): An Example</strong></p><p name="be7c" id="be7c" class="graf graf--p graf-after--p">Let’s look again at the NIC case and now let’s suppose we have a DMA-based CPU and device interactions. Similarly, there are some steps we have to follow,</p><ul class="postList"><li name="26b1" id="26b1" class="graf graf--li graf-after--p">CPU writes to the <strong class="markup--strong markup--li-strong">command register</strong> to request a packet transmission</li><li name="bc66" id="bc66" class="graf graf--li graf-after--li">CPU sends an operation to configure the <strong class="markup--strong markup--li-strong">DMA controller</strong> with the information of the <strong class="markup--strong markup--li-strong">in-memory address</strong> (i.e. data location) and <strong class="markup--strong markup--li-strong">the size of the packet buffer</strong> (i.e. total amount of data)</li></ul><p name="51a9" id="51a9" class="graf graf--p graf-after--li">When this is done, the device can perform the desired operation.</p><p name="5789" id="5789" class="graf graf--p graf-after--p">So from the CPU’s perspective, we perform 1 store instruction and 1 DMA configuration in order to transfer a 1,500 B package to the device. This is much better because we only need 2 instructions in total. However, the downside of this method is that the DMA is not a trivial operation and it takes more cycles than a memory store. Therefore, for small transfers, the programmed I/O will still be better than DMA because DMA itself is quite complex.</p><p name="2cfc" id="2cfc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Typical Device Access Procedure</strong></p><p name="7386" id="7386" class="graf graf--p graf-after--p">The typical ways in which a user processes interact with a device are as follows. Let’s say the process needs to perform an operation that requires access from a hardware device and we have to follow the following steps,</p><ul class="postList"><li name="fd40" id="fd40" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">perform a system call</strong>: specify the operation and then go to the kernel-mode</li><li name="f8cf" id="f8cf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">run the in-kernel stack</strong>: the in-kernel stack (e.g. TCP/IP stack for the NIC, file system for the disk block) related to the device are going to be executed</li><li name="ac75" id="ac75" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">invoke the appropriate driver</strong></li><li name="9841" id="9841" class="graf graf--li graf-after--li">device driver <strong class="markup--strong markup--li-strong">performs the configuration of the request</strong> to the device (e.g. write out an appropriate transformation, or issue certain commands for moving the disk heads)</li><li name="fed5" id="fed5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">perform the request</strong>: the request will be performed after the device is configured properly</li><li name="bdaa" id="bdaa" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">send back results</strong>: any results from the request or any events that are originating on the devices will traverse this chain in a reverse manner (as the red lines)</li></ul><figure name="d4ae" id="d4ae" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*fI9yhdBvNgwczN6JQ5gemQ.png" data-width="1682" data-height="522" src="https://cdn-images-1.medium.com/max/800/1*fI9yhdBvNgwczN6JQ5gemQ.png"></figure><p name="8b7f" id="8b7f" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(9) OS Bypass</strong></p><p name="7538" id="7538" class="graf graf--p graf-after--p">However, it is not necessary for us to go to the kernel if we want to get to a device. For some devices, it is possible to configure them to be directly accessed from the user level. This method is called the <strong class="markup--strong markup--p-strong">OS bypass</strong>. Since we don’t want the user process to go into the operating system, this driver has to be some <strong class="markup--strong markup--p-strong">user-level driver</strong> or the user process should have a <strong class="markup--strong markup--p-strong">user-level device library</strong>. Like the device drivers, this UL driver or library should also be provided by the designers or manufacturers.</p><figure name="41d7" id="41d7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZRWjAT9CpQeTn75ezYaJww.png" data-width="1682" data-height="522" src="https://cdn-images-1.medium.com/max/800/1*ZRWjAT9CpQeTn75ezYaJww.png"></figure><p name="306a" id="306a" class="graf graf--p graf-after--figure">When bypassing the OS, the OS has to make sure that it still has some kind of <strong class="markup--strong markup--p-strong">coarse-grain control</strong> like, for instance, enabling or disabling a device, adding permissions to add more processes to use the device, or etc.</p><p name="c1e0" id="c1e0" class="graf graf--p graf-after--p">In the regular device stack where the OS is involved, it is the kernel that is aware of the resources that are allocated to each process access to the device. When the OS is bypassed, those types of checks have to be performed by the device itself.</p><p name="ef64" id="ef64" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) OS Bypass Accessing Block Device</strong></p><p name="6163" id="6163" class="graf graf--p graf-after--p">In Linux, the <code class="markup--code markup--p-code">ioctl()</code> command can be used to manipulate the device’s control registers. When the following function is executed, the memory location that’s pointed by the <code class="markup--code markup--p-code">numblocks</code> variable will be filled out with the returned value from the device.</p><pre name="3caa" id="3caa" class="graf graf--pre graf-after--p">unsigned long numblocks = 0;</pre><pre name="bdc8" id="bdc8" class="graf graf--pre graf-after--pre">ioctl(fd, BLKGETSIZE, &amp;numblocks);</pre><p name="9aba" id="9aba" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(11) The Definition of Synchronous Access</strong></p><p name="ba69" id="ba69" class="graf graf--p graf-after--p">When an I/O request is made, the user process will require some response from the device. So what will happen once the I/O call is made? The simplest idea is that the current process that calls for this I/O device will simply be <strong class="markup--strong markup--p-strong">blocked</strong>. The OS will place this thread on the wait queue and it will eventually become runnable when the response from the request becomes available. This is called <strong class="markup--strong markup--p-strong">synchronous access</strong>.</p><p name="0664" id="0664" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(12) The Definition of Asynchronous Access</strong></p><p name="20aa" id="20aa" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">asynchronous access</strong> is that the user process is allowed to <strong class="markup--strong markup--p-strong">continue</strong> as soon as it issues the I/O call. At some later time, the user process can be allowed to come in and check are the result is ready for retrieving, or the process will be notified by the device or OS after the operation has completed.</p><p name="2269" id="2269" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(13) Block Device Access Stack</strong></p><p name="ce27" id="ce27" class="graf graf--p graf-after--p">Block devices like disks are typically used for storage and the typical storage-related abstraction used by applications is a file, and now, let’s look closer at how the block devices are used.</p><figure name="d96a" id="d96a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Ds-vOaumSpoheAVoECmO7w.png" data-width="1440" data-height="522" src="https://cdn-images-1.medium.com/max/800/1*Ds-vOaumSpoheAVoECmO7w.png"></figure><ul class="postList"><li name="565f" id="565f" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">File</strong>: The file is a <strong class="markup--strong markup--li-strong">logical storage unit</strong> and it is mapped to some underlying physical storage location. Below this file-based interface used by applications will be the file system.</li><li name="8b02" id="8b02" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">File System (FS)</strong>: The file system will have the information on how to take these reads and writes that are coming from the application and to then determine where exactly is the file, how to access it, what is the particular portion of that file needs to be accessed, what are any permission checks that need to be performed and to ultimately initiate the actual access. The operating systems allow for a file system to be <strong class="markup--strong markup--li-strong">modified</strong> or <strong class="markup--strong markup--li-strong">completely replaced</strong> with a different file system because it specifies something about the well-defined file system interfaces like the <strong class="markup--strong markup--li-strong">POSIX API</strong>. Therefore, the file system can be replaced without modifying the application.</li><li name="e4c4" id="e4c4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Hard Drive Devices</strong>: If the files are indeed stored on block devices, clearly at the lowest level, the FS will need to interact with these block devices via their device drivers. We can have different types of block devices like SCSI disk or IDE disk that require certain <strong class="markup--strong markup--li-strong">protocol-specific APIs</strong>.</li><li name="5364" id="5364" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Generic Block Layer</strong>: Different types of block devices can have some differences in the errors and so on. In order to mask all of that, the block device stack introduces another layer called the <strong class="markup--strong markup--li-strong">generic block layer</strong>. The intent of this layer is to provide a <strong class="markup--strong markup--li-strong">standard</strong> for a particular operating system to all types of block devices.</li></ul><figure name="eec2" id="eec2" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*b0dFkiX7O5w7FDlbwrSt_Q.png" data-width="1440" data-height="522" src="https://cdn-images-1.medium.com/max/800/1*b0dFkiX7O5w7FDlbwrSt_Q.png"></figure><p name="c2d3" id="c2d3" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">3. Virtual File System Abstractions</strong></p><p name="a927" id="a927" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) A Problem for the Device Access Procedure</strong></p><p name="30e3" id="30e3" class="graf graf--p graf-after--p">We have discussed that we can easily modify or replace the file system with the previous device access procedure we have discussed because the APIs we use are well-defined.</p><p name="edf1" id="edf1" class="graf graf--p graf-after--p">However, there is another problem. In the previous procedure, we can only have one file system and we need to replace the file system if we need to support more platforms. But the process of replacing the file system can be inefficient and the devices will work better if we support more file systems at the same time. What’s more, we may want to communicate with a non-local machine and potentially this machine will have a completely different file system. Therefore, it seems better if we can support multiple file systems at the same time. But how does it possible?</p><p name="71bd" id="71bd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Virtual File System (VFS)</strong></p><p name="426c" id="426c" class="graf graf--p graf-after--p">To deal with this problem, the Linux operating system uses a <strong class="markup--strong markup--p-strong">virtual file system</strong> (aka. <strong class="markup--strong markup--p-strong">VFS</strong>) layer, and this layer is responsible for hiding from the applications all details regarding the underlying file system. Therefore, we can now support various types of file systems.</p><figure name="0751" id="0751" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*xjCo4zal4FM_gkE6GDTujA.png" data-width="1452" data-height="518" src="https://cdn-images-1.medium.com/max/800/1*xjCo4zal4FM_gkE6GDTujA.png"></figure><p name="d974" id="d974" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) Common File Systems</strong></p><p name="bc3d" id="bc3d" class="graf graf--p graf-after--p">We have talked a lot about the file systems but we are still not familiar with them. The common file systems are like,</p><ul class="postList"><li name="5410" id="5410" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Linux supported FS</strong>: EXT, EXT2, EXT3, EXT4</li><li name="5510" id="5510" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Unix supported FS</strong>: SysV, Minix</li><li name="9039" id="9039" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Microsoft supported FS</strong>: MS-DOS, FAT, VFAT, FAT32, exFAT, NFTS</li><li name="fb77" id="fb77" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">CD_ROM supported FS</strong>: UDF, DVD</li><li name="24df" id="24df" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Apple supported FS</strong>: HFS, AFFS, ADFS, APFS</li><li name="4451" id="4451" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Network FS</strong>: NFS, NFSv2, NFSv3, NFSv4</li></ul><p name="9540" id="9540" class="graf graf--p graf-after--li">We can check the current file system we are using. On Mac OSX, we can check the FS by,</p><pre name="7965" id="7965" class="graf graf--pre graf-after--p">$ diskutil list</pre><p name="7a93" id="7a93" class="graf graf--p graf-after--pre">And we may find out that if you have the latest Apple computer, the FS will be APFS.</p><p name="b750" id="b750" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) The Definition of the File</strong></p><p name="2356" id="2356" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">File</strong> is one of the key abstractions for VFS. They are the elements on which the VFS operates. The OS represents the files via <strong class="markup--strong markup--p-strong">file descriptors</strong> (aka. fd), which are created when the files are opened. There is a number of operations that are supported for files. These operations include,</p><ul class="postList"><li name="e332" id="e332" class="graf graf--li graf-after--p">open</li><li name="6add" id="6add" class="graf graf--li graf-after--li">read</li><li name="1a24" id="1a24" class="graf graf--li graf-after--li">write</li><li name="3470" id="3470" class="graf graf--li graf-after--li">sendfile</li><li name="0b0b" id="0b0b" class="graf graf--li graf-after--li">lock</li><li name="74af" id="74af" class="graf graf--li graf-after--li">close</li><li name="37f1" id="37f1" class="graf graf--li graf-after--li">etc.</li></ul><p name="ea8f" id="ea8f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) The Definition of Inode</strong></p><p name="ee8a" id="ee8a" class="graf graf--p graf-after--p">For each file, the VFS maintains a persistent data structure called an <strong class="markup--strong markup--p-strong">inode </strong>(means index node). The inode is a standard data structure in Unix-based systems, and again, it is important because the file doesn’t need to be stored contiguously on the disk and we have to maintain this index for finding the data. The inode contains some important information like,</p><ul class="postList"><li name="bfd1" id="bfd1" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">list of all data blocks</strong></li><li name="cfd5" id="cfd5" class="graf graf--li graf-after--li">permission</li><li name="f557" id="f557" class="graf graf--li graf-after--li">size of the file</li><li name="5019" id="5019" class="graf graf--li graf-after--li">whether lock or not</li><li name="ca5e" id="ca5e" class="graf graf--li graf-after--li">etc.</li></ul><p name="cdf3" id="cdf3" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) The Definition of Directory</strong></p><p name="ebde" id="ebde" class="graf graf--p graf-after--p">The files are organized in the <strong class="markup--strong markup--p-strong">directory</strong>. From the VFS and Unix-based system’s perspective, a directory is really just a file with its contents include information about all the <strong class="markup--strong markup--p-strong">files</strong> and their <strong class="markup--strong markup--p-strong">inodes</strong>. Therefore, we can find where the data blocks for each file.</p><p name="02d8" id="02d8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) The Definition of Dentry</strong></p><p name="4706" id="4706" class="graf graf--p graf-after--p">To interpret the directory, Linux maintains a data structure called <strong class="markup--strong markup--p-strong">dentry</strong> (means directory entry) and each dentry corresponds to a single path component that’s being traversed as we are trying to reach a particular file. The reason we need to have this dentry is that when we need to find another file that is also stored in the current directory, we don’t have to go through the entire path and reread. The FS will also maintain a cache of all the directory entries that have been visited called <strong class="markup--strong markup--p-strong">dentry cache</strong>.</p><p name="922f" id="922f" class="graf graf--p graf-after--p">Note that the dentry is in the memory maintained by the OS, so they are not persistent on-disk representation objects.</p><p name="a1e5" id="a1e5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) The Definition of Superblock</strong></p><p name="9dd8" id="9dd8" class="graf graf--p graf-after--p">There is also a <strong class="markup--strong markup--p-strong">superblock</strong> abstraction required by VFS so that it can provide some information about how a particular file system is laid out on some storage device. This is like a map that the FS maintains to figure out how has it organized on disk. Each FS also maintains some additional metadata in the superblock structure that helps during its operation.</p><p name="e1ec" id="e1ec" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) EXT2 File System</strong></p><p name="eba4" id="eba4" class="graf graf--p graf-after--p">Now, let’s see an example about the EXT2 file system to have a concrete understanding of the VFS abstractions. EXT2 stands for extended file system version 2. It was a default file system in several versions of Linux until it was replaced by ext3 and then ext4 more recently that are the default versions in more current versions of Linux. It is also available for other operating systems.</p><figure name="7a8b" id="7a8b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*7EmXZnJIgfW9PVKvfXVsLw.png" data-width="1413" data-height="194" src="https://cdn-images-1.medium.com/max/800/1*7EmXZnJIgfW9PVKvfXVsLw.png"></figure><ul class="postList"><li name="64e4" id="64e4" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Boot Block</strong>: The first block, block 0, is not used by Linux and it often contains the code to boot the computer.</li><li name="2625" id="2625" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Block Groups</strong>: The rest of the storage is divided into <strong class="markup--strong markup--li-strong">block groups</strong> and the sizes of these groups have nothing to do with the physics of the disks</li><li name="412a" id="412a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Superblock</strong>: The first block in a block group is the superblock and this contains information about the overall block group. It will have information about the <strong class="markup--strong markup--li-strong"># of inodes</strong>, about the <strong class="markup--strong markup--li-strong"># of disk blocks </strong>in this block, and it will also have information about the <strong class="markup--strong markup--li-strong">start of the free blocks</strong>.</li><li name="85fb" id="85fb" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Group Descriptor</strong>: describes the overall state of the block group. It has <strong class="markup--strong markup--li-strong">bitmaps</strong>, the <strong class="markup--strong markup--li-strong"># of free nodes</strong>, the <strong class="markup--strong markup--li-strong">total #of directories</strong> in the system. This information is useful when files are being allocated because ext2 tries to <strong class="markup--strong markup--li-strong">balance</strong> the overall allocation of directories and files across the different block groups.</li><li name="acd5" id="acd5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Bitmaps</strong>: used to quickly find a <strong class="markup--strong markup--li-strong">free block</strong> or a <strong class="markup--strong markup--li-strong">free inode</strong>, so for every single inode in this particular group and every single data block, the bitmap will be able to tell the upper layer allocators whether that inode component or that data block is free</li><li name="f61f" id="f61f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Inodes</strong>: number from 1 up to some maximum number. And every one of the inodes is in ext2 a 128-byte long data structure that describes exactly 1 file. It will have information like <strong class="markup--strong markup--li-strong">the owner of the file</strong>, some <strong class="markup--strong markup--li-strong">accounting information</strong> that system calls like stat would return, and also some information on <strong class="markup--strong markup--li-strong">how to locate the actual data blocks</strong>.</li></ul><p name="889f" id="889f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">4. Understanding Inode</strong></p><p name="55d9" id="55d9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Get the Inode of a File</strong></p><p name="f810" id="f810" class="graf graf--p graf-after--p">We have said that in the Linux or Unix-like system, the files can only be found through the inode of this file. So the file names are actually something for human reads, and the machine can not find the files directly by the file names. So every time when we try to access a file, what we will actually do is to first find the inode of this file.</p><p name="fe3d" id="fe3d" class="graf graf--p graf-after--p">To get an inode of a file, let’s first create a new file in the <code class="markup--code markup--p-code">/tmp</code> directory and then we will manually get its inode index by <code class="markup--code markup--p-code">stat</code> command. We can create a new file named <code class="markup--code markup--p-code">hello</code> by,</p><pre name="442e" id="442e" class="graf graf--pre graf-after--p">$ echo &quot;<code class="markup--code markup--pre-code">Hello, World</code>&quot; &gt; /tmp/hello</pre><p name="cb0e" id="cb0e" class="graf graf--p graf-after--pre">Then, we can use the <code class="markup--code markup--p-code">stat</code> command to get its inode index,</p><pre name="a691" id="a691" class="graf graf--pre graf-after--p">$ stat -f %i /tmp/hello</pre><p name="0d42" id="0d42" class="graf graf--p graf-after--pre">Suppose the output we have is,</p><pre name="efe9" id="efe9" class="graf graf--pre graf-after--p">42328446</pre><p name="96ac" id="96ac" class="graf graf--p graf-after--pre">And we will use this inode index for our following discussion. Remember now, we have a mapping rule of,</p><figure name="e13f" id="e13f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*f1uIypZEsy_FlfqfDncb4g.png" data-width="1256" data-height="72" src="https://cdn-images-1.medium.com/max/800/1*f1uIypZEsy_FlfqfDncb4g.png"></figure><p name="1149" id="1149" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(2) Find the File Data By Inode</strong></p><p name="2802" id="2802" class="graf graf--p graf-after--p">So now we have the inode of this file, but where can we find the data of this file? Recall that the blocks are some fixed-size storage and it can be much smaller than our file. So in order to keep the data of our files, we may use <strong class="markup--strong markup--p-strong">several blocks</strong> for storing a single file.</p><p name="2d6f" id="2d6f" class="graf graf--p graf-after--p">What’s more, all these blocks are not necessarily consecutive and they can distribute discretely in the hard disk. In order to be able to find all the related blocks of a file, the inode itself contains a <strong class="markup--strong markup--p-strong">list</strong> of all the blocks that correspond to the actual file.</p><figure name="7f2f" id="7f2f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mN30fiO3zB3R33elvlqnAA.png" data-width="1376" data-height="364" src="https://cdn-images-1.medium.com/max/800/1*mN30fiO3zB3R33elvlqnAA.png"></figure><p name="33b4" id="33b4" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) Inode Metadata</strong></p><p name="08e6" id="08e6" class="graf graf--p graf-after--p">The inode also has some metadata information, and this is useful to keep track of whether or not certain file accesses are legal or to correctly update the status of the file (if it is locked or not locked). We can use the stat command to show all the inode metadata,</p><pre name="84ed" id="84ed" class="graf graf--pre graf-after--p">$ stat /tmp/hello</pre><p name="5b3d" id="5b3d" class="graf graf--p graf-after--pre">And the printed result can be interpreted as,</p><ul class="postList"><li name="593d" id="593d" class="graf graf--li graf-after--p">Device ID</li><li name="e07e" id="e07e" class="graf graf--li graf-after--li">Inode number</li><li name="df91" id="df91" class="graf graf--li graf-after--li">Permissions (mode)</li><li name="a11e" id="a11e" class="graf graf--li graf-after--li">Hard link count (usually 1)</li><li name="d553" id="d553" class="graf graf--li graf-after--li">File userid (owner)</li><li name="1765" id="1765" class="graf graf--li graf-after--li">File grouped</li><li name="447c" id="447c" class="graf graf--li graf-after--li">Device ID</li><li name="9010" id="9010" class="graf graf--li graf-after--li">Size in bytes</li><li name="5fd8" id="5fd8" class="graf graf--li graf-after--li">Last access time</li><li name="d971" id="d971" class="graf graf--li graf-after--li">Last (contents) modification time</li><li name="ce3a" id="ce3a" class="graf graf--li graf-after--li">Last permissions change time</li><li name="85af" id="85af" class="graf graf--li graf-after--li">Create time</li><li name="ceab" id="ceab" class="graf graf--li graf-after--li">The ideal block size for file</li><li name="4219" id="4219" class="graf graf--li graf-after--li">512-byte-size blocks allocated for the file</li><li name="0e64" id="0e64" class="graf graf--li graf-after--li">Flags set on file</li></ul><p name="9182" id="9182" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Inode Performance</strong></p><p name="6d72" id="6d72" class="graf graf--p graf-after--p">For the inode we have discussed, the benefit of this list approach is that it is easy to perform sequential or random access to the file because all the blocks that correspond to the file can be easily found from the list elements. However, there is a problem with the <strong class="markup--strong markup--p-strong">file size</strong>. Because we have a list with a limited number of elements, so the total size of blocks is limited. Therefore, we will reach a barrier if we keep enlarging the file size.</p><p name="085e" id="085e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Inode with Indirect Pointers</strong></p><p name="e22e" id="e22e" class="graf graf--p graf-after--p">One way for this problem is to improve the inode with <strong class="markup--strong markup--p-strong">indirect pointers</strong>. So the new pointer will not point directly to the blocks, instead, it will point to some new lists. And if we have a <strong class="markup--strong markup--p-strong">single indirect pointer</strong>, the pointers in the new list will directly point to the disk blocks.</p><figure name="0c92" id="0c92" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*9btv50nuwpTVd4_47q6qRQ.png" data-width="1514" data-height="640" src="https://cdn-images-1.medium.com/max/800/1*9btv50nuwpTVd4_47q6qRQ.png"></figure><p name="e7fc" id="e7fc" class="graf graf--p graf-after--figure">Also, we can have <strong class="markup--strong markup--p-strong">double indirect pointers</strong> or <strong class="markup--strong markup--p-strong">triple indirect pointers </strong>if we have an even larger file.</p><p name="a5a7" id="a5a7" class="graf graf--p graf-after--p">The benefit of this approach is that now we can maintain a large file size even with a small inode size. However, the downside is that the file access will be slow down because we have to traverse more lists in order to get direct pointers to the disk blocks.</p><p name="576f" id="576f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Techniques for Disk Access Optimizations</strong></p><p name="d1f9" id="d1f9" class="graf graf--p graf-after--p">File systems use several techniques to try to minimize access to the disk and to improve the file access overheads. These include,</p><ul class="postList"><li name="528e" id="528e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Caching/Buffering</strong>: reducing the disk accesses</li><li name="566b" id="566b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">I/O Scheduling</strong>: reducing disk head movement</li><li name="090e" id="090e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Prefetching</strong>: benefit from locality</li><li name="b354" id="b354" class="graf graf--li graf-after--li graf--trailing"><strong class="markup--strong markup--li-strong">Journaling/Logging</strong>: reduce random access (EXT3, EXT4)</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/6f81e85c0a7f"><time class="dt-published" datetime="2021-04-13T19:08:52.551Z">April 13, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-21-introduction-to-i-o-devices-cpu-and-device-interactions-virtual-file-6f81e85c0a7f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>