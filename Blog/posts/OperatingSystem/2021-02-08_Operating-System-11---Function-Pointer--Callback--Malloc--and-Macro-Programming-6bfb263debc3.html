<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 11 | Function Pointer, Callback, Malloc, and Macro Programming</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 11 | Function Pointer, Callback, Malloc, and Macro Programming</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="ad6e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6146" id="6146" class="graf graf--h3 graf--leading graf--title">Operating System 11 | <strong class="markup--strong markup--h3-strong">Function Pointer, Callback, Malloc, and Macro Programming</strong></h3><figure name="90dc" id="90dc" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*oeRyOjMbtavj9T4T.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*oeRyOjMbtavj9T4T.png"></figure><ol class="postList"><li name="ab44" id="ab44" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Function Pointer</strong></li></ol><p name="046e" id="046e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Function Pointer</strong></p><p name="9edd" id="9edd" class="graf graf--p graf-after--p">Sometimes we may want a pointer pointing to a function. For example, suppose we a function <code class="markup--code markup--p-code">int add(int a, int b)</code> that will return the value of <code class="markup--code markup--p-code">a + b</code> . We have known that the <code class="markup--code markup--p-code">add</code> variable is actually the pointer value of this function, so we may simply have the idea that we can build an integer pointer to store this function. For instance,</p><pre name="ea8b" id="ea8b" class="graf graf--pre graf-after--p">int *p = add;</pre><p name="9b75" id="9b75" class="graf graf--p graf-after--pre">Regardless of the warning of this line, this assigned statement can work for us and we will actually get a pointer pointing to the address <code class="markup--code markup--p-code">add</code>. But could this pointer know that it is pointing to a function? The answer is no. If we define the pointer in that way, the pointer be a pointer pointing towards an integer instead of a function. Thus, it will explain the data at the address <code class="markup--code markup--p-code">data</code> as an integer and this attempt will definitely fail.</p><p name="dc33" id="dc33" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">function pointer</strong> is a pointer that points to a function. So when we use a function pointer, it actually knows that it is going to point to a function. For our <code class="markup--code markup--p-code">add</code> function case, we can define a function pointer <code class="markup--code markup--p-code">p</code> as,</p><pre name="5cf6" id="5cf6" class="graf graf--pre graf-after--p">int (*p)(int, int) = add;</pre><p name="bbb8" id="bbb8" class="graf graf--p graf-after--pre">After that, the pointer <code class="markup--code markup--p-code">p</code> will be pointing to the address of the <code class="markup--code markup--p-code">add</code> function and we can use it exactly the same as the <code class="markup--code markup--p-code">add</code>. Here’s an example code,</p><figure name="fea5" id="fea5" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/fbeda63373be8a577e253237fb05bc4d.js"></script></figure><p name="bfa6" id="bfa6" class="graf graf--p graf-after--figure">The output of this code might (note the address can be different),</p><pre name="cbdf" id="cbdf" class="graf graf--pre graf-after--p">0x10f6d5ef0: 5<br>0x10f6d5ef0: 7</pre><p name="e556" id="e556" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(2) Callback Function</strong></p><p name="d950" id="d950" class="graf graf--p graf-after--p">Now, we may have a problem. Why don’t we use <code class="markup--code markup--p-code">add</code> directly in the last example? Well, the answer is that we can use only <code class="markup--code markup--p-code">add</code> in the last example, while in reality, we do have some situations when we need the function pointer. Let’s see an example,</p><p name="b343" id="b343" class="graf graf--p graf-after--p">Suppose we have the following code,</p><figure name="5239" id="5239" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/a49383ec1d2f014df64da8d42250d60c.js"></script></figure><p name="4217" id="4217" class="graf graf--p graf-after--figure">The output should be,</p><pre name="3796" id="3796" class="graf graf--pre graf-after--p">3<br>-1</pre><p name="68e7" id="68e7" class="graf graf--p graf-after--pre">For <code class="markup--code markup--p-code">func1</code> and <code class="markup--code markup--p-code">func2</code>, the functions compare <code class="markup--code markup--p-code">a</code> and <code class="markup--code markup--p-code">b</code> in the first place, and then return <code class="markup--code markup--p-code">a + b</code> or <code class="markup--code markup--p-code">a — b</code> based on the corresponding comparison result. If we have these needs, it seems that we must create two separate functions even these functions are quite similar. When there are more codes for each function, it will not be a good idea if we create different functions with the almost same content. In order to reuse the code, we can think about using the function pointer as a parameter of our function. This function is then called a <strong class="markup--strong markup--p-strong">callback function</strong> because there are some executable codes passed as an argument to other code. So the code will be,</p><figure name="0b54" id="0b54" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/49afa20bd52e0ead0637a545bb3a9bab.js"></script></figure><p name="8495" id="8495" class="graf graf--p graf-after--figure">This is convenient for us because when we want to change the condition (for example, we may want to add a comparison of <code class="markup--code markup--p-code">2*a &gt; b</code>) of the <code class="markup--code markup--p-code">func</code> function, we can simply add another function (for example, <code class="markup--code markup--p-code">foo3</code>) and pass the name of this function as an argument of the <code class="markup--code markup--p-code">func</code> function.</p><p name="d88d" id="d88d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Return Function Pointer</strong></p><p name="2775" id="2775" class="graf graf--p graf-after--p">Suppose we have defined a function <code class="markup--code markup--p-code">foo</code> and then we want to return the pointer of this function when we call <code class="markup--code markup--p-code">func</code> function in the <code class="markup--code markup--p-code">main</code> function. So we have to figure out what we can write to return a function pointer. In the following code, we simply use <code class="markup--code markup--p-code">int</code> for the <code class="markup--code markup--p-code">func</code> , which is definitely wrong.</p><pre name="20ee" id="20ee" class="graf graf--pre graf-after--p">#include &lt;stdio.h&gt;</pre><pre name="1b3f" id="1b3f" class="graf graf--pre graf-after--pre">int foo(int a, int b) {<br>    return a &gt; b;<br>}</pre><pre name="d721" id="d721" class="graf graf--pre graf-after--pre">// the following func function is wrong<strong class="markup--strong markup--pre-strong"><br>int func() {<br>    return foo;<br>}</strong></pre><pre name="543f" id="543f" class="graf graf--pre graf-after--pre">int main(void) {<br>    <br>    return 0;<br>}</pre><p name="b5bc" id="b5bc" class="graf graf--p graf-after--pre">Someone may think that we can use the following code,</p><pre name="178a" id="178a" class="graf graf--pre graf-after--p">int (*)(int, int) func() {<br>    return foo;<br>}</pre><p name="2aa0" id="2aa0" class="graf graf--p graf-after--pre">Even though the code above seems clear to us, the compiler will not return the right function pointer for us. Instead, what we should use is,</p><pre name="3a9b" id="3a9b" class="graf graf--pre graf-after--p">int (*func())(int, int) {<br>    return foo;<br>}</pre><p name="b90f" id="b90f" class="graf graf--p graf-after--pre">This can be hard to remember and difficult to type if we have to return the function pointers for several functions. To deal with the complexity, we can use <code class="markup--code markup--p-code">typedef</code> to define a new function pointer datatype,</p><pre name="355b" id="355b" class="graf graf--pre graf-after--p">typedef int (*fp)(int, int);</pre><p name="aa17" id="aa17" class="graf graf--p graf-after--pre">Then we can simply return the <code class="markup--code markup--p-code">fp</code> type for the <code class="markup--code markup--p-code">func</code> function,</p><pre name="a707" id="a707" class="graf graf--pre graf-after--p">fp func() {<br>    return foo;<br>}</pre><p name="740d" id="740d" class="graf graf--p graf-after--pre">The example code is as follows,</p><figure name="514c" id="514c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/e0f767ba4acdc85e3830805e15f917e9.js"></script></figure><p name="2fac" id="2fac" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">2. Malloc</strong></p><p name="0dd1" id="0dd1" class="graf graf--p graf-after--p">Suppose we have defined a structure <code class="markup--code markup--p-code">foo</code> with two elements <code class="markup--code markup--p-code">int a[10];</code> and <code class="markup--code markup--p-code">char b[20];</code> by,</p><pre name="af59" id="af59" class="graf graf--pre graf-after--p">typedef struct foo {<br>    int a[10];<br>    char b[20];<br>}foo;</pre><p name="ad60" id="ad60" class="graf graf--p graf-after--pre">Then if we want to create an instance of this structure, we may think about using,</p><pre name="9418" id="9418" class="graf graf--pre graf-after--p">foo struct1;</pre><p name="ca59" id="ca59" class="graf graf--p graf-after--pre">However, when we do so, 60 bytes ( = 4*10 + 1*20) of memory will be directly allocated to this instance <code class="markup--code markup--p-code">struct1</code>. It is a pity that we have this memory occupied when we create this instance and we can not reallocate this memory until the end of the current function (or maybe the program if this instance is created in <code class="markup--code markup--p-code">main</code>).</p><p name="5a78" id="5a78" class="graf graf--p graf-after--p">Instead, we want to allocate memory to this structure only when we need it and we want to free the memory of this structure when we finish our task. So what we can do is to allocate the memory in a dynamic way. To dynamically allocate a segment of memory, we can use the malloc function,</p><pre name="959e" id="959e" class="graf graf--pre graf-after--p">foo *struct1 = (foo *)malloc(sizeof(foo));</pre><p name="1b9c" id="1b9c" class="graf graf--p graf-after--pre">When we do so, we must remember to free the allocated memory after we finish our task (or at the end of our program).</p><pre name="967e" id="967e" class="graf graf--pre graf-after--p">free(struct1);</pre><p name="be24" id="be24" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. Macro Programming Introduction</strong></p><p name="0ca4" id="0ca4" class="graf graf--p graf-after--p">In the previous examples, we have defined macros by,</p><pre name="cce9" id="cce9" class="graf graf--pre graf-after--p">#define BUF_SIZE 20</pre><p name="1469" id="1469" class="graf graf--p graf-after--pre">A macro in computer science is a rule or pattern that specifies how a certain input should be mapped to a replacement output. When we define the <code class="markup--code markup--p-code">BUF_SIZE</code> , we are actually mapping this value to 20 by <code class="markup--code markup--p-code">#define</code>.</p><p name="cf77" id="cf77" class="graf graf--p graf-after--p">In the C language, we have know that different objected files have to be linked together to create an executable binary file. If we have a macro defined with different values, there will be a macro confliction. For example if we define,</p><pre name="cd51" id="cd51" class="graf graf--pre graf-after--p">// macro.c<br>#define SYSTEM &quot;MACOS&quot;</pre><pre name="5326" id="5326" class="graf graf--pre graf-after--pre">// macro.h<br>#define SYSTEM &quot;WINDOWS&quot;</pre><p name="c257" id="c257" class="graf graf--p graf-after--pre">Then the linker can not decide which macro value to use. To resolve this confliction, we have to use either <code class="markup--code markup--p-code">#ifndef</code> or <code class="markup--code markup--p-code">#undef</code>. These two directives serves for different purposes.</p><p name="b602" id="b602" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">#ifndef</code> means if not defined. So if the macro after <code class="markup--code markup--p-code">#ifndef</code> is not defined, we are going to run the following macro directives until <code class="markup--code markup--p-code">#endif</code> . If we have the following code,</p><figure name="a311" id="a311" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/d768d2e1e25581d97592c203d1b176fe.js"></script></figure><p name="e50a" id="e50a" class="graf graf--p graf-after--figure">The output should be,</p><pre name="7f8a" id="7f8a" class="graf graf--pre graf-after--p">MACOS</pre><p name="0ce5" id="0ce5" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">#undef</code> means undefined. Usually, we would first use <code class="markup--code markup--p-code">#ifdef</code> to see whether or not a macro is defined. Then if it is defined, we would undefine this macro and then redefine its value. So if we have the following code,</p><figure name="88e0" id="88e0" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/85ae5637e95bacbbee6f91d278601381.js"></script></figure><p name="f0b4" id="f0b4" class="graf graf--p graf-after--figure">The output should be,</p><pre name="4355" id="4355" class="graf graf--pre graf-after--p graf--trailing">WINDOWS</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/6bfb263debc3"><time class="dt-published" datetime="2021-02-08T15:29:41.294Z">February 8, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-11-function-pointer-callback-malloc-and-macro-programming-6bfb263debc3" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>