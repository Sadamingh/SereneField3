<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 19 | Libcurl Library, Sys V IPC APIs, and Linux Signals</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 19 | Libcurl Library, Sys V IPC APIs, and Linux Signals</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="af5e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="26b7" id="26b7" class="graf graf--h3 graf--leading graf--title">Operating System 19 | Libcurl Library, Sys V IPC APIs, and Linux Signals</h3><figure name="3ae0" id="3ae0" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*1jA2vFpk80oXZpSy.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*1jA2vFpk80oXZpSy.png"></figure><ol class="postList"><li name="58ae" id="58ae" class="graf graf--li graf-after--figure"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">libcurl</strong></code><strong class="markup--strong markup--li-strong"> Library</strong></li></ol><p name="dbd5" id="dbd5" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(0) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">liburl</strong></code><strong class="markup--strong markup--p-strong"> Installation</strong></p><p name="8058" id="8058" class="graf graf--p graf-after--p">There is a probability we don’t have the libcurl installed in our system. So before we use it, we have to install it first. We can use the following command to test if we have <code class="markup--code markup--p-code">libcurl</code> library installed.</p><pre name="444a" id="444a" class="graf graf--pre graf-after--p">$ curl-config --libs</pre><p name="bfe6" id="bfe6" class="graf graf--p graf-after--pre">If the output is,</p><pre name="7f49" id="7f49" class="graf graf--pre graf-after--p">-bash: curl-config: command not found</pre><p name="da6d" id="da6d" class="graf graf--p graf-after--pre">This means that we must install it in the first place. We can install the curl library by,</p><pre name="5a4e" id="5a4e" class="graf graf--pre graf-after--p">$ sudo apt install libcurl4-nss-dev</pre><p name="309d" id="309d" class="graf graf--p graf-after--pre">Then we can test it again,</p><pre name="33a2" id="33a2" class="graf graf--pre graf-after--p">$ cd </pre><p name="18f2" id="18f2" class="graf graf--p graf-after--pre">If we successfully installed the libcurl, we can get the following output,</p><pre name="46fd" id="46fd" class="graf graf--pre graf-after--p">-lcurl</pre><p name="6c19" id="6c19" class="graf graf--p graf-after--pre">However, this method can not be useful when you are doing the project, because later we may meet a Problem with the SSL CA cert (code 77). When we meet this error, we would suggest deleting the whole environment and re-installing it as follows,</p><ul class="postList"><li name="6a4d" id="6a4d" class="graf graf--li graf-after--p">a. Open <em class="markup--em markup--li-em">Oracle VirtualBox</em></li><li name="5235" id="5235" class="graf graf--li graf-after--li">b. power off your environment.</li><li name="19bb" id="19bb" class="graf graf--li graf-after--li">c. Right-click on the env and press <em class="markup--em markup--li-em">remove</em></li><li name="6af5" id="6af5" class="graf graf--li graf-after--li">d. Then <em class="markup--em markup--li-em">delete all files</em></li></ul><figure name="90fb" id="90fb" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*TXjtO0IOzaly7VowxJsyBw.png" data-width="1582" data-height="486" src="https://cdn-images-1.medium.com/max/800/1*TXjtO0IOzaly7VowxJsyBw.png"></figure><p name="26ae" id="26ae" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(1) Why Should We Use Libcutrl?</strong></p><p name="c690" id="c690" class="graf graf--p graf-after--p">You have known the CURL command in Linux and we can use this command to send an HTTP request. For example,</p><pre name="b8ed" id="b8ed" class="graf graf--pre graf-after--p">$ curl <a href="https://stallman.org/internet-voting.html" data-href="https://stallman.org/internet-voting.html" class="markup--anchor markup--pre-anchor" rel="nofollow noopener" target="_blank">https://stallman.org/internet-voting.html</a></pre><p name="d30a" id="d30a" class="graf graf--p graf-after--pre">Then we can get the content of this webpage. The Libcurl is the library for the CURL command and we can use the <a href="http://curl.haxx.se/libcurl/c/" data-href="http://curl.haxx.se/libcurl/c/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">libcurl’s easy C interface</a> for the same usage. Now, let’s see how it works in the C language.</p><p name="6449" id="6449" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Initializing Libcurl</strong></p><p name="6f6b" id="6f6b" class="graf graf--p graf-after--p">Before we use the easy interface of the <code class="markup--code markup--p-code">libcurl</code>, we have to first know how to initialize the curl. Because <code class="markup--code markup--p-code">libcurl</code> has a global constant environment that you must set up and maintain while using libcurl. This essentially means you call <code class="markup--code markup--p-code">curl_global_init</code> at the start of your program and <code class="markup--code markup--p-code">curl_global_cleanup</code> at the end. The flag of <code class="markup--code markup--p-code">curl_global_init</code> should be set to <code class="markup--code markup--p-code">CURL_GLOBAL_ALL</code> so that it can handle with everything possible.</p><p name="4b13" id="4b13" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">curl_version</code> can be called to print the version of the present <code class="markup--code markup--p-code">libcurl</code> , so that we can confirm that the environment of the <code class="markup--code markup--p-code">libcurl</code> is successfully set up.</p><p name="451d" id="451d" class="graf graf--p graf-after--p">The following code can be used to test how to do this initialization.</p><figure name="e4ab" id="e4ab" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/43170c0a9747f1ed360ed8e96b27166c.js"></script></figure><p name="8a11" id="8a11" class="graf graf--p graf-after--figure">In the end, you will get a result of,</p><pre name="7554" id="7554" class="graf graf--pre graf-after--p">Libcurl Version: libcurl/7.54.0 LibreSSL/2.6.5 zlib/1.2.11 nghttp2/1.24.1</pre><p name="6884" id="6884" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Curl’s Easy Interface</strong></p><p name="e37d" id="e37d" class="graf graf--p graf-after--p">Now, let’s do something more. Let’s see how we can mimic the command curl and print the content of a webpage as our output. In this case, the curl’s easy interface will be used. We will continue with the CURL environment that we have set up in the last section.</p><p name="ced1" id="ced1" class="graf graf--p graf-after--p">We can create an “easy handle” using the <code class="markup--code markup--p-code">curl_easy_init</code> call. The type of easy handle is a <code class="markup--code markup--p-code">CURL</code> type (which is defined by <code class="markup--code markup--p-code">typedef void CURL;</code> in the <code class="markup--code markup--p-code">curl.h</code> file).</p><p name="9210" id="9210" class="graf graf--p graf-after--p">We then set your desired set of options in that handle with <code class="markup--code markup--p-code">curl_easy_setopt</code> function. In this case, we will only use the <code class="markup--code markup--p-code">CURLOPT_URL</code> option, which can be used to set the URL that we are going to work on. Particularly, the value of this option will be set to <a href="https://stallman.org/internet-voting.html" data-href="https://stallman.org/internet-voting.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://stallman.org/internet-voting.html</a> in our case because we are this webpage is simple enough to be used as an example.</p><p name="aa47" id="aa47" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">curl_easy_perform</code> call will start to perform the transfer. It will get all the content of the URL that we are requesting and then directly print all the contents directly in the output.</p><p name="d685" id="d685" class="graf graf--p graf-after--p">It will be a good manner if we do the <code class="markup--code markup--p-code">curl_easy_cleanup</code> after we perform a translation. This function is called to eliminate all the data structures related to the easy handle that we have set.</p><p name="b452" id="b452" class="graf graf--p graf-after--p">The following code is an example that shows how the easy interface can be used by us.</p><figure name="80db" id="80db" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/2470cb7f0ac11de510e7cd68bc4fe31c.js"></script></figure><p name="6237" id="6237" class="graf graf--p graf-after--figure">The output should be,</p><pre name="abfd" id="abfd" class="graf graf--pre graf-after--p">Libcurl Version: libcurl/7.54.0 LibreSSL/2.6.5 zlib/1.2.11 nghttp2/1.24.1<br>&lt;!DOCTYPE HTML&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>...</pre><p name="c4d3" id="c4d3" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(4) Write Callback</strong></p><p name="4292" id="4292" class="graf graf--p graf-after--p">Now, we have already mastered the basic easy interface of CURL, now, let’s continue to think more about it. In the last example, we directly print the result to the terminal and this can be inconvenient for us at some time. For example, we may find it hard to save the contents as a file, or we may find it difficult to print some of the content that we need instead of all the contents. In these cases, we can modify the write callback function of writing the data.</p><p name="d215" id="d215" class="graf graf--p graf-after--p">If the callback function is not referred by us, we will get a result of the arbitrary output. Or we can use the <code class="markup--code markup--p-code">curl_easy_setopt</code> to reset the callback function to the callback function we are going to use for other specific cases (e.g. partially print, save as a file, etc.). The option that can be used to reset the callback function is <code class="markup--code markup--p-code">CURLOPT_WRITEFUNCTION</code>. For example,</p><pre name="2455" id="2455" class="graf graf--pre graf-after--p">curl_easy_setopt(easy_handle, CURLOPT_WRITEFUNCTION, writecb);</pre><p name="6e7c" id="6e7c" class="graf graf--p graf-after--pre">In order to reset the callback function properly, we should also maintain a <code class="markup--code markup--p-code">memory</code> data structure that can be used both in the callback function and the main function. This structure will help us store the data that we receive as a response from the HTTP server.</p><p name="746f" id="746f" class="graf graf--p graf-after--p">There need to be 2 elements maintained in this function,</p><ul class="postList"><li name="d601" id="d601" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">response</code> is the pointer to a string that can be used to store the data received from the HTTP server</li><li name="bd29" id="bd29" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">size</code> is used to keep the length of the data we receive</li></ul><p name="b976" id="b976" class="graf graf--p graf-after--li">So this function can be realized by,</p><pre name="3903" id="3903" class="graf graf--pre graf-after--p">typedef struct memory {<br>    char *response;<br>    size_t size;<br>} datamemory;</pre><p name="b16b" id="b16b" class="graf graf--p graf-after--pre">We would like to redefine the name of this structure as <code class="markup--code markup--p-code">datamemory</code>. To make this structure visible for both the main function and the callback function, we will create an instance of this structure in the main function and then pass its pointer to the callback function. So the callback function can also have access to this instance. We will call the <strong class="markup--strong markup--p-strong">pointer</strong> to this instance of <code class="markup--code markup--p-code">datamemory</code> we have created as a <code class="markup--code markup--p-code">chunk</code>.</p><p name="d659" id="d659" class="graf graf--p graf-after--p">Before we pass the <code class="markup--code markup--p-code">chunk</code> to the callback function, we have to remember to allocate a range of memory to our instance. We will use the <code class="markup--code markup--p-code">malloc</code> function in our case and we will also have to initialize the value in this by NULL and 0,</p><pre name="37c0" id="37c0" class="graf graf--pre graf-after--p">datamemory *chunk = (datamemory *) malloc(sizeof(datamemory));<br>chunk-&gt;response = NULL;<br>chunk-&gt;size = 0;</pre><p name="bf9c" id="bf9c" class="graf graf--p graf-after--pre">Remember we can also use a more advanced method to initialize the structure by <code class="markup--code markup--p-code">memset</code> and it can be used as,</p><pre name="ec40" id="ec40" class="graf graf--pre graf-after--p">datamemory *chunk = (datamemory *) malloc(sizeof(datamemory));<br>memset(chunk, 0, sizeof(datamemory));</pre><p name="734c" id="734c" class="graf graf--p graf-after--pre">Then, the pointer to this <code class="markup--code markup--p-code">datamemory</code> instance can be passed to the callback function by using the <code class="markup--code markup--p-code">CURLOPT_WRITEDATA</code> option of <code class="markup--code markup--p-code">curl_easy_setopt</code> by,</p><pre name="65f6" id="65f6" class="graf graf--pre graf-after--p">curl_easy_setopt(easy_handle, CURLOPT_WRITEDATA, chunk);</pre><p name="9279" id="9279" class="graf graf--p graf-after--pre">The callback function <code class="markup--code markup--p-code">writecb(void *buffer, size_t size, size_t nmemb, void *user_p)</code> contains the following arguments,</p><ul class="postList"><li name="56b0" id="56b0" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">buffer</code> is the data that we have received as a response from the server</li><li name="4888" id="4888" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">size</code> is the data size of the chunks (not the same as the <code class="markup--code markup--li-code">chunk</code> pointer that we have discussed) in the buffer. This value is used because for most transfers, this callback gets called many times and each invoke delivers another chunk of data in the buffer.</li><li name="2ab9" id="2ab9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">nmemb</code> is the number of chunks in the buffer</li><li name="e957" id="e957" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">user_p</code> is the <code class="markup--code markup--li-code">chunk</code> pointer that we have passed to this callback function by the <code class="markup--code markup--li-code">curl_easy_setopt</code> function</li></ul><p name="31ff" id="31ff" class="graf graf--p graf-after--li">Now, we are going to mimic the process of directly print the contents as the output. What’s different is that we will get a copy of the content in the <code class="markup--code markup--p-code">datamemory</code> instance that can be used for us in the future in the main function.</p><p name="ac09" id="ac09" class="graf graf--p graf-after--p">First, the real size of the content should be calculated by multiplying the <code class="markup--code markup--p-code">size</code> and <code class="markup--code markup--p-code">nmemb</code>. The whole size of the output will be assigned to a <code class="markup--code markup--p-code">realsize</code> variable,</p><pre name="6400" id="6400" class="graf graf--pre graf-after--p">size_t realsize = size * nmemb;</pre><p name="c77c" id="c77c" class="graf graf--p graf-after--pre">To use the <code class="markup--code markup--p-code">user_p</code> pointer as the <code class="markup--code markup--p-code">chunk</code> pointer, we have to convert its data type from <code class="markup--code markup--p-code">void *</code> to <code class="markup--code markup--p-code">datamemory *</code>. The memory allocated to the <code class="markup--code markup--p-code">response</code> variable should be reallocated if we want to store the data in the <code class="markup--code markup--p-code">buffer</code> to it. The newly assigned memory should have a size of <code class="markup--code markup--p-code">realsize + 1</code> so that it can be able to restore the entire data we need.</p><pre name="9c9e" id="9c9e" class="graf graf--pre graf-after--p">datamemory *chunk = (datamemory *) user_p;<br>chunk-&gt;response = realloc(chunk-&gt;response, chunk-&gt;size + realsize + 1);</pre><p name="2bbd" id="2bbd" class="graf graf--p graf-after--pre">Note that we have to check if there is enough memory for us to allocate when we use the <code class="markup--code markup--p-code">realloc</code> function,</p><pre name="2dbb" id="2dbb" class="graf graf--pre graf-after--p">if (chunk-&gt;response == NULL) {<br>    printf(&quot;Out of memory!&quot;);<br>    return 0;<br>}</pre><p name="35e5" id="35e5" class="graf graf--p graf-after--pre">After this procedure, we have a well-sized <code class="markup--code markup--p-code">datamemory</code> instance that can be used for us to store the data in the <code class="markup--code markup--p-code">buffer</code>. <code class="markup--code markup--p-code">memcpy</code> will then be called to copy the memory content in the buffer to the chunk.</p><figure name="ba89" id="ba89" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BMND-IAseYP5lYMK8blvMQ.png" data-width="1570" data-height="284" src="https://cdn-images-1.medium.com/max/800/1*BMND-IAseYP5lYMK8blvMQ.png"></figure><pre name="cc1f" id="cc1f" class="graf graf--pre graf-after--figure">memcpy(&amp;(chunk-&gt;response[chunk-&gt;size]), buffer, realsize);</pre><p name="4d92" id="4d92" class="graf graf--p graf-after--pre">Then we can update the <code class="markup--code markup--p-code">size</code> element in our <code class="markup--code markup--p-code">datamemory</code> instance with the <code class="markup--code markup--p-code">realsize</code>.</p><pre name="8fa8" id="8fa8" class="graf graf--pre graf-after--p">chunk-&gt;size += realsize;</pre><p name="c835" id="c835" class="graf graf--p graf-after--pre">To directly print the data now in the <code class="markup--code markup--p-code">datamemory</code> instance, we can use,</p><pre name="7ff2" id="7ff2" class="graf graf--pre graf-after--p">printf(&quot;%s&quot;, chunk-&gt;response);</pre><p name="ab18" id="ab18" class="graf graf--p graf-after--pre">After we conduct <code class="markup--code markup--p-code">curl_global_cleanup</code>, because we have saved the data in the <code class="markup--code markup--p-code">datamemory</code> instance, we can still print the data to the output. This can be checked by adding the following codes to the end,</p><pre name="fe9e" id="fe9e" class="graf graf--pre graf-after--p">printf(&quot;\nCheck the existence of the data =================== \n&quot;);<br>char data[256];<br>strncpy(data, chunk-&gt;response, 100);<br>data[100] = &#39;\0&#39;;<br>printf(&quot;%s\n&quot;, data);<br>printf(&quot;end ================================================= \n&quot;);</pre><p name="408e" id="408e" class="graf graf--p graf-after--pre">Note that this code will print only the first 100 characters in the response from the HTTP server.</p><p name="b2be" id="b2be" class="graf graf--p graf-after--p">The example of the code we have discussed will be,</p><figure name="9997" id="9997" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/31790b02d5c8c3d2cc7a7cbfa8e22a68.js"></script></figure><p name="adb7" id="adb7" class="graf graf--p graf-after--figure">Then the output of this code should be,</p><pre name="6160" id="6160" class="graf graf--pre graf-after--p">Libcurl Version: libcurl/7.54.0 LibreSSL/2.6.5 zlib/1.2.11 nghttp2/1.24.1<br>&lt;!DOCTYPE HTML&gt;<br>...<br>&lt;/html&gt;<br>This is from the modified callback.</pre><pre name="b4d6" id="b4d6" class="graf graf--pre graf-after--pre">Check the existence of the data =================== <br>&lt;!DOCTYPE HTML&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>  &lt;title&gt;Internet Voting&lt;/title&gt;<br>  &lt;meta http-equiv=&quot;Content-Type&quot; con<br>end =================================================</pre><p name="7a10" id="7a10" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(5) HTTP Requests Exceptions</strong></p><p name="bc4d" id="bc4d" class="graf graf--p graf-after--p">When we have a wrong webpage address, we will potentially get a <code class="markup--code markup--p-code">404 Not Found</code> because the HTTP server needs to prevent <strong class="markup--strong markup--p-strong">probing security attacks</strong>. What we expect is that, when we get a 404 Not Found response, we will not print the contents. Instead, we will print an error <code class="markup--code markup--p-code">ERROR: Can’t find the resource</code>. The <code class="markup--code markup--p-code">curl_easy_getinfo</code> function can be used to get the response code from the HTTP server. If the code is 200, that means we successfully find the resource we need. Instead, if the code is 404, that means we have a file not found error. The response code can be stored as the <code class="markup--code markup--p-code">status</code> variable.</p><pre name="9461" id="9461" class="graf graf--pre graf-after--p">long status;<br>curl_easy_getinfo(easy_handle, CURLINFO_RESPONSE_CODE, &amp;status);</pre><p name="0236" id="0236" class="graf graf--p graf-after--pre">Then if the status is 404, we will return the function.</p><pre name="734d" id="734d" class="graf graf--pre graf-after--p">if (status == 404) {<br>    fprintf(stderr, &quot;ERROR: Can&#39;t find the resource.\n&quot;);<br>    return 0;<br>}</pre><p name="aff5" id="aff5" class="graf graf--p graf-after--pre">The example code should be,</p><figure name="08a6" id="08a6" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/2d20ef2395a41f65e42ce414b4ce47d7.js"></script></figure><p name="1270" id="1270" class="graf graf--p graf-after--figure">The output will be,</p><pre name="f104" id="f104" class="graf graf--pre graf-after--p">Libcurl Version: libcurl/7.54.0 LibreSSL/2.6.5 zlib/1.2.11 nghttp2/1.24.1<br>ERROR: Can&#39;t find the resource.</pre><p name="e2bc" id="e2bc" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Inter-Process Communication Implementation</strong></p><p name="38d7" id="38d7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(0) Create a New Process</strong></p><p name="9316" id="9316" class="graf graf--p graf-after--p">In this section, we would like to have multiple processes, so it is necessary for us to recall some of the functions for managing child processes. The <code class="markup--code markup--p-code">fork</code> function can be used to create a new process. The return value of this function in the parent process will be 0, but in the children process, this will be a non-zero value,</p><figure name="b9ab" id="b9ab" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/86d2cec711702e54a92c3ce9c1981122.js"></script></figure><p name="76dc" id="76dc" class="graf graf--p graf-after--figure">The output can be (note the value <code class="markup--code markup--p-code">56908</code> should be different),</p><pre name="63c3" id="63c3" class="graf graf--pre graf-after--p">56908: This is the child process.<br>0: This is the parent process.</pre><p name="c764" id="c764" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(1) Pipe</strong></p><p name="9968" id="9968" class="graf graf--p graf-after--p">Now, let’s see how we can use the pipe to communicate between two processes. In this case, we want to create a pipe so that the parent process can write to this pipe. After the parent writes to the pipe, the child can then read from the pipe and get the message it wants.</p><p name="806f" id="806f" class="graf graf--p graf-after--p">Before we call the function <code class="markup--code markup--p-code">pipe</code> to create a pipe for communication, we must maintain a 2-item array <code class="markup--code markup--p-code">pipefd</code> of the <code class="markup--code markup--p-code">int</code> type. The array <code class="markup--code markup--p-code">pipefd</code> is used to<br> return two file descriptors referring to the two ends of the pipe. <code class="markup--code markup--p-code">pipefd[0]</code> refers to the read end of the pipe and <code class="markup--code markup--p-code">pipefd[1]</code> refers to the write end of the pipe. Then we can use the following code to create this pipe.</p><pre name="12d1" id="12d1" class="graf graf--pre graf-after--p">int pipefd[2];<br>if (pipe(pipefd) == -1) {<br>    printf(&quot;Unable to create pipe\n&quot;);<br>    return -1;<br>}</pre><p name="c064" id="c064" class="graf graf--p graf-after--pre">This pipe seems like the following diagram,</p><figure name="024d" id="024d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*pjQm3IQmsbyY-cF_5GZ-jQ.png" data-width="1582" data-height="230" src="https://cdn-images-1.medium.com/max/800/1*pjQm3IQmsbyY-cF_5GZ-jQ.png"></figure><p name="d145" id="d145" class="graf graf--p graf-after--figure">Then, we can use <code class="markup--code markup--p-code">fork</code> to create a new process. In the parent process, we are going to use <code class="markup--code markup--p-code">write</code> to send data to the pipe. For example,</p><pre name="6106" id="6106" class="graf graf--pre graf-after--p">write(pipefd[1], &quot;Hi &quot;, STREAM_SIZE);</pre><p name="1cfe" id="1cfe" class="graf graf--p graf-after--pre">Note because the parent process will only write to the pipe, it will never use the <code class="markup--code markup--p-code">pipefd[0]</code> endpoint. Thus, we can <code class="markup--code markup--p-code">close</code> this end for the safety concerns.</p><pre name="da7f" id="da7f" class="graf graf--pre graf-after--p">close(pipefd[0]);</pre><p name="0afc" id="0afc" class="graf graf--p graf-after--pre">Similarly, in the child process, we will first close the unused write endpoint and then <code class="markup--code markup--p-code">read</code> from the read endpoint.</p><pre name="077a" id="077a" class="graf graf--pre graf-after--p">char readmessage[STREAM_SIZE];</pre><pre name="08bd" id="08bd" class="graf graf--pre graf-after--pre">close(pipefd[1]);<br>read(pipefd[0], readmessage, sizeof(readmessage));</pre><p name="fda1" id="fda1" class="graf graf--p graf-after--pre">In general, the following example code can be used to communicate between two processes via <code class="markup--code markup--p-code">pipe</code>,</p><figure name="0bf3" id="0bf3" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/6509e640cbe5266985f3905a25fa44c3.js"></script></figure><p name="a239" id="a239" class="graf graf--p graf-after--figure">The output should be,</p><pre name="20fc" id="20fc" class="graf graf--pre graf-after--p">Parent Process - Message writing to pipe<br>Parent Process - Message writing to pipe<br>Child Process - Reading from pipe – Message 1 is Hi <br>Child Process - Reading from pipe – Message 2 is Pipe!</pre><p name="4dff" id="4dff" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(2) Named Pipe</strong></p><p name="49c5" id="49c5" class="graf graf--p graf-after--p">Now, we have implemented the pipe, but there is a problem. The pipe can only be used for related processes (e.g. parent process and child process) so that they can share the same pipe easily. However, there can be many situations that we want two unrelated processes (e.g. the client and the server) to communicate via the pipe. At this moment, the pipe will no longer be useful. Instead, we will use the concept of the <strong class="markup--strong markup--p-strong">named pipe</strong>. The named pipe is also called <strong class="markup--strong markup--p-strong">FIFO </strong>(means first in first out).</p><p name="7d0d" id="7d0d" class="graf graf--p graf-after--p">The named pipe is nothing like a real pipe, instead, it seems more like a special kind of <strong class="markup--strong markup--p-strong">file</strong>. The main idea of the named pipe is that we can attach this file to both of the two processes so that they can read or write from this file. The file follows the FIFO rule, which means that we will first read the first thing write to this file.</p><figure name="7f81" id="7f81" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*kK6kC9WDkjrEAkXweD5glw.png" data-width="1582" data-height="338" src="https://cdn-images-1.medium.com/max/800/1*kK6kC9WDkjrEAkXweD5glw.png"></figure><p name="f65f" id="f65f" class="graf graf--p graf-after--figure">To create a named pipe, we must select the directory of the named pipe file. Commonly, we will put this file under the <code class="markup--code markup--p-code">/tmp</code> directory so that it can be automatically deleted after rebooting. In our case, we will store the file in the directory <code class="markup--code markup--p-code">/tmp/myfifo</code>,</p><pre name="0173" id="0173" class="graf graf--pre graf-after--p">#define FIFO_FILE &quot;/tmp/myfifo&quot;</pre><p name="f2a3" id="f2a3" class="graf graf--p graf-after--pre">Then the function <code class="markup--code markup--p-code">mkfifo</code> is called in each process to establish a FIFO file and attach this file to the current process. <code class="markup--code markup--p-code">DEFFILEMODE</code> is the permission we will use for this file, which simply means <code class="markup--code markup--p-code">S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</code> (permission for all the users). You can also assign <code class="markup--code markup--p-code">0666</code> for this argument, which means basically the same.</p><pre name="efcc" id="efcc" class="graf graf--pre graf-after--p">mkfifo(FIFO_FILE, DEFFILEMODE);</pre><p name="0283" id="0283" class="graf graf--p graf-after--pre">After we attached this pipe two these processes, they can then communicate with each other via this named pipe. Let’s see how it works. When one process wants to send a message to another, it will first <code class="markup--code markup--p-code">open</code> the file (as the write-only mode) and then <code class="markup--code markup--p-code">write</code> the message to the named pipe. After writing, the file should be closed by the <code class="markup--code markup--p-code">close</code> function.</p><pre name="f078" id="f078" class="graf graf--pre graf-after--p">int fd = open(FIFO_FILE, O_WRONLY);<br>write(fd, &quot;Hello&quot;, strlen(&quot;Hello&quot;)+1);<br>close(fd);</pre><p name="d486" id="d486" class="graf graf--p graf-after--pre">Then, in another process, if we want to read from this process, we should first open the file (as the read-only mode) and then <code class="markup--code markup--p-code">read</code> the message from the named pipe. After reading, the file should be closed by the <code class="markup--code markup--p-code">close</code> function.</p><pre name="98f5" id="98f5" class="graf graf--pre graf-after--p">char str[80];</pre><pre name="072e" id="072e" class="graf graf--pre graf-after--pre">fd = open(FIFO_FILE, O_RDONLY);<br>read(fd, str, 80);<br>close(fd);</pre><p name="7ee0" id="7ee0" class="graf graf--p graf-after--pre">Now, let’s see an example code. The code for <code class="markup--code markup--p-code">fifoserver.c</code> should be,</p><figure name="9199" id="9199" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/b252a966ee4304684ea5b506afebaed5.js"></script></figure><p name="b55d" id="b55d" class="graf graf--p graf-after--figure">The code for <code class="markup--code markup--p-code">fifoclient.c</code> should be,</p><figure name="1279" id="1279" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/90a95f9fe3b21e8266755f650920696f.js"></script></figure><p name="c646" id="c646" class="graf graf--p graf-after--figure">The output for the server will be,</p><pre name="a953" id="a953" class="graf graf--pre graf-after--p">Named pipe established! ==============<br>Server: send Connected!<br>Client: Hello Server</pre><p name="a924" id="a924" class="graf graf--p graf-after--pre">The output for the client will be,</p><pre name="93e2" id="93e2" class="graf graf--pre graf-after--p">Named pipe established! ==============<br>Server: Connected!<br>Client: send Hello Server</pre><p name="908b" id="908b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Shared Memory</strong></p><p name="fd34" id="fd34" class="graf graf--p graf-after--p">Now, let’s see how we can use the shared memory. We will see two examples in this section.</p><p name="f8d0" id="f8d0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">In the first example</strong>, we will have to communicate between two related processes (i.e. a parent process and its child). The shared memory will be attached to both these two processes and then they are able to communicate via this shared memory. In this case, we are going to use the <strong class="markup--strong markup--p-strong">Sys V APIs</strong> for sharing the memory.</p><p name="b263" id="b263" class="graf graf--p graf-after--p">The basic idea of the first program is that, firstly, the shared memory is created by the <code class="markup--code markup--p-code">shmget</code> function. In this case, the unique key will not be generated, instead, we will assign <code class="markup--code markup--p-code">IPC_PRIVATE</code> (i.e. value 0) to this argument. This is because we have a private IPC and we don’t really care about this unique key.</p><p name="af06" id="af06" class="graf graf--p graf-after--p">Then, the <code class="markup--code markup--p-code">shmat</code> is called to attach the current process to this shared memory we have created by <code class="markup--code markup--p-code">shmget</code>. The return value of <code class="markup--code markup--p-code">shmat</code> is <code class="markup--code markup--p-code">void *</code> so that we have to convert it to the data structure we will use to store the shared data.</p><p name="4eff" id="4eff" class="graf graf--p graf-after--p">Although we can use a simple string for communication, in this case, we are going to use a user-defined data structure called <code class="markup--code markup--p-code">datamemory</code>. Similarly, this data structure has two elements as we have discussed. One is the <code class="markup--code markup--p-code">message</code> variable that we are going to use for storing the shared data. The other is the <code class="markup--code markup--p-code">size</code> variable that represents the length of the shared data.</p><pre name="1d8d" id="1d8d" class="graf graf--pre graf-after--p">typedef struct {<br>    char message[SHARED_MEM_SIZE];<br>    int size;<br>} datamemory;</pre><p name="3224" id="3224" class="graf graf--p graf-after--pre">Then the <code class="markup--code markup--p-code">fork</code> is called to create the child process of the current process. Because we have already called <code class="markup--code markup--p-code">shmat</code> , now both of these processes are attached to the same shared memory. Because they can do write and read to the shared memory simultaneously, we have to do some <strong class="markup--strong markup--p-strong">synchronizations</strong> to make sure that the child process writes in the first place, and then the parent will read from the shared memory. We are going to discuss the synchronizations later and now we will simply use <code class="markup--code markup--p-code">sleep</code> to synchronize these two processes.</p><p name="9c9f" id="9c9f" class="graf graf--p graf-after--p">First, the parent will read from the memory and reads nothing because the memory is empty now. So the child should <code class="markup--code markup--p-code">sleep</code> at the beginning. After the parent reads from the memory, it should <code class="markup--code markup--p-code">sleep</code> and wait for the child to write. In end, after the child writes to the shared memory, the parent will read the shared memory again and get the shared data. In fact, we should have a workload of the following diagram.</p><figure name="75ce" id="75ce" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*lnememp183a5UMyA7oNKSg.png" data-width="1764" data-height="970" src="https://cdn-images-1.medium.com/max/800/1*lnememp183a5UMyA7oNKSg.png"></figure><p name="4cf3" id="4cf3" class="graf graf--p graf-after--figure">After the child writes to the memory, it will wait for another second before it returns (Why? You can delete the <code class="markup--code markup--p-code">sleep(1);</code> to see what will happen). It should also detach from the shared memory because it finishes its task. However, it must not destroy the shared memory because the parent may be reading from this memory.</p><p name="3c6a" id="3c6a" class="graf graf--p graf-after--p">When the parent process successfully read the data from the shared memory, it can be detached from it, and then we can call <code class="markup--code markup--p-code">shmctl</code> to destroy the shared memory because it will no longer be useful.</p><p name="a4bf" id="a4bf" class="graf graf--p graf-after--p">The example code should be,</p><figure name="c8b0" id="c8b0" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/30fb7362c146a54be64176280e7d3e46.js"></script></figure><p name="be33" id="be33" class="graf graf--p graf-after--figure">And the output should be,</p><pre name="705b" id="705b" class="graf graf--pre graf-after--p">SHM Content:<br>SHM Content: Hello, shared memory.</pre><p name="7b7d" id="7b7d" class="graf graf--p graf-after--pre">Now, let’s see the <strong class="markup--strong markup--p-strong">second example</strong>. The second is much simpler than the first one but we have to communicate between two unrelated processes. In this case, we will directly use a shared string instead of a user-defined data structure because the size of the data is useless.</p><p name="11af" id="11af" class="graf graf--p graf-after--p">The writer process will first write to the shared memory and then it will be detached from the memory. The reader process will then read from the shared memory. After it prints the data in the shared memory, it will be detached from the shared memory. In the end, the shared memory will then be destroyed through <code class="markup--code markup--p-code">shmctl</code> by the reader.</p><figure name="48b7" id="48b7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dQr6eBqpBxjgGeXlhgQjXA.png" data-width="1464" data-height="392" src="https://cdn-images-1.medium.com/max/800/1*dQr6eBqpBxjgGeXlhgQjXA.png"></figure><p name="d51a" id="d51a" class="graf graf--p graf-after--figure">What is different in this case is that, because this is not a private IPC anymore, we have to assign a unique key to this shared memory so that the other process can know where to find this shared memory. Thus, the unique key is relatively important in this case. We will use <code class="markup--code markup--p-code">ftok</code> to generate the unique key. Note that the first argument of this function must be the path of an existing file, but the file content is not relevant for us. Also, the second argument is also not relevant. In our case, we will use <code class="markup--code markup--p-code">65</code> but you can change the value of it to whatever you like.</p><p name="af28" id="af28" class="graf graf--p graf-after--p">The example codes for this case are,</p><figure name="fe0d" id="fe0d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/6fd76ff9bde50042eb74151c42166fad.js"></script></figure><figure name="ba25" id="ba25" class="graf graf--figure graf--iframe graf-after--figure"><script src="https://gist.github.com/Sadamingh/c7c9db61444f2abc583855fa39260465.js"></script></figure><p name="54ec" id="54ec" class="graf graf--p graf-after--figure">And the output for the reader should be,</p><pre name="b4cb" id="b4cb" class="graf graf--pre graf-after--p">Data read from memory: Hello, shared memory.</pre><p name="e7bd" id="e7bd" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(4) Message Queue</strong></p><p name="c299" id="c299" class="graf graf--p graf-after--p">The main difference between the message queue and the pipe is that the latter one can only be used for IPC between relative processes. The main difference between the message queue and the named pipe is that the named pipe relies on the file, while the message does not rely on the file depend on the processes. The main difference between the message queue and the former one doesn’t need synchronization.</p><p name="98bc" id="98bc" class="graf graf--p graf-after--p">The Sys V API for creating a message queue is quite similar to the shared memory. The <code class="markup--code markup--p-code">msgget</code> is called create a message queue and an identifier of this queue will be returned. To create a message queue, we should get a unique key for this message queue. The function <code class="markup--code markup--p-code">msgsnd</code> is used to send the data to the message queue and <code class="markup--code markup--p-code">msgrcv</code> is used to read the data from the queue. After the reader reads from the queue, <code class="markup--code markup--p-code">msgctl</code> will be called to destroy the message queue.</p><p name="1c46" id="1c46" class="graf graf--p graf-after--p">The example code can be found from <a href="https://www.geeksforgeeks.org/ipc-using-message-queues/" data-href="https://www.geeksforgeeks.org/ipc-using-message-queues/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>. Note that we will read a message from the queue instead of some bytes at a time.</p><figure name="5586" id="5586" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*R8UNPJuWVhwCRvVpKQL9qw.png" data-width="1464" data-height="392" src="https://cdn-images-1.medium.com/max/800/1*R8UNPJuWVhwCRvVpKQL9qw.png"></figure><p name="bbb6" id="bbb6" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">3. Linux Signals</strong></p><p name="8a6e" id="8a6e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Signal Handler</strong></p><p name="6c80" id="6c80" class="graf graf--p graf-after--p">Most Linux users use the key combination Ctrl+C to terminate processes in Linux. The reason behind this is that whenever Ctrl+C is pressed, a signal <code class="markup--code markup--p-code">SIGINT</code> is sent to the process. The <strong class="markup--strong markup--p-strong">default action</strong> of this signal is to terminate the process.</p><p name="089b" id="089b" class="graf graf--p graf-after--p">Now, let’s add another print. Before the process terminates, we will have to print <code class="markup--code markup--p-code">Received SIGINT, quitting …</code> , this means we must modify the signal handler to some user-defined functions. In fact, the handler can be replaced by the <code class="markup--code markup--p-code">signal</code> function and the second argument will become a callback function of the present signal. The example code of modifying the signal should be,</p><figure name="7c15" id="7c15" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/a9e1d4441bdedfd8aa08c6f83fed3120.js"></script></figure><p name="780e" id="780e" class="graf graf--p graf-after--figure">The output of the program should be,</p><pre name="cc53" id="cc53" class="graf graf--pre graf-after--p">^C<br>Received SIGINT, quitting ...</pre><p name="b56f" id="b56f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(2) Linux’s Kill Command</strong></p><p name="991c" id="991c" class="graf graf--p graf-after--p">Now, let’s try another way to terminate a process. You may know that the <code class="markup--code markup--p-code">kill</code> command can be used to terminate a process in Linux. This is true but we must know the <strong class="markup--strong markup--p-strong">process id</strong> (i.e. pid) we would like to kill. Let’s run the program above again but we will not use Ctrl+C to terminate it this time. After executing the code above, we can use the following command to find its process id (in another terminal).</p><pre name="3fc0" id="3fc0" class="graf graf--pre graf-after--p">$ ps | grep signal</pre><p name="ec94" id="ec94" class="graf graf--p graf-after--pre">The output might be,</p><pre name="7055" id="7055" class="graf graf--pre graf-after--p">96001 ttys003    0:00.00 grep <strong class="markup--strong markup--pre-strong">signal<br></strong>96056 ttys005    0:20.09 /.../<strong class="markup--strong markup--pre-strong">signal</strong></pre><p name="88dc" id="88dc" class="graf graf--p graf-after--pre">Note that the first line is useless, this means that we are going to use a grep command in finding the keyword signal. The process in the second line is exactly the process we want and its pid should be <code class="markup--code markup--p-code">96056</code> . Note that you might get a different pid and it will be okay. Then we can use the kill command to terminate the process,</p><pre name="495f" id="495f" class="graf graf--pre graf-after--p">$ kill 96056</pre><p name="860b" id="860b" class="graf graf--p graf-after--pre">Then we will find the process is terminated and the output will be,</p><pre name="3fdd" id="3fdd" class="graf graf--pre graf-after--p">Terminated: 15</pre><p name="200e" id="200e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(3) Modify SIGKILL handler</strong></p><p name="74cf" id="74cf" class="graf graf--p graf-after--p">Now, how about let’s have a try on modifying the <code class="markup--code markup--p-code">SIGKILL</code> handler just as what we have done to the <code class="markup--code markup--p-code">SIGINT</code>. So when we meet a <code class="markup--code markup--p-code">SIGKILL</code>, we can print <code class="markup--code markup--p-code">Received SIGKILL, quitting …</code> before the process is terminated. You can try the following program to see if it works,</p><figure name="919c" id="919c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/05a7056e64f1dc025c400b881e24d380.js"></script></figure><p name="5402" id="5402" class="graf graf--p graf-after--figure">However, it is a pity because the output says,</p><pre name="89ff" id="89ff" class="graf graf--pre graf-after--p">Error: Can&#39;t catch SIGKILL</pre><p name="020d" id="020d" class="graf graf--p graf-after--pre">This is because the <code class="markup--code markup--p-code">SIGKILL </code>is handled by the kernel and we, as the users, can not simply change the handler of it. It’s quite a similar case for the <code class="markup--code markup--p-code">SIGSTOP</code> signal. This is why the manual says,</p><blockquote name="5752" id="5752" class="graf graf--blockquote graf-after--p">The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</blockquote><p name="b84e" id="b84e" class="graf graf--p graf-after--blockquote">You can also view <a href="https://stackoverflow.com/questions/35569659/the-signals-sigkill-and-sigstop-cannot-be-caught-blocked-or-orignored-why" data-href="https://stackoverflow.com/questions/35569659/the-signals-sigkill-and-sigstop-cannot-be-caught-blocked-or-orignored-why" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this StackOverflow page</a> for more insights.</p><p name="91c8" id="91c8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) User Defined Signals</strong></p><p name="b01d" id="b01d" class="graf graf--p graf-after--p">Even though we can not modify the <code class="markup--code markup--p-code">SIGKILL</code> signal, we can send some user-defined signals to the process by the <code class="markup--code markup--p-code">kill</code> command. In Linux, the system provides us two user-defined signals that can be used by us, the <code class="markup--code markup--p-code">SIGUSR1</code> and the <code class="markup--code markup--p-code">SIGUSR2</code>. For example, when we receive a <code class="markup--code markup--p-code">SIGUSR1</code> , we can print <code class="markup--code markup--p-code">Someone is knocking.</code> and then do nothing. Let’s see an example code,</p><figure name="6587" id="6587" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/33312816b388d99c3fd6ded9493f1894.js"></script></figure><p name="14ef" id="14ef" class="graf graf--p graf-after--figure">The <code class="markup--code markup--p-code">kill</code> command can also be used to pass a specific signal to the process. For example, we can use the following command to send a <code class="markup--code markup--p-code">SIGUSR1</code> to our process (remember to change the pid),</p><pre name="63cd" id="63cd" class="graf graf--pre graf-after--p">$ kill -USR1 96056</pre><p name="23cc" id="23cc" class="graf graf--p graf-after--pre">Then the process will print,</p><pre name="6614" id="6614" class="graf graf--pre graf-after--p">Someone is knocking.</pre><p name="c875" id="c875" class="graf graf--p graf-after--pre">Because the process will not quit after receiving this signal, this means that you can try it several times. For Example, we can use,</p><pre name="5e9c" id="5e9c" class="graf graf--pre graf-after--p">$ kill -USR1 96056<br>$ kill -USR1 96056<br>$ kill -USR1 96056<br>$ kill -USR1 96056</pre><p name="3585" id="3585" class="graf graf--p graf-after--pre">Then the output will be,</p><pre name="9131" id="9131" class="graf graf--pre graf-after--p">Someone is knocking.</pre><pre name="df95" id="df95" class="graf graf--pre graf-after--pre">Someone is knocking.</pre><pre name="d037" id="d037" class="graf graf--pre graf-after--pre">Someone is knocking.</pre><pre name="7985" id="7985" class="graf graf--pre graf-after--pre graf--trailing">Someone is knocking.<br><br></pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/6ff4a8c62e56"><time class="dt-published" datetime="2021-03-24T06:23:44.302Z">March 24, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-19-libcurl-library-sys-v-ipc-apis-and-linux-signals-6ff4a8c62e56" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>