<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 24 | gRPC and protobuf Starter Tutorial</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 24 | gRPC and protobuf Starter Tutorial</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="798a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="60be" id="60be" class="graf graf--h3 graf--leading graf--title">Operating System 24 | gRPC and protobuf Starter Tutorial</h3><figure name="4363" id="4363" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*nD8TU2C9oB8PCmqV.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*nD8TU2C9oB8PCmqV.png"></figure><p name="4f19" id="4f19" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">1. gRPC Setup</strong></p><p name="3ab0" id="3ab0" class="graf graf--p graf-after--p">In C++, we need to build and install gRPC before we test our Hello World example. Suppose we have MacOS, and first we need to choose a directory to hold locally installed packages. This page assumes that the environment variable <code class="markup--code markup--p-code">MY_INSTALL_DIR</code> holds this directory path.</p><pre name="bdd4" id="bdd4" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ export MY_INSTALL_DIR=$HOME/.local</code></pre><p name="964e" id="964e" class="graf graf--p graf-after--pre">Ensure that the directory exists,</p><pre name="6b9c" id="6b9c" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ mkdir -p $MY_INSTALL_DIR</code></pre><p name="5442" id="5442" class="graf graf--p graf-after--pre">Add the local <code class="markup--code markup--p-code">bin</code> folder to your path variable,</p><pre name="4b1a" id="4b1a" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ export PATH=&quot;$PATH:$MY_INSTALL_DIR/bin&quot;</code></pre><p name="7abe" id="7abe" class="graf graf--p graf-after--pre">You need version <code class="markup--code markup--p-code">3.19.6</code> or later of <code class="markup--code markup--p-code">cmake</code>. Install it by,</p><pre name="ca42" id="ca42" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ wget -q -O cmake-linux.sh https://github.com/Kitware/CMake/releases/download/v3.19.6/cmake-3.19.6-Linux-x86_64.sh<br>$ sh cmake-linux.sh -- --skip-license --prefix=$MY_INSTALL_DIR<br>$ rm cmake-linux.sh</code></pre><p name="5ace" id="5ace" class="graf graf--p graf-after--pre">Then check the version of <code class="markup--code markup--p-code">cmake</code>,</p><pre name="e023" id="e023" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ cmake --version<br>cmake version 3.19.6</code></pre><p name="f5be" id="f5be" class="graf graf--p graf-after--pre">Install the basic tools required to build gRPC,</p><pre name="cfde" id="cfde" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ brew install autoconf automake libtool pkg-config</code></pre><p name="5e23" id="5e23" class="graf graf--p graf-after--pre">Then, clone the <code class="markup--code markup--p-code">gRPC</code> repo,</p><pre name="ca14" id="ca14" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ git clone --recurse-submodules -b v1.35.0 https://github.com/grpc/grpc</code></pre><p name="10ad" id="10ad" class="graf graf--p graf-after--pre">While not mandatory, <code class="markup--code markup--p-code">gRPC</code> applications usually IDL <code class="markup--code markup--p-code">proto3</code> for service definitions and data serialization,</p><pre name="1941" id="1941" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">$ cd grpc<br>$ mkdir -p cmake/build<br>$ pushd cmake/build<br>$ cmake -DgRPC_INSTALL=ON <strong class="markup--strong markup--pre-strong">\<br></strong>      -DgRPC_BUILD_TESTS=OFF <strong class="markup--strong markup--pre-strong">\<br></strong>      -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR <strong class="markup--strong markup--pre-strong">\<br></strong>      ../..<br>$ make install -j4  // 4 means that you should have a 4-core system<br>$ popd</code></pre><p name="7add" id="7add" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. Helloworld Example</strong></p><p name="c800" id="c800" class="graf graf--p graf-after--p">First, let’s check the helloworld example. The example code is part of the <code class="markup--code markup--p-code">grpc</code> repo source, which you cloned as part of the steps of the previous section. First, let’s change to the example’s directory,</p><pre name="b69e" id="b69e" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ cd examples/cpp/helloworld</code></pre><p name="c9d8" id="c9d8" class="graf graf--p graf-after--pre">Then build the example using <code class="markup--code markup--p-code">cmake</code>,</p><pre name="88df" id="88df" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ mkdir -p cmake/build<br>$ pushd cmake/build<br>$ cmake -DCMAKE_PREFIX_PATH=$MY_INSTALL_DIR ../..<br>$ make -j4          </code></pre><p name="9fb7" id="9fb7" class="graf graf--p graf-after--pre">After we meet,</p><pre name="034e" id="034e" class="graf graf--pre graf-after--p">[100%] Built target greeter_client</pre><p name="592c" id="592c" class="graf graf--p graf-after--pre">Then it means that we can test our code. From the first terminal, we can use</p><pre name="2844" id="2844" class="graf graf--pre graf-after--p">$ ./greeter_server<br>Server listening on 0.0.0.0:50051</pre><p name="4f1f" id="4f1f" class="graf graf--p graf-after--pre">In the second terminal, run</p><pre name="a73b" id="a73b" class="graf graf--pre graf-after--p">$ ./greeter_client</pre><p name="378a" id="378a" class="graf graf--p graf-after--pre">And we will receive the following message,</p><pre name="fb78" id="fb78" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">Greeter received: Hello world</code></pre><p name="636e" id="636e" class="graf graf--p graf-after--pre">Congratulations! You’ve just run a client-server application with gRPC.</p><p name="3389" id="3389" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Protocol Buffer</strong></p><p name="455b" id="455b" class="graf graf--p graf-after--p">In the last section, we have discussed that we can use the XDR files to construct the client stub and the server stub. For the gRPC, we will use <a href="https://developers.google.com/protocol-buffers/docs/overview" data-href="https://developers.google.com/protocol-buffers/docs/overview" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">protobuf</a> by default. This is a serializing open-source compiler developed by Google. We can install the protobuf by,</p><pre name="707c" id="707c" class="graf graf--pre graf-after--p">$ brew install protobuf</pre><figure name="2dde" id="2dde" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*WP4LrFyAsUgQgb2j0LP36Q.png" data-width="1272" data-height="168" src="https://cdn-images-1.medium.com/max/800/1*WP4LrFyAsUgQgb2j0LP36Q.png"></figure><p name="462e" id="462e" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">4. Protocol Buffer Version</strong></p><p name="6ecf" id="6ecf" class="graf graf--p graf-after--p">The first step when working with protocol buffers is to define the structure for the data you want to serialize in a proto file, which is an ordinary text file with a <code class="markup--code markup--p-code">.proto</code> extension. In the first line of a <code class="markup--code markup--p-code">.proto</code> file, we must explicitly point out that we will use <code class="markup--code markup--p-code">proto3</code> because by default, we will be using <code class="markup--code markup--p-code">proto2</code>.</p><pre name="fcf6" id="fcf6" class="graf graf--pre graf-after--p">syntax = &quot;proto3&quot;;</pre><p name="6449" id="6449" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">5. Proto Message</strong></p><p name="dbd8" id="dbd8" class="graf graf--p graf-after--p">Protocol buffer data is structured as <strong class="markup--strong markup--p-strong">messages</strong>, where each message is a small logical record of information containing a series of name-value pairs called <strong class="markup--strong markup--p-strong">fields</strong>. Here’s a simple example in the helloworld example,</p><pre name="5428" id="5428" class="graf graf--pre graf-after--p">// The request message containing the user&#39;s name.<br>message HelloRequest {<br>    string name = 1;<br>}</pre><p name="5f3d" id="5f3d" class="graf graf--p graf-after--pre">We can try to compile the following simple.proto code by the compiler <code class="markup--code markup--p-code">protoc</code>,</p><figure name="8f93" id="8f93" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/43a34331b2e96d15285da035a5648772.js"></script></figure><p name="a2cf" id="a2cf" class="graf graf--p graf-after--figure">By,</p><pre name="46be" id="46be" class="graf graf--pre graf-after--p">$ mkdir -p build<br>$ protoc simple.proto --cpp_out=./build<br>$ ls ./build<br>simple.pb.cc    simple.pb.h</pre><p name="61da" id="61da" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">6. Field and Field Number</strong></p><p name="6b98" id="6b98" class="graf graf--p graf-after--p">In the previous example, we have found out that in a specific message, we must have name-value pairs called <strong class="markup--strong markup--p-strong">fields</strong>. And these fields can be used to transfer the data. But why do we must include a field number after each field? Before we answer this question, let’s try to compile the following code,</p><figure name="2294" id="2294" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/5b6a3e67012c942379506cec119acf82.js"></script></figure><p name="7ad3" id="7ad3" class="graf graf--p graf-after--figure">If we compile this code, we will find the following error,</p><pre name="6ef8" id="6ef8" class="graf graf--pre graf-after--p">simple.proto:6:16: Field number 1 has already been used in &quot;HelloRequest&quot; by field &quot;name&quot;.</pre><p name="21fb" id="21fb" class="graf graf--p graf-after--pre">This means that the field number must be unique for each field in each message. However, in two different messages, we can use the same field number. For example, in the helloworld example, field <code class="markup--code markup--p-code">name</code> and field <code class="markup--code markup--p-code">message</code> in two different messages can have the same field number.</p><figure name="e972" id="e972" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/6c83f5e4c2f5efa7a7c24f7dcacf5918.js"></script></figure><p name="9f39" id="9f39" class="graf graf--p graf-after--figure">But why should we include this field number? Let’s see an explanation from the <a href="https://stackoverflow.com/questions/26826421/protocol-buffers-unique-numbered-tag-clarification" data-href="https://stackoverflow.com/questions/26826421/protocol-buffers-unique-numbered-tag-clarification" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">StackOverflow</a>. It says that the field numbers are used to match fields when serializing and deserializing the data. So if we don’t include this value, there will be ambiguity from both sides. For example, if we want to transfer both the string name and an int32 typed code, the client and the server will not know how to interpret the message data because we can have two different cases,</p><figure name="93d5" id="93d5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*psojnbCWrRngfqFOlE9Hhw.png" data-width="1272" data-height="88" src="https://cdn-images-1.medium.com/max/800/1*psojnbCWrRngfqFOlE9Hhw.png"></figure><p name="7804" id="7804" class="graf graf--p graf-after--figure">If we attach a field number for each field, then it will be easier because now both the server and the client know how to serialize and deserialize the data.</p><p name="75e5" id="75e5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">7. Proto Services</strong></p><p name="75d4" id="75d4" class="graf graf--p graf-after--p">In the <code class="markup--code markup--p-code">.proto</code> file, we should also define our gRPC services. For example, in the helloworld example, both the server and the client stub have a <code class="markup--code markup--p-code">SayHello()</code> RPC method that takes a <code class="markup--code markup--p-code">HelloRequest</code> parameter from the client and returns a <code class="markup--code markup--p-code">HelloResponse</code> from the server, and that this method is defined like this,</p><pre name="5024" id="5024" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">service Greeter {<br>  <em class="markup--em markup--pre-em">// Sends a greeting<br></em>  rpc SayHello (HelloRequest) returns (HelloReply) {}<br>}</code></pre><p name="2bc2" id="2bc2" class="graf graf--p graf-after--pre">You can add another service simply and now let’s have a try. Suppose after the greeter, we would like to send a password to the server and the server will send back the <code class="markup--code markup--p-code">int32</code> type private key. So we can update the new <code class="markup--code markup--p-code">.proto</code> file as,</p><figure name="933e" id="933e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/81eb36ae21570dc00df657d1edb34ca4.js"></script></figure><p name="45d8" id="45d8" class="graf graf--p graf-after--figure">Before we can use the new service method, we need to recompile the updated proto file. From the directory <code class="markup--code markup--p-code">…/examples/cpp/helloworld/cmake/build</code> , we should run,</p><pre name="005d" id="005d" class="graf graf--pre graf-after--p">$ make -j4</pre><p name="477b" id="477b" class="graf graf--p graf-after--pre">This regenerates <code class="markup--code markup--p-code">helloworld.pb.{h,cc}</code> and <code class="markup--code markup--p-code">helloworld.grpc.pb.{h,cc}</code>, which contains the generated client and server classes, as well as classes for populating, serializing, and retrieving our request and response types.</p><p name="bd9d" id="bd9d" class="graf graf--p graf-after--p">Then, we still need to implement and call the new method in the human-written parts of our example application.</p><figure name="ea54" id="ea54" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/Sadamingh/73df5f177ee493b3aac2a11da7c79f6a.js"></script></figure><p name="4383" id="4383" class="graf graf--p graf-after--figure">Finally, from the directory <code class="markup--code markup--p-code">…/examples/cpp/helloworld/cmake/build</code> , we should run,</p><pre name="a519" id="a519" class="graf graf--pre graf-after--p">$ make -j4</pre><p name="c2e7" id="c2e7" class="graf graf--p graf-after--pre">Then, from one terminal,</p><pre name="3253" id="3253" class="graf graf--pre graf-after--p">$ ./greeter_server<br>Server listening on 0.0.0.0:50051</pre><p name="887e" id="887e" class="graf graf--p graf-after--pre">From another terminal,</p><pre name="1df5" id="1df5" class="graf graf--pre graf-after--p graf--trailing">$ ./greeter_client<br>Greeter received: Hello world<br>Private key: 102513</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/7a5ad6f1464b"><time class="dt-published" datetime="2021-04-17T22:23:15.414Z">April 17, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-24-grpc-and-protobuf-starter-tutorial-7a5ad6f1464b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>