<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 6 | Thread Part 2, Reader-Writer Problem, Spurious Wakeups, and Deadlocks</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 6 | Thread Part 2, Reader-Writer Problem, Spurious Wakeups, and Deadlocks</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="8fcf" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9e1a" id="9e1a" class="graf graf--h3 graf--leading graf--title">Operating System 6 | Thread Part 2, <strong class="markup--strong markup--h3-strong">Reader-Writer Problem, Spurious Wakeups, and Deadlocks</strong></h3><figure name="2d82" id="2d82" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*5jrwI45FEa8MhrSQ.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*5jrwI45FEa8MhrSQ.png"></figure><ol class="postList"><li name="e7f4" id="e7f4" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Mutex And Condition Variable</strong></li></ol><p name="9364" id="9364" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Reader/Writer Problem</strong></p><p name="e069" id="e069" class="graf graf--p graf-after--p">Reader/writer problems can be common in a multi-threading system as a combination of mutex and condition variables. Some of the threads operations try to access the shared state for reading, while other threads would like to perform write operations to that same shared state. Suppose we have 0 or more threads read from a file and 0 or 1 thread for writing to it.</p><figure name="ce06" id="ce06" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*U7xaHiQnQ-6-raNiIgn_Eg.png" data-width="1684" data-height="764" src="https://cdn-images-1.medium.com/max/800/1*U7xaHiQnQ-6-raNiIgn_Eg.png"></figure><p name="1b43" id="1b43" class="graf graf--p graf-after--figure">To avoid concurrency problems, we may want to lock the access to the file by a mutex, so that only one thread can have access to this file at a time.</p><figure name="987c" id="987c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*LlsQG6SF-cFdpmBcYqYwRw.png" data-width="1684" data-height="764" src="https://cdn-images-1.medium.com/max/800/1*LlsQG6SF-cFdpmBcYqYwRw.png"></figure><p name="a75e" id="a75e" class="graf graf--p graf-after--figure">However, this mutex lock can be too restrictive for a reader/writer problem. Even though the writing thread is precisely restricted to a binary state (1 thread or 0), the reading threads are also restricted to 1 thread at a time. But we are not allowed to have multiple reading threads at a time, which should be allowed.</p><p name="6f2b" id="6f2b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Solution for Reader/Writer Problem</strong></p><p name="cec2" id="cec2" class="graf graf--p graf-after--p">The solution for this r/w problem is that we can add thread counters to count the number of the reading threads and the writing threads. For instance, suppose we have the counter <code class="markup--code markup--p-code">read_counter</code> for counting the reading threads and <code class="markup--code markup--p-code">write_counter</code> for counting the writing threads. Then,</p><pre name="b0d6" id="b0d6" class="graf graf--pre graf-after--p">if (read_counter == 0 AND <code class="markup--code markup--pre-code">write_counter == 0</code>) {R ok; W ok;}<br>if (read_counter &gt; 0) {R ok; W no;}<br>if (<code class="markup--code markup--pre-code">write_counter == 1</code>) {R no; W no;}</pre><p name="4fbf" id="4fbf" class="graf graf--p graf-after--pre">In reality, we are going to construct a <code class="markup--code markup--p-code">counter</code> for our resource and there will be three states for this counter, <code class="markup--code markup--p-code">free</code>, <code class="markup--code markup--p-code">reading</code>, <code class="markup--code markup--p-code">writing</code>.</p><pre name="0ae1" id="0ae1" class="graf graf--pre graf-after--p">// free state<br>resource_counter == 0;</pre><pre name="9b65" id="9b65" class="graf graf--pre graf-after--pre">// reading state<br>resource_counter &gt; 0;</pre><pre name="4922" id="4922" class="graf graf--pre graf-after--pre">// writing state <br>resource_counter == -1;</pre><p name="2df8" id="2df8" class="graf graf--p graf-after--pre">This counter is also called a <strong class="markup--strong markup--p-strong">predicator</strong> or a <strong class="markup--strong markup--p-strong">proxy variable</strong>, which can be used to show the states of the threads.</p><p name="b6cf" id="b6cf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Reader/Writer Example</strong></p><p name="9f8e" id="9f8e" class="graf graf--p graf-after--p">Now that we have constructed our condition variable for this problem, it is time to implement the readers and the writer. For readers, we will first lock the resource and see whether we can access the file by checking the condition variable <code class="markup--code markup--p-code">resource_counter</code>. If the <code class="markup--code markup--p-code">resource_counter</code> is set to be <code class="markup--code markup--p-code">-1</code>, which means we can only write to the source by the writing thread, then this reading thread will call <code class="markup--code markup--p-code">Wait</code> to wait for a signal <code class="markup--code markup--p-code">read_phase</code>.</p><pre name="883c" id="883c" class="graf graf--pre graf-after--p">Condition read_phase;<br>int resource_counter = 0;<br>Mutex m;<br>lock(m) {<br>    while(resource_counter == -1) Wait(m, read_phase);<br>}</pre><p name="64de" id="64de" class="graf graf--p graf-after--pre">Once we get the signal of <code class="markup--code markup--p-code">read_phase</code>, the current reading thread can continue and then read the resource.</p><pre name="2a84" id="2a84" class="graf graf--pre graf-after--p">Condition read_phase, write_phase;<br>int resource_counter = 0;<br>Mutex m;<br>lock(m) {<br>    while(resource_counter == -1) Wait(m, read_phase);<br>    resource.read();<br>    if(resource_counter == 0) Signal(write_phase);<br>}</pre><p name="c579" id="c579" class="graf graf--p graf-after--pre">However, this can have a problem. Suppose we have two reading threads and all of them receive a <code class="markup--code markup--p-code">read_phase</code> signal from the writer (by <code class="markup--code markup--p-code">Broadcast</code>). Then they are all going to read from the resource. Suppose one thread finishes the reading first and the other finishes the reading later, then two <code class="markup--code markup--p-code">write_phase</code> signals will be sent in turn. When the writer receives the signal <code class="markup--code markup--p-code">write_phase</code> from the first reading thread, the second one is still reading. This is where we will have a concurrency problem.</p><p name="d2f4" id="d2f4" class="graf graf--p graf-after--p">So what we can do is that we can separate actually access to the file from the control blocks. Thus, if there are more than 1 reading threads executing, we will not send the <code class="markup--code markup--p-code">write_phase</code> signal. This can be implemented by,</p><pre name="2bef" id="2bef" class="graf graf--pre graf-after--p">Condition read_phase, write_phase;<br>int resource_counter = 0;<br>Mutex m;<br>lock(m) {<br>    while(resource_counter == -1) Wait(m, read_phase);<br>    resource_counter++;<br>}<br>// access resource for reading<br>resource.read();    // we don&#39;t use a mutex here for multi threads<br>lock(m) {<br>    resource_counter--;<br>    if(resource_counter == 0) Signal(write_phase);<br>}</pre><p name="9a77" id="9a77" class="graf graf--p graf-after--pre">For the writer, this can be quite similar. We have to wait for the signal <code class="markup--code markup--p-code">write_phase</code> when the counter is not 0 and we have to set the counter to <code class="markup--code markup--p-code">-1</code> before we write to the resource.</p><pre name="7e24" id="7e24" class="graf graf--pre graf-after--p">Condition read_phase, write_phase;<br>int resource_counter = 0;<br>Mutex m;<br>lock(m) {<br>    while(resource_counter != 0) Wait(m, write_phase);<br>    resource_counter = -1;<br>}</pre><p name="c10e" id="c10e" class="graf graf--p graf-after--pre">Then we can write to the resource. After the writing thread writes to the resource, it updates the resource counter to <code class="markup--code markup--p-code">0</code> so that the resource is now free. And finally, it will broadcast to all reading threads the <code class="markup--code markup--p-code">read_phase</code> signal and then we will signal to the <code class="markup--code markup--p-code">write_phase</code>.</p><pre name="9843" id="9843" class="graf graf--pre graf-after--p">Condition read_phase, write_phase;<br>int resource_counter = 0;<br>Mutex m;<br>lock(m) {<br>    while(resource_counter != 0) Wait(m, write_phase);<br>    resource_counter = -1;<br>}<br>// access resource for writing<br>resource.write(...)<br>lock(m) {<br>    resource_counter = 0;<br>    Broadcast(read_phase);<br>    Signal(write_phase);<br>}</pre><p name="2d08" id="2d08" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(4) Critical Section</strong></p><p name="825b" id="825b" class="graf graf--p graf-after--p">In general, for the previous case, the reader threads should be,</p><pre name="f1e8" id="f1e8" class="graf graf--pre graf-after--p">Condition read_phase, write_phase;<br>int resource_counter = 0;<br>Mutex m;<br>lock(m) {<br>    while(resource_counter == -1) Wait(m, read_phase);<br>    resource_counter++;<br>}<br><strong class="markup--strong markup--pre-strong">// access resource for reading<br>resource.read();</strong><br>lock(m) {<br>    resource_counter--;<br>    if(resource_counter == 0) Signal(write_phase);<br>}</pre><p name="5be5" id="5be5" class="graf graf--p graf-after--pre">And the writer threads should be,</p><pre name="b6ad" id="b6ad" class="graf graf--pre graf-after--p">Condition read_phase, write_phase;<br>int resource_counter = 0;<br>Mutex m;<br>lock(m) {<br>    while(resource_counter != 0) Wait(m, write_phase);<br>    resource_counter = -1;<br>}<br><strong class="markup--strong markup--pre-strong">// access resource for writing<br>resource.write(...)</strong><br>lock(m) {<br>    resource_counter = 0;<br>    Broadcast(read_phase);<br>    Signal(write_phase);<br>}</pre><p name="a60e" id="a60e" class="graf graf--p graf-after--pre">So what are the critical section for the readers and the writer? We have known that the critical section is a code segment where the shared variables can be accessed and the shared resource can be accessed only when we <code class="markup--code markup--p-code">read</code> or <code class="markup--code markup--p-code">write</code> to the shared resource. Therefore, the critical section in the case above is the bolded content of <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">resource.read();</strong></code> and <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">resource.write();</strong></code>.</p><p name="3aa2" id="3aa2" class="graf graf--p graf-after--p">In general, the code segment before the critical section is called the <strong class="markup--strong markup--p-strong">enter critical section</strong> and it is sort of like a lock operation that we have to perform before accessing a resource. The code segment after the critical section is called the <strong class="markup--strong markup--p-strong">exit critical section</strong> and it is also sort of like an unlock operation that we have to perform after accessing a resource.</p><p name="817d" id="817d" class="graf graf--p graf-after--p">The enter critical section has the structure of,</p><pre name="eb9a" id="eb9a" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">// ENTER CRITICAL SECTION </strong><br>Lock(Mutex) {<br>    while(predicator != access_ok) Wait(Mutex, Condition);<br>    predicator = new_state;<br>}</pre><p name="f972" id="f972" class="graf graf--p graf-after--pre">The exit critical section has the structure of,</p><pre name="df39" id="df39" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">// EXIT CRITICAL SECTION</strong><br>Lock(Mutex) {<br>    predicator = updated_state;<br>    Broadcast/Signal(Condition_Wait_Threads);<br>}</pre><p name="50fe" id="50fe" class="graf graf--p graf-after--pre">And the main code segment should be,</p><pre name="fa62" id="fa62" class="graf graf--pre graf-after--p">// ENTER CRITICAL SECTION<br><strong class="markup--strong markup--pre-strong">read/write(shared_file);   // CRITICAL SECTION</strong><br>// EXIT CRITICAL SECTION</pre><p name="54b2" id="54b2" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(5) Tips for Avoiding Common Mistakes of Mutex and Condition Variables</strong></p><ul class="postList"><li name="f54d" id="f54d" class="graf graf--li graf-after--p">Keep track of every mutex or condition variables used with a resource. For example,</li></ul><pre name="60fc" id="60fc" class="graf graf--pre graf-after--li">Mutex m1;  // mutex for file 1</pre><ul class="postList"><li name="9f0d" id="9f0d" class="graf graf--li graf-after--pre">Check that you are always using lock and unlock. Don’t eat one of them. The compiler will always generate some warnings of the half-locked resource.</li><li name="2c23" id="2c23" class="graf graf--li graf-after--li">Use a single mutex for a single resource. For instance, if we use both <code class="markup--code markup--li-code">Mutex m1;</code> and <code class="markup--code markup--li-code">Mutex m2;</code> for the access of the same file. If two threads lock this resource by <code class="markup--code markup--li-code">m1</code> and <code class="markup--code markup--li-code">m2</code>, respectively, then these 2 threads could run concurrently, and these mutexes <code class="markup--code markup--li-code">m1</code> and <code class="markup--code markup--li-code">m2</code> are useless.</li><li name="37fd" id="37fd" class="graf graf--li graf-after--li">Check that you are signaling the correct condition. Using comments when you signal or broadcast any conditions.</li><li name="f1d6" id="f1d6" class="graf graf--li graf-after--li">Check that you are not using a <code class="markup--code markup--li-code">signal</code> when a <code class="markup--code markup--li-code">broadcast</code> is needed. If you are doing so, it is potential that you are going to have deadlocks. However, when you need a <code class="markup--code markup--li-code">signal</code> but instead, you use a <code class="markup--code markup--li-code">broadcast</code>, this can be safe (if you don’t care about the performance). So when you are not sure about which one to use, always use the <code class="markup--code markup--li-code">broadcast</code>.</li></ul><p name="1877" id="1877" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">2. Spurious Wakeups and Deadlocks</strong></p><p name="29f4" id="29f4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Spurious Wakeups</strong></p><p name="7a1c" id="7a1c" class="graf graf--p graf-after--p">The spurious wakeups happen when we wake the threads up (by broadcast or signal) knowing that they may not be able to proceed. For example, suppose we have the following writer,</p><pre name="12f8" id="12f8" class="graf graf--pre graf-after--p">Mutex m;<br>lock(m) {<br>    resource_counter = 0;<br>    Broadcast(read_phase);<br>    // some other things here<br>}</pre><p name="fe38" id="fe38" class="graf graf--p graf-after--pre">And we also have the following reader,</p><pre name="8f3a" id="8f3a" class="graf graf--pre graf-after--p">Wait(m, read_phase);</pre><p name="23c1" id="23c1" class="graf graf--p graf-after--pre">We have known that when the reader receives the <code class="markup--code markup--p-code">read_phase</code> signal, it will be moved from the waiting queue and starts to re-acquire the mutex <code class="markup--code markup--p-code">m</code>. However, in this case, because the writer is not finished (it may have some other operations to execute) and the mutex <code class="markup--code markup--p-code">m</code> is not released by the writer. So even though the reader threads are woken up by the broadcast, they still have to wait for the mutex to release. This is called <strong class="markup--strong markup--p-strong">spurious wakeups </strong>or <strong class="markup--strong markup--p-strong">unnecessary wakeups</strong>.</p><p name="6683" id="6683" class="graf graf--p graf-after--p">However, the spurious wakeups will not impact the correctness of our program. Instead, it will impact the overall performance by wasted cycles for context switching. The spurious wakeups can happen only when we unlock the mutex after the <code class="markup--code markup--p-code">broadcast</code> or <code class="markup--code markup--p-code">signal</code> operations, which means that this pitfall can be eliminated if we first release the mutex (unlock) and then call the <code class="markup--code markup--p-code">broadcast</code> or <code class="markup--code markup--p-code">signal</code>. For instance, we can simply change the program in the previous case to</p><pre name="99c5" id="99c5" class="graf graf--pre graf-after--p">Mutex m;<br>lock(m) {<br>    resource_counter = 0;<br>}  // unlock<br>Broadcast(read_phase);<br>// some other things here</pre><p name="bc7e" id="bc7e" class="graf graf--p graf-after--pre">and then there will be no spurious wakeups.</p><p name="124a" id="124a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Spurious Wakeups Exceptions</strong></p><p name="0587" id="0587" class="graf graf--p graf-after--p">However, there’s also a situation that we can not eliminate the spurious wakeup problems. Let’s see that if we have a <code class="markup--code markup--p-code">broad</code> or a <code class="markup--code markup--p-code">signal</code> call rely on a specific condition of the predicator, we can not release the mutex <code class="markup--code markup--p-code">m</code> because then the value of the predicator can be changed by some other threads. For example,</p><pre name="1936" id="1936" class="graf graf--pre graf-after--p">Mutex m;<br>lock(m) {<br>    resource_counter--;<br>    if(resource_counter == 0) signal(write_phase);<br>}  // unlock</pre><p name="68ba" id="68ba" class="graf graf--p graf-after--pre">This would not be possible if we move the <code class="markup--code markup--p-code">if(resource_counter == 0) signal(write_phase);</code> out of the lock and release the mutex before we run this operation.</p><p name="c236" id="c236" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of Deadlocks</strong></p><p name="0b4b" id="0b4b" class="graf graf--p graf-after--p">One of the scariest problems related to multi-threading is the deadlock. The <strong class="markup--strong markup--p-strong">deadlocks</strong> happen when two or more competing threads are waiting on each other to complete, but none of them ever do. So the execution of the process overall of all these threads is stuck and it can’t continue.</p><p name="9c12" id="9c12" class="graf graf--p graf-after--p">Let’s see <a href="https://www.reddit.com/r/ProgrammerHumor/comments/8387wd/deadlock_explained/" data-href="https://www.reddit.com/r/ProgrammerHumor/comments/8387wd/deadlock_explained/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">a joke</a> about the deadlock. In this joke, the interviewer is waiting for the interviewee to explain the deadlock first, while the interviewee is waiting for the interviewer to hire him/her first. So both of them are waiting for each other to respond and none of them actually do anything. This analogy perfectly describes the situation of a deadlock.</p><figure name="834d" id="834d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*giKcSJ2L0-qMGAAnaLQ7ag.png" data-width="1264" data-height="398" src="https://cdn-images-1.medium.com/max/800/1*giKcSJ2L0-qMGAAnaLQ7ag.png"></figure><p name="08d1" id="08d1" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Deadlock: An Example</strong></p><p name="17ae" id="17ae" class="graf graf--p graf-after--p">Let’s now see an example of the deadlock. Suppose we have got two threads and both of these two threads call a function <code class="markup--code markup--p-code">foo</code> that requires resource <code class="markup--code markup--p-code">A</code> and resource <code class="markup--code markup--p-code">B</code>. In order to call this function, thread 1 first lock the resource <code class="markup--code markup--p-code">A</code> , and then the resource <code class="markup--code markup--p-code">B</code>. However, thread 2 first lock the resource <code class="markup--code markup--p-code">B</code> , and then the resource <code class="markup--code markup--p-code">A</code>. So this will be,</p><pre name="e107" id="e107" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">/* T1 */                        /* T2 */</strong><br>// do something                 // do something<br>lock(mutex_A) {                 lock(mutex_B) {<br>    // do something                  // do something<br>    lock(mutex_B) {                  lock(mutex_A) {<br>        // do something                   // do something<br>        foo(A, B);                        foo(B, A);<br>    }                                }<br>}                               }</pre><p name="3c76" id="3c76" class="graf graf--p graf-after--pre">When thread 1 locks <code class="markup--code markup--p-code">mutex_B</code>, it may be blocked because thread 2 might lock this the <code class="markup--code markup--p-code">mutex_B</code> before. In addition, when thread 2 locks <code class="markup--code markup--p-code">mutex_A</code>, it may be blocked because thread 1 might lock this the <code class="markup--code markup--p-code">mutex_A</code> before. If both of the situations happen, thread 1 will be waiting for thread 2 to release the <code class="markup--code markup--p-code">mutex_B</code> , while thread 2 will be waiting for thread 1 to release the <code class="markup--code markup--p-code">mutex_A</code>. You can see here is a deadlock!</p><p name="f959" id="f959" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Deadlock Solution 1: Fine-Grained Locking</strong></p><p name="93d1" id="93d1" class="graf graf--p graf-after--p">The simplest idea to deal with a deadlock is that can release some mutex so there will not be any deadlocks. For example, for the following code, we can discover that the <code class="markup--code markup--p-code">lock(mutex_B)</code> is not necessary for the function call <code class="markup--code markup--p-code">foo2</code> so we can simply release this lock. This is called <strong class="markup--strong markup--p-strong">fine-grained locking</strong>.</p><pre name="f010" id="f010" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">/* T1 */                        /* T2 */</strong><br>// do something                 // do something<br>lock(mutex_A) {                 lock(mutex_B) {<br>    // do something                  // do something<br>    lock(mutex_B) {                  lock(mutex_A) {<br>        // do something                   // do something<br>        foo(A, B);                        foo2(A);<br>    }                                }<br>}                               }</pre><p name="8f6d" id="8f6d" class="graf graf--p graf-after--pre">Then after the fine-grained locking,</p><pre name="1fcc" id="1fcc" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">/* T1 */                        /* T2 */</strong><br>// do something                 // do something<br>lock(mutex_A) {                 lock(mutex_B) {<br>    // do something                  // do something<br>    lock(mutex_B) {             }<br>        // do something         lock(mutex_A) {<br>        foo(A, B);                   // do something<br>    }                                foo2(A);<br>}                               }</pre><p name="9647" id="9647" class="graf graf--p graf-after--pre">However, our case is different because we need the resource <code class="markup--code markup--p-code">A</code> and <code class="markup--code markup--p-code">B</code> both in thread 2. Thus, the fine-grained locking will not be useful.</p><p name="b716" id="b716" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Deadlock Solution 2: Mega Locking</strong></p><p name="4c69" id="4c69" class="graf graf--p graf-after--p">Another idea is that we can lock both <code class="markup--code markup--p-code">A</code> and <code class="markup--code markup--p-code">B</code> at the same time, and this is called a <strong class="markup--strong markup--p-strong">mega lock</strong>. To implement this, we can replace <code class="markup--code markup--p-code">mutex_A</code> and <code class="markup--code markup--p-code">mutex_B</code> with a mega mutex <code class="markup--code markup--p-code">mutex_AB</code>. After mega locking, the program will then be,</p><pre name="9a2c" id="9a2c" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">/* T1 */                        /* T2 */</strong><br>// do something                 // do something<br>lock(mutex_AB) {                lock(mutex_AB) {<br>    // do something                  // do something<br>    foo(A, B);                       foo(B, A);<br>}                               }</pre><p name="e4a4" id="e4a4" class="graf graf--p graf-after--pre">Then in this application, the deadlock can be dealt with perfectly. However, for some other applications, we may create some mutex that can be too restrictive (i.e. <code class="markup--code markup--p-code">mutex_ABCDEFG…</code>) and this limits the parallelism and reduces the performance of the system.</p><p name="3368" id="3368" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Deadlock Solution 3: Maintaining the Locking Order</strong></p><p name="72c4" id="72c4" class="graf graf--p graf-after--p">There is another solution that is widely used. In this solution, we just need to maintain the order of the mutex for each thread. For example, if we restrict that all the threads must lock <code class="markup--code markup--p-code">mutex_A</code> before they call <code class="markup--code markup--p-code">mutex_B</code>, then the program will be,</p><pre name="446d" id="446d" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">/* T1 */                        /* T2 */</strong><br>// do something                 // do something<br>lock(mutex_A) {                 lock(mutex_A) {<br>    // do something                  // do something<br>    lock(mutex_B) {             }<br>        // do something         lock(mutex_B) {<br>        foo(A, B);                   // do something<br>    }                                foo2(A);<br>}                               }</pre><p name="3548" id="3548" class="graf graf--p graf-after--pre">After this solution, there will be no potential deadlocks in this program.</p><p name="3b18" id="3b18" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Deal with the Real Deadlocks</strong></p><p name="fc44" id="fc44" class="graf graf--p graf-after--p">Note that we have talked that we can <strong class="markup--strong markup--p-strong">prevent deadlocks</strong> by locking order, mega locking, etc. But these methods can be quite <strong class="markup--strong markup--p-strong">expensive</strong> for the performance.</p><p name="e44c" id="e44c" class="graf graf--p graf-after--p">We can also do <strong class="markup--strong markup--p-strong">deadlock detection and recovery</strong>. But this requires us to design a <strong class="markup--strong markup--p-strong">rollback</strong> mechanism which can also be costly.</p><p name="d6da" id="d6da" class="graf graf--p graf-after--p graf--trailing">In reality, we will actually apply the <strong class="markup--strong markup--p-strong">Ostrich Algorithm</strong>! In computer science, the ostrich algorithm is a strategy of ignoring potential problems on the basis that they may be exceedingly rare. We just take an optimistic view that the deadlock can be rare and it not happens to me and then we hide our head in the sand just like an ostrich. So what if we have a real-time deadlock problem? Just reboot the machine! Remember that rebooting is our best friend of debugging.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/6e28ab161002"><time class="dt-published" datetime="2021-01-31T07:38:02.520Z">January 31, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-6-thread-part-2-reader-writer-problem-spurious-wakeups-and-deadlocks-6e28ab161002" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>