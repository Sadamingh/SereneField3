<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Operating System 22 | Introduction of Virtualization, Virtualization Models, Hardware Protection…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Operating System 22 | Introduction of Virtualization, Virtualization Models, Hardware Protection…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Operating System
</section>
<section data-field="body" class="e-content">
<section name="908a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d962" id="d962" class="graf graf--h3 graf--leading graf--title">Operating System 22 | <strong class="markup--strong markup--h3-strong">Introduction of Virtualization, Virtualization Models, Hardware Protection, Processor Virtualization, Memory Virtualization, and Device Virtualization</strong></h3><figure name="2f98" id="2f98" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*nfumnaNf5DlFyT_P.png" data-width="1508" data-height="794" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*nfumnaNf5DlFyT_P.png"></figure><ol class="postList"><li name="5428" id="5428" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Introduction of Virtualization</strong></li></ol><p name="551e" id="551e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) History of Virtualization</strong></p><p name="b8b5" id="b8b5" class="graf graf--p graf-after--p">Virtualization is an old idea. It originated in the 60s at IBM when the norm of computing was that there were a few large mainframe computers that were shared by many users and many business services. In order to concurrently run very diverse workloads on the same physical hardware, without requiring that a single operating system be used for all of the o- applications for all of the possible purposes, it was necessary to come up with a model where multiple operating systems can concurrently be deployed on the same hardware platform.</p><p name="1a48" id="1a48" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Virtual Resources</strong></p><p name="c237" id="c237" class="graf graf--p graf-after--p">With virtualization, each of the operating systems that are deployed on the same physical platform has an <strong class="markup--strong markup--p-strong">illusion</strong> that it actually owns the underlying hardware resources. Or at least some smaller portion of them. Therefore, each OS thinks that it owns the hardware resources, and these resources are called the <strong class="markup--strong markup--p-strong">virtual resources</strong>.</p><p name="817f" id="817f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of Virtual Machine</strong></p><p name="81c5" id="81c5" class="graf graf--p graf-after--p">Each operating system together with its applications as well as the virtual resources that it pings at us is called a <strong class="markup--strong markup--p-strong">virtual machine</strong>, or <strong class="markup--strong markup--p-strong">VM</strong> for short. This represents a virtual machine because it is distinct from the physical machine that is natively managed by some software stack. Virtual machines are often referred to as guests such as <strong class="markup--strong markup--p-strong">guest VMs</strong> or also referred to as <strong class="markup--strong markup--p-strong">domains</strong>.</p><p name="269d" id="269d" class="graf graf--p graf-after--p">Classically, in Popek and Goldberg’s <a href="https://s3.amazonaws.com/content.udacity-data.com/courses/ud923/references/ud923-popek-goldberg-paper.pdf" data-href="https://s3.amazonaws.com/content.udacity-data.com/courses/ud923/references/ud923-popek-goldberg-paper.pdf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">paper</a>, the <strong class="markup--strong markup--p-strong">virtual machine</strong> is taken to be an <strong class="markup--strong markup--p-strong">efficient</strong>, <strong class="markup--strong markup--p-strong">isolated</strong>, <strong class="markup--strong markup--p-strong">duplicate</strong> of the real machine, which is supported by a <strong class="markup--strong markup--p-strong">virtual machine monitor</strong> (<strong class="markup--strong markup--p-strong">VMM</strong>). The VMM is actually the layer that enables VMs to exist.</p><p name="9d36" id="9d36" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Characteristics for VMM</strong></p><p name="67f9" id="67f9" class="graf graf--p graf-after--p">As a piece of the software, the virtual machine monitor has three essential characteristics,</p><ul class="postList"><li name="ae40" id="ae40" class="graf graf--li graf-after--p">It provides an environment that is <strong class="markup--strong markup--li-strong">essentially identical</strong> to the original machine. This means that the VMM must provide some <strong class="markup--strong markup--li-strong">fidelity</strong> that the representation of the hardware visible to the VM matches the hardware that’s available on the physical platform</li><li name="ab7e" id="ab7e" class="graf graf--li graf-after--li">Programs show at worse only <strong class="markup--strong markup--li-strong">minor decrease in speed</strong>. The idea is that if the VM is given the exact amount of resources as the physical machine, then the OS and the processes would be able to perform at the same speeds. Therefore, the <strong class="markup--strong markup--li-strong">performance</strong> of the VMs should be as close as the physical machine.</li><li name="39a5" id="39a5" class="graf graf--li graf-after--li">VMM is in <strong class="markup--strong markup--li-strong">complete control of the system resources</strong>. This means that the VMM has full control to make any decisions. This doesn&#39;t mean that every single piece of hardware has to be inspected by the VMM, but VMM determines if a particular VM is to be given direct hardware access. Once those decisions are put in place, a virtual machine can not just change those policies. So another goal for the VMM is that it needs to provide safety and isolation guarantees.</li></ul><p name="ffc1" id="ffc1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Reasons for Virtualization</strong></p><p name="aaea" id="aaea" class="graf graf--p graf-after--p">There are actually some reasons for doing virtualization,</p><ul class="postList"><li name="bd70" id="bd70" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">consolidation</strong>: enables to run multiple operating systems on a single physical platform. It decreases costs and improves manageability.</li><li name="9b2d" id="9b2d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">migration</strong>: once the OS in its applications is nicely encapsulated, it can be easy to migrate the OS and the applications from one machine to another. This provides us the availability of the system, and it also provides solutions that improve the reliability.</li><li name="b66c" id="b66c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">other reasons</strong>: there are some other benefits for doing virtualization, like <strong class="markup--strong markup--li-strong">security</strong>, <strong class="markup--strong markup--li-strong">debugging</strong>, support for <strong class="markup--strong markup--li-strong">legacy OSs</strong>, and so on.</li></ul><p name="4c2f" id="4c2f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">2. Virtualization Models</strong></p><p name="ed26" id="ed26" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Two Types of Virtualization Models</strong></p><p name="0f6e" id="0f6e" class="graf graf--p graf-after--p">Before describing the technical requirements for virtualization, let’s take a look at the two main Virtualization models. The two popular models for virtualization are called <strong class="markup--strong markup--p-strong">bare-metal</strong> (aka. <strong class="markup--strong markup--p-strong">hypervisor-based</strong>) <strong class="markup--strong markup--p-strong">model</strong> and <strong class="markup--strong markup--p-strong">hosted model</strong>. They are also often referred to as <strong class="markup--strong markup--p-strong">type 1</strong> for the hypervisor-based model and <strong class="markup--strong markup--p-strong">type 2</strong> for the hosted model for virtualization solutions.</p><p name="0c70" id="0c70" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Bare-Metal Virtualization (BMV)</strong></p><p name="2816" id="2816" class="graf graf--p graf-after--p">In the bare-metal model, a <strong class="markup--strong markup--p-strong">VMM</strong> (or called the <strong class="markup--strong markup--p-strong">hypervisor</strong>) is responsible for the management of the physical resources, and it supports the execution of the entire virtual machine.</p><figure name="f262" id="f262" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5A3pBxdVNKN7Kb1q63ANDA.png" data-width="1514" data-height="234" src="https://cdn-images-1.medium.com/max/800/1*5A3pBxdVNKN7Kb1q63ANDA.png"></figure><p name="2b66" id="2b66" class="graf graf--p graf-after--figure">But this model has an issue with the device drivers. According to the model, the hypervisor must manage all possible devices, or stated differently, device manufacture now have to provide device drivers not just for the different operating systems, but also for the different types of hypervisors. This can be wasteful in practice.</p><figure name="dd05" id="dd05" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qmMgosrXMGwr1cP6-iUS0w.png" data-width="1514" data-height="544" src="https://cdn-images-1.medium.com/max/800/1*qmMgosrXMGwr1cP6-iUS0w.png"></figure><p name="aa62" id="aa62" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) Service VM</strong></p><p name="9d7b" id="9d7b" class="graf graf--p graf-after--p">To eliminate this issue, the hypervisor model typically integrates a special virtual machine called <strong class="markup--strong markup--p-strong">service VM</strong> that runs a standard operating system and has full hardware privileges to access and perform any kind of hardware manipulation.</p><p name="0743" id="0743" class="graf graf--p graf-after--p">The privilege VM would,</p><ul class="postList"><li name="530c" id="530c" class="graf graf--li graf-after--p">run all of the device drivers</li><li name="b35b" id="b35b" class="graf graf--li graf-after--li">have control over how the devices on the platform are used</li><li name="8dd3" id="8dd3" class="graf graf--li graf-after--li">run some other management tasks (e.g. how hypervisor allocate resources across VMs)</li><li name="dbbf" id="dbbf" class="graf graf--li graf-after--li">run some other configuration tasks</li></ul><figure name="e050" id="e050" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*n0OPMAAGamp2mQy_12sgSA.png" data-width="1514" data-height="848" src="https://cdn-images-1.medium.com/max/800/1*n0OPMAAGamp2mQy_12sgSA.png"></figure><p name="69ba" id="69ba" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Bare-Metal Virtualization Example #1: Xen</strong></p><p name="4d04" id="4d04" class="graf graf--p graf-after--p">For both the open-source version and the version that’s supported by Citrix, VMs that are run in the virtualized Xen environment are referred to as <strong class="markup--strong markup--p-strong">domains</strong>. The organization of Xen is,</p><ul class="postList"><li name="5075" id="5075" class="graf graf--li graf-after--p">domains: VMs</li><li name="8e61" id="8e61" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">dom0</code>: privileged domain, or service VM</li><li name="3527" id="3527" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">domU</code>: guest VMs</li><li name="ab9e" id="ab9e" class="graf graf--li graf-after--li">Xen: VMM or hypervisor</li></ul><figure name="101c" id="101c" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*35sYz4t3Rnlf3lUHDrm6JA.png" data-width="1514" data-height="848" src="https://cdn-images-1.medium.com/max/800/1*35sYz4t3Rnlf3lUHDrm6JA.png"></figure><p name="13b6" id="13b6" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Bare-Metal Virtualization Example #2: VMware ESX</strong></p><p name="e06e" id="e06e" class="graf graf--p graf-after--p">Given that VMware and its hypervisors were first to market, VMware still owns the largest percentage of virtualized server cores.</p><p name="53d6" id="53d6" class="graf graf--p graf-after--p">For historical reasons, VMware is using an older model with all the drivers become part of the hypervisor. However, this is possible because of two reasons. Firstly, VMWare is mandated by the vendors so that they do provide the drivers for the different devices. Secondly, this is not as bad because VMware really targeting the server, and there will not be as many devices like the PC market.</p><p name="869c" id="869c" class="graf graf--p graf-after--p">To support a third-party community of developers, VMware actually also exports a number of APIs. And in the past, the ESX architecture was such that there was a control core based on Linux. But right now, all of the configuration-related tasks are configured via <strong class="markup--strong markup--p-strong">remote APIs</strong>.</p><figure name="7998" id="7998" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jrnE1TbR-LVf0f7eWWxkeg.png" data-width="1514" data-height="848" src="https://cdn-images-1.medium.com/max/800/1*jrnE1TbR-LVf0f7eWWxkeg.png"></figure><p name="cfee" id="cfee" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) Hosted Virtualization Model</strong></p><p name="9a1a" id="9a1a" class="graf graf--p graf-after--p">The main difference between the bared-metal model and the hosted model is that, at the lowest level of the hosted model, there is a <strong class="markup--strong markup--p-strong">full-fledged host OS</strong> that manages all of the hardware resources.</p><p name="82e5" id="82e5" class="graf graf--p graf-after--p">The Host OS integrates a <strong class="markup--strong markup--p-strong">VMM module</strong> that is responsible for providing the virtual machines with their virtual platform interface and for managing all of the context switching scheduling, etc. In addition, this VMM module will invoke <strong class="markup--strong markup--p-strong">drivers </strong>or other components of the host operating system as needed.</p><p name="ac91" id="ac91" class="graf graf--p graf-after--p">There are several benefits of this model,</p><ul class="postList"><li name="44c5" id="44c5" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Less </strong>functionality needs to be <strong class="markup--strong markup--li-strong">redeveloped</strong> for the VMM module because it can leverage all of the services and mechanisms that are already developed for the host OS.</li><li name="cf90" id="cf90" class="graf graf--li graf-after--li">We can run guest VMs and <strong class="markup--strong markup--li-strong">native applications</strong> directly on the host operating system simultaneously.</li></ul><figure name="acb6" id="acb6" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*5-kzBTxcW6DVMGSE52MG_Q.png" data-width="1514" data-height="532" src="https://cdn-images-1.medium.com/max/800/1*5-kzBTxcW6DVMGSE52MG_Q.png"></figure><p name="85bd" id="85bd" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(7) Hosted Virtualization Example: KVM</strong></p><p name="0f08" id="0f08" class="graf graf--p graf-after--p">One example of the Hosted model is <strong class="markup--strong markup--p-strong">KVM</strong>, which stands for <strong class="markup--strong markup--p-strong">kernel-based VM</strong>, and this is based on the Linux OS. The support for running guest VMs is through a combination of the KVM module and a hardware emulator called <strong class="markup--strong markup--p-strong">QEMU</strong>, which is used as a virtualizer to provide identical hardware simulations like X86 Intel or AMD. This is because the intent of virtualization is to provide identical hardware, but it may be impossible for us to find the exact same hardware.</p><figure name="5161" id="5161" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Kl33zcajrKgfAVejb7pBUw.png" data-width="1514" data-height="630" src="https://cdn-images-1.medium.com/max/800/1*Kl33zcajrKgfAVejb7pBUw.png"></figure><p name="bb6c" id="bb6c" class="graf graf--p graf-after--figure">A huge benefit for KVM has been that it’s able to really leverage all of the advances that are continuously being contributed to the large Linux open-source community. Because of this KVM can quickly adapt to new hardware features, new devices, new security, bugs, or similar things.</p><p name="dc5c" id="dc5c" class="graf graf--p graf-after--p">In fact, the KVM Module was originally developed as a Linux module in order to allow regular use of Linux applications to take advantage of some of the virtualization-related hardware that started appearing in commodity platforms. All of the sudden, users realized that this can be useful to actually run guest VMs. And so three months later, KVM was an actual virtualization solution that was part of the mainstream Linux kernel.</p><p name="3c76" id="3c76" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Hardware Protection</strong></p><p name="2921" id="2921" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Protection Levels for x86 Architecture</strong></p><p name="0ae1" id="0ae1" class="graf graf--p graf-after--p">It is fortunate to observe that commodity hardware actually has more than two protection levels. Looking at the x86 architecture, there are 4 protection levels called <strong class="markup--strong markup--p-strong">rings</strong>.</p><ul class="postList"><li name="9c64" id="9c64" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Ring 0 (OS)</strong>: it has the <strong class="markup--strong markup--li-strong">highest privilege</strong> and can access all of the resources and execute all hardware-supported instructions, so this is where the OS would reside.</li><li name="bebd" id="bebd" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Ring 3 (Apps)</strong>: it has the <strong class="markup--strong markup--li-strong">lowest level of privilege</strong>, so this is where the applications would reside.</li></ul><figure name="88bf" id="88bf" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*xZTUsr_CSvG7afqW5cwVSg.png" data-width="1514" data-height="524" src="https://cdn-images-1.medium.com/max/800/1*xZTUsr_CSvG7afqW5cwVSg.png"></figure><p name="e841" id="e841" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(2) Protection Levels for Virtualization</strong></p><p name="e766" id="e766" class="graf graf--p graf-after--p">One way in which these protection levels can be used is to put the hypervisor now in ring 0, so that’s the one that has full control over the hardware, to leave the applications to execute at ring 3 level, and then the operating system would execute at ring 1 level.</p><figure name="3696" id="3696" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*1hIzKncp3PiF526J5s-5sw.png" data-width="1514" data-height="524" src="https://cdn-images-1.medium.com/max/800/1*1hIzKncp3PiF526J5s-5sw.png"></figure><p name="a8c8" id="a8c8" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(3) Protection Modes for x86 Architecture</strong></p><p name="43fb" id="43fb" class="graf graf--p graf-after--p">More recent x86 architectures also introduce two different protection modes called the <strong class="markup--strong markup--p-strong">root mode</strong> and the <strong class="markup--strong markup--p-strong">non-root mode</strong>. Within each of these modes, the four protection levels exist, so there are two times these protection rings.</p><ul class="postList"><li name="7a62" id="7a62" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Root Mode</strong>: the <strong class="markup--strong markup--li-strong">highest privileged mode</strong> with all of the operations are permitted, all hardware is accessible, all instructions can be executed.</li><li name="70af" id="70af" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Non-root Mode</strong>: many operations will request root permissions</li></ul><p name="a514" id="a514" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Protection Modes for Virtualization</strong></p><p name="9320" id="9320" class="graf graf--p graf-after--p">The ring 0 of the root mode is where we would run the hypervisor. In contrast, in non-root mode, because certain types of operations are not permitted, the guest VMs would execute in this non-root mode. Therefore, their applications will be running in ring 3 and their operating systems will be running at ring 0 privilege level in the non-root mode.</p><figure name="23c7" id="23c7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_QyxYFkaZmySbRmPmtGp8w.png" data-width="1570" data-height="1092" src="https://cdn-images-1.medium.com/max/800/1*_QyxYFkaZmySbRmPmtGp8w.png"></figure><p name="0fdc" id="0fdc" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Root-Non-Root Crossing: VMexits and VMentry</strong></p><p name="7d3e" id="7d3e" class="graf graf--p graf-after--p">Sometimes the guest OS needs to perform some privileged operations, then we should pass the operation across the root-non-root boundary. Attempts by the guest OS to perform privileged operations are called <strong class="markup--strong markup--p-strong">VMexits</strong>. And these trigger a switch to this root mode and pass control to the hypervisor.</p><p name="238a" id="238a" class="graf graf--p graf-after--p">When the hypervisor completes its operation, it passes control back to the virtual machine by performing a <strong class="markup--strong markup--p-strong">VMentry</strong> which switches the mode into non-root mode, to ring 0, so that the execution continues.</p><figure name="3e3c" id="3e3c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Fd3FIh4JPga6vJvCBGwerg.png" data-width="1570" data-height="1092" src="https://cdn-images-1.medium.com/max/800/1*Fd3FIh4JPga6vJvCBGwerg.png"></figure><p name="375e" id="375e" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">4. Processor (CPU) Virtualization</strong></p><p name="2a22" id="2a22" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Trap-and-Emulate Technique</strong></p><p name="05ba" id="05ba" class="graf graf--p graf-after--p">So now, let’s discuss what will happen when the guest OS starts executing the instructions.</p><p name="618f" id="618f" class="graf graf--p graf-after--p">We may have a question now. Could the guest instructions directly executed by the hardware concerning the protection issues? The answer to this question is yes, and the guest’s <strong class="markup--strong markup--p-strong">non-privileged instructions</strong> executed <strong class="markup--strong markup--p-strong">directly</strong> by the hardware. The VMM doesn’t interfere with every single instruction that is issued by the guest OS because one goal of the VM is efficiency and we want to achieve <strong class="markup--strong markup--p-strong">hardware speed</strong>. As long as the guest operating system and its applications operate within the resources that were allocated to them by the hypervisor, then everything is <strong class="markup--strong markup--p-strong">safe</strong>.</p><p name="3e0f" id="3e0f" class="graf graf--p graf-after--p">However, when we issue privileged instructions, things are quite different because the hypervisor should be involved for protecting the system. Whenever a privileged instruction gets accessed, then the processor causes a trap, and control is automatically switched to the most privileged hypervisor. At this point, the hypervisor can determine whether the operation is,</p><ul class="postList"><li name="a8b1" id="a8b1" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">illegal</strong>: if it shouldn’t be allowed, then the hypervisor can perform some action, for example, to terminate the VM</li><li name="56b8" id="56b8" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">legal</strong>: if it is allowed the hypervisor should perform the <strong class="markup--strong markup--li-strong">necessary emulation</strong> so that the guest operating system is under the impression that it actually does have control over the hardware. So from the guest&#39;s perspective, it should seem as if the hardware did exactly what it was expected to do given the instruction.</li></ul><p name="5cbd" id="5cbd" class="graf graf--p graf-after--li">This <strong class="markup--strong markup--p-strong">trap-and-emulate mechanism</strong> is a key method on which virtualization solutions rely in order to achieve efficient CPU virtualization.</p><figure name="1ac2" id="1ac2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BypeXXJP-uyEV4Nzd9itGg.png" data-width="1368" data-height="298" src="https://cdn-images-1.medium.com/max/800/1*BypeXXJP-uyEV4Nzd9itGg.png"></figure><p name="9c1f" id="9c1f" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(2) Problem for</strong> <strong class="markup--strong markup--p-strong">Trap-and-Emulate Technique</strong></p><p name="dcd9" id="dcd9" class="graf graf--p graf-after--p">Now, the trap-and-emulate technique seems good and beautiful for simulating processors for the guest VMs. However, in the 90s, the need to reapply virtualization solutions to the prevalent x86 architecture came up. And it turned out that there were certain problems with this model.</p><p name="a698" id="a698" class="graf graf--p graf-after--p">At the time, x86 platforms had just <strong class="markup--strong markup--p-strong">4 rings</strong>. There wasn’t any support for root or non-root mode. And so the way to virtualize them would be to run the hypervisor in ring 0 and the guest OS in ring 1. It turned out that there were exactly 17 privileged instructions (expected illegal when issuing from ring 1, and expected legal when issuing from ring 0, e.g. POPF/PUSHF instructions) that did not cause traps if they were called from the ring 1 protection level or above. When these instructions are issued from ring 1 in the pre-2005 architecture, they just fail and the instructions pipeline is allowed to continue to the next instruction.</p><p name="32d0" id="32d0" class="graf graf--p graf-after--p">The problem with the situation that there is <strong class="markup--strong markup--p-strong">no trap </strong>because<strong class="markup--strong markup--p-strong"> </strong>most real-world instruction sets, including x86, were not designed with virtualization in mind. As a result, there are privileged instructions that do not have any corresponding trap facility. So the control isn’t passed to the hypervisor, and the hypervisor has no idea that the OS wanted to change the interrupt status. Then the hypervisor will not do anything to change these settings.</p><p name="2882" id="2882" class="graf graf--p graf-after--p">At the same time, because the failure of the instruction was silent, the operating system, the guest OS doesn’t know that anything wrong happened. So the OS will continue its execution, assuming that correctly the interrupts were enabled or disabled as intended, which will result in a corrupt state or in a deadlock state. So clearly this is a major problem and makes this trap-and-emulate approach not applicable for this architecture.</p><p name="835b" id="835b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) History of the Binary Translation Technique</strong></p><p name="f6d9" id="f6d9" class="graf graf--p graf-after--p">One way to deal with the no trap problem is called binary translation. It is pioneered by professor <a href="https://profiles.stanford.edu/mendel-rosenblum" data-href="https://profiles.stanford.edu/mendel-rosenblum" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Mendel Rosenblum</a> at Stanford, and then this project is commercialized as VMware. VMware still owns by far the largest share of the virtualized cores in the server market.</p><p name="9d45" id="9d45" class="graf graf--p graf-after--p">Rosenblum later received the ACM Fellow reward, and in the recognition, he was specifically credited for reinventing virtualization. He served as VMware’s chief scientist for about ten years and now is back full time at Stanford.</p><p name="3be5" id="3be5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Binary Translation Technique</strong></p><p name="ce93" id="ce93" class="graf graf--p graf-after--p">The main idea of the binary translation is not difficult. Instead of depending on the processor itself to detect the privileged instructions and pass control over to the hypervisor or host, virtualization software inspects the instruction stream in <strong class="markup--strong markup--p-strong">software</strong>. When the software detects that we are issuing one of the 17 instructions, then the binary code of this instruction will be <strong class="markup--strong markup--p-strong">rewritten </strong>(or so-called <strong class="markup--strong markup--p-strong">translated</strong>) to some other codes. This translation should be done in a <strong class="markup--strong markup--p-strong">dynamic</strong> way because we may need some parameters when doing the translation. So a formal binary translation should have the following steps,</p><ul class="postList"><li name="67f7" id="67f7" class="graf graf--li graf-after--p">The software will <strong class="markup--strong markup--li-strong">inspect</strong> the code blocks to be executed to see whether we have one of 17 privileged instructions</li><li name="2616" id="2616" class="graf graf--li graf-after--li">If the instruction is <strong class="markup--strong markup--li-strong">safe </strong>(means that it is not one of 17 privileged instructions), then it is allowed to execute at <strong class="markup--strong markup--li-strong">hardware speeds</strong></li><li name="8e89" id="8e89" class="graf graf--li graf-after--li">If the instruction is one of the 17 <strong class="markup--strong markup--li-strong">privileged</strong> instructions, then the binary code of this instruction will be translated to some other instructions that avoid the undesired instructions, but in some way, <strong class="markup--strong markup--li-strong">emulates the desired behavior</strong>. This can possibly be achieved even by bypassing a trap to the hypervisor.</li></ul><figure name="64c6" id="64c6" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*k8yxrn5J1m0On_jY6yCmpQ.png" data-width="1368" data-height="452" src="https://cdn-images-1.medium.com/max/800/1*k8yxrn5J1m0On_jY6yCmpQ.png"></figure><p name="f068" id="f068" class="graf graf--p graf-after--figure">Certainly, binary translation adds <strong class="markup--strong markup--p-strong">overheads</strong> and the number of mechanisms is incorporated specifically in VMware’s solution for improving the efficiency of the process. These techniques include,</p><ul class="postList"><li name="36ac" id="36ac" class="graf graf--li graf-after--p">caching code fragments</li><li name="0cf8" id="0cf8" class="graf graf--li graf-after--li">distinguish binary for instruction code</li><li name="31c4" id="31c4" class="graf graf--li graf-after--li">etc.</li></ul><p name="a6f1" id="a6f1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Full Virtualization Vs. Paravirtualization</strong></p><p name="eaa2" id="eaa2" class="graf graf--p graf-after--p">We have discussed that what we want for an ideal VM is that we want to have exactly the same copy of the guest OS and nothing needs to be modified so that the guest OS does not know that it is running on a virtual machine. This is called <strong class="markup--strong markup--p-strong">full virtualization</strong>.</p><p name="3cca" id="3cca" class="graf graf--p graf-after--p">However, a totally different idea is to give up on the goal of running unmodified operating systems. Instead, the primary goal is to offer a virtualization solution that offers performance and <strong class="markup--strong markup--p-strong">avoids some of the overheads</strong> that may be associated with any of the complexities that are necessary to support unmodified guests. In contrast to full virtualization, this is called <strong class="markup--strong markup--p-strong">paravirtualization</strong>.</p><p name="4431" id="4431" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Hypercall Approach</strong></p><p name="f4e8" id="f4e8" class="graf graf--p graf-after--p">With paravirtualization, the guest OS is modified so that it now knows that it’s running in a virtualized environment on top of a hypervisor as opposed to on top of native physical resources. A para-virtualized guest OS will not necessarily try to directly perform operations, which it knows that they will fail. And instead, it will make explicit calls to the hypervisor to request the desired behavior. These calls to the hypervisor are called <strong class="markup--strong markup--p-strong">hypercalls</strong>, which behave in a way like the system calls. So we have the following steps of making a hypercall,</p><ul class="postList"><li name="44d6" id="44d6" class="graf graf--li graf-after--p">package the context info</li><li name="eb31" id="eb31" class="graf graf--li graf-after--li">specify the desired hypercall</li><li name="bd43" id="bd43" class="graf graf--li graf-after--li">trap to VMM</li></ul><p name="e76d" id="e76d" class="graf graf--p graf-after--li">This approach of paravirtualization was originally adapted and popularized by the <strong class="markup--strong markup--p-strong">Xen hypervisor</strong>. And it was a popular virtualization solution and originally was an open-source hypervisor that started as a research project at the University of Cambridge in the UK. This was later commercialized as XenSource and XenSource is now owned by Citrix. But there still remains a lot of activity in the open-source Xen project.</p><p name="d5e3" id="d5e3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">5. Memory Virtualization</strong></p><p name="1ee4" id="1ee4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Virtual Address Vs. Physical Address Vs. Machine Address</strong></p><p name="abd2" id="abd2" class="graf graf--p graf-after--p">In the discussion of the previous sections, we have discussed the difference between the virtual address and the physical address. The <strong class="markup--strong markup--p-strong">virtual address</strong> space is the address space that can be viewed by the applications and the physical address space is the real address space the OS manipulates.</p><p name="15d4" id="15d4" class="graf graf--p graf-after--p">However, when we have virtualization, the <strong class="markup--strong markup--p-strong">physical address</strong> space viewed by the guest OS will not be the same as the real address. Instead, these will be the ones that the guest OS thinks are addresses of the physical resources. The <strong class="markup--strong markup--p-strong">machine addresses</strong> will then become the name of the actual addresses on the machine on the underlying platform.</p><p name="9afa" id="9afa" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Full Memory Virtualization</strong></p><p name="600b" id="600b" class="graf graf--p graf-after--p">The full memory virtualization means that all the guest VMs expect they have their own contiguous physical memory starting at the address 0. Note that at the hardware level, we have a number of the memory management units like MMU or TLB, and these can still help with the address translation process.</p><p name="619b" id="619b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Full Memory Virtualization Option #1: Direct Translation</strong></p><p name="4720" id="4720" class="graf graf--p graf-after--p">The simplest idea is that we can do two translations to find the machine address. One is the traditional V2P translation supported by the guest’s page tables, the other is a P2M (physical to machine) translation supported by the hypervisor.</p><p name="e517" id="e517" class="graf graf--p graf-after--p">However, clearly, this option is going to be too <strong class="markup--strong markup--p-strong">expensive</strong> since it adds overheads on every single memory reference, and it will <strong class="markup--strong markup--p-strong">slow</strong> down the ability to run at near-native hardware speeds.</p><figure name="f25c" id="f25c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vemCPzaHs2teDQtE8i0gaw.png" data-width="1368" data-height="686" src="https://cdn-images-1.medium.com/max/800/1*vemCPzaHs2teDQtE8i0gaw.png"></figure><p name="296f" id="296f" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Full Memory Virtualization Option #2: Shadow Page Table</strong></p><p name="fbec" id="fbec" class="graf graf--p graf-after--p">One way to improve the previous model is that the hypervisor can maintain a <strong class="markup--strong markup--p-strong">shadow page table</strong>, in which it actually looks at what are the virtual addresses the guests have mapped to these physical addresses, and then in the shadow page table, it directly establishes a mapping between the VAs that are used by the guest and the MAs that are used by the hypervisor. If the MMU is using this shadow PT, then we can do directly V2M translations.</p><p name="c18d" id="c18d" class="graf graf--p graf-after--p">Whenever the guest OS tries to install new V2P address mapping in the PTs used by the guest, this will cause a <strong class="markup--strong markup--p-strong">trap</strong> to the hypervisor. Then the hypervisor will be able to pick up that VA, and then associate the corresponding machine address, and insert this mapping into the shadow PT used by the hardware MMU. This can be done completely <strong class="markup--strong markup--p-strong">transparently</strong> to guest OS.</p><figure name="eab5" id="eab5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Jo48Imt20yBfLHHAKnAn0w.png" data-width="1368" data-height="678" src="https://cdn-images-1.medium.com/max/800/1*Jo48Imt20yBfLHHAKnAn0w.png"></figure><p name="3cb9" id="3cb9" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Memory Paravirtualized Virtualization</strong></p><p name="784c" id="784c" class="graf graf--p graf-after--p">In para-virtualized systems, the operating system knows that it’s executing in a virtualized environment. So the physical addresses the guest would like to use has the following features,</p><ul class="postList"><li name="1745" id="1745" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">no</strong> strict requirement for using <strong class="markup--strong markup--li-strong">contiguous physical memory that starts at 0</strong></li><li name="e003" id="e003" class="graf graf--li graf-after--li">the guest OS can explicitly register the page tables that it uses with the hypervisor, so <strong class="markup--strong markup--li-strong">no need for dual page tables</strong> (one for the V2P, another for the shadow PT)</li><li name="7055" id="7055" class="graf graf--li graf-after--li">the guest OS can batch a number of page table updates, and then issue a single hypercall to tell the hypervisor to install all of these mappings.</li></ul><p name="8c53" id="8c53" class="graf graf--p graf-after--li">By the way, the two mechanisms for memory virtualization (full virtualization vs. paravirtualization) have substantially been improved given advances in the new hardware architectures. So, some of these overheads have completely been eliminated or at least substantially reduced if we take a look at what’s happening at the newer generation of x86 platforms.</p><p name="d088" id="d088" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">6. Device Virtualization</strong></p><p name="9394" id="9394" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Diversity Problem of the Device Virtualization</strong></p><p name="16c7" id="16c7" class="graf graf--p graf-after--p">We have talked about memory virtualization and processor virtualization, but they are not as diverse as device virtualization. Also, there is a lack of standardized interfaces and behaviors. To deal with this diversity, virtualization solutions adopt one of the <strong class="markup--strong markup--p-strong">three key models</strong> to virtualize devices.</p><p name="55a4" id="55a4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Passthrough Model</strong></p><p name="1453" id="1453" class="graf graf--p graf-after--p">The way that the passthrough model works is that the <strong class="markup--strong markup--p-strong">VMM level driver</strong> is responsible for configuring the access permissions for devices. For instance, it will allow a Guest VM to have access to the memory where the control registers for the device are.</p><figure name="9301" id="9301" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5IRBmv2himJLnyZhE3PqyA.png" data-width="1368" data-height="450" src="https://cdn-images-1.medium.com/max/800/1*5IRBmv2himJLnyZhE3PqyA.png"></figure><p name="324d" id="324d" class="graf graf--p graf-after--figure">The benefits of this model are,</p><ul class="postList"><li name="5faa" id="5faa" class="graf graf--li graf-after--p">VM can <strong class="markup--strong markup--li-strong">exclusively access</strong> the device</li><li name="33ca" id="33ca" class="graf graf--li graf-after--li">VM can <strong class="markup--strong markup--li-strong">directly access</strong> the device without passing the VMM (also called VMM-bypass)</li></ul><p name="8e03" id="8e03" class="graf graf--p graf-after--li">The downsides of the model are,</p><ul class="postList"><li name="9f1f" id="9f1f" class="graf graf--li graf-after--p">Sharing the devices for different VMs can be difficult</li><li name="a241" id="a241" class="graf graf--li graf-after--li">Guest VM should have the specific type of device driver</li><li name="68cf" id="68cf" class="graf graf--li graf-after--li">VM migration would be difficult because the device is now bond to the VM</li></ul><p name="c163" id="c163" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Hypervisor-Direct Model</strong></p><p name="7549" id="7549" class="graf graf--p graf-after--p">In this model, VMM needs to intercept all the device accesses. Once the VMM has the device accesses, it will perform the following operations to emulate device operation,</p><ul class="postList"><li name="26f2" id="26f2" class="graf graf--li graf-after--p">translate to generic I/O operation</li><li name="fef0" id="fef0" class="graf graf--li graf-after--li">traverse VMM-resident I/O stack, and the bottom of that stack is the actual real device driver</li><li name="8235" id="8235" class="graf graf--li graf-after--li">revoke the VMM device driver and perform the I/O operation on behalf of the guest VM</li></ul><figure name="d181" id="d181" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*XX0rOTQ5oV-M26VVjki5_A.png" data-width="1368" data-height="468" src="https://cdn-images-1.medium.com/max/800/1*XX0rOTQ5oV-M26VVjki5_A.png"></figure><p name="e283" id="e283" class="graf graf--p graf-after--figure">The benefits of this model are,</p><ul class="postList"><li name="87eb" id="87eb" class="graf graf--li graf-after--p">VM is <strong class="markup--strong markup--li-strong">decoupled</strong> from the physical device, and any translation and any emulation will be performed by the hypervisor</li><li name="e295" id="e295" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Sharing</strong> the devices for different VMs is easier</li><li name="7ff2" id="7ff2" class="graf graf--li graf-after--li">VM <strong class="markup--strong markup--li-strong">migration</strong> would be easy</li><li name="1696" id="1696" class="graf graf--li graf-after--li">Guest VM <strong class="markup--strong markup--li-strong">doesn’t need to have the specific type of device driver</strong></li></ul><p name="9870" id="9870" class="graf graf--p graf-after--li">The downsides of the model are,</p><ul class="postList"><li name="f39c" id="f39c" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Add latency</strong> on the device accesses</li><li name="fd86" id="fd86" class="graf graf--li graf-after--li">There are<strong class="markup--strong markup--li-strong"> device driver complexities </strong>in the hypervisor and they are not always provided by the designers or the manufactures</li></ul><p name="d628" id="d628" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Split Device Driver Model</strong></p><p name="de8a" id="de8a" class="graf graf--p graf-after--p">The last mode is called split because all of the device accesses are controlled in a way that involves both a component that resides in the guest VM and also a component that resides in the hypervisor layer. Specifically, device accesses are controlled using a device driver that sits in the guest VM called the <strong class="markup--strong markup--p-strong">front-end device driver</strong>. And the actual driver for the physical device in the service VM (or the lost OS for type-2 virtualization) is called the <strong class="markup--strong markup--p-strong">back-end driver</strong>.</p><p name="4a50" id="4a50" class="graf graf--p graf-after--p">Although this back-end driver does not necessarily have to be modified, the front-end driver has to be modified, because it needs to take the device operations that are made by the applications in the guest and then put them together like a special message that will directly be passed to this backend component that’s in the service VM. So this approach essentially <strong class="markup--strong markup--p-strong">applies only to paravirtualized guests</strong> that will be able to explicitly install these special front-end device drivers.</p><figure name="ead7" id="ead7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*7UwJ0pa4Bs9jxkJrPEfIlg.png" data-width="1368" data-height="468" src="https://cdn-images-1.medium.com/max/800/1*7UwJ0pa4Bs9jxkJrPEfIlg.png"></figure><p name="34c8" id="34c8" class="graf graf--p graf-after--figure">The benefits of this model are,</p><ul class="postList"><li name="2b79" id="2b79" class="graf graf--li graf-after--p">Eliminate emulation overheads</li><li name="362f" id="362f" class="graf graf--li graf-after--li graf--trailing">Allow <strong class="markup--strong markup--li-strong">better management </strong>of the shared devices</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/78c430139202"><time class="dt-published" datetime="2021-04-14T11:23:43.532Z">April 14, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/operating-system-22-introduction-of-virtualization-virtualization-models-hardware-protection-78c430139202" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>