<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Software Development Process 12 | Black-Box Testing</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Software Development Process 12 | Black-Box Testing</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Software Development Process
</section>
<section data-field="body" class="e-content">
<section name="a6aa" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7ea1" id="7ea1" class="graf graf--h3 graf--leading graf--title">Software Development Process 12 | Black-Box Testing</h3><figure name="9569" id="9569" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*wz75JyqXj-dacJp6.png" data-width="700" data-height="328" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*wz75JyqXj-dacJp6.png"></figure><ol class="postList"><li name="3015" id="3015" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Black-Box Testing</strong></li></ol><p name="e83d" id="e83d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Black-Box Testing</strong></p><p name="834b" id="834b" class="graf graf--p graf-after--p">As we said at the end of the previous section, black-box testing (aka. functional testing) is the testing of the software when we look at it as a black box, as a closed box, without looking at it inside, without looking at the code.</p><p name="db4d" id="db4d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) Advantages of Using Black-Box Testing</strong></p><ul class="postList"><li name="3466" id="3466" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Focus on the input domain</strong>: we can make sure we are actually covering this domain, that we are actually covering the important behaviors of the software.</li><li name="d7fc" id="d7fc" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">No need for the codes</strong>: you can start designing and writing your test cases, even before writing your code, so that when the code is ready, we can test it right away. This means that we can do an early test design.</li><li name="f53e" id="f53e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Catches logic defects</strong>: black-box testing can catch logic defects because it focuses on the description of what the software should do, and therefore on its logic.</li><li name="ceb9" id="ceb9" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Applicable at all granularity levels</strong>: we can use black-box testing in unit testing, integration testing, system testing, and so on. So we can basically use it at all levels.</li></ul><p name="0c14" id="0c14" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Systemic Functional Testing Approach</strong></p><p name="9be9" id="9be9" class="graf graf--p graf-after--p">Black box testing starts from a description of the software called a <strong class="markup--strong markup--p-strong">functional specification</strong>. The final result of black-box testing is a set of <strong class="markup--strong markup--p-strong">test cases</strong>, a set of actual inputs and corresponding outputs that we can use to exercise our code and to try to find defects in our code.</p><p name="75fd" id="75fd" class="graf graf--p graf-after--p">Going from this description to a concrete set of tests is a very complex analytical process. So what we want to do is to have a systematic approach to derive test cases from a functional specification, which will simplify the overall problem by dividing the process into elementary steps as follows,</p><figure name="4700" id="4700" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*oVO-Ath_1VRNQM8A3qpU5A.png" data-width="1750" data-height="874" src="https://cdn-images-1.medium.com/max/800/1*oVO-Ath_1VRNQM8A3qpU5A.png"></figure><p name="eb5f" id="eb5f" class="graf graf--p graf-after--figure">In particular, in the diagram shown above, we have to perform three main steps,</p><ul class="postList"><li name="281f" id="281f" class="graf graf--li graf-after--p">Identify independently testable features (ITFs), which are the individual features in the software that we can test.</li><li name="beae" id="beae" class="graf graf--li graf-after--li">Identify what are the relevant inputs, which are the inputs or the behaviors that are worth testing for these features.</li><li name="b807" id="b807" class="graf graf--li graf-after--li">Derive test specifications, which are descriptions of the test cases that we can then use to generate actual test cases.</li></ul><p name="ac41" id="ac41" class="graf graf--p graf-after--li">The systemic approach in this way has many advantages,</p><ul class="postList"><li name="b568" id="b568" class="graf graf--li graf-after--p">It allows for dividing brain intensive steps from steps that can be automated</li><li name="3635" id="3635" class="graf graf--li graf-after--li">It allows you for monitoring the testing process.</li></ul><p name="276c" id="276c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Identify ITF Examples</strong></p><p name="9fd8" id="9fd8" class="graf graf--p graf-after--p">For simple function <code class="markup--code markup--p-code">printSum(int a, int b)</code> used to add and print two numbers, there is only one feature that we can test for adding two numbers.</p><p name="06b1" id="06b1" class="graf graf--p graf-after--p">For the Microsoft Excel spreadsheet, there are many ITFs we can test,</p><ul class="postList"><li name="ea11" id="ea11" class="graf graf--li graf-after--p">Cell Merging</li><li name="7671" id="7671" class="graf graf--li graf-after--li">Chart Creation</li><li name="00f9" id="00f9" class="graf graf--li graf-after--li">Statistical Function</li><li name="b189" id="b189" class="graf graf--li graf-after--li">etc.</li></ul><p name="d2c0" id="d2c0" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) Test Data Selection</strong></p><p name="1c0a" id="1c0a" class="graf graf--p graf-after--p">Once we have identified independently testable features, the next step is to identify the relevant inputs for each one of these features. The problem of identifying relevant inputs for some software or some feature of it is called <strong class="markup--strong markup--p-strong">test data selection</strong> and can be expressed as followed. As usual, we have,</p><ul class="postList"><li name="293e" id="293e" class="graf graf--li graf-after--p">Input domain: the set of inputs for all the software</li><li name="e6ff" id="e6ff" class="graf graf--li graf-after--li">Output domain: the set of corresponding outlets for these inputs</li></ul><p name="168f" id="168f" class="graf graf--p graf-after--li">So the question here is, how can we select a meaningful set of inputs in my domain? There are basically some ideas,</p><ul class="postList"><li name="c0ed" id="c0ed" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Exhaustive Testing</strong>: one possible idea is to test them all. We can do all the inputs if we have powerful machines or if we have a lot of computational power in the cloud. For example, if we want to do exhaustive testing on the function <code class="markup--code markup--li-code">printSum(int a, int b)</code> , we have to take all the integer combinations into the consideration and it’s going to take 600 years for a modern computer. So the bottom line here is that we just can’t do exhaustive testing.</li><li name="87c4" id="87c4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Random Testing</strong>: random testing means that we pick the inputs to test just as we pick a number by rolling a set of dice randomly. There are some benefits of this idea, (1) we pick inputs uniformly; (2) all inputs considered equal; (3) no designer bias, which is the developer’s assumption or preference on the user’s behaviors. However, in practice, we don’t do random testing because it is like we are looking for a needle in a haystack, and failing inputs are generally very sparse in the input domain.</li><li name="247e" id="247e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Partition Testing</strong>: Fortunately not all is lost, there is a silver lining. We can actually leverage the fact that the failures are dense in some subdomains. The domain is naturally split into partitions where partitions are areas of the domain that are treated homogeneously by the software. So rather than picking inputs randomly, we want to do two things: (1) identify partitions of our domain; (2) select inputs from each partition. By doing so, we can dramatically increase our chances to reveal faults in the code.</li></ul><p name="e294" id="e294" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) Partition Testing Example</strong></p><p name="4ca1" id="4ca1" class="graf graf--p graf-after--p">Let’s see the following function for splitting a string,</p><pre name="34fb" id="34fb" class="graf graf--pre graf-after--p">split(String str, int size)</pre><p name="4a79" id="4a79" class="graf graf--p graf-after--pre">Basically, we can have the following partitions,</p><ul class="postList"><li name="d8af" id="d8af" class="graf graf--li graf-after--p">size &lt; 0</li><li name="f2cb" id="f2cb" class="graf graf--li graf-after--li">size = 0</li><li name="aee3" id="aee3" class="graf graf--li graf-after--li">size &gt; 0</li><li name="8c2a" id="8c2a" class="graf graf--li graf-after--li">str.length ≤ size</li><li name="b48e" id="b48e" class="graf graf--li graf-after--li">size &lt; str.length ≤ size * 2</li><li name="7b1f" id="7b1f" class="graf graf--li graf-after--li">str.length &gt; size * 2</li><li name="449e" id="449e" class="graf graf--li graf-after--li">etc.</li></ul><p name="052d" id="052d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Boundary Values</strong></p><p name="ad8d" id="ad8d" class="graf graf--p graf-after--p">Errors tend to occur at the boundary of a domain, or a sub-domain because these are the cases that are less understood by the developers. For example,</p><ul class="postList"><li name="27e2" id="27e2" class="graf graf--li graf-after--p">the last iteration of a loop</li><li name="78b2" id="78b2" class="graf graf--li graf-after--li">a special value like zero for integers</li><li name="b2aa" id="b2aa" class="graf graf--li graf-after--li">etc.</li></ul><p name="fdff" id="fdff" class="graf graf--p graf-after--li">So what is complementary to partition testing is that we want to select inputs at these boundaries. Let’s view back to the <code class="markup--code markup--p-code">split</code> functional example, now we can have some possible inputs,</p><ul class="postList"><li name="9795" id="9795" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">size = -1</code></li><li name="ddb2" id="ddb2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">size = 0</code></li><li name="fe52" id="fe52" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">size = 1</code></li><li name="2e56" id="2e56" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">string.length = size - 1</code></li><li name="925d" id="925d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">string.length = size</code></li><li name="f460" id="f460" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">string.length = size * 1.5</code></li><li name="bb26" id="bb26" class="graf graf--li graf-after--li">etc.</li></ul><p name="933a" id="933a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) Deriving Test Case Specifications</strong></p><p name="2cc5" id="2cc5" class="graf graf--p graf-after--p">Once we have identified the values of interest, we derive test case specifications for these values. And the test case specification defines how the values should be <strong class="markup--strong markup--p-strong">put together</strong> when actually testing the system. For example, the split function now has several test cases and we can actually put some of them together. For example,</p><ul class="postList"><li name="a08f" id="a08f" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">size = -1, str.length = -2</code> (doesn&#39;t make sense)</li><li name="aa91" id="aa91" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">size = -1, str.length = -1</code> (doesn’t make sense)</li><li name="f506" id="f506" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">size = -1, str.length = 0</code></li><li name="31ee" id="31ee" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">size = 1, str.length = 0</code></li><li name="e694" id="e694" class="graf graf--li graf-after--li">etc.</li></ul><p name="0668" id="0668" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(9) Category-Partition Method</strong></p><p name="0137" id="0137" class="graf graf--p graf-after--p">The following step is to use these test case specifications to generate actual test cases. And this is normally a fairly mechanical step in the sense that we just have to instantiate what is in the test case specification as actual test cases.</p><p name="42ff" id="42ff" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">Category-Partition Method</strong> was defined by Ostrand &amp; Balcer in 1988 in an article to the peer-reviewed magazine Communications of the ACM. So this is a method for going from a specification (i.e. a description of the system) to a set of test cases (e.g. any other black-box testing approach) by following six steps,</p><ul class="postList"><li name="d75c" id="d75c" class="graf graf--li graf-after--p">Step 1. Identify independently testable features</li><li name="9821" id="9821" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 2. Identify categories </strong>(i.e. characteristics of each input element): For the example of <code class="markup--code markup--li-code">split</code> function, the categories for <code class="markup--code markup--li-code">str</code> is <code class="markup--code markup--li-code">length</code> and <code class="markup--code markup--li-code">content</code> , and the category for <code class="markup--code markup--li-code">size</code> is its <code class="markup--code markup--li-code">value</code>.</li><li name="e684" id="e684" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Step 3. Partition categories into choices </strong>(i.e. interesting cases or subdomains): For example,<code class="markup--code markup--li-code">length = 0, size-1, size, ...</code> , <code class="markup--code markup--li-code">content = &quot; &quot;, &quot;&lt;special characters&gt;&quot;, ...</code> , <code class="markup--code markup--li-code">value = -1, 0, 1, maxInt, ...</code></li><li name="6c34" id="6c34" class="graf graf--li graf-after--li">Step 4. Identify constraints among choices: we have to do this because we need to eliminate meaningless combinations of inputs and reduce the number of test cases. There are three types of properties: a. Pair property…if… (e.g. we should have <code class="markup--code markup--li-code">str.length != 0</code> if we want to test special characters); b. Error properties (e.g. we should throw an error for <code class="markup--code markup--li-code">size value &lt; 0</code>); c. Single properties (e.g. should be tested only once and should have no combination with the other test cases).</li><li name="7f0b" id="7f0b" class="graf graf--li graf-after--li">Step 5. Produce/Evaluate test case specifications: this is a step that can be completely automated given the results of the previous steps, and the final result of this step is the production of a set of <strong class="markup--strong markup--li-strong">test frames</strong> where a test frame is the specification of a test. For example, a test frame can be,</li></ul><pre name="55b5" id="55b5" class="graf graf--pre graf-after--li">Test Frame #36<br>    input str<br>        length = size - 1<br>        content = special characters<br>    input size<br>        value &gt; 1</pre><ul class="postList"><li name="7a83" id="7a83" class="graf graf--li graf-after--pre">Step 6. Generate test cases from test case specifications: This step mainly consists of a simple instantiation of frames and its final result is a set of concrete tests. For the test frame #36 example, we can have,</li></ul><pre name="1270" id="1270" class="graf graf--pre graf-after--li">Test Case #36<br>    str = &quot;ABCC!\n\tΦ&quot;<br>    size = 10</pre><p name="ed5f" id="ed5f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">(10) Model-Based Testing</strong></p><p name="6a56" id="6a56" class="graf graf--p graf-after--p">The systemic functional testing approach is not the only way for generating the test cases, and another popular one is called the <strong class="markup--strong markup--p-strong">model-based testing</strong> approach.</p><p name="967f" id="967f" class="graf graf--p graf-after--p">A model is an abstract representation of the software under test. In model-based testing, the way in which we go from specifications to test cases is through the construction of a model. Also, in this case, there are many possible models, that we can use, but here in this section, we will only focus on the finite state machines (FSM) model.</p><p name="7b2e" id="7b2e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) Finite State Machine (FSM)</strong></p><p name="313b" id="313b" class="graf graf--p graf-after--p">At a high level, a state machine is a graph in which nodes represent states of the system. Edges represent transitions between states. And finally, the labels on the edges represent events and actions. So how do we build such a final state machine starting from a specification?</p><ul class="postList"><li name="e128" id="e128" class="graf graf--li graf-after--p">Start from the specifications</li><li name="7bf1" id="7bf1" class="graf graf--li graf-after--li">Identify the system’s boundaries and the I/O to the system</li><li name="b2f1" id="b2f1" class="graf graf--li graf-after--li">Identify the relevant states and transitions within the boundaries of the system</li><li name="da96" id="da96" class="graf graf--li graf-after--li">Refine it into several states</li><li name="3a29" id="3a29" class="graf graf--li graf-after--li">Identify how the system can go from one state to another, including which inputs cause which transition, and which result in outputs we can obtain</li></ul><p name="8aff" id="8aff" class="graf graf--p graf-after--li">Here are some important considerations for FSM,</p><ul class="postList"><li name="e141" id="e141" class="graf graf--li graf-after--p">Applicability: FSM is a very general approach and we can apply the technique to state charts in UML</li><li name="6ad4" id="6ad4" class="graf graf--li graf-after--li">Abstraction: we have to find the right abstraction of the system</li><li name="5be8" id="5be8" class="graf graf--li graf-after--li graf--trailing">Other approaches: we can use many other models rather than FSM. For example, the decision tables, the flow graphs, and even the historical models</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/ea06963dc3df"><time class="dt-published" datetime="2021-10-24T22:09:39.106Z">October 24, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/software-development-process-11-black-box-testing-ea06963dc3df" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>