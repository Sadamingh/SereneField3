<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Software Development Process 2 | Traditional Software Phases, Software Lifecycle Models, and…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Software Development Process 2 | Traditional Software Phases, Software Lifecycle Models, and…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Software Development Process
</section>
<section data-field="body" class="e-content">
<section name="1267" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="183a" id="183a" class="graf graf--h3 graf--leading graf--title">Software Development Process 2 | <strong class="markup--strong markup--h3-strong">Traditional Software Phases, Software Lifecycle Models, and Common Software Development Mistakes</strong></h3><figure name="6f37" id="6f37" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*Adsh1wHcTOVjaYz3.png" data-width="1400" data-height="657" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*Adsh1wHcTOVjaYz3.png"></figure><ol class="postList"><li name="8e3f" id="8e3f" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Traditional Software Phases</strong></li></ol><p name="9d15" id="9d15" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Review: Traditional Software Phases</strong></p><p name="8ca3" id="8ca3" class="graf graf--p graf-after--p">We have talked about the traditional software phases in the last article. And before we have a more detailed introduction of it, let’s first review its components.</p><ul class="postList"><li name="55cc" id="55cc" class="graf graf--li graf-after--p">Requirement Engineering</li><li name="f8fc" id="f8fc" class="graf graf--li graf-after--li">Design</li><li name="ea55" id="ea55" class="graf graf--li graf-after--li">Implementation</li><li name="6216" id="6216" class="graf graf--li graf-after--li">Verification and Validation</li><li name="d6ab" id="d6ab" class="graf graf--li graf-after--li">Maintenance</li></ul><p name="4000" id="4000" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) The Definition of Requirement Engineering</strong></p><p name="09d1" id="09d1" class="graf graf--p graf-after--p">Requirement Engineering is the process of establishing the needs of stakeholders that are to be solved by the software.</p><p name="fa43" id="fa43" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) Importance of Requirement Engineering</strong></p><p name="ca34" id="ca34" class="graf graf--p graf-after--p">In general, the cost of correcting an error depends on the number of subsequent decisions that are based on it. Therefore, errors made in understanding requirements have the potential for the greatest cost because many other design decisions depend on them and many other follow-up decisions depend on them. The cost grows dramatically as we go from the requirements phase to the maintenance phase because if we discover a problem later, to correct the error we’re left to undo a lot of the decisions that we had made before.</p><p name="e00e" id="e00e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Steps to Collect Right Requirements</strong></p><p name="f5f7" id="f5f7" class="graf graf--p graf-after--p">In order to avoid the cost of a late correction, we have to collect the requirements in the right way through the following steps,</p><ul class="postList"><li name="8e55" id="8e55" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Elicitation</strong>: the collection of requirements from stakeholders and other sources and can be done in a variety of ways</li><li name="9129" id="9129" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Requirement Analysis</strong>: this involves the study and a deeper understanding of the collective requirements</li><li name="95d5" id="95d5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Specification of requirements</strong>: the collective requirements are suitably represented, organized, and saved so that they can be shared</li><li name="213e" id="213e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Validation</strong>: it is to make sure the softwares are complete, consistent, not redundant, and so on. So that they have satisfied a set of important properties for requirements</li><li name="7d1a" id="7d1a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Requirement management</strong>: this accounts for changes to requirements during the lifetime of the project.</li></ul><p name="311e" id="311e" class="graf graf--p graf-after--li">In reality, as we will see, this is an iterative process instead of a linear process, in which we will go on and cover different phases in an iterative fashion.</p><p name="1462" id="1462" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) The Definition of Software Design</strong></p><p name="d2bc" id="d2bc" class="graf graf--p graf-after--p">The software design is a phase where software requirements are analyzed in order to produce a description of the internal structure and organization of the system. This description will serve as the basis for the construction of the actual system.</p><p name="d7be" id="d7be" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Common Design Activities</strong></p><p name="e5b0" id="e5b0" class="graf graf--p graf-after--p">Traditionally, the software design phase consists of a series of design activities, normally consisting of,</p><ul class="postList"><li name="ef07" id="ef07" class="graf graf--li graf-after--p">architectural design phase</li><li name="4f12" id="4f12" class="graf graf--li graf-after--li">abstract specification</li><li name="be18" id="be18" class="graf graf--li graf-after--li">interface design</li><li name="520b" id="520b" class="graf graf--li graf-after--li">component design</li><li name="9872" id="9872" class="graf graf--li graf-after--li">data structure</li><li name="2cdb" id="2cdb" class="graf graf--li graf-after--li">algorithm design</li></ul><p name="e1c1" id="e1c1" class="graf graf--p graf-after--li">Note that these are just possible components of design activity, and a design activity can actually be constructed in many different ways. These activities result in a bunch of <strong class="markup--strong markup--p-strong">design products</strong>. For example,</p><ul class="postList"><li name="8ea1" id="8ea1" class="graf graf--li graf-after--p">system structure and architecture</li><li name="6615" id="6615" class="graf graf--li graf-after--li">software specification</li><li name="d83f" id="d83f" class="graf graf--li graf-after--li">interface specification</li><li name="09b3" id="09b3" class="graf graf--li graf-after--li">component specification</li><li name="327c" id="327c" class="graf graf--li graf-after--li">data structure specification</li><li name="5803" id="5803" class="graf graf--li graf-after--li">algorithm specification</li></ul><p name="8d01" id="8d01" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) The Definition of Implementation</strong></p><p name="5f47" id="5f47" class="graf graf--p graf-after--p">In the implementation phase, what we do is to basically take care of realizing the design of the system that we just created for creating a natural software system.</p><p name="f2db" id="f2db" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Four Principles of Software Implementation</strong></p><p name="dded" id="dded" class="graf graf--p graf-after--p">Basically, there are 4 fundamental principles or four pillars that can affect the way in which the software is constructed.</p><ul class="postList"><li name="0b82" id="0b82" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">reduction of complexity</strong>: this aims to build software that is easier to understand and use</li><li name="bdd6" id="bdd6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">anticipation of diversity</strong>: this principle takes into account that software construction might change in various ways over time and in many different cases, the softwares may involve many unexpected kinds of ways. Therefore, we want to anticipate some of these changes</li><li name="a07d" id="a07d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">structuring for validation</strong> (aka. <strong class="markup--strong markup--li-strong">design for testability</strong>): what this means is that we want to build software so that it is easily testable during the subsequent validation and verification activities</li><li name="2270" id="2270" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">use of internal or external standards</strong>: it is important that the software conforms to a set of internal or external standards and this is especially true within specific organizations and or domains</li></ul><p name="a1e4" id="a1e4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(9) The Definition of Verification and Validation</strong></p><p name="f603" id="f603" class="graf graf--p graf-after--p">After we build our system, verification and validation is the phase of software development that aims to check if the software system meets the specification and fulfills its intended purpose.</p><ul class="postList"><li name="cb80" id="cb80" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Validation</strong>: Did we build the right system? Will it make the customers happy?</li><li name="dea2" id="dea2" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Verification</strong>: Did we build the system right? Did we build a system that actually implements the specification that we defined?</li></ul><p name="7778" id="7778" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(10) Levels of Verification and Validation</strong></p><p name="7b47" id="7b47" class="graf graf--p graf-after--p">Another aspect that we would like to talk about is that verification and validation can be performed at different levels. In particular,</p><ul class="postList"><li name="f451" id="f451" class="graf graf--li graf-after--p">it can be performed at the <strong class="markup--strong markup--li-strong">unit level</strong>: test individual units</li><li name="d818" id="d818" class="graf graf--li graf-after--li">it can be performed at the <strong class="markup--strong markup--li-strong">integration level</strong>: test the interaction between different units</li><li name="7cf3" id="7cf3" class="graf graf--li graf-after--li">it can be performed at the <strong class="markup--strong markup--li-strong">system level</strong>: test the system as a whole</li></ul><p name="1778" id="1778" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(11) The Definition of Maintenance</strong></p><p name="d2df" id="d2df" class="graf graf--p graf-after--p">As we have discussed before, software development efforts normally result in the delivery of a software product that satisfies the user requirements. After the release of a software product to its final users, many things can happen. For example,</p><ul class="postList"><li name="a4eb" id="a4eb" class="graf graf--li graf-after--p">environment might change</li><li name="95c4" id="95c4" class="graf graf--li graf-after--li">there might be new libraries</li><li name="2782" id="2782" class="graf graf--li graf-after--li">there might be new systems in which our software has to operate</li><li name="a413" id="a413" class="graf graf--li graf-after--li">there might be future requests: this means the customers may want to do something different with the program that was given to them</li><li name="19e2" id="19e2" class="graf graf--li graf-after--li">users may find out problems with the software, and they may file bug reports</li></ul><p name="3b92" id="3b92" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(12) Three Maintenance Activities</strong></p><p name="aae8" id="aae8" class="graf graf--p graf-after--p">Specifically, in response to these problems, the software developers created three kinds of maintenance activities,</p><ul class="postList"><li name="8d28" id="8d28" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Corrective maintenance</strong> to eliminate problems with the code</li><li name="9689" id="9689" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Perfective maintenance</strong> to accommodate feature requests, and in some cases just to improve the software, for example, to make it more efficient</li><li name="5847" id="5847" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Adaptive maintenance</strong> to take care of the environment changes.</li></ul><p name="53b9" id="53b9" class="graf graf--p graf-after--li">After these activities have been performed, the software developers will produce a new version of the application, release it, and the cycle will continue throughout the lifetime of the software. That’s why maintenance is a fundamental activity and a very expensive one.</p><p name="034d" id="034d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(13) The Definition of Regression Testing</strong></p><p name="975e" id="975e" class="graf graf--p graf-after--p">One of the reasons why maintenance is expensive is <strong class="markup--strong markup--p-strong">regression testing</strong>, which is the activity of retesting software after it has been modified to make sure that the changes in your performance to the software work as expected, and to make sure that your changes did not introduce any unforeseen effect.</p><p name="80a5" id="80a5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Software Process/Lifecycle Models</strong></p><p name="591b" id="591b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Software Lifecycle Models</strong></p><p name="d201" id="d201" class="graf graf--p graf-after--p">The software lifecycle models, also named the software process models, are prescriptive models of what should happen from the very beginning to the very end of a software development process.</p><p name="522f" id="522f" class="graf graf--p graf-after--p">The main function of these models is to determine the order of the different activities so that we know which one should come first and which one should follow. Another function of these models is to determine the transition criteria between activities.</p><p name="083d" id="083d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Waterfall Process Model</strong></p><p name="b8c9" id="b8c9" class="graf graf--p graf-after--p">The grandfather of all the other software lifecycle models is the waterfall model. In the waterfall model, the project progresses to an orderly sequence of steps, from the initial software concept, down until the final phase of system testing. The ordered phases are,</p><ul class="postList"><li name="6774" id="6774" class="graf graf--li graf-after--p">software concept</li><li name="9bf6" id="9bf6" class="graf graf--li graf-after--li">requirement analysis</li><li name="8aa3" id="8aa3" class="graf graf--li graf-after--li">architecture design</li><li name="d7a5" id="d7a5" class="graf graf--li graf-after--li">detailed design</li><li name="b438" id="b438" class="graf graf--li graf-after--li">coding and debugging</li><li name="af6b" id="af6b" class="graf graf--li graf-after--li">system testing</li></ul><p name="da67" id="da67" class="graf graf--p graf-after--li">At the end of each phase, there will be a review to determine whether the project is ready to advance to the next phase.</p><figure name="6d96" id="6d96" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ea9lbVm4MRzN8GX0-fm52w.png" data-width="982" data-height="742" src="https://cdn-images-1.medium.com/max/800/1*ea9lbVm4MRzN8GX0-fm52w.png"><figcaption class="imageCaption"><a href="http://www-scf.usc.edu/~csci201/lectures/Lecture11/boehm1988.pdf" data-href="http://www-scf.usc.edu/~csci201/lectures/Lecture11/boehm1988.pdf" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">A Spiral Model of Software Development and Enhancement</a>, 1986, Barry Boehm</figcaption></figure><p name="1110" id="1110" class="graf graf--p graf-after--figure">The pure waterfall model performs well for software products in which there is a stable product definition. This means that the domain is well known and the technologies involved are well understood. In these kinds of domains, the waterfall model helps you to find errors in the early, local stages of the projects.</p><p name="0cc4" id="0cc4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Evaluation of Waterfall Process Model</strong></p><p name="d420" id="d420" class="graf graf--p graf-after--p">The main advantage of the waterfall model is that it allows you to find errors early. However, the main disadvantages of the waterfall model arise from the fact that it is not flexible, because it is difficult to fully specify requirements at the beginning of a project.</p><p name="7183" id="7183" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) The History of Spiral Process</strong></p><p name="b1ee" id="b1ee" class="graf graf--p graf-after--p">The spiral model was first described by Barry Boehm in his paper from 1986 that was entitled <a href="http://www-scf.usc.edu/~csci201/lectures/Lecture11/boehm1988.pdf" data-href="http://www-scf.usc.edu/~csci201/lectures/Lecture11/boehm1988.pdf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">A Spiral Model of Software Development and Enhancement</em></a>. One of the main characteristics of that paper is that it was describing the spiral model using a diagram which has become very popular.</p><figure name="63bc" id="63bc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*8CIpsBp4mRuPWGn_v48V9w.png" data-width="1144" data-height="674" src="https://cdn-images-1.medium.com/max/800/1*8CIpsBp4mRuPWGn_v48V9w.png"><figcaption class="imageCaption"><a href="http://www-scf.usc.edu/~csci201/lectures/Lecture11/boehm1988.pdf" data-href="http://www-scf.usc.edu/~csci201/lectures/Lecture11/boehm1988.pdf" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">A Spiral Model of Software Development and Enhancement</a>, 1986, Barry Boehm</figcaption></figure><p name="73ba" id="73ba" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) The Definition of Spiral Process Model</strong></p><p name="e3a3" id="e3a3" class="graf graf--p graf-after--p">The spiral model is an incremental <strong class="markup--strong markup--p-strong">risk-oriented lifecycle model</strong> that has four main phases.</p><ul class="postList"><li name="0542" id="0542" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Determine objectives</strong>: requirements will be gathered</li><li name="ca25" id="ca25" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Identify and resolve risks</strong>: risks and alternate solutions will be identified, and a prototype will be produced</li><li name="7aef" id="7aef" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Development and tests</strong>: produce software and tests for it</li><li name="9825" id="9825" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Plan the next iteration</strong>: the output of the project, so far, is evaluated, and the next iteration is planned</li></ul><p name="3ca1" id="3ca1" class="graf graf--p graf-after--li">What the spiral process prescribes is a way of developing software by going through these phases in an iterative way, in which we learn more and more of the software, we identify more and more, and account for, more and more risks, and we go more and more towards our final release.</p><p name="e0fa" id="e0fa" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Advantages for Using the Spiral Model</strong></p><p name="f233" id="f233" class="graf graf--p graf-after--p">There are several advantages for this model,</p><ul class="postList"><li name="58cf" id="58cf" class="graf graf--li graf-after--p">Risk reduction: extensive risk analysis does reduce the chances of the project to fail</li><li name="453f" id="453f" class="graf graf--li graf-after--li">Flexibility: functionality can be added at a later phase because of the iterative nature of the process</li><li name="5433" id="5433" class="graf graf--li graf-after--li">Deliverability: software is produced early in the software lifecycle. So at any iteration, we have something to show for our development</li><li name="f985" id="f985" class="graf graf--li graf-after--li">Feedback Accessibility: we are able to get early feedback from the customer about what we have produced</li></ul><p name="3953" id="3953" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Disadvantages for Using the Spiral Model</strong></p><p name="cd2f" id="cd2f" class="graf graf--p graf-after--p">However, there are still some disadvantages.</p><ul class="postList"><li name="4a4f" id="4a4f" class="graf graf--li graf-after--p">Risk analysis requires highly specific expertise, and the whole success of the project is depending on that</li><li name="5203" id="5203" class="graf graf--li graf-after--li">Risk analysis is way more complex than other models, and therefore, it can be costly to implement</li></ul><p name="22cf" id="22cf" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) The Definition of Evolutionary Prototyping Model</strong></p><p name="5468" id="5468" class="graf graf--p graf-after--p">Another lifecycle model is called the evolutionary prototyping model, and it works in four main phases,</p><ul class="postList"><li name="4dda" id="4dda" class="graf graf--li graf-after--p">start from an <strong class="markup--strong markup--li-strong">initial concept</strong></li><li name="21f8" id="21f8" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">design</strong> and implement a prototype based on this initial concept</li><li name="3e9d" id="3e9d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">refine</strong> the prototype until it is acceptable</li><li name="ca56" id="ca56" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">complete and release</strong> the prototype</li></ul><p name="a64b" id="a64b" class="graf graf--p graf-after--li">When developing a system using evolutionary prototyping, the system is continually refined and rebuilt. So it is actually an ideal process when not all requirements are well understood, which is a very common situation.</p><p name="c09f" id="c09f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Reality for Evolutionary Prototyping Model</strong></p><p name="0fbc" id="0fbc" class="graf graf--p graf-after--p">Because it is common that not all the requirements are well understood, developers start by developing the parts of the system that might not be very clear at the stage. The partial system is then shown to the customer, and the customer’s feedback is used to drive the next iteration, in which either changes are made to the current features or new features are added. So either the current prototype is improved or the prototype is extended.</p><p name="c747" id="c747" class="graf graf--p graf-after--p">When the customer agrees that the prototype is good enough, the developers will complete the remaining work on the system and release the prototype as the final product.</p><p name="1903" id="1903" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) Evolutionary Prototyping Model: Evaluation</strong></p><p name="ff8a" id="ff8a" class="graf graf--p graf-after--p">There are some advantages to this model. For example,</p><ul class="postList"><li name="a3c8" id="a3c8" class="graf graf--li graf-after--p">developers can get immediate feedback</li></ul><p name="ef2e" id="ef2e" class="graf graf--p graf-after--li">However, there are also some disadvantages. For example,</p><ul class="postList"><li name="d9d1" id="d9d1" class="graf graf--li graf-after--p">the project is difficult to plan: for example, it is difficult to predict how long the developing process will take because the number of iterations is uncertain</li></ul><p name="5a1f" id="5a1f" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(11) The Definition of Rational Unified Process (RUP)</strong></p><p name="5ffd" id="5ffd" class="graf graf--p graf-after--p">The rational unified process (RUP) is a very popular process model based on UML. RUP works in an iterative way, which means that it performs different iterations, and at each iteration, it performs four phases.</p><ul class="postList"><li name="3a7f" id="3a7f" class="graf graf--li graf-after--p">interception: to scope the system</li><li name="107b" id="107b" class="graf graf--li graf-after--li">elaboration: to perform domain analysis and define the basic architecture</li><li name="2938" id="2938" class="graf graf--li graf-after--li">construction: the bulk of the development actually occurs</li><li name="be84" id="be84" class="graf graf--li graf-after--li">transition: to go from development to production</li></ul><p name="f6bd" id="f6bd" class="graf graf--p graf-after--li">In each one of these four phases, we perform standard software engineering activities, like</p><ul class="postList"><li name="574d" id="574d" class="graf graf--li graf-after--p">business modeling</li><li name="b3dd" id="b3dd" class="graf graf--li graf-after--li">requirement gathering</li><li name="0cc5" id="0cc5" class="graf graf--li graf-after--li">analysis and design</li><li name="bb84" id="bb84" class="graf graf--li graf-after--li">implementation</li><li name="52df" id="52df" class="graf graf--li graf-after--li">test</li><li name="5950" id="5950" class="graf graf--li graf-after--li">deployment</li><li name="4ccb" id="4ccb" class="graf graf--li graf-after--li">etc.</li></ul><p name="ef9a" id="ef9a" class="graf graf--p graf-after--li">and we do them to different extents based on the phase in which we are.</p><p name="77a1" id="77a1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(12) The Definition of Agile Process Model</strong></p><p name="4216" id="4216" class="graf graf--p graf-after--p">The agile model is, in fact, a group of software development methods that are based on highly iterative and incremental development. In particular, the method we will talk about is called test-driven development (TDD).</p><p name="0676" id="0676" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(13) The Definition of Test-Driven Development</strong></p><p name="4e71" id="4e71" class="graf graf--p graf-after--p">The TDD is based on the iteration of three main phases and we mark them in different colors,</p><ul class="postList"><li name="1ed4" id="1ed4" class="graf graf--li graf-after--p">RED (fail): we write test cases that encode our requirements, and for which we have not written code yet, they will definitely fall</li><li name="2087" id="2087" class="graf graf--li graf-after--li">GREEN (pass): after we make the test enough code to make the test cases pass, we have a set of test cases that are all passing</li><li name="5742" id="5742" class="graf graf--li graf-after--li">YELLOW (refactor): because the structure of the code deteriorates over time if we keep adding pieces, we have to modify the code to make it more readable and more maintainable. In general, we modify to improve the design of the code.</li></ul><p name="a77e" id="a77e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(14) Model Selection</strong></p><p name="7fca" id="7fca" class="graf graf--p graf-after--p">Now we have discussed plenty of models, and want we want to focus on is how to select the appropriate model for a project. A good model can ensure the success of the project, while a wrong can potentially make the project fail. To decide which model to choose, we have to take into consideration many factors,</p><ul class="postList"><li name="c76c" id="c76c" class="graf graf--li graf-after--p">requirement understanding: hard or easy one?</li><li name="a576" id="a576" class="graf graf--li graf-after--li">expected lifetime: quick or long-term support?</li><li name="f370" id="f370" class="graf graf--li graf-after--li">risk: do we know the domain and technologies?</li><li name="537f" id="537f" class="graf graf--li graf-after--li">schedule constraints: how many resources do we have?</li><li name="37e9" id="37e9" class="graf graf--li graf-after--li">interaction with managements or customers: do we have a continuous interaction? Do we have some initial phases or some checking points?</li><li name="786a" id="786a" class="graf graf--li graf-after--li">expertise: do we have the right people to handle the work?</li></ul><p name="dc9c" id="dc9c" class="graf graf--p graf-after--li">For example, for the development of a software control system, we can use the pure waterfall model because the requirements are clear. For the development of a software for midcourse corrections, both the spiral model and the evolutionary prototyping can be used because it can be too expensive to update the course if we use a pure waterfall process.</p><p name="3fe4" id="3fe4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Well-known Ineffective Development Practices</strong></p><p name="08eb" id="08eb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Mistakes Involving People</strong></p><ul class="postList"><li name="a415" id="a415" class="graf graf--li graf-after--p">Heroics: too much emphasis on can-do attitudes. This discourages cooperation.</li><li name="94b2" id="94b2" class="graf graf--li graf-after--li">Wrong working environment: all the people would like to work in a good environment</li><li name="a045" id="a045" class="graf graf--li graf-after--li">Poor people management: The lack of leadership creates an unhappy atmosphere and people will leave the teams. Another common one is to add people to the project behind schedule, and it costs to bring the new people to the right speed.</li></ul><p name="a3c7" id="a3c7" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Mistakes Involving Process</strong></p><ul class="postList"><li name="895f" id="895f" class="graf graf--li graf-after--p">Scheduling issue: the team is unable to come out with an unrealistic schedule</li><li name="b0f3" id="b0f3" class="graf graf--li graf-after--li">Planning issue: insufficient planning or abundant planning due to pressure, usually lead inexorably to failure</li><li name="31b2" id="31b2" class="graf graf--li graf-after--li">Unforeseen failures: failures on the constructor’s ends lead to downstream effects</li></ul><p name="8e71" id="8e71" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Mistakes Involving Product</strong></p><ul class="postList"><li name="cced" id="cced" class="graf graf--li graf-after--p">Gold plating: people tend to have more requirements than they actually need</li><li name="703d" id="703d" class="graf graf--li graf-after--li">Feature creep: adding more features to a product that were not initially planned</li><li name="318c" id="318c" class="graf graf--li graf-after--li">Research ≠ Development: working on a project that strains on the limit of computer science</li></ul><p name="81ba" id="81ba" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) Mistakes Involving Technology</strong></p><ul class="postList"><li name="70ae" id="70ae" class="graf graf--li graf-after--p">Silver-bullet syndrome: too much reliance on the advertised benefits of some previously unused technology</li><li name="c9b7" id="c9b7" class="graf graf--li graf-after--li">Switch or add tools in the middle of a project: introducing a new tool can usually have a steep learning curve</li><li name="14b2" id="14b2" class="graf graf--li graf-after--li graf--trailing">Lack of automated version control: easy to make mistakes, and unable to find an out-of-date version back</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/5ea35bfd4662"><time class="dt-published" datetime="2021-09-01T17:43:57.795Z">September 1, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/software-development-process-2-traditional-software-phases-software-lifecycle-models-and-5ea35bfd4662" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>