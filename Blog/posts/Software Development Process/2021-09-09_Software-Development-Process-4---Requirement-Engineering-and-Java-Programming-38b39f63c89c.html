<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Software Development Process 4 | Requirement Engineering and Java Programming</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Software Development Process 4 | Requirement Engineering and Java Programming</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Software Development Process
</section>
<section data-field="body" class="e-content">
<section name="9443" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3857" id="3857" class="graf graf--h3 graf--leading graf--title">Software Development Process 4 | <strong class="markup--strong markup--h3-strong">Requirement Engineering and Java Programming</strong></h3><figure name="27d3" id="27d3" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*LaIe7OqcGsnapjk3.png" data-width="1400" data-height="657" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*LaIe7OqcGsnapjk3.png"></figure><ol class="postList"><li name="08b5" id="08b5" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Requirement Engineering (RE)</strong></li></ol><p name="3508" id="3508" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Requirement Engineering (RE)</strong></p><p name="cf79" id="cf79" class="graf graf--p graf-after--p">Requirements engineering (RE) is the process of establishing the services that the customer requires from the software system. In addition to that, requirements engineering also has to do with the constraints under which the system operates and is developed.</p><p name="ae49" id="ae49" class="graf graf--p graf-after--p">There are reasons why the requirement engineering is very important,</p><ul class="postList"><li name="0cd6" id="0cd6" class="graf graf--li graf-after--p">Many errors are made in requirement specifications</li><li name="ace5" id="ace5" class="graf graf--li graf-after--li">Not detect these errors can dramatically increase software costs</li></ul><p name="e605" id="e605" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) The Definition of Software Requirements Specification (SRS)</strong></p><p name="8e81" id="8e81" class="graf graf--p graf-after--p">The final result of the requirements engineering process is a software requirements specification (SRS). This answers the question on,</p><ul class="postList"><li name="b059" id="b059" class="graf graf--li graf-after--p">what the proposed system is intended to do</li></ul><p name="bea6" id="bea6" class="graf graf--p graf-after--li">Instead of,</p><ul class="postList"><li name="f893" id="f893" class="graf graf--li graf-after--p">how the system does it: this is a result of the design of the system</li></ul><p name="1706" id="1706" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) The Definition of Software</strong></p><p name="a990" id="a990" class="graf graf--p graf-after--p">Software is an abstract description of a set of computations that becomes concrete and useful only when we run the software on some hardware in the context of some human activity that it can support. When we say software, what we really mean is a <strong class="markup--strong markup--p-strong">software-intensive system</strong>. It&#39;s the combination of 3 things,</p><ul class="postList"><li name="e5fe" id="e5fe" class="graf graf--li graf-after--p">The <strong class="markup--strong markup--li-strong">software</strong></li><li name="cb3b" id="cb3b" class="graf graf--li graf-after--li">The <strong class="markup--strong markup--li-strong">hardware</strong> on which the software runs</li><li name="bc78" id="bc78" class="graf graf--li graf-after--li">The <strong class="markup--strong markup--li-strong">context</strong> in which the software is used</li></ul><p name="00b8" id="00b8" class="graf graf--p graf-after--li">We usually take hardware and context for granted, but they actually need to be explicitly considered when building a system. Otherwise, we might forget this is all the functionality, and ultimately of the requirements and we might end up with the wrong system.</p><p name="0525" id="0525" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) The Definition of Software Quality</strong></p><p name="0b34" id="0b34" class="graf graf--p graf-after--p">Software quality is not just a function of the software. Instead, it is a function of both the <strong class="markup--strong markup--p-strong">software</strong> and its <strong class="markup--strong markup--p-strong">purpose</strong>. So a software system can be of low quality not only because it does not work well, but also for it does not fulfill its purpose. We can therefore define the quality of software in terms of fitness for purpose.</p><p name="1bca" id="1bca" class="graf graf--p graf-after--p">Identifying the purpose of the software is exactly the goal of requirements engineering, and it is the reason why requirements engineering is such a fundamental activity in the context of software engineering.</p><p name="df4c" id="df4c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Difficulties of Requirement Engineering</strong></p><p name="3e03" id="3e03" class="graf graf--p graf-after--p">In fact, identifying the purpose or defining the requirements of a system is an extremely hard task. It is hard because，</p><ul class="postList"><li name="bb2c" id="bb2c" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Sheer Complexity</strong>: the purpose of most systems is inherently and extreme complex</li><li name="f2fa" id="f2fa" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Subtle Human Purpose</strong>: it is very hard to extract from humans this purpose and make it explicit</li><li name="82ac" id="82ac" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Unstable Requirements</strong>: requirements often change over time</li><li name="680f" id="680f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Stakeholders Issues</strong>: stakeholders often have conflicting goals and requirements</li></ul><p name="f9d7" id="f9d7" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) The Definition of Completeness</strong></p><p name="2f9d" id="2f9d" class="graf graf--p graf-after--p">One bad result from these requirement engineering difficulties is the lack of completeness. <strong class="markup--strong markup--p-strong">Completeness</strong> refers to the fact that it is often extremely difficult to identify all of the requirements. Therefore, it is very difficult to have a complete picture of the purpose of the software.</p><p name="22a8" id="22a8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) The Definition of Pertinence</strong></p><p name="2973" id="2973" class="graf graf--p graf-after--p">Another result has to do with the lack of pertinence. <strong class="markup--strong markup--p-strong">Pertinence</strong> conversely has to do with the relevance of the requirements. To avoid completeness problems developers often end up collecting a lot of irrelevant when not conflicting requirements. And to make things even worse, collecting all of these requirements sometimes doesn&#39;t even solve the completeness issue. There are some possible harms for the irrelevant requirements,</p><ul class="postList"><li name="a378" id="a378" class="graf graf--li graf-after--p">they can introduce inconsistencies</li><li name="40f2" id="40f2" class="graf graf--li graf-after--li">they can waste development resources</li></ul><p name="d660" id="d660" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) The Bottom Line of Requirement Engineering</strong></p><p name="a696" id="a696" class="graf graf--p graf-after--p">Based on our discussion, the bottom line is that gathering an adequate, accurate, complete, and pertinent set of requirements that identify the purpose of a software system is an arduous task.</p><p name="6051" id="6051" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(9) Best Practice for Requirement Engineering</strong></p><p name="22b5" id="22b5" class="graf graf--p graf-after--p">In practice, developers or analysts usually identify a whole bunch of requirements, sometimes the easiest and most obvious ones. They bring those to the stakeholders, and the stakeholders have to read the requirements, understand them, and if they agree, sign off on them.</p><p name="876d" id="876d" class="graf graf--p graf-after--p">However, the problem is that these requirements documents are difficult in general because they are</p><ul class="postList"><li name="4e68" id="4e68" class="graf graf--li graf-after--p">long</li><li name="54b9" id="54b9" class="graf graf--li graf-after--li">unstructured</li><li name="eb4a" id="eb4a" class="graf graf--li graf-after--li">full of information</li><li name="01f6" id="01f6" class="graf graf--li graf-after--li">unpleasant to read</li></ul><p name="91bc" id="91bc" class="graf graf--p graf-after--li">So what happens is that often the stakeholders are short on time and overwhelmed by the amount of information they’re given, and so they give in to the pressure and sign. This is a bit of a dramatization but it&#39;s clear that what we are looking at is not an ideal scenario.</p><p name="9197" id="9197" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(10) Another Definition of Requirement Engineering</strong></p><p name="e5ce" id="e5ce" class="graf graf--p graf-after--p">Before we see how we can form a rigorous and effective requirements engineering process, let’s first see another definition of requirement engineering.</p><blockquote name="75d1" id="75d1" class="graf graf--blockquote graf-after--p">Requirement engineering is <strong class="markup--strong markup--blockquote-strong">a set of activities</strong> concerned with <strong class="markup--strong markup--blockquote-strong">identifying and communicating</strong> the <strong class="markup--strong markup--blockquote-strong">purpose</strong> of a software-intensive system and the <strong class="markup--strong markup--blockquote-strong">context</strong> in which it will be used. Hence, requirement engineering acts as the bridge between the <strong class="markup--strong markup--blockquote-strong">real-world needs</strong> of users, customers, and other <strong class="markup--strong markup--blockquote-strong">constituencies</strong> affected by a software system, and the <strong class="markup--strong markup--blockquote-strong">capabilities and opportunities</strong> afforded by software technologies.</blockquote><p name="c1f6" id="c1f6" class="graf graf--p graf-after--blockquote">Now let’s analyze this definition,</p><ul class="postList"><li name="7fb6" id="7fb6" class="graf graf--li graf-after--p">RE is a set of activities rather than a phase or a stage</li><li name="73c5" id="73c5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Communication</strong> is as important as analysis</li><li name="ea25" id="ea25" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Quality</strong> means fitness-for-purpose</li><li name="b08f" id="b08f" class="graf graf--li graf-after--li">Designers should now the <strong class="markup--strong markup--li-strong">context</strong> (where and how) of the system</li><li name="864c" id="864c" class="graf graf--li graf-after--li">Requirements are partly about what is needed, and partly about what is possible</li><li name="1e36" id="1e36" class="graf graf--li graf-after--li">Constituencies mean that we should identify <strong class="markup--strong markup--li-strong">all the stakeholders </strong>— not just the customers and the users</li></ul><p name="ac75" id="ac75" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(11) The Definition of Requirement</strong></p><p name="e3f6" id="e3f6" class="graf graf--p graf-after--p">At this point, we have talked quite a lot about the requirement, but what is a requirement actually? To define that we’ll use the following diagram which is a classical one,</p><figure name="ba42" id="ba42" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XunNAzU1DC7uMu0XUcWDMg.png" data-width="1592" data-height="308" src="https://cdn-images-1.medium.com/max/800/1*XunNAzU1DC7uMu0XUcWDMg.png"></figure><p name="c6a1" id="c6a1" class="graf graf--p graf-after--figure">At a higher level, this diagram contains two main parts,</p><ul class="postList"><li name="93e6" id="93e6" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">The Domain of the Machine</strong>: the hardware, operating system, libraries, and so on, on which the software will run (normally no direct application in the real world)</li><li name="3e62" id="3e62" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">The Domain of the Application</strong>: a world in which the software will operate (normally a concrete purpose of the real world without any plan)</li></ul><p name="29c5" id="29c5" class="graf graf--p graf-after--li">At a lower level,</p><ul class="postList"><li name="d38e" id="d38e" class="graf graf--li graf-after--p">The machine domain is characterized by computers (i.e. C), which are the hardware devices, and the programs (i.e. P), which are the software running on these devices</li><li name="ae98" id="ae98" class="graf graf--li graf-after--li">The application domain is characterized by domain properties (i.e. D), which are the things that are true of the world anyway whether I am building my system or not, and the requirements (i.e. R), which are things in the world we would like to achieve by delivering the system that we are building</li></ul><p name="1258" id="1258" class="graf graf--p graf-after--li">At the intersection of the application domain and the machine, the domain is what we normally call the <strong class="markup--strong markup--p-strong">specification</strong> (i.e. S), which is often a formal description of what the system that we are building should do to meet the requirements.</p><p name="c098" id="c098" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(12) Two Kinds of Shared Phenomena</strong></p><p name="09d8" id="09d8" class="graf graf--p graf-after--p">As the diagram shows, the specification is written in terms of shared phenomena, which are the things in both the machine domain and the application domain. And we can think about two main kinds of phenomena,</p><ul class="postList"><li name="2e44" id="2e44" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Phenomena I</strong>: events in the real world that the machine can directly sense. These are events happening in the application domain, but the machine can detect them.</li><li name="35e7" id="35e7" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Phenomena II</strong>: actions in the real world that the machine can directly cause. This is something that the machine can make happen and then can have a manifestation in the real world by application domain.</li></ul><p name="5bd1" id="5bd1" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(13) Functional Requirements Vs. Non-Functional Requirements</strong></p><p name="f241" id="f241" class="graf graf--p graf-after--p">Among the requirement that we can collect from the application domain, we need to distinguish between two main types, functional requirements and non-functional requirements.</p><ul class="postList"><li name="465a" id="465a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Functional Requirements: </strong>have to do with the functionality of the system. In general, these kinds of requirements have well-defined satisfaction criteria.</li><li name="8254" id="8254" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Non-Functional Requirements</strong>: refer to a system’s non-functional properties or systems qualities such as security, accuracy, performance, cost — or usability, adaptability, interoperability, reusability, and so on. Unlike functional requirements, non-functional requirements do not always have clear satisfaction criteria. Therefore, we need to refine these requirements so that they become verifiable.</li></ul><p name="fbde" id="fbde" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(14) User Requirements Vs. System Requirements</strong></p><p name="c26f" id="c26f" class="graf graf--p graf-after--p">Another important distinction, when talking about requirements, is that between user and system requirements.</p><ul class="postList"><li name="44d1" id="44d1" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">User Requirements: </strong>requirements that are written for the customers and stakeholders, and are often in natural language, and don’t contain technical details. It’s a way for the analyst, the developers, to communicate with the customers, with the stakeholders.</li><li name="15f4" id="15f4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">System Requirements: </strong>written for developers and contain detailed functional and non-functional requirements which are clearly and more rigorously specified than the user requirements. They must contain enough details so the developers can take them and use them to design and then develop a system.</li></ul><p name="aec8" id="aec8" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(15) Requirement Origins &amp; Sources</strong></p><p name="698a" id="698a" class="graf graf--p graf-after--p">Now, let’s discuss where do requirements actually come from? There are three main origins,</p><ul class="postList"><li name="a93d" id="a93d" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Stakeholders</strong>: anybody who is affected by the system and its functionality (e.g. customers, users, and so on).</li><li name="262f" id="262f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Application Domain</strong>: where should we use this software? What are the constraints and regulations (e.g. banking regulations, school regulations, etc.)?</li><li name="d739" id="d739" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Documentations</strong>: everything else that refers to the functionality of the system we are going to build (e.g. notes, papers, manuals, books, and so on).</li></ul><p name="19b6" id="19b6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(16) Requirement Elicitation Problems</strong></p><p name="9f18" id="9f18" class="graf graf--p graf-after--p">However, extracting requirements from these sources is not a straightforward task. There are many issues involved with the requirements elicitation,</p><ul class="postList"><li name="44ee" id="44ee" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Thin spread of domain knowledge</strong>: knowledge is vague, distributed, and rarely written down. There are often conflicts between the knowledge gathered from different sources.</li><li name="17f0" id="17f0" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Say-do problem</strong>: knowledge is often tacit. Even if the knowledge were more concentrated, people simply find it hard to describe knowledge that they regularly use.</li><li name="735b" id="735b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Limited observability</strong>: the problem owners might be too busy to perform the task that we need to observe, or they might be doing a lot of other things together with the task that we need to observe so that it becomes confusing. In addition, the presence of an observer might change their problem. It is very typical for human subjects to improve or modify an aspect of their behavior, which is being experimentally measured in response to the fact that they know that they’re being studied.</li><li name="0f20" id="0f20" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Biased Information</strong>: the information that we collect might be biased for several reasons. In all the common cases in which the outcome might affect them, people might provide you a different picture from the real one in order to influence you. They might have a hidden agenda, and mislead you, either consciously or unconsciously.</li></ul><p name="608a" id="608a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(17) Traditional Techniques for Requirement Elicitation</strong></p><p name="121b" id="121b" class="graf graf--p graf-after--p">Here are some traditional techniques for requirement elicitation that can be used separately or combined,</p><ul class="postList"><li name="9525" id="9525" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Background Reading</strong>: reading existing documents such as company reports, organizational charts, policy manuals, job descriptions, documentation of existing systems, and so on.</li><li name="ebc6" id="ebc6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Hard Data and Samples</strong>: viewing hard data includes facts and figures such as forms, invoices, financial information, server results, marketing data, and so on.</li><li name="6fff" id="6fff" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Interviews</strong>: interviews can be structured or open-ended based on the purpose. On the positive side, interviews can rich knowledge in depth. On the negative side, an interview requires experience and expertise. If this information is hard to analyze or even irrelevant, it might become useless.</li><li name="3a67" id="3a67" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Surveys</strong>: quickly collect information from a large number of people onsite or remotely. However, surveys tend to severely constrain the information that the user can provide and might miss opportunities to collect unforeseen, relevant information.</li><li name="cac3" id="cac3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Meetings</strong>: summarization of findings and collection of feedback. It is fundamental that they have clearly stated objectives and are planned carefully. This is something that should be quite obvious but doesn’t always happen in practice.</li></ul><p name="da61" id="da61" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(18) Other Techniques for Requirement Elicitation</strong></p><p name="e55d" id="e55d" class="graf graf--p graf-after--p">Besides, there are some other techniques that can be divided mainly into three groups,</p><ul class="postList"><li name="2a51" id="2a51" class="graf graf--li graf-after--p">Collaborative Techniques: like brainstorming</li><li name="cee2" id="cee2" class="graf graf--li graf-after--li">Social Approaches: like ethnographic techniques</li><li name="4c5c" id="4c5c" class="graf graf--li graf-after--li">Cognitive Techniques: leverage cognitive science approaches to discover expert knowledge</li></ul><p name="dbc6" id="dbc6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(19) Modeling Requirements</strong></p><p name="384c" id="384c" class="graf graf--p graf-after--p">Once we collected the required knowledge on the requirements for the system that we’re developing, we need to model it in a structured and clear way. More specifically, when modeling requirements, you need to decide what you want to model and how you want to model it. There are really tons of ways to do this depending on your focus and objectives, and the very first one for you to choose is what to model. Basically, we have the following options,</p><ul class="postList"><li name="9006" id="9006" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Emphasis on characteristics of the enterprise</strong>: model goals and objectives of the company, or its organizational structure, its task and dependencies, and so on.</li><li name="a608" id="a608" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Emphasis on information and behaviors</strong>: concentrate on aspects such as the structure of information, various behavioral views, or maybe the time, or sequencing requirements.</li><li name="8d45" id="8d45" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Emphasis on quality of the system</strong>: focus on the various non-functional properties of the software that are relevant in the context considered (e.g. reliability, robustness, security, and so on).</li></ul><p name="4f24" id="4f24" class="graf graf--p graf-after--li">After deciding what to model in our system, we have to decide how we want to model it. Whether modeling enterprises, information, or quality aspects there are many possible models that we can use to represent it and all these models have advantages and disadvantages, different levels of formality, and different focuses. In this series, we will only focus on expressing the requirements in the following two ways,</p><ul class="postList"><li name="d9c4" id="d9c4" class="graf graf--li graf-after--p">Using <strong class="markup--strong markup--li-strong">natural language</strong>: informal specifications</li><li name="fbb4" id="fbb4" class="graf graf--li graf-after--li">Using <strong class="markup--strong markup--li-strong">UML diagrams</strong>: graphic models</li></ul><p name="12e1" id="12e1" class="graf graf--p graf-after--li">There is also another well-known model called the <strong class="markup--strong markup--p-strong">goal model</strong>. The main idea with the goal model is it starts with the main goal of the system and then keeps refining it by decomposing it into sub-goals.</p><p name="f3d5" id="f3d5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(20) Analyzing Requirements</strong></p><p name="5b87" id="5b87" class="graf graf--p graf-after--p">After having collected and modeled our requirements, we are at the point in which we would like to analyze the requirements to identify the possible problems. Specifically, there are three types of analysis that we can perform,</p><ul class="postList"><li name="e3d2" id="e3d2" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Verification</strong>: in requirements verification, developers will study the requirements to check whether they’re correct, complete, pertinent, consistent, unambiguous, testable, and so on.</li><li name="89d4" id="89d4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Validation</strong>: check whether the collected requirements define the system that the stakeholders really want. Stakeholders may check the requirements directly or interact with a prototype. Surveys, testing, and other techniques can also be used to validate requirements.</li><li name="d560" id="d560" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Risk Analysis</strong>: identify and analyze the main risks involved with the development of the system being considered. We may change the requirements if some requirements are deemed to be too risky to eliminate or address these risks.</li></ul><p name="186e" id="186e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(21) Requirements Prioritization</strong></p><p name="3c78" id="3c78" class="graf graf--p graf-after--p">While collecting, modeling, and analyzing requirements we might realize that the resources (e.g. time, money, manpower) available for the project are not enough to satisfy all of them. Therefore, we need to prioritize them, and this can be done by classifying them in one of the following three classes,</p><ul class="postList"><li name="0bdc" id="0bdc" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Mandatory</strong>: they are must-do things</li><li name="7c0c" id="7c0c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Nice to have</strong>: satisfy them if resources allow</li><li name="bba7" id="bba7" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Superfluous</strong>: maybe in the next release</li></ul><p name="2fd4" id="2fd4" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(22) Interactive Process of Requirement Engineering</strong></p><p name="ade2" id="ade2" class="graf graf--p graf-after--p">Basically, a requirement engineering consists of three main steps,</p><ul class="postList"><li name="32b3" id="32b3" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Elicitation</strong>: extract requirements from various sources</li><li name="04dc" id="04dc" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Modeling</strong>: represent the requirements using one or more notations or formal reasons</li><li name="5dd2" id="5dd2" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Analysis</strong>: identify possible issues with our requirements</li></ul><p name="30fc" id="30fc" class="graf graf--p graf-after--li">But there is actually a 4th step that we kind of mention but not explicitly,</p><ul class="postList"><li name="ba73" id="ba73" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Negotiation</strong>: this can happen between the stakeholders and the developers during which requirements are discussed and modified until an agreement is reached</li></ul><p name="21ac" id="21ac" class="graf graf--p graf-after--li">In practice, we continue to iterate over these four steps gathering a better and better understanding of the requirements.</p><p name="2408" id="2408" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(23) Software Requirement Specification (SRS) Document</strong></p><p name="d45f" id="d45f" class="graf graf--p graf-after--p">Software Requirement Specification document is an important fundamental way to communicate requirements to others. They represent a common ground between analysts and stakeholders because different projects might require different software requirement specifications. So we need to know our context.</p><p name="af8e" id="af8e" class="graf graf--p graf-after--p">In order to have a common format for the SRS document, IEEE defined a standard that divides the document into predefined sections. This is called the IEEE SRS format. It should include the following three main sections,</p><ul class="postList"><li name="50c1" id="50c1" class="graf graf--li graf-after--p">An introduction: purpose, context, and objectives of the project</li><li name="0bf0" id="0bf0" class="graf graf--li graf-after--li">A user requirement definition: user requirements</li><li name="fc73" id="fc73" class="graf graf--li graf-after--li">A system requirement specification: functional and non-functional requirements</li></ul><p name="59d7" id="59d7" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">2. Basic Java Coding and JUnit Assignment</strong></p><p name="1f48" id="1f48" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) GitHub CLI Authorization</strong></p><p name="85f7" id="85f7" class="graf graf--p graf-after--p">We have done this in the last section. If you haven’t finished it yet, it’s okay to follow the steps. Use GitHub CLI to authorize git,</p><pre name="844e" id="844e" class="graf graf--pre graf-after--p">$ gh auth login</pre><p name="a5cc" id="a5cc" class="graf graf--p graf-after--pre">Choose,</p><ul class="postList"><li name="ca81" id="ca81" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">What account do you want to log into?</strong> GitHub Enterprise Server</li><li name="6fee" id="6fee" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">GHE hostname: </strong>github.gatech.edu</li><li name="7d4e" id="7d4e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">How would you like to authenticate?</strong> Login with a web browser</li></ul><p name="3da9" id="3da9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Build the Environment</strong></p><p name="a7ee" id="a7ee" class="graf graf--p graf-after--p">Go to your local workspace. Clone the latest version of the remote repository, then go to the root directory in the local repo.</p><pre name="a228" id="a228" class="graf graf--pre graf-after--p">$ git clone https://github.gatech.edu/gt-omscs-se-2021fall/6300Fall21&lt;GT username&gt;.git<br>$ cd 6300Fall21&lt;GT username&gt;</pre><p name="8964" id="8964" class="graf graf--p graf-after--pre">Download <code class="markup--code markup--p-code">assignment3.tar.gz</code> from this <a href="https://drive.google.com/file/d/1g-UQC5c5q5IMjjmnTmHRHvnWdhsT6BDC/view" data-href="https://drive.google.com/file/d/1g-UQC5c5q5IMjjmnTmHRHvnWdhsT6BDC/view" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">link</a>, and then extract this archive in the root directory of the local repo.</p><pre name="de38" id="de38" class="graf graf--pre graf-after--p">$ tar -xf assignment3.tar.gz</pre><p name="3415" id="3415" class="graf graf--p graf-after--pre">this will create a directory called <code class="markup--code markup--p-code">Assignment3</code> and several subdirectories. Thereafter, we will refer to the directory <code class="markup--code markup--p-code">Assignment3</code> in your local repo as <code class="markup--code markup--p-code">&lt;dir&gt;</code>.</p><ul class="postList"><li name="a6dc" id="a6dc" class="graf graf--li graf-after--p">Directory <code class="markup--code markup--li-code">&lt;dir&gt;/src</code> contains, in a suitable directory, the Java interface <code class="markup--code markup--li-code">edu.gatech.seclass.MyStringInterface</code>. It also contains an exception class <code class="markup--code markup--li-code">edu.gatech.seclass.MyIndexOutOfBoundsException</code>, which is used by the interface.</li></ul><pre name="dee9" id="dee9" class="graf graf--pre graf-after--li">$ ls Assignment3/src/edu/gatech/seclass/<br>MyIndexOutOfBoundsException.java MyStringInterface.java</pre><ul class="postList"><li name="de8f" id="de8f" class="graf graf--li graf-after--pre">Directory <code class="markup--code markup--li-code">&lt;dir&gt;/test</code> contains, in a suitable directory, a template JUnit test class <code class="markup--code markup--li-code">edu.gatech.seclass.MyStringTest</code>.</li></ul><pre name="3c7a" id="3c7a" class="graf graf--pre graf-after--li">$ ls Assignment3/test/edu/gatech/seclass/<br>MyStringTest.java</pre><p name="e73a" id="e73a" class="graf graf--p graf-after--pre">Push an initial version of <code class="markup--code markup--p-code">Assignment3</code> to the remote repo. Note that you may need to force add the <code class="markup--code markup--p-code">jar</code> files because they are typically excluded by <code class="markup--code markup--p-code">.gitignore</code> file,</p><pre name="68d1" id="68d1" class="graf graf--pre graf-after--p">$ git add -f .<br>$ git commit -m &quot;Initialize Assignment3&quot;<br>$ git push</pre><p name="d25b" id="d25b" class="graf graf--p graf-after--pre">Then, we should open the <code class="markup--code markup--p-code">Assignment3</code> directory as a project in IntelliJ to edit the code.</p><p name="7352" id="7352" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">implements</strong></code><strong class="markup--strong markup--p-strong"> Keyword</strong></p><p name="4c84" id="4c84" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">implements</code> keyword should be used in the Java class <code class="markup--code markup--p-code">MyString</code> for indicating the relationship to the interface.</p><p name="7cb5" id="7cb5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Edit JUnit Tests</strong></p><ul class="postList"><li name="1ddf" id="1ddf" class="graf graf--li graf-after--p">Test for cases</li></ul><pre name="5091" id="5091" class="graf graf--pre graf-after--li">assertEquals(&lt;value&gt;, &lt;called function&gt;);</pre><ul class="postList"><li name="7aba" id="7aba" class="graf graf--li graf-after--pre">Test for exceptions</li></ul><pre name="86ee" id="86ee" class="graf graf--pre graf-after--li">@Test(expected = &lt;exception class name&gt;.class</pre><p name="7f6a" id="7f6a" class="graf graf--p graf-after--pre">Make sure to submit only the test cases in the template and do not add extra tests.</p><p name="ae58" id="ae58" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Run JUnit Tests</strong></p><p name="1d24" id="1d24" class="graf graf--p graf-after--p">Right-click on the name tag for the testing file, and then select <code class="markup--code markup--p-code">Run &#39;MyStringTest&#39;</code> . If all the test pass locally, we are expected to see,</p><figure name="53c7" id="53c7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*4qtjvF3IgN7E9maHgVgdtw.png" data-width="1460" data-height="158" src="https://cdn-images-1.medium.com/max/800/1*4qtjvF3IgN7E9maHgVgdtw.png"></figure><p name="59b5" id="59b5" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(6) Submission</strong></p><p name="c1b9" id="c1b9" class="graf graf--p graf-after--p">To submit our solution, we should,</p><ul class="postList"><li name="cc7c" id="cc7c" class="graf graf--li graf-after--p">Retrieve the commit ID by</li></ul><pre name="16e4" id="16e4" class="graf graf--pre graf-after--li">$ git log -1<br>commit ...</pre><p name="2e14" id="2e14" class="graf graf--p graf-after--pre">and the commit ID is the long hexadecimal number after <code class="markup--code markup--p-code">commit</code>.</p><ul class="postList"><li name="ec04" id="ec04" class="graf graf--li graf-after--p">Create a file named <code class="markup--code markup--li-code">submission.txt</code> . The first line in this file should be your github username, and the second line should be the commit ID for your submission.</li><li name="cb7a" id="cb7a" class="graf graf--li graf-after--li">Submit this assignment to Gradescope.</li></ul><p name="5e53" id="5e53" class="graf graf--p graf-after--li graf--trailing">Note that we may have to use <code class="markup--code markup--p-code">$ git add -f lib/*</code> for pushing <code class="markup--code markup--p-code">.jar</code> files.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/38b39f63c89c"><time class="dt-published" datetime="2021-09-09T19:55:35.970Z">September 9, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/software-development-process-4-requirement-engineering-and-java-programming-38b39f63c89c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>