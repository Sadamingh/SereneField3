<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Software Development Process 11 | Software Verification and Testings</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Software Development Process 11 | Software Verification and Testings</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Software Development Process
</section>
<section data-field="body" class="e-content">
<section name="20fc" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="39f2" id="39f2" class="graf graf--h3 graf--leading graf--title">Software Development Process 11 | <strong class="markup--strong markup--h3-strong">Software Verification and Testings</strong></h3><figure name="5c53" id="5c53" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*e5kIRmQZcujS-i_e.png" data-width="700" data-height="328" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*e5kIRmQZcujS-i_e.png"></figure><ol class="postList"><li name="7fde" id="7fde" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Software Verification</strong></li></ol><p name="5003" id="5003" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) Data of Buggy Software</strong></p><p name="8bc5" id="8bc5" class="graf graf--p graf-after--p">In fact, a federal report from a few years ago assessed that software bugs are costing the US economy $60 billion every year. In addition, studies have shown that software contains on average 1~5 bugs every 1000 lines of code. So, building 100% correct mass-market software is just impossible. This means that we have to verify the software as much as possible and we will discuss different alternative ways of very fine software systems with particular attention to the most common type of verification, which is software testing.</p><p name="8366" id="8366" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Definition of Failure</strong></p><p name="fe5d" id="fe5d" class="graf graf--p graf-after--p">A failure is an observable <strong class="markup--strong markup--p-strong">incorrect behavior</strong> of the software. It is conceptually related to the behavior of the program, rather than its code.</p><p name="fbdf" id="fbdf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Definition of Fault</strong></p><p name="c06b" id="c06b" class="graf graf--p graf-after--p">A fault (aka. bug) is an <strong class="markup--strong markup--p-strong">incorrect piece of code</strong>. In other words, a fault is related to the code and is a necessary, but not sufficient</p><p name="bad9" id="bad9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) The Definition of Error</strong></p><p name="e0b1" id="e0b1" class="graf graf--p graf-after--p">An error is the cause of a fault. It is usually a <strong class="markup--strong markup--p-strong">human error</strong>, which can be conceptual, for example, a typo or something along those lines.</p><p name="5a31" id="5a31" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Software Verification Approaches</strong></p><p name="0ecc" id="0ecc" class="graf graf--p graf-after--p">There are several ways to verify a software system. Among those, we will discuss four mainstream approaches.</p><ul class="postList"><li name="dece" id="dece" class="graf graf--li graf-after--p">Testing (aka. Dynamic Verification): Software testing is the most popular and most used approach in the industry.</li><li name="5fdb" id="5fdb" class="graf graf--li graf-after--li">Static Verification</li><li name="c5f1" id="c5f1" class="graf graf--li graf-after--li">Inspections</li><li name="86de" id="86de" class="graf graf--li graf-after--li">Formal Proofs of Correctness</li></ul><p name="5622" id="5622" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(6) Software Testing (aka. Dynamic Verification)</strong></p><p name="f349" id="f349" class="graf graf--p graf-after--p">Testing a system means exercising the system to try to make it fail. More precisely, let’s consider a program. The <strong class="markup--strong markup--p-strong">input domain</strong> is the set of all the possible inputs for the program, and its <strong class="markup--strong markup--p-strong">output domain</strong> is a set of all the possible corresponding outputs. Given this context, we can define what a test case is.</p><p name="ee3f" id="ee3f" class="graf graf--p graf-after--p">A <strong class="markup--strong markup--p-strong">test case</strong> is a pair that consists of input <code class="markup--code markup--p-code">i</code> from the input domain <code class="markup--code markup--p-code">D</code>, and then, expected output <code class="markup--code markup--p-code">o</code> from the output domain <code class="markup--code markup--p-code">O</code>. And <code class="markup--code markup--p-code">o</code> is the element in the output domain <code class="markup--code markup--p-code">O</code> that a correct software would produce when run against <code class="markup--code markup--p-code">i</code>.</p><pre name="3a89" id="3a89" class="graf graf--pre graf-after--p">Test Case: {i ∈ D, o ∈ O}</pre><p name="aad6" id="aad6" class="graf graf--p graf-after--pre">We can also define the concept of the <strong class="markup--strong markup--p-strong">test suite</strong>, which is a set of test cases.</p><p name="7e38" id="7e38" class="graf graf--p graf-after--p">The benefit of this approach is that,</p><ul class="postList"><li name="013d" id="013d" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">No false positives</strong>: when testing generates a failure, that means that there is an actual problem in the code.</li></ul><p name="e76b" id="e76b" class="graf graf--p graf-after--li">The downside is that,</p><ul class="postList"><li name="5876" id="5876" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Highly incomplete</strong>: Even in the best scenario, testing can consider only a tiny fraction of the problem domain, and therefore a tiny fraction of the program’s behavior.</li></ul><p name="637b" id="637b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Static Verification</strong></p><p name="b94e" id="b94e" class="graf graf--p graf-after--p">Static verification tries to identify specific classes of problems in the program, such as null pointer dereferences. Unlike testing, what it does is that it does not just consider individual inputs, it instead considers all possible inputs for the program. So it considers in a sense all possible executions of the program and all possible behaviors of the program, that’s why we say that verification is <strong class="markup--strong markup--p-strong">complete</strong>.</p><p name="2cba" id="2cba" class="graf graf--p graf-after--p">The benefit of this approach is that,</p><ul class="postList"><li name="d8a6" id="d8a6" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Considers all program behaviors</strong></li></ul><p name="406a" id="406a" class="graf graf--p graf-after--li">The downside is that,</p><ul class="postList"><li name="9565" id="9565" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Generate false positives</strong>: Due to the limitation of this kind of analysis and due to infeasibility issues, static verification considers not only all the possible behaviors but also some impossible behaviors. For example, it might report a possible NULL pointer to the reference that cannot actually occur in practice.</li></ul><p name="0cb0" id="0cb0" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) Inspections</strong></p><p name="5bcf" id="5bcf" class="graf graf--p graf-after--p">Inspections are also called <strong class="markup--strong markup--p-strong">reviews</strong> or <strong class="markup--strong markup--p-strong">walkthroughs</strong>. And unlike the previous techniques, inspections are a human-intensive activity. More precisely, they are a <strong class="markup--strong markup--p-strong">manual and group activity</strong> in which several people from the organization that developed the software, look at the code or other artifacts developed during the software production and try to identify defects in these artifacts. Interestingly, inspections have been shown to be quite effective in practice and that’s the reason why they’re used quite widely in the industry.</p><p name="f82b" id="f82b" class="graf graf--p graf-after--p">The benefit of this approach is that,</p><ul class="postList"><li name="2d2a" id="2d2a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Systematic and thorough</strong>: Inspections are done in a rigorous way.</li></ul><p name="3977" id="3977" class="graf graf--p graf-after--li">The downside is that,</p><ul class="postList"><li name="4bfa" id="4bfa" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Informal and subjective</strong>: They are nevertheless a manual process or a human process. The result may depend on the specific people who perform the inspection.</li></ul><p name="9701" id="9701" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(9) Formal Proof</strong></p><p name="78e5" id="78e5" class="graf graf--p graf-after--p">Given a software specification or a formal specification, so a document that formally defines and specifies the expected behavior of the program. A formal proof of correctness proves that the program is <strong class="markup--strong markup--p-strong">verified</strong> and actually implements the program <strong class="markup--strong markup--p-strong">specification</strong>. It does that through a sophisticated mathematical analysis of the specifications and of the code.</p><p name="ae51" id="ae51" class="graf graf--p graf-after--p">The benefit of this approach is that,</p><ul class="postList"><li name="5fa7" id="5fa7" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Provide strong guarantees</strong>: They can guarantee that the program is correct, which is not something that any of the other approaches can do, including static verification.</li></ul><p name="a862" id="a862" class="graf graf--p graf-after--li">But the main limitation of formal proofs is that,</p><ul class="postList"><li name="0b6a" id="0b6a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Complex and expensive</strong>: they need a form of specification or a complete mathematical description of the expected behavior of the whole program. Unfortunately, such a specification is rarely available, and it is very complex to build one. In addition, it is also very complex, and possibly expensive, to prove that the program corresponds to a specification. That is a process that requires strong mathematical skills and, therefore, a very specialized personnel.</li></ul><p name="ea5c" id="ea5c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">2. Testing</strong></p><p name="28fd" id="28fd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Definition of Testing</strong></p><p name="0482" id="0482" class="graf graf--p graf-after--p">As we have mentioned earlier, testing means executing the program on a <strong class="markup--strong markup--p-strong">tiny</strong> <strong class="markup--strong markup--p-strong">sample</strong> of the input domain, which is all the possible input data. There are two important aspects of testing,</p><ul class="postList"><li name="dfc7" id="dfc7" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Dynamic Technique</strong>: the program must be executed in order to perform testing</li><li name="8272" id="8272" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Optimistic Approximation</strong>: the program under test is exercised with a very small subset of all the possible inputs as we just said. And this is done under the assumption that the behavior with any other input is <strong class="markup--strong markup--li-strong">consistent</strong> with the behavior shown for the selected subset of input data. And that is why it is an optimistic approach.</li></ul><p name="4a5a" id="4a5a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) Testing Granularity Levels</strong></p><p name="f172" id="f172" class="graf graf--p graf-after--p">There are several granularity levels for the developer’s testing, which means the tests are performed within the testing organization, or by somebody who is doing like third-party testers on behalf of the testing organizations. For example,</p><ul class="postList"><li name="f0ac" id="f0ac" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Unit Testing</strong>: the testing of the individual units or modules in isolation.</li><li name="e1cd" id="e1cd" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Integration Testing</strong>: Integration testing is the testing of the interactions among different modules and it can be performed according to different strategies depending on the order in which the modules are integrated and on whether we integrate one module at a time or multiple modules together, all at once.</li><li name="a1d4" id="a1d4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">System Testing</strong>: System testing is the testing of the complete system and it includes both functional and non-functional testing. System testing includes both <strong class="markup--strong markup--li-strong">functional</strong> and <strong class="markup--strong markup--li-strong">non-functional testing</strong>.</li><li name="6e53" id="6e53" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Functional Testing</strong>: Functional tests are the test that aims to verify the functionality provided by the system.</li><li name="7327" id="7327" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Non-functional Testing</strong>: Conversely, non-functional testings are the ones that target, surprisingly, no functional properties of the system. For example, the non-functional tests will include performance tests, load tests, robustness tests. The aim is to assess different qualities of the system such as reliability, maintainability, usability, etc.</li><li name="9128" id="9128" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Acceptance Testing</strong>: The validation of the software against the customer requirements. So this is the testing that makes sure that the system does what the customer wants it to do.</li><li name="a08f" id="a08f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Regression Testing</strong>: Regression testing is the type of testing or retesting, that we perform every time that we change our system and we need to make sure that the changes behave as intended and that the unchanged code is not negatively affected by the modifications. The <strong class="markup--strong markup--li-strong">regression errors</strong> are parts of the code that aren’t related to the changes, are actually affected by the changes, and start misbehaving.</li></ul><p name="ee21" id="ee21" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Alpha Testing Vs. Beta Testing</strong></p><p name="3f47" id="3f47" class="graf graf--p graf-after--p">There are two other kinds of testing that are also related to testing phases, and these are<strong class="markup--strong markup--p-strong"> alpha</strong> and <strong class="markup--strong markup--p-strong">beta</strong> testing.</p><ul class="postList"><li name="1fa8" id="1fa8" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Alpha testing</strong> is the testing performed by distributing a software system ready to be released to <strong class="markup--strong markup--li-strong">a set of users that are internal</strong> <strong class="markup--strong markup--li-strong">to the organization</strong> that developed the software. So you can consider these users as <a href="https://www.theguardian.com/science/2005/aug/25/thisweekssciencequestions1" data-href="https://www.theguardian.com/science/2005/aug/25/thisweekssciencequestions1" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">guinea pigs</a> that will use an early version of the code and will likely discover errors that escaped testing and will have made it to the field if not caught.</li><li name="31b5" id="31b5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Beta testing</strong> is the next step after alpha testing, in which the software is released to a <strong class="markup--strong markup--li-strong">selected subset of users outside your organization</strong>. And also, in this case, the users are likely to discover latent errors in the code before it is officially released to the broader user population, so before we have an actual product release.</li></ul><p name="9fd5" id="9fd5" class="graf graf--p graf-after--li">The reason why we conduct alpha testings rather a one-step beta testing is that alpha testing is performed to iron out the very obvious issues that still escape testing. And the rationale is that alpha testers have a higher tolerance for problems than beta testers, who expect a mostly working system.</p><p name="3e1f" id="3e1f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(4) Black Box Testing Vs. White Box Testing</strong></p><p name="6e0d" id="6e0d" class="graf graf--p graf-after--p">Now let’s see an overview of the black-box testing and the white-box testing, and we will talk more about them in the following series.</p><ul class="postList"><li name="9047" id="9047" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Black-Box Testing</strong>: Instead of looking inside the software, we just going to look at the description of the software. So this is the testing that is based on a description of the software, which is what we normally call the specification for the software. And what black box testing tries to do is to cover as much<strong class="markup--strong markup--li-strong"> specified behavior</strong> as possible, and the main limitation of black box testing and the reason why this is complimentary to white-box testing is that it cannot reveal errors due to implementation details.</li><li name="f609" id="f609" class="graf graf--li graf-after--li graf--trailing"><strong class="markup--strong markup--li-strong">White-Box Testing</strong>: Conversely, white-box testing looks at the codeand uses this information to perform the testing. So white-box testing is based on the code, its goal is to cover as much <strong class="markup--strong markup--li-strong">coded behavior</strong> in this case, as possible, and its limitation is that unlike black-box testing, it can’t reveal errors due to missing paths.</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/3d7f02e7d088"><time class="dt-published" datetime="2021-10-24T17:29:24.107Z">October 24, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/software-development-process-11-software-verification-and-testings-3d7f02e7d088" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>