<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Computer Systems Experiments 20 | Modular GPIO Design</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Computer Systems Experiments 20 | Modular GPIO Design</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Computer Systems Experiments
</section>
<section data-field="body" class="e-content">
<section name="3592" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c0d4" id="c0d4" class="graf graf--h3 graf--leading graf--title">Computer Systems Experiments 20 | Modular GPIO Design</h3><figure name="f0ec" id="f0ec" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*HvUAOGbg_uprZvlW.png" data-width="1530" data-height="1104" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*HvUAOGbg_uprZvlW.png"></figure><p name="0882" id="0882" class="graf graf--p graf-after--figure">In the previous experiments, we have used the pointers to set and clear values. However, the pointers are not easy to use and we may find ourselves debugging for a long time. So in this experiment, we are going to construct a GPIO model for us so that we can develop useful functions and also reuse the code for the other experiments.</p><p name="9797" id="9797" class="graf graf--p graf-after--p">To start with this experiment, we have to pull the starter code from the <code class="markup--code markup--p-code">clock-starter</code> <a href="https://github.com/Sadamingh/ComputerSysE/tree/main/clock-starter" data-href="https://github.com/Sadamingh/ComputerSysE/tree/main/clock-starter" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">repo</a>. In this repo, you can find <code class="markup--code markup--p-code">Makefile</code> that is used for compiling and a <code class="markup--code markup--p-code">src</code> folder that contains our starter code.</p><p name="fe7a" id="fe7a" class="graf graf--p graf-after--p">In the <code class="markup--code markup--p-code">src</code> folder, you can find 4 folders,</p><ul class="postList"><li name="c3f7" id="c3f7" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">apps</code> contains a file named <code class="markup--code markup--li-code">clock.c</code> that we are going to implement in the following experiments.</li><li name="3252" id="3252" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">boot</code> contains three files: <code class="markup--code markup--li-code">cstart.c</code> , <code class="markup--code markup--li-code">start.s</code> , and <code class="markup--code markup--li-code">memmap</code> . The <code class="markup--code markup--li-code">memmap</code> the file is used by the linker when building the program and <code class="markup--code markup--li-code">start.s</code> and <code class="markup--code markup--li-code">cstart.c</code> provide the minimum startup to set up a C program to run in the bare metal environment. Feel free to look into the files now to get a sneak preview, but don’t worry if you don’t fully understand them yet. We will discuss them in more detail soon.</li><li name="0f5c" id="0f5c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">lib</code> contains three files: <code class="markup--code markup--li-code">gpio.c</code> , <code class="markup--code markup--li-code">abort.c</code> , and <code class="markup--code markup--li-code">timer.c</code> . The file <code class="markup--code markup--li-code">gpio.c</code> is the file that we are going to implement in this experiment and the file <code class="markup--code markup--li-code">timer.c</code> is the file for the next experiment. The <code class="markup--code markup--li-code">abort.c</code> file is used for asserting the execution of the test.</li><li name="2ea7" id="2ea7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">tests</code> contains the testing file <code class="markup--code markup--li-code">test_gpio_timer.c</code> and in this experiment, we are going to configure this file in order to add more tests.</li></ul><p name="5b37" id="5b37" class="graf graf--p graf-after--li">The direction file of this experiment is the header file of the <code class="markup--code markup--p-code">gpio.c</code> , which is named <code class="markup--code markup--p-code">gpio.h</code> . You can find this file from the environment folder. The path to <code class="markup--code markup--p-code">gpio.h</code> on my computer is,</p><pre name="5dc8" id="5dc8" class="graf graf--pre graf-after--p">~/ComputerSysE/environment/include/gpio.h</pre><p name="4e0a" id="4e0a" class="graf graf--p graf-after--pre">Now, let’s start. The first operations we are going to implement are <code class="markup--code markup--p-code">gpio_set_function</code> and <code class="markup--code markup--p-code">gpio_get_function</code>. These operations use the <code class="markup--code markup--p-code">FSEL</code> device registers to configure the mode of a GPIO pin.</p><p name="c0e8" id="c0e8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">0. Testing the result</strong></p><p name="6010" id="6010" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">assert()</code> function in the testing file <code class="markup--code markup--p-code">test_gpio_timer.c</code> drives the red and green LEDs on the Pi as a simple status indicator. If an assertion fails, the program halts and blinks the red LED (for me, it is not blinking but shining) of doom. If all asserts pass and the program finishes normally and the green LED of happiness will turn on. Your goal is to make that little green light shine. Here is a reference table for a quick check,</p><figure name="8890" id="8890" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*sjW9xg3zTi751pLO8vrnqQ.png" data-width="1644" data-height="372" src="https://cdn-images-1.medium.com/max/800/1*sjW9xg3zTi751pLO8vrnqQ.png"></figure><p name="4767" id="4767" class="graf graf--p graf-after--figure">To test our result, we have to use the command,</p><pre name="ab1d" id="ab1d" class="graf graf--pre graf-after--p">$ make test</pre><ol class="postList"><li name="7cd5" id="7cd5" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">gpio_set_function</strong></code><strong class="markup--strong markup--li-strong"> Implementation</strong></li></ol><p name="c03f" id="c03f" class="graf graf--p graf-after--li">First of all, we have to make sure that the parameter <code class="markup--code markup--p-code">pin</code> and <code class="markup--code markup--p-code">function</code> are all valid. We can check values by,</p><pre name="4a52" id="4a52" class="graf graf--pre graf-after--p">if (!(pin &gt;= GPIO_PIN_FIRST &amp;&amp; pin &lt;= GPIO_PIN_LAST)) return;<br>if (!(function &gt;= GPIO_FUNC_INPUT &amp;&amp; function &lt;= GPIO_FUNC_ALT3)) return;</pre><p name="4197" id="4197" class="graf graf--p graf-after--pre">Or, we can also do,</p><pre name="566e" id="566e" class="graf graf--pre graf-after--p">if (pin &lt; GPIO_PIN_FIRST || pin &gt; GPIO_PIN_LAST) return;<br>if (function &lt; GPIO_FUNC_INPUT || function &gt; GPIO_FUNC_ALT3) return;</pre><p name="165b" id="165b" class="graf graf--p graf-after--pre">Note that the upper bound condition of the <code class="markup--code markup--p-code">function</code> parameter is <code class="markup--code markup--p-code">GPIO_FUNC_ALT3</code> instead of <code class="markup--code markup--p-code">GPIO_FUNC_ALT5</code>. You can find form the <code class="markup--code markup--p-code">gpio.h</code> that <code class="markup--code markup--p-code">GPIO_FUNC_ALT3 = 7</code> and <code class="markup--code markup--p-code">GPIO_FUNC_ALT5 = 2</code> .</p><p name="eece" id="eece" class="graf graf--p graf-after--p">Then, we have to find the FSEL register we would like to assign. We can get a pointer to the target FSEL register based on the value of <code class="markup--code markup--p-code">pin</code> .</p><pre name="47e7" id="47e7" class="graf graf--pre graf-after--p">volatile unsigned int *FSEL = FSEL_BASE + (pin / 10);</pre><p name="7ef6" id="7ef6" class="graf graf--p graf-after--pre">Note that,</p><pre name="99c6" id="99c6" class="graf graf--pre graf-after--p">FSEL_BASE + (pin / 10)</pre><p name="1545" id="1545" class="graf graf--p graf-after--pre">doesn’t mean to add <code class="markup--code markup--p-code">pin/10</code> directly. When we add a <code class="markup--code markup--p-code">int</code> value to a <code class="markup--code markup--p-code">pointer</code> variable, it actually follows the rule of,</p><pre name="9fb3" id="9fb3" class="graf graf--pre graf-after--p">(unsigned int *) ((int) FSEL_BASE + (pin / 10) * sizeof(unsigned int))</pre><p name="2226" id="2226" class="graf graf--p graf-after--pre">In this case, the size of an unsigned variable is 4, so we don&#39;t have to multiply 4 to <code class="markup--code markup--p-code">pin / 10</code> .</p><p name="cb18" id="cb18" class="graf graf--p graf-after--p">The following question can be a little bit tricky. How can we set the value of the given pin without impacting the other pin functions? Let’s, first of all, try. the OR operation. For example, if we want to change a function from <code class="markup--code markup--p-code">0b001</code> to <code class="markup--code markup--p-code">0b111</code> ,</p><pre name="8fb6" id="8fb6" class="graf graf--pre graf-after--p">  Origin: 0000 0000 0000 1000<br>Function:             11 1<br>  Target: 0000 0000 0011 1000</pre><p name="f25f" id="f25f" class="graf graf--p graf-after--pre">Okay, we can find out it works well in this case, but to think about another example. Let’s say we would like to change <code class="markup--code markup--p-code">0b111</code> to <code class="markup--code markup--p-code">0b001</code> , then</p><pre name="9401" id="9401" class="graf graf--pre graf-after--p">  Origin: 0000 0000 0011 1000<br>Function:             00 1<br>  Target: 0000 0000 0011 1000</pre><p name="73a5" id="73a5" class="graf graf--p graf-after--pre">the OR operation no longer works. The same situation happens to the AND operation, so we can not achieve our goal merely by a single operation. Here, we are going to introduce the mask method. For any of the given origin, let’s first clear the target pin function to <code class="markup--code markup--p-code">000</code> without impacting the other functions (by a mask), and then we can use the OR operation to assign the value. To use this method, let’s first calculate the offset value of our given pin by,</p><pre name="9d33" id="9d33" class="graf graf--pre graf-after--p">int offset = (pin % 10) * 3;</pre><p name="df3f" id="df3f" class="graf graf--p graf-after--pre">Then, we can use our method to reset the value.</p><pre name="4d2e" id="4d2e" class="graf graf--pre graf-after--p">*FSEL = *FSEL &amp; ~(0b111 &lt;&lt; offset);<br>*FSEL = *FSEL | (function &lt;&lt; offset);</pre><p name="1b31" id="1b31" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">gpio_get_function</strong></code><strong class="markup--strong markup--p-strong"> Implementation</strong></p><p name="627a" id="627a" class="graf graf--p graf-after--p">Again, we have to make sure the <code class="markup--code markup--p-code">pin</code> is valid,</p><pre name="007c" id="007c" class="graf graf--pre graf-after--p">if (!(pin &gt;= GPIO_PIN_FIRST &amp;&amp; pin &lt;= GPIO_PIN_LAST)) return GPIO_INVALID_REQUEST;</pre><p name="a347" id="a347" class="graf graf--p graf-after--pre">Note that we have to return <code class="markup--code markup--p-code">GPIO_INVALID_REQUEST</code> when the <code class="markup--code markup--p-code">pin</code> is not valid. We can extract the function of a pin by its offset value and then extract the last three bits of the result after a right shifting,</p><pre name="9736" id="9736" class="graf graf--pre graf-after--p">return (*FSEL &gt;&gt; offset) &amp; 0b111;</pre><p name="2c0b" id="2c0b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">gpio_write</strong></code><strong class="markup--strong markup--p-strong"> Implementation</strong></p><p name="419f" id="419f" class="graf graf--p graf-after--p">Because we are using the SET register, the offset is no longer calculated by <code class="markup--code markup--p-code">(pin%10)*3</code> . Instead, it can be calculated by,</p><pre name="8c63" id="8c63" class="graf graf--pre graf-after--p">int offset = pin % 32;</pre><p name="53bb" id="53bb" class="graf graf--p graf-after--pre">When <code class="markup--code markup--p-code">value</code> is 1, that means we have to set the value of the <code class="markup--code markup--p-code">SET</code> register. When <code class="markup--code markup--p-code">value</code> is 0, we have to set the value of the <code class="markup--code markup--p-code">CLR</code> register. We can use a conditioned structure for this,</p><pre name="2567" id="2567" class="graf graf--pre graf-after--p">if (value) {<br>   volatile unsigned int *reg = SET_BASE + (pin / 32);<br>   *reg = (1 &lt;&lt; offset);<br>}<br>else {<br>   volatile unsigned int *reg = CLR_BASE + (pin / 32);<br>   *reg = (1 &lt;&lt; offset);<br>}</pre><p name="df82" id="df82" class="graf graf--p graf-after--pre">Note that we can not write the program like,</p><pre name="f5f6" id="f5f6" class="graf graf--pre graf-after--p">if (value) {<br>   volatile unsigned int *reg = SET_BASE + (pin / 32);<br>}<br>else {<br>   volatile unsigned int *reg = CLR_BASE + (pin / 32);<br>}<br>*reg = (1 &lt;&lt; offset);</pre><p name="d1a2" id="d1a2" class="graf graf--p graf-after--pre">Because this function will not know the <code class="markup--code markup--p-code">reg</code> variable outside the <code class="markup--code markup--p-code">{}</code> sign.</p><p name="28a7" id="28a7" class="graf graf--p graf-after--p">Also, we can directly use <code class="markup--code markup--p-code">1 &lt;&lt; offset</code> and there is no need to worry about the impact of the other pins. This is because we can only set the output of a pin to HIGH by <code class="markup--code markup--p-code">SET</code> so <code class="markup--code markup--p-code">0</code> will not influence the other outputs.</p><p name="f722" id="f722" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">gpio_read</strong></code><strong class="markup--strong markup--p-strong"> Implementation</strong></p><p name="2163" id="2163" class="graf graf--p graf-after--p">It is quite similar to read from the function. To read from a pin, the pin should be set to <code class="markup--code markup--p-code">input</code> (we don’t have to check this) and we should read from the <code class="markup--code markup--p-code">LEV</code> register. The level of a pin is only the last bit after offsetting,</p><pre name="73c6" id="73c6" class="graf graf--pre graf-after--p">return (*LEV &gt;&gt; offset) &amp; 0b1;</pre><p name="8bbe" id="8bbe" class="graf graf--p graf-after--pre">In conclusion, the overall program <code class="markup--code markup--p-code">gpio.c</code> can be found in my <a href="https://github.com/Sadamingh/ComputerSysE/blob/main/clock/src/lib/gpio.c" data-href="https://github.com/Sadamingh/ComputerSysE/blob/main/clock/src/lib/gpio.c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">repo</a>.</p><p name="5cb5" id="5cb5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">5. Testing the result</strong></p><p name="92cb" id="92cb" class="graf graf--p graf-after--p">To test our result, we have to uncomment the <code class="markup--code markup--p-code">test_gpio_set_get_function();</code> and <code class="markup--code markup--p-code">test_gpio_read_write();</code> in the <code class="markup--code markup--p-code">main</code> function of the testing file <code class="markup--code markup--p-code">test_gpio_timer.c</code> ,</p><pre name="3105" id="3105" class="graf graf--pre graf-after--p">void main(void) {<br>    test_gpio_set_get_function();<br>    test_gpio_read_write();<br>    // test_timer();<br>}</pre><p name="cbc9" id="cbc9" class="graf graf--p graf-after--pre">Also, the tests in the function <code class="markup--code markup--p-code">test_gpio_set_get_function()</code> can not cover all the cases. We can add the following assertions to test for the integrity of the features,</p><pre name="1709" id="1709" class="graf graf--pre graf-after--p">// Confirm setting a GPIO pin to alternate function modes, <br>// not just input or output<br>// test 1<br>gpio_set_function(GPIO_PIN2, GPIO_FUNC_INPUT);<br>assert( gpio_get_function(GPIO_PIN2) == GPIO_FUNC_INPUT );<br>// test 2<br>gpio_set_function(GPIO_PIN2, GPIO_FUNC_ALT5);<br>assert( gpio_get_function(GPIO_PIN2) == GPIO_FUNC_ALT5 );<br>// test 3<br>gpio_set_function(GPIO_PIN2, GPIO_FUNC_ALT0);<br>assert( gpio_get_function(GPIO_PIN2) == GPIO_FUNC_ALT0 );<br>// test 4<br>gpio_set_function(GPIO_PIN2, GPIO_FUNC_ALT3);<br>assert( gpio_get_function(GPIO_PIN2) == GPIO_FUNC_ALT3 );</pre><pre name="006e" id="006e" class="graf graf--pre graf-after--pre">// Confirm can configure a GPIO pin in each of the different<br>// FSEL registers<br>gpio_set_output(GPIO_PIN12);<br>assert( gpio_get_function(GPIO_PIN12) == GPIO_FUNC_OUTPUT );</pre><pre name="ea32" id="ea32" class="graf graf--pre graf-after--pre">gpio_set_output(GPIO_PIN22);<br>assert( gpio_get_function(GPIO_PIN22) == GPIO_FUNC_OUTPUT );</pre><pre name="87f5" id="87f5" class="graf graf--pre graf-after--pre">gpio_set_output(GPIO_PIN32);<br>assert( gpio_get_function(GPIO_PIN32) == GPIO_FUNC_OUTPUT );</pre><pre name="d056" id="d056" class="graf graf--pre graf-after--pre">gpio_set_output(GPIO_PIN42);<br>assert( gpio_get_function(GPIO_PIN42) == GPIO_FUNC_OUTPUT );</pre><pre name="a8cf" id="a8cf" class="graf graf--pre graf-after--pre">gpio_set_output(GPIO_PIN52);<br>assert( gpio_get_function(GPIO_PIN52) == GPIO_FUNC_OUTPUT );</pre><pre name="bec4" id="bec4" class="graf graf--pre graf-after--pre">// Confirm no interference when configuring multiple GPIO <br>// pins within the same FSEL register<br>gpio_set_output(GPIO_PIN12);<br>gpio_set_output(GPIO_PIN13);<br>gpio_set_output(GPIO_PIN14);<br>assert( gpio_get_function(GPIO_PIN12) == GPIO_FUNC_OUTPUT );<br>assert( gpio_get_function(GPIO_PIN13) == GPIO_FUNC_OUTPUT );<br>assert( gpio_get_function(GPIO_PIN14) == GPIO_FUNC_OUTPUT );</pre><pre name="3033" id="3033" class="graf graf--pre graf-after--pre">// Confirm that improper requests are gracefully handled<br>assert( gpio_get_function(70) == GPIO_INVALID_REQUEST );<br>assert( gpio_get_function(-10) == GPIO_INVALID_REQUEST );</pre><pre name="547b" id="547b" class="graf graf--pre graf-after--pre">// Random tests<br>gpio_set_function(GPIO_PIN31, GPIO_FUNC_ALT5);<br>gpio_set_function(GPIO_PIN24, GPIO_FUNC_ALT3);<br>gpio_set_function(GPIO_PIN50, GPIO_FUNC_ALT2);<br>assert( gpio_get_function(GPIO_PIN31) == GPIO_FUNC_ALT5 );<br>assert( gpio_get_function(GPIO_PIN24) == GPIO_FUNC_ALT3 );<br>assert( gpio_get_function(GPIO_PIN50) == GPIO_FUNC_ALT2 );<br>gpio_set_function(GPIO_PIN11, GPIO_FUNC_ALT5);<br>gpio_set_function(GPIO_PIN12, GPIO_FUNC_ALT3);<br>gpio_set_function(GPIO_PIN13, GPIO_FUNC_ALT2);<br>gpio_set_function(GPIO_PIN16, GPIO_FUNC_ALT4);<br>gpio_set_function(GPIO_PIN17, GPIO_FUNC_OUTPUT);<br>assert( gpio_get_function(GPIO_PIN11) == GPIO_FUNC_ALT5 );<br>assert( gpio_get_function(GPIO_PIN12) == GPIO_FUNC_ALT3 );<br>assert( gpio_get_function(GPIO_PIN13) == GPIO_FUNC_ALT2 );<br>assert( gpio_get_function(GPIO_PIN16) == GPIO_FUNC_ALT4 );<br>assert( gpio_get_function(GPIO_PIN17) == GPIO_FUNC_OUTPUT );</pre><p name="9e68" id="9e68" class="graf graf--p graf-after--pre graf--trailing">You can also find this completed testing file from <a href="https://github.com/Sadamingh/ComputerSysE/blob/main/clock/src/tests/test_gpio_timer.c" data-href="https://github.com/Sadamingh/ComputerSysE/blob/main/clock/src/tests/test_gpio_timer.c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">my repo</a>.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/a57701e83fbd"><time class="dt-published" datetime="2021-01-06T23:19:14.951Z">January 6, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/computer-systems-experiments-20-modular-gpio-design-a57701e83fbd" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>