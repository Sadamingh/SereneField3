<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Video Game Design 5 | Physics Engine, Collision Detection and Solution, and Further Concepts of…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Video Game Design 5 | Physics Engine, Collision Detection and Solution, and Further Concepts of…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Series: Video Game Design
</section>
<section data-field="body" class="e-content">
<section name="7389" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b2bc" id="b2bc" class="graf graf--h3 graf--leading graf--title">Video Game Design 5 | <strong class="markup--strong markup--h3-strong">Physics Engine, Collision Detection and Solution, and Further Concepts of Physics Engine</strong></h3><figure name="9603" id="9603" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*88LmJJz1SaslL4Eh.png" data-width="1216" data-height="672" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*88LmJJz1SaslL4Eh.png"></figure><ol class="postList"><li name="f97f" id="f97f" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Physics Engine</strong></li></ol><p name="cf3a" id="cf3a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(1) The Definition of Physics Engine</strong></p><p name="00aa" id="00aa" class="graf graf--p graf-after--p">A physics engine provides a service of the physics simulation calculation for a virtual environment. Basically, there are generally two flavors,</p><ul class="postList"><li name="d977" id="d977" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">High-precision offline engines</strong>: mainly for scientific researches</li><li name="f38c" id="f38c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Real-time engines</strong>: mainly for video games or physical predictions for robots</li></ul><p name="ea95" id="ea95" class="graf graf--p graf-after--li">There are many different games that are implemented with a physics engine. For example,</p><ul class="postList"><li name="f0c8" id="f0c8" class="graf graf--li graf-after--p">Bridge Builder</li><li name="ee47" id="ee47" class="graf graf--li graf-after--li">Trials</li></ul><p name="9303" id="9303" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(2) List of Real-Time Physics Engine</strong></p><ul class="postList"><li name="b6dd" id="b6dd" class="graf graf--li graf-after--p">Havok: one of the most famous commercial game engine</li><li name="864c" id="864c" class="graf graf--li graf-after--li">Newton</li><li name="01fb" id="01fb" class="graf graf--li graf-after--li">Open Dynamics Engine (ODE): open source</li><li name="3555" id="3555" class="graf graf--li graf-after--li">Nvidia PhysX: Unity with this integration</li></ul><p name="2f22" id="2f22" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Components in the Physics Engine</strong></p><p name="a35d" id="a35d" class="graf graf--p graf-after--p">So here are some of the components that we can find in a physics engine. We have,</p><ul class="postList"><li name="6cfe" id="6cfe" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Bodies</strong>: usually rigid bodies like boxes, spheres, capsules, triangle meshes, etc.</li><li name="50f3" id="50f3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Connector</strong>: ways for attaching bodies</li><li name="a41f" id="a41f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Forces</strong>: notation how we are reacting on the bodies</li><li name="31ae" id="31ae" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Constraint:</strong> the constraint is similar to connectors</li><li name="6288" id="6288" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Collision detection</strong>: we can only provide collision detection without any dynamics</li></ul><p name="b03b" id="b03b" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) The Definition of Body</strong></p><p name="47c2" id="47c2" class="graf graf--p graf-after--p">In terms of the concept of bodies, we have mentioned that most of them are rigid bodies. Here are some common types of a body,</p><ul class="postList"><li name="4b87" id="4b87" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Dynamic Body</strong>: this we can move the body around (moveable)</li><li name="cfa3" id="cfa3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Static Body</strong>: this means we can not move this body (unmoveable) (maybe) because of the infinite mass</li><li name="ca85" id="ca85" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Enabling/Disabling Body</strong>: in general, it is important to enable objects that are useful</li><li name="7b17" id="7b17" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Sleep/Awake Body</strong>: a body may move a bit at the beginning and quickly settle down (i.e. sleep). But you can also do something else (e.g. kick the ball) to move the body around (i.e. awake).</li><li name="8e0b" id="8e0b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Body with Layers/Groups</strong>: this is like a separate physics universes that are sort of superimposed one on top of another.</li></ul><p name="3713" id="3713" class="graf graf--p graf-after--li">Bodies also have some other properties that as you would expect like,</p><ul class="postList"><li name="84ed" id="84ed" class="graf graf--li graf-after--p">Position</li><li name="b113" id="b113" class="graf graf--li graf-after--li">Orientation</li><li name="d2b4" id="d2b4" class="graf graf--li graf-after--li">Velocity</li><li name="ab04" id="ab04" class="graf graf--li graf-after--li">Angular Velocity</li><li name="edf2" id="edf2" class="graf graf--li graf-after--li">Other Properties: mass, dynamic/static friction, restitution (bounciness), softness, anisotropic friction (skateboard), mesh shapes with per triangle materials (terrain)</li></ul><p name="1ca6" id="1ca6" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(5) The Definition of Collision</strong></p><p name="4bd2" id="4bd2" class="graf graf--p graf-after--p">Collision basically means one shape is intersecting with another one.</p><p name="0631" id="0631" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) The Definition Collision Hulls</strong></p><p name="52b4" id="52b4" class="graf graf--p graf-after--p">Collision hulls are used to reduce the complexity of collision calculation. They are in general made from the primitives (e.g. boxes for vehicles, capsules for skeletons) mentioned before.</p><p name="f24a" id="f24a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(7) Ways to Create Collision Hulls</strong></p><p name="af66" id="af66" class="graf graf--p graf-after--p">Hulls are often required to be convex if non-static for performance because it reduces the calculation, and here are some ways about how to create them,</p><ul class="postList"><li name="f383" id="f383" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Minimum Hulls</strong>: Usually, we have a <strong class="markup--strong markup--li-strong">minimum hull</strong> to concave the source. For example, we can use an ordinary box for containing an object, but if we want something tighter, we can rotate the box to find the smallest convex one with the object inside.</li><li name="31f5" id="31f5" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Compound Colliders</strong>: Of course, you can also make hulls by hand. In Unity, we commonly use <strong class="markup--strong markup--li-strong">compound colliders</strong> with fixed joints and connections to produce the concave effect.</li><li name="d395" id="d395" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Hierarchical Collision Hull</strong>: Access aligned bounding box around different parts of a complicated shape so we have a large simple bounding collision hull to test for the intersection, and then work down to more specific geometry.</li></ul><p name="528c" id="528c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(8) The Definition of Skin Width</strong></p><p name="25a2" id="25a2" class="graf graf--p graf-after--p">The skin width is a dilation or expansion of the geometry so whatever geometry you have for your collider, imaging filling it with air and expand it to a larger form by some amount as if there is a skin on top of the true geometry. In physics, this is called a contact offset or a rest offset.</p><p name="34f9" id="34f9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Collision Detection and Solution</strong></p><p name="8dc6" id="8dc6" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) Discrete Collision Detection</strong></p><p name="52cd" id="52cd" class="graf graf--p graf-after--p">Discrete collision updates the collider position once per fixed frame and detects the collision between the overlapping colliders. Imagine a case when we have a ball with a constant velocity, and in each fixed frame time, we can perform a collision detection of it to the wall. For example, as it is shown in the figure below, the detection will show no collision from <code class="markup--code markup--p-code">t0</code> to <code class="markup--code markup--p-code">t4</code>, but it will detect a collision at <code class="markup--code markup--p-code">t5</code>.</p><figure name="9851" id="9851" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*uj_YdsFSIC040m85yMt9gQ.png" data-width="1500" data-height="320" src="https://cdn-images-1.medium.com/max/800/1*uj_YdsFSIC040m85yMt9gQ.png"></figure><p name="6204" id="6204" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(2) Discrete Collision Detection Problem: Tunneling</strong></p><p name="442f" id="442f" class="graf graf--p graf-after--p">So what if we have a skinny wall. Let’s assume this ball has the same property, the same velocity, the same scale, and etc, and we also perform the same collision detection in each frame. However, what we have now is that the ball can pass through the wall between <code class="markup--code markup--p-code">t4</code> and <code class="markup--code markup--p-code">t5</code>, because the wall is too thin to be detected or in the other perspective, the ball is too fast for the wall.</p><figure name="0528" id="0528" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*SWly5HvlB5F5iHECdh1ukg.png" data-width="1538" data-height="386" src="https://cdn-images-1.medium.com/max/800/1*SWly5HvlB5F5iHECdh1ukg.png"></figure><p name="e696" id="e696" class="graf graf--p graf-after--figure">There are several ways to deal with this problem.</p><ul class="postList"><li name="331a" id="331a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Slow the ball</strong>: the easiest solution is that we can simply slow down the ball so that at some frame, we can detect this collision</li><li name="a223" id="a223" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Ban skinny walls</strong>: also, we can use big thick walls instead of skinny walls so that won’t be a problem for us</li></ul><p name="69a7" id="69a7" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(3) Tunneling Solution 1: Single Raycast</strong></p><p name="479c" id="479c" class="graf graf--p graf-after--p">When the ball is moving, we can just perform a simple raycast from the previous position to the current.</p><figure name="4894" id="4894" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jfNwj6-R07p-5Nm0ASqSBw.png" data-width="1346" data-height="400" src="https://cdn-images-1.medium.com/max/800/1*jfNwj6-R07p-5Nm0ASqSBw.png"></figure><p name="8ef8" id="8ef8" class="graf graf--p graf-after--figure">However, this solution is not perfect. When we hit the wall on the edge or we have a crack or seam in the wall, this single raycast may not be enough to detect the collision because it is actually missing. This will probably result in gameplay breaking.</p><figure name="199d" id="199d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*i_pnpM-1PcwAA7ybrF_2hA.png" data-width="1448" data-height="558" src="https://cdn-images-1.medium.com/max/800/1*i_pnpM-1PcwAA7ybrF_2hA.png"></figure><p name="7728" id="7728" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Tunneling Solution 2: Multiple Raycasts</strong></p><p name="53f5" id="53f5" class="graf graf--p graf-after--p">To fix this problem, another way is to add more raycasts and at the same time, of course, the cost of these raycasts is much more expensive.</p><figure name="008a" id="008a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*S0udIgjMor_VIRFXv9-Ilw.png" data-width="1584" data-height="538" src="https://cdn-images-1.medium.com/max/800/1*S0udIgjMor_VIRFXv9-Ilw.png"></figure><p name="f115" id="f115" class="graf graf--p graf-after--figure">Except for the cost, another problem is that we may not be able to detect collision on very tiny things (e.g. bullets). We are actually reaching the point that we could consolidate all of our multiple raycasts into something else.</p><figure name="3adc" id="3adc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*X8Mq_yafA0yqhiCXKMWXrg.png" data-width="1860" data-height="548" src="https://cdn-images-1.medium.com/max/800/1*X8Mq_yafA0yqhiCXKMWXrg.png"></figure><p name="1f7b" id="1f7b" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(4) Tunneling Solution 3: Silhouette Raycasts</strong></p><p name="0cc8" id="0cc8" class="graf graf--p graf-after--p">Even if we rotate the raycasts to create silhouettes, we can still miss some tiny objects. As a result, we will finally have some problem of missing something tiny at a really high cost.</p><figure name="6dbb" id="6dbb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*DEbeNrVVBMdI8AnJnFbflw.png" data-width="1638" data-height="476" src="https://cdn-images-1.medium.com/max/800/1*DEbeNrVVBMdI8AnJnFbflw.png"></figure><p name="3f2a" id="3f2a" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(5) Tunneling Solution 4: Speculative</strong></p><p name="b6be" id="b6be" class="graf graf--p graf-after--p">One solution in PhysX is called speculative or speculative collision detection. What it does is that PhysX normally has this skin width, which is usually a very some and constant offset but if you enable speculative collision to section what happens is that there is a <strong class="markup--strong markup--p-strong">dynamic skin width</strong>.</p><figure name="9e94" id="9e94" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Eq_rTazUyA8IMfiiaJ1QHA.png" data-width="1502" data-height="474" src="https://cdn-images-1.medium.com/max/800/1*Eq_rTazUyA8IMfiiaJ1QHA.png"></figure><p name="0ea3" id="0ea3" class="graf graf--p graf-after--figure">When the ball is fast, the skin can expand to its compensation. When the ball slows down, the skin can shrink back to its default. However, it does have some problems because the skin might not actually grow fast enough to what it is about to collide with, and we can still end up with tunneling.</p><p name="44ae" id="44ae" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(6) Collision with Rotation</strong></p><p name="d23b" id="d23b" class="graf graf--p graf-after--p">Now, imagine we have a rotating axe and we would like to see if it can collide with the wall. You may find out that this fast rotation makes all the previous techniques tricky, even though we can still do the discrete collision detection. In general, there can be two compromises for this,</p><ul class="postList"><li name="45dd" id="45dd" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Restrict the maximum velocity</strong>: In Unity and PhysX, what we commonly do is restrict the maximum value of the angular velocity by <code class="markup--code markup--li-code">Rigidbody.maxAngularVelocity</code> so that the rotation problem will not be that complicated.</li><li name="609e" id="609e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Use a blur hull</strong>: As far as we concern, the axe can exactly pass through the wall without any collision. However, this can be complicated for calculation and it is actually not that important for gameplay. So in fact, you may not need anything seems like an axe, and probably, a disc can be probably fine.</li><li name="fe13" id="fe13" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Take a smaller step</strong>: often, the best solution is to take a smaller step in terms of our simulation by increasing our frame rate. Knowing the size of the objects, a speed threshold can be identified where tunneling might occur. When that speed is exceeded, start sub-stepping but otherwise use discrete collision detection.</li></ul><p name="6744" id="6744" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(7) Collision Dynamics</strong></p><p name="66c1" id="66c1" class="graf graf--p graf-after--p">So how can we resolve our collisions? Ultimately, we want something that is realistic, so we have certain expectations we are looking for if two objects collide. This means that we want to see something (e.g. bounce back, push away, drop, etc.) with one of them.</p><p name="6cf9" id="6cf9" class="graf graf--p graf-after--p">So we actually need some methods to do this.</p><p name="d4db" id="d4db" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(8) Collision Dynamics Methods 1: Penalty Force Method</strong></p><p name="52b8" id="52b8" class="graf graf--p graf-after--p">There are some mechanisms to deal with this and one of the earliest ones is called the penalty force method. This is actually the one used in the game <em class="markup--em markup--p-em">Trespasser</em>.</p><p name="2668" id="2668" class="graf graf--p graf-after--p">The basic concept of the <strong class="markup--strong markup--p-strong">penalty force method</strong> is that we sort of recognizing that an object, when it applies with something else, is touching the object, and we need a correct for this touch to make sure that they have already gotten to the point that they are crossing the boundary from one to another. The result of the application of a force vector is to be added to the point of deepest penetration on successive simulation steps, so that we can, as a result, push the shape away.</p><figure name="e8e2" id="e8e2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*H8h_RXJYmYRCJA46BFBdkw.png" data-width="735" data-height="150" src="https://cdn-images-1.medium.com/max/800/1*H8h_RXJYmYRCJA46BFBdkw.png"></figure><p name="db01" id="db01" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(9) Improvements on Penalty Force</strong></p><p name="fc06" id="fc06" class="graf graf--p graf-after--p">So now let’s consider some improvements on the penalty force method. What we are going to do are,</p><ul class="postList"><li name="0c38" id="0c38" class="graf graf--li graf-after--p">Relax the contact criteria via skin width: the skin is like an expansion of the shape</li><li name="e272" id="e272" class="graf graf--li graf-after--li">Consider <strong class="markup--strong markup--li-strong">all</strong> collision contacts (not just the deepest): we will see this in a few minutes</li><li name="ca3c" id="ca3c" class="graf graf--li graf-after--li">Find a solution that addresses all constraints introduced by the collision contacts</li></ul><p name="2d15" id="2d15" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(10) All Contact Points</strong></p><p name="5a9f" id="5a9f" class="graf graf--p graf-after--p">If we have two surfaces that are touching in their flesh. There’s not points of contact, instead, there’s a whole area of contacts. So when we say all the contacts, we are actually going to simplify that based on perimeter vertices. Usually, spheres, cylinders, and capsule ends are unique cases as compared to triangles. Since this is along the parameter of the contact area, our corrective forces are applying. So the collision dynamics is still going to work effectively.</p><p name="7095" id="7095" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(11) Skin Width for Contacts</strong></p><p name="c467" id="c467" class="graf graf--p graf-after--p">Another way is that we can define the contacts based on the skin penetration instead of the actual geometry touches. The cool thing about using this approach is that we can begin correcting, which means we can spread our corrective forces over multiple frames.</p><p name="78e7" id="78e7" class="graf graf--p graf-after--p">We can also make it proportional to the degree of penetration like it can be scaled according to how much penetration there is. If two object skins are barely touching, we can have a very small corrective force. So soft collision correction as skin penetrations can become stronger and stronger as further penetration. This is greater for friction modeling and reducing jitter by using a smoother sort of approach. Friction modeling benefits from fact that skin penetration can persist across simulation steps and, therefore, contact point persist.</p><p name="f36e" id="f36e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(12) Case Study: Edgry and Rolonda</strong></p><p name="4b06" id="4b06" class="graf graf--p graf-after--p">Now, let’s see a case of two shapes. The shape on the left called Edgry is flying through the air towards Rolonda. At the beginning, we have tested nothing because there’s no penetration.</p><figure name="b09a" id="b09a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MUlZVpeiAVyqoPnpMQof3A.png" data-width="1470" data-height="414" src="https://cdn-images-1.medium.com/max/800/1*MUlZVpeiAVyqoPnpMQof3A.png"></figure><p name="2c0f" id="2c0f" class="graf graf--p graf-after--figure">But as the simulation advances, our tests for intersection are going to be get an intersection of the skin only. At that point, we are going to generate the metadata or the book keeping to keep track of the contract point. And we may choose a small proportional corrective force proportional to the degree of the interpenetration of the skin. At this time, the skin interpenetration is quite small and therefore, there has to be a small correction.</p><figure name="0afd" id="0afd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Vw8izzcQdcPGetxpYMVEow.png" data-width="1470" data-height="414" src="https://cdn-images-1.medium.com/max/800/1*Vw8izzcQdcPGetxpYMVEow.png"></figure><p name="b1a9" id="b1a9" class="graf graf--p graf-after--figure">But if it does continue, now we are going to ramp up the corrective force and this will be, again, based on the skin interpenetration. So now, we are going to get a larger corrective force, and ideally we may be able to push that part into a stable contact.</p><figure name="fc55" id="fc55" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*16l-2XCRnph_MwN_Pmvv5Q.png" data-width="1470" data-height="414" src="https://cdn-images-1.medium.com/max/800/1*16l-2XCRnph_MwN_Pmvv5Q.png"></figure><p name="7ac0" id="7ac0" class="graf graf--p graf-after--figure">If this collision continues, we are going to get to the point where’s an actual contact of the actual geometry. This will result in a lot of forces. So when this happens, you will have to ramp all the way up to the maximum of the skin base correction for forces. This will push them apart if there’s any restitution allowed by the simulation.</p><figure name="b380" id="b380" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6-4UyYxUXw-YW6C_o_aBiw.png" data-width="1470" data-height="414" src="https://cdn-images-1.medium.com/max/800/1*6-4UyYxUXw-YW6C_o_aBiw.png"></figure><p name="3923" id="3923" class="graf graf--p graf-after--figure">But sometimes, things don’t work out the way you want. This will usually happen when you have lots of objects involved and they are all pushing each other. And somehow, you end up with the inner geometry in addtion to the skin. At that point, the actual geometry are intersecting and you have a last ditch <strong class="markup--strong markup--p-strong">extreme corrective force</strong> to apply, which can be set in PhysX or Unity.</p><figure name="4da8" id="4da8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YjiGyyzDYyBpcoFGitxJMg.png" data-width="1470" data-height="414" src="https://cdn-images-1.medium.com/max/800/1*YjiGyyzDYyBpcoFGitxJMg.png"></figure><p name="b5ae" id="b5ae" class="graf graf--p graf-after--figure">Because you don’t want to real geometry collisions, you are expected to get a result that the Edgry will go flying through the air and go off like extreme heights.</p><figure name="ba4d" id="ba4d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*2Acm96fySiKqcXKviF0u1g.png" data-width="1470" data-height="446" src="https://cdn-images-1.medium.com/max/800/1*2Acm96fySiKqcXKviF0u1g.png"></figure><p name="e5d2" id="e5d2" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">(13) A Common Bug: <em class="markup--em markup--p-em">Sea of Thieves</em></strong></p><p name="1174" id="1174" class="graf graf--p graf-after--p">In this case, we will see a common bug for geometry collision. We are going to use an example in the game <em class="markup--em markup--p-em">Sea of Thieves</em>. This bug happens when a boat sinks, and then for whatever reason, it flies.</p><figure name="2e97" id="2e97" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fVwXDwjzp1n5FHsf6Mcvqw.png" data-width="1708" data-height="350" src="https://cdn-images-1.medium.com/max/800/1*fVwXDwjzp1n5FHsf6Mcvqw.png"></figure><p name="c4d6" id="c4d6" class="graf graf--p graf-after--figure">So what actually happens here is when the ship first scuttled, it goes physics control under kinematic control because there is an animation just plays that it is moving down below the water or sea level. So it goes down for a while and then they turn off the kinematic control and go under the simulation control. Under water, there are some rigid bodies like the sand and seaweed, so there maybe a terrain collider or some static mesh collider. So now the physics simulation decide that there is a huge amount of interpenetration occurring right now and we have to apply a maximum corrective force.</p><p name="4ef0" id="4ef0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(14) Linear-Complementary Problem (LCP)</strong></p><p name="4a70" id="4a70" class="graf graf--p graf-after--p">So when we have a contact, the most commonly solution we are going to apply is based on the l<strong class="markup--strong markup--p-strong">inear-complementary problem (LCP) with Jacobian</strong> <strong class="markup--strong markup--p-strong">constraints</strong>. The goal of this solution is to help you find the degrees of freedom relative to the contacts and to answer how can the object move under this contact.</p><figure name="0075" id="0075" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*7WWNyCWfsetdCG0ydWMinQ.png" data-width="1614" data-height="316" src="https://cdn-images-1.medium.com/max/800/1*7WWNyCWfsetdCG0ydWMinQ.png"></figure><p name="40d2" id="40d2" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Jacobian</strong> is actually a mathematical concept like a pre-derived path of least resistance to enforce a constraint (e.g. a direction vector in constraint space). It actually allows you to determine what those degrees of freedoms are and then it would be like adjustments to position in an orientation.</p><p name="7462" id="7462" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Further Concepts of Physics Engine</strong></p><p name="aa68" id="aa68" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(1) The Defintion of Forces</strong></p><p name="e7a6" id="e7a6" class="graf graf--p graf-after--p">Forces are the ways to make the objects around. The most common force in the physics engine is the gravity, but this is not always the case because you may want some layers of the simulation that are not affected by the gravity.</p><p name="db92" id="db92" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(2) The Defintion of Impulse</strong></p><p name="a462" id="a462" class="graf graf--p graf-after--p">The impulse is a kind of instantaneous force and it results in a change of the velocity. It stops after there’s no over a single frame. This will be great for jumping. In Unity, there are different variations of impulse</p><p name="3da1" id="3da1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(3) The Defintion of Connectors</strong></p><p name="2475" id="2475" class="graf graf--p graf-after--p">Connectors is what we use to attach our shapes and it means to restrict motions between actors relative to the degree of freedom. These are implemented with multibody dynamics with Jacobian constraints. There are some other aspects connectors dealing with,</p><ul class="postList"><li name="eb93" id="eb93" class="graf graf--li graf-after--p">connect collision</li><li name="8be3" id="8be3" class="graf graf--li graf-after--li">flexibility</li><li name="7c54" id="7c54" class="graf graf--li graf-after--li">degree of freedom</li><li name="b485" id="b485" class="graf graf--li graf-after--li">etc.</li></ul><p name="56f8" id="56f8" class="graf graf--p graf-after--li">There are also several types of connectors,</p><ul class="postList"><li name="412c" id="412c" class="graf graf--li graf-after--p">spring</li><li name="b946" id="b946" class="graf graf--li graf-after--li">force</li><li name="4faa" id="4faa" class="graf graf--li graf-after--li">damping</li><li name="1f00" id="1f00" class="graf graf--li graf-after--li">joint motor</li><li name="678e" id="678e" class="graf graf--li graf-after--li">breakable joints</li></ul><p name="4969" id="4969" class="graf graf--p graf-after--li">There are also different types of constraints to the connectors,</p><ul class="postList"><li name="04a7" id="04a7" class="graf graf--li graf-after--p">hard constraint: the rules should never be violated</li><li name="82b7" id="82b7" class="graf graf--li graf-after--li">soft constraint: the rules are designed to be violated</li><li name="fc35" id="fc35" class="graf graf--li graf-after--li">joint constraint: there are some degrees of freedom with linear or angular amounts</li></ul><p name="24db" id="24db" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">(4) The Definition of Deactivation</strong></p><p name="655b" id="655b" class="graf graf--p graf-after--p">Because it is important to minimize calculations in a real-time simulation, we have to limit the actors that are active in simulation at a time. So sometimes, we have to sleep the linear and angular velocity of the rigid bodies.</p><p name="3901" id="3901" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">(5) Common Steps of Applying a Physics Engine</strong></p><ul class="postList"><li name="52f4" id="52f4" class="graf graf--li graf-after--p">set gravity vector</li><li name="4865" id="4865" class="graf graf--li graf-after--li">make some kind of ground surface that doesn’t fall</li><li name="d2dc" id="d2dc" class="graf graf--li graf-after--li">apply forces to bodies</li><li name="1170" id="1170" class="graf graf--li graf-after--li">adjust joint parameters as necessary</li><li name="d9cd" id="d9cd" class="graf graf--li graf-after--li">call collision detection</li><li name="4610" id="4610" class="graf graf--li graf-after--li">step the simulation based on time</li><li name="d3de" id="d3de" class="graf graf--li graf-after--li">keep the graphics objects and physics object in synchronizations</li><li name="89c3" id="89c3" class="graf graf--li graf-after--li graf--trailing">deactivate some objects</li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@adamedelweiss" class="p-author h-card">Adam Edelweiss</a> on <a href="https://medium.com/p/3482c56121e7"><time class="dt-published" datetime="2021-09-17T14:35:42.730Z">September 17, 2021</time></a>.</p><p><a href="https://medium.com/@adamedelweiss/video-game-design-5-physics-engine-collision-detection-and-solution-and-further-concepts-of-3482c56121e7" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>