<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>计算机网络4 传输层协议</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">计算机网络4 传输层协议</h1>
</header>
<section data-field="subtitle" class="p-summary">
一、用户数据报UDP协议
</section>
<section data-field="body" class="e-content">
<section name="0c26" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0d23" id="0d23" class="graf graf--h3 graf--leading graf--title"><strong class="markup--strong markup--h3-strong">计算机网络4 传输层协议</strong></h3><figure name="9dab" id="9dab" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*cjJgSgroJtgtXMVPTmt2WA.jpeg" data-width="2689" data-height="1513" src="https://cdn-images-1.medium.com/max/800/1*cjJgSgroJtgtXMVPTmt2WA.jpeg"></figure><p name="56ff" id="56ff" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">一、用户数据报UDP协议</strong></p><ol class="postList"><li name="d652" id="d652" class="graf graf--li graf-after--p">为什么我们需要UDP协议？</li></ol><ul class="postList"><li name="f509" id="f509" class="graf graf--li graf-after--li">ip协议中没有端口的概念，只能从一个ip传到另一个ip</li><li name="e8d1" id="e8d1" class="graf graf--li graf-after--li">​多个通讯信道的分配需求</li></ul><p name="9ab5" id="9ab5" class="graf graf--p graf-after--li">2. UDP和TCP都是在IP报文的数据字段传输，进程的每个输出操作都正好产生一个 UDP 数据报，并组装成一份待发送的 IP 数据报。</p><figure name="f3f2" id="f3f2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*SrhaolPnTBZigDAp96C2Ww.png" data-width="1482" data-height="518" src="https://cdn-images-1.medium.com/max/800/1*SrhaolPnTBZigDAp96C2Ww.png"><figcaption class="imageCaption">via cloudflare</figcaption></figure><p name="17f2" id="17f2" class="graf graf--p graf-after--figure">3. UDP协议的格式</p><figure name="5270" id="5270" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZgQmHz8q9rNb2yJ84hxz1Q.png" data-width="984" data-height="408" src="https://cdn-images-1.medium.com/max/800/1*ZgQmHz8q9rNb2yJ84hxz1Q.png"></figure><ul class="postList"><li name="ae74" id="ae74" class="graf graf--li graf-after--figure">端口号：目的是标识一台计算机的不同应用进程</li><li name="a968" id="a968" class="graf graf--li graf-after--li">本机端口号字段：16位，包括数据报发送者使用的端口，接收端会将其视为发送响应的目的地址。如果发送端不写入端口号，则该字段为0</li><li name="74bb" id="74bb" class="graf graf--li graf-after--li">目的端口号字段：16位，接收机接收UDP报文使用的端口号。</li><li name="b8b1" id="b8b1" class="graf graf--li graf-after--li">UDP报文长度字段：16位，该字段表示UDP报文的长度，由于UDP报文首部长度为8字节，因此该字段的最小值为8</li><li name="c274" id="c274" class="graf graf--li graf-after--li">校验和字段：16位，同其他报文，包括UDP协议的伪首部，用于检测在传输过程中该报文是否损坏</li></ul><ol class="postList"><li name="0580" id="0580" class="graf graf--li graf--empty graf-after--li"><br></li><li name="0474" id="0474" class="graf graf--li graf-after--li">无连接特点</li><li name="5598" id="5598" class="graf graf--li graf--empty graf-after--li"><br></li><li name="47ae" id="47ae" class="graf graf--li graf-after--li">在发送数据之前，数据的发送端和接收端之间不需要进行连接</li><li name="1233" id="1233" class="graf graf--li graf--empty graf-after--li"><br></li><li name="888f" id="888f" class="graf graf--li graf-after--li">在数据的发送过程中，数据的发送端和接收端不需要维护连接状态</li><li name="5f7b" id="5f7b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="3d09" id="3d09" class="graf graf--li graf-after--li">具体来说，UDP协议在每次发送的过程中不需要给每一个数据报进行编号和发送确认号，因此UDP协议的延迟更小，实时性更好</li><li name="58a7" id="58a7" class="graf graf--li graf--empty graf-after--li"><br></li><li name="cfad" id="cfad" class="graf graf--li graf-after--li">因此，对于对数据正确率不高但是需要延迟性低的传输（比如视频），UDP协议具有更好的传输效果和应用</li><li name="1df5" id="1df5" class="graf graf--li graf--empty graf-after--li"><br></li><li name="5fac" id="5fac" class="graf graf--li graf-after--li">不可靠的特点</li><li name="a984" id="a984" class="graf graf--li graf--empty graf-after--li"><br></li><li name="c481" id="c481" class="graf graf--li graf-after--li">没有确认机制：如果校验和有错误就直接丢弃，不会向发送端进行反馈</li><li name="f6bc" id="f6bc" class="graf graf--li graf--empty graf-after--li"><br></li><li name="dca2" id="dca2" class="graf graf--li graf-after--li">不会对报文排序：如果数据字段的顺序是不正确的，接收端也没有办法对报文进行排序</li><li name="100e" id="100e" class="graf graf--li graf--empty graf-after--li"><br></li><li name="df10" id="df10" class="graf graf--li graf-after--li">可能产生缓冲区溢出丢包：UDP报文不对流量进行控制，因此接收端处理太慢会导致缓存溢出，产生丢包问题</li><li name="c3d6" id="c3d6" class="graf graf--li graf--empty graf-after--li"><br></li><li name="cb49" id="cb49" class="graf graf--li graf-after--li">没有超时机制：发送端确认丢包了，也不会重新发送数据报</li><li name="b474" id="b474" class="graf graf--li graf--empty graf-after--li"><br></li><li name="2514" id="2514" class="graf graf--li graf-after--li">UDP协议的伪首部</li><li name="2292" id="2292" class="graf graf--li graf--empty graf-after--li"><br></li><li name="61d7" id="61d7" class="graf graf--li graf-after--li">伪首部不占用地址空间，在实际的传输中不会传输这个部分，但是在计算校验和的时候要将其包括在内</li><li name="7f5f" id="7f5f" class="graf graf--li graf--empty graf-after--li"><br></li><li name="858e" id="858e" class="graf graf--li graf-after--li">伪首部的格式</li><li name="a866" id="a866" class="graf graf--li graf--empty graf-after--li"><br></li><li name="05c3" id="05c3" class="graf graf--li graf-after--li">32位本机ip地址字段：发送端ip地址</li><li name="dd3b" id="dd3b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="aabe" id="aabe" class="graf graf--li graf-after--li">32位接收端ip地址字段：目的ip地址</li><li name="bfef" id="bfef" class="graf graf--li graf--empty graf-after--li"><br></li><li name="6fab" id="6fab" class="graf graf--li graf-after--li">8位0字段：占位用，没有实际意义</li><li name="e7a7" id="e7a7" class="graf graf--li graf--empty graf-after--li"><br></li><li name="63f1" id="63f1" class="graf graf--li graf-after--li">8位协议号字段：值17表示UDP协议</li><li name="29c2" id="29c2" class="graf graf--li graf--empty graf-after--li"><br></li><li name="d077" id="d077" class="graf graf--li graf-after--li">16位UDP长度字段：同UDP首部中的UDP长度字段</li><li name="5bb6" id="5bb6" class="graf graf--li graf--empty graf-after--li"><br></li><li name="6b78" id="6b78" class="graf graf--li graf-after--li">伪首部存在的意义：让UDP协议两次检查数据是否已经到达目的地</li><li name="0cf6" id="0cf6" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9b9f" id="9b9f" class="graf graf--li graf-after--li">通过伪首部的IP地址检验：接收端确认目的IP地址是否是本机地址</li><li name="b30b" id="b30b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="390a" id="390a" class="graf graf--li graf-after--li">通过伪首部协议字段检验：确认ip是否把不应该传送给UDP的更高级数据报传送给UDP，也就是说，检验有没有传输到正确的上层协议</li><li name="1f2d" id="1f2d" class="graf graf--li graf--empty graf-after--li"><br></li><li name="7fb9" id="7fb9" class="graf graf--li graf-after--li">TCP协议</li><li name="0462" id="0462" class="graf graf--li graf--empty graf-after--li"><br></li><li name="56c5" id="56c5" class="graf graf--li graf-after--li">可靠特点</li><li name="c346" id="c346" class="graf graf--li graf--empty graf-after--li"><br></li><li name="e22f" id="e22f" class="graf graf--li graf-after--li">面向连接特点</li><li name="9f1e" id="9f1e" class="graf graf--li graf--empty graf-after--li"><br></li><li name="efe9" id="efe9" class="graf graf--li graf-after--li">基于字节流特点</li><li name="06f0" id="06f0" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1cb8" id="1cb8" class="graf graf--li graf-after--li">TCP的报文首部格式</li><li name="3e26" id="3e26" class="graf graf--li graf--empty graf-after--li"><br></li><li name="4158" id="4158" class="graf graf--li graf-after--li">端口号字段：用来区分不同进程</li><li name="e445" id="e445" class="graf graf--li graf--empty graf-after--li"><br></li><li name="2966" id="2966" class="graf graf--li graf-after--li">本机端口号字段：16位，标识发送端的端口号</li><li name="6151" id="6151" class="graf graf--li graf--empty graf-after--li"><br></li><li name="76bc" id="76bc" class="graf graf--li graf-after--li">目的端口号字段：16位，表示接受端的端口号，应该为接收端开放的接收特定程序的端口</li><li name="628b" id="628b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="c323" id="c323" class="graf graf--li graf-after--li">序号和确认号字段：用来为报文的序号进行排序</li><li name="08ad" id="08ad" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1da2" id="1da2" class="graf graf--li graf-after--li">序号Seq：32位，类似于ip协议中片偏移的概念。</li><li name="0417" id="0417" class="graf graf--li graf--empty graf-after--li"><br></li><li name="f762" id="f762" class="graf graf--li graf-after--li">初始序号是随机的，可能是0到4294967295中的任何一个值。</li><li name="ad96" id="ad96" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9e05" id="9e05" class="graf graf--li graf-after--li">但是，初始序号的相对序号被规定为0。</li><li name="ad5e" id="ad5e" class="graf graf--li graf--empty graf-after--li"><br></li><li name="6784" id="6784" class="graf graf--li graf-after--li">TCP传输流中数据端的每一个字节表示一个序号。</li><li name="c0a8" id="c0a8" class="graf graf--li graf--empty graf-after--li"><br></li><li name="960d" id="960d" class="graf graf--li graf-after--li">例如一个TCP报文的序号为101，这个报文的数据段中有200个字节，那么这个数据段最后一个字节的序号为300，下一个TCP报文的序号就应该从301开始。</li><li name="3b1c" id="3b1c" class="graf graf--li graf--empty graf-after--li"><br></li><li name="7c0d" id="7c0d" class="graf graf--li graf-after--li">确认号ack：32位，它的值表示的是序号</li><li name="d567" id="d567" class="graf graf--li graf--empty graf-after--li"><br></li><li name="5800" id="5800" class="graf graf--li graf-after--li">确认号包含发送确认的一端所期望收到的下一个序号</li><li name="fc02" id="fc02" class="graf graf--li graf--empty graf-after--li"><br></li><li name="5fbf" id="5fbf" class="graf graf--li graf-after--li">确认号只有在ACK标志为1时才有效</li><li name="b518" id="b518" class="graf graf--li graf--empty graf-after--li"><br></li><li name="be29" id="be29" class="graf graf--li graf-after--li">首部长度字段：4位，又叫做数据偏移字段。用于表示TCP报文的首部长度，范围是值5到15，每个单位表示4个字节。由于TCP报文的首部前20个字节是必须有的，因此最小值为5。</li><li name="f375" id="f375" class="graf graf--li graf--empty graf-after--li"><br></li><li name="7191" id="7191" class="graf graf--li graf-after--li">保留字段：6位，为了未来定义使用的字段，现阶段只能均为零。</li><li name="15ef" id="15ef" class="graf graf--li graf--empty graf-after--li"><br></li><li name="51fb" id="51fb" class="graf graf--li graf-after--li">标志字段：共6位，每位表示一个标志，从左到右的顺序排列如下</li><li name="c8df" id="c8df" class="graf graf--li graf--empty graf-after--li"><br></li><li name="25a4" id="25a4" class="graf graf--li graf-after--li">紧急标志位URG：此标志位为1表示此TCP协议传输的数据为紧急数据，不必等待先前数据报被消耗才能发送，而是直接发送</li><li name="81a0" id="81a0" class="graf graf--li graf--empty graf-after--li"><br></li><li name="076d" id="076d" class="graf graf--li graf-after--li">确认标志位ACK：确认标志位为1的时候，确认号字段是有效的，大多数情况下这位的值为1。如果ACK为0，那么认为确认号是无效的。</li><li name="6766" id="6766" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9684" id="9684" class="graf graf--li graf-after--li">push标志位PSH：通常情况下，一个数据报发送到接收端时会进入缓存区排队，在缓存区内改数据达到一定大小才会统一发送给应用程序。此标志位为1会告知接收端不需要在缓存中等待排队，而是可以直接发送到应用程序。</li><li name="ab40" id="ab40" class="graf graf--li graf--empty graf-after--li"><br></li><li name="2ef0" id="2ef0" class="graf graf--li graf-after--li">复位标志位RST：当RST标志位的值为1，通常表示主机在寻找远程主机时发生了错误，比如未在远程主机上找到相关服务。主机会拒绝请求，并在发送的回复中将RST标志位的值更改为1。</li><li name="0c5b" id="0c5b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1776" id="1776" class="graf graf--li graf-after--li">同步标志位SYN：</li><li name="133c" id="133c" class="graf graf--li graf--empty graf-after--li"><br></li><li name="7d65" id="7d65" class="graf graf--li graf-after--li">同步标志位用来表示连接过程的信息，只在三次握手的过程中有效</li><li name="db79" id="db79" class="graf graf--li graf--empty graf-after--li"><br></li><li name="db99" id="db99" class="graf graf--li graf-after--li">它用来提示连接的服务端检查序号</li><li name="a0de" id="a0de" class="graf graf--li graf--empty graf-after--li"><br></li><li name="7fb5" id="7fb5" class="graf graf--li graf-after--li">SYN=1，ACK=0，表示请求建立一个连接</li><li name="c31e" id="c31e" class="graf graf--li graf--empty graf-after--li"><br></li><li name="11ea" id="11ea" class="graf graf--li graf-after--li">SYN=1，ACK=1，表示同意建立一个连接</li><li name="a2f0" id="a2f0" class="graf graf--li graf--empty graf-after--li"><br></li><li name="59b6" id="59b6" class="graf graf--li graf-after--li">结束标志位FIN：FIN位的值为1时，表示发送端已经完全完成发送任务，用来释放连接。</li><li name="fb3f" id="fb3f" class="graf graf--li graf--empty graf-after--li"><br></li><li name="d9de" id="d9de" class="graf graf--li graf-after--li">非法标志位组合：</li><li name="0dee" id="0dee" class="graf graf--li graf--empty graf-after--li"><br></li><li name="6ae9" id="6ae9" class="graf graf--li graf-after--li">所有标志位均为0</li><li name="2e23" id="2e23" class="graf graf--li graf--empty graf-after--li"><br></li><li name="2cc5" id="2cc5" class="graf graf--li graf-after--li">SYN和FIN同时为1</li><li name="ef27" id="ef27" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9d80" id="9d80" class="graf graf--li graf-after--li">SYN和RST同时为1</li><li name="48cf" id="48cf" class="graf graf--li graf--empty graf-after--li"><br></li><li name="99a9" id="99a9" class="graf graf--li graf-after--li">FIN和RST同时为1</li><li name="6fae" id="6fae" class="graf graf--li graf--empty graf-after--li"><br></li><li name="88c1" id="88c1" class="graf graf--li graf-after--li">ACK位为0，但是FIN位为1</li><li name="b6ea" id="b6ea" class="graf graf--li graf--empty graf-after--li"><br></li><li name="dcfc" id="dcfc" class="graf graf--li graf-after--li">ACK位为0，但是PSH位为1</li><li name="522d" id="522d" class="graf graf--li graf--empty graf-after--li"><br></li><li name="b4e6" id="b4e6" class="graf graf--li graf-after--li">ACK位为0，但是URG位为1</li><li name="e066" id="e066" class="graf graf--li graf--empty graf-after--li"><br></li><li name="5b22" id="5b22" class="graf graf--li graf-after--li">窗口字段：16位，用来告知自己作为接收端时的数据缓存大小，以此控制发送端发送的速率，从而达到流量控制。</li><li name="f285" id="f285" class="graf graf--li graf--empty graf-after--li"><br></li><li name="ff13" id="ff13" class="graf graf--li graf-after--li">校验和字段：16位，针对TCP整个报文（包括TCP报文的伪首部）进行奇偶校验，由发送端计算和储存，由接收端验证。</li><li name="daae" id="daae" class="graf graf--li graf--empty graf-after--li"><br></li><li name="824e" id="824e" class="graf graf--li graf-after--li">其他可选字段</li><li name="3f2d" id="3f2d" class="graf graf--li graf--empty graf-after--li"><br></li><li name="042f" id="042f" class="graf graf--li graf-after--li">TCP协议的伪首部</li><li name="fbb3" id="fbb3" class="graf graf--li graf--empty graf-after--li"><br></li><li name="cff3" id="cff3" class="graf graf--li graf-after--li">伪首部不占用地址空间，在实际的传输中不会传输这个部分，但是在计算校验和的时候要将其包括在内</li><li name="9e36" id="9e36" class="graf graf--li graf--empty graf-after--li"><br></li><li name="7cb9" id="7cb9" class="graf graf--li graf-after--li">伪首部的格式</li><li name="15b8" id="15b8" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1435" id="1435" class="graf graf--li graf-after--li">32位本机ip地址字段：发送端ip地址</li><li name="46a1" id="46a1" class="graf graf--li graf--empty graf-after--li"><br></li><li name="b624" id="b624" class="graf graf--li graf-after--li">32位接收端ip地址字段：目的ip地址</li><li name="de46" id="de46" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1870" id="1870" class="graf graf--li graf-after--li">8位0字段：占位用，没有实际意义</li><li name="9ca3" id="9ca3" class="graf graf--li graf--empty graf-after--li"><br></li><li name="ff2c" id="ff2c" class="graf graf--li graf-after--li">8位协议号字段：值6表示UDP协议</li><li name="5e61" id="5e61" class="graf graf--li graf--empty graf-after--li"><br></li><li name="13c2" id="13c2" class="graf graf--li graf-after--li">16位TCP总长度字段：同TCP总长度字段，包括TCP首部+数据</li><li name="7ee9" id="7ee9" class="graf graf--li graf--empty graf-after--li"><br></li><li name="b385" id="b385" class="graf graf--li graf-after--li">TCP的连接控制机制</li><li name="3a1f" id="3a1f" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9202" id="9202" class="graf graf--li graf-after--li">三次握手</li><li name="dfed" id="dfed" class="graf graf--li graf--empty graf-after--li"><br></li><li name="bd36" id="bd36" class="graf graf--li graf-after--li">三次握手指的是在建立一个TCP连接的过程中，需要本机（可看作客户端）和远程主机（可看作服务端）总共发送和接收3个数据包来建立连接。</li><li name="263b" id="263b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="b801" id="b801" class="graf graf--li graf-after--li">第一次握手：请求连接</li><li name="019d" id="019d" class="graf graf--li graf--empty graf-after--li"><br></li><li name="3e1b" id="3e1b" class="graf graf--li graf-after--li">本机向远程主机发送一个“<strong class="markup--strong markup--li-strong">同步标志位SYN=1，确认标志位ACK=0，序号Seq=某个常数x</strong>”的数据包，这个数据报的含义是向远程主机发送一个连接的请求，需要指明本机想要连接的端口。</li><li name="b731" id="b731" class="graf graf--li graf--empty graf-after--li"><br></li><li name="458a" id="458a" class="graf graf--li graf-after--li">x表示传输数据时第一个数据字节的序号为x</li><li name="f486" id="f486" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9ebb" id="9ebb" class="graf graf--li graf-after--li">发送完毕后，本机进入SYN_SEND的状态</li><li name="f2f6" id="f2f6" class="graf graf--li graf--empty graf-after--li"><br></li><li name="7d7e" id="7d7e" class="graf graf--li graf-after--li">第二次握手：同意连接</li><li name="579b" id="579b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="eac4" id="eac4" class="graf graf--li graf-after--li">远程主机向本机发送一个“<strong class="markup--strong markup--li-strong">同步标志位SYN=1，确认标志位ACK=1，序号Seq=某个常数y，确认号ack=x+1</strong>”的数据包，表示同意连接请求</li><li name="966a" id="966a" class="graf graf--li graf--empty graf-after--li"><br></li><li name="b944" id="b944" class="graf graf--li graf-after--li">发送完毕后，远程主机进入SYN_RCVD的状态</li><li name="fdd9" id="fdd9" class="graf graf--li graf--empty graf-after--li"><br></li><li name="077e" id="077e" class="graf graf--li graf-after--li">第三次握手：已连接</li><li name="dc61" id="dc61" class="graf graf--li graf--empty graf-after--li"><br></li><li name="6e78" id="6e78" class="graf graf--li graf-after--li">远程主机向本机发送一个“<strong class="markup--strong markup--li-strong">同步标志位SYN=0，确认标志位ACK=1，序号Seq=x+1，确认号ack=y+1</strong>”的数据包，表示已经建立连接</li><li name="3123" id="3123" class="graf graf--li graf--empty graf-after--li"><br></li><li name="45e8" id="45e8" class="graf graf--li graf-after--li">发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</li><li name="a9e0" id="a9e0" class="graf graf--li graf--empty graf-after--li"><br></li><li name="22fe" id="22fe" class="graf graf--li graf-after--li">四次挥手</li><li name="446b" id="446b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="6cdf" id="6cdf" class="graf graf--li graf-after--li">第一次挥手：请求关闭连接</li><li name="69eb" id="69eb" class="graf graf--li graf--empty graf-after--li"><br></li><li name="978c" id="978c" class="graf graf--li graf-after--li">假设本机想要关闭连接，本机发送一个“<strong class="markup--strong markup--li-strong">结束标志位FIN=1，序号Seq=常数x</strong>”的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</li><li name="9ae3" id="9ae3" class="graf graf--li graf--empty graf-after--li"><br></li><li name="f4d0" id="f4d0" class="graf graf--li graf-after--li">发送完毕后，本机进入 FIN_WAIT_1 状态。</li><li name="00e2" id="00e2" class="graf graf--li graf--empty graf-after--li"><br></li><li name="be59" id="be59" class="graf graf--li graf-after--li">第二次挥手：已收到关闭连接请求</li><li name="e850" id="e850" class="graf graf--li graf--empty graf-after--li"><br></li><li name="0a05" id="0a05" class="graf graf--li graf-after--li">远程主机确认客户端的 FIN 包，发送一个“<strong class="markup--strong markup--li-strong">确认标志位ACK=1，序号Seq=常数y，确认号ack=x+1</strong>”的确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</li><li name="f373" id="f373" class="graf graf--li graf--empty graf-after--li"><br></li><li name="d138" id="d138" class="graf graf--li graf-after--li">发送完毕后，远程主机进入 CLOSE_WAIT 状态，本机接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待远程主机关闭连接。</li><li name="0602" id="0602" class="graf graf--li graf--empty graf-after--li"><br></li><li name="f195" id="f195" class="graf graf--li graf-after--li">在第二次和第三次挥手之间，远程主机要向本机完成剩余的数据发送，当数据全部发送完毕时，远端主机便可以准备好关闭连接。</li><li name="1992" id="1992" class="graf graf--li graf--empty graf-after--li"><br></li><li name="e793" id="e793" class="graf graf--li graf-after--li">第三次挥手：无需要传递的数据，已准备好关闭连接</li><li name="da6b" id="da6b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="0ad6" id="0ad6" class="graf graf--li graf-after--li">远程主机准备好关闭连接时，向本机发送一个“<strong class="markup--strong markup--li-strong">结束标志位FIN=1，确认标志位ACK=1，序号Seq=常数w（因为有数据传输，w实际上等于y+第二次挥手和第三次挥手之间传输的数据字节数），确认号ack=x+1</strong>”，表示结束连接请求。</li><li name="0859" id="0859" class="graf graf--li graf--empty graf-after--li"><br></li><li name="74c5" id="74c5" class="graf graf--li graf-after--li">发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</li><li name="0534" id="0534" class="graf graf--li graf--empty graf-after--li"><br></li><li name="701e" id="701e" class="graf graf--li graf-after--li">第四次挥手：已经关闭连接</li><li name="3424" id="3424" class="graf graf--li graf--empty graf-after--li"><br></li><li name="924c" id="924c" class="graf graf--li graf-after--li">本机接收到来自远程主机的“已准备好关闭连接”请求，发送一个“<strong class="markup--strong markup--li-strong">确认标志位ACK=1，序号Seq=x+1，确认号ack=w+1</strong>”确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。</li><li name="7e44" id="7e44" class="graf graf--li graf--empty graf-after--li"><br></li><li name="b2cf" id="b2cf" class="graf graf--li graf-after--li">远程主机接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li><li name="a60f" id="a60f" class="graf graf--li graf--empty graf-after--li"><br></li><li name="c34d" id="c34d" class="graf graf--li graf-after--li">本机等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK 包 ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</li><li name="1672" id="1672" class="graf graf--li graf--empty graf-after--li"><br></li><li name="0b99" id="0b99" class="graf graf--li graf-after--li">同时打开：本机和远端主机同时打开的情况</li><li name="8655" id="8655" class="graf graf--li graf--empty graf-after--li"><br></li><li name="6754" id="6754" class="graf graf--li graf-after--li">两端主机同时向对方发送一个“<strong class="markup--strong markup--li-strong">SYN：1，ACK：0，Seq：x（or y）</strong>”的数据包。</li><li name="7990" id="7990" class="graf graf--li graf--empty graf-after--li"><br></li><li name="eed3" id="eed3" class="graf graf--li graf-after--li">发送完毕后，两方主机都进入SYN_SEND的状态</li><li name="e402" id="e402" class="graf graf--li graf--empty graf-after--li"><br></li><li name="351c" id="351c" class="graf graf--li graf-after--li">两端主机可能会先后向对方回复一个“<strong class="markup--strong markup--li-strong">SYN：1，ACK：1，Seq：x+1（or y+1），ack：y+1（or x+1）</strong>”的数据包。</li><li name="f1a4" id="f1a4" class="graf graf--li graf--empty graf-after--li"><br></li><li name="b8e7" id="b8e7" class="graf graf--li graf-after--li">发送完毕后，两方主机都进入SYN_RCVD的状态</li><li name="f3c0" id="f3c0" class="graf graf--li graf--empty graf-after--li"><br></li><li name="231b" id="231b" class="graf graf--li graf-after--li">在主机为SYN_RCVD的状态的情况下，收到对方发来的“<strong class="markup--strong markup--li-strong">SYN：1，ACK：1，Seq：x+1（or y+1），ack：y+1（or x+1）</strong>”的数据包，本地主机可以认为对方已经允许建立连接，不需要在进行第三次握手。</li><li name="3671" id="3671" class="graf graf--li graf--empty graf-after--li"><br></li><li name="f15c" id="f15c" class="graf graf--li graf-after--li">接收到对方发送的数据报后，两方主机都进入ESTABLISHED的状态</li><li name="7d3a" id="7d3a" class="graf graf--li graf--empty graf-after--li"><br></li><li name="97b8" id="97b8" class="graf graf--li graf-after--li">同时关闭：本机和远端主机同时关闭的情况</li><li name="7218" id="7218" class="graf graf--li graf--empty graf-after--li"><br></li><li name="4aa2" id="4aa2" class="graf graf--li graf-after--li">在同时关闭的情况，两方都没有数据需要发送</li><li name="d41a" id="d41a" class="graf graf--li graf--empty graf-after--li"><br></li><li name="0abe" id="0abe" class="graf graf--li graf-after--li">因此我们不需要进行第二次挥手和第三次挥手，不需要进行等待传输全部数据就可以关闭两端主机</li><li name="649a" id="649a" class="graf graf--li graf--empty graf-after--li"><br></li><li name="6a65" id="6a65" class="graf graf--li graf-after--li">半关闭</li><li name="0ee6" id="0ee6" class="graf graf--li graf--empty graf-after--li"><br></li><li name="5eb4" id="5eb4" class="graf graf--li graf-after--li">当TCP链接中A向B发送 FIN 请求关闭，另一端B回应ACK之后，并没有立即发送 FIN 给A。</li><li name="b80b" id="b80b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="56ad" id="56ad" class="graf graf--li graf-after--li">A方处于半关闭状态，此时A可以接收B发送的数据，但是A已经不能再向B发送数据。</li><li name="6b53" id="6b53" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9032" id="9032" class="graf graf--li graf-after--li">半连接</li><li name="2ecf" id="2ecf" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9640" id="9640" class="graf graf--li graf-after--li">发生在TCP三次握手中</li><li name="c24b" id="c24b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="50a9" id="50a9" class="graf graf--li graf-after--li">如果A向B发起链接，B也按照正常情况响应了，但是A不进行三次握手，这就是半连接。</li><li name="d035" id="d035" class="graf graf--li graf--empty graf-after--li"><br></li><li name="26f6" id="26f6" class="graf graf--li graf-after--li">半连接攻击：半连接，会造成B分配的内存资源就一直这么耗着，直到资源耗尽。（SYN攻击）</li><li name="151d" id="151d" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9f7b" id="9f7b" class="graf graf--li graf-after--li">半打开</li><li name="f501" id="f501" class="graf graf--li graf--empty graf-after--li"><br></li><li name="a9e4" id="a9e4" class="graf graf--li graf-after--li">如果一方关闭或者异常关闭（断电，断网），而另一方并不知情，这样的链接称之为半打开。</li><li name="fff4" id="fff4" class="graf graf--li graf--empty graf-after--li"><br></li><li name="c9f1" id="c9f1" class="graf graf--li graf-after--li">处于半打开的连接，如果双方不进行数据通信，是发现不了问题的，只有在通信是才真正的察觉到这个连接已经处于半打开状态，如果双方不传输数据的话，仍处于连接状态的一方就不会检测另外一方已经出现异常</li><li name="9f68" id="9f68" class="graf graf--li graf--empty graf-after--li"><br></li><li name="ffcb" id="ffcb" class="graf graf--li graf-after--li">解决方法： 如何解决半打开问题，引入心跳机制就可以察觉半打开。</li><li name="8db9" id="8db9" class="graf graf--li graf--empty graf-after--li"><br></li><li name="18b7" id="18b7" class="graf graf--li graf-after--li">如果需要发数据的话，这边收到之后 其实发现这个连接并不存在了，就会回复RST包告知，这个时候就需要重新建立连接了</li><li name="d788" id="d788" class="graf graf--li graf--empty graf-after--li"><br></li><li name="39bb" id="39bb" class="graf graf--li graf-after--li">TCP流量控制机制</li><li name="6de6" id="6de6" class="graf graf--li graf--empty graf-after--li"><br></li><li name="347f" id="347f" class="graf graf--li graf-after--li">进行流量控制的目的：</li><li name="384a" id="384a" class="graf graf--li graf--empty graf-after--li"><br></li><li name="29b3" id="29b3" class="graf graf--li graf-after--li">避免分组丢失：发送者发送过快，接收者来不及接收</li><li name="29d3" id="29d3" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1cb9" id="1cb9" class="graf graf--li graf-after--li">避免缓存溢出：发送者发送过快，接收者接收量超过缓存，发生溢出</li><li name="b0fb" id="b0fb" class="graf graf--li graf--empty graf-after--li"><br></li><li name="167d" id="167d" class="graf graf--li graf-after--li">滑动窗口字段</li><li name="5e8d" id="5e8d" class="graf graf--li graf--empty graf-after--li"><br></li><li name="f23a" id="f23a" class="graf graf--li graf-after--li">滑动窗口字段时由本机发送给目标机的参数，这个字段规定了给出了本机的缓存大小，从而告知目标机限制发送数据的流量</li><li name="5db8" id="5db8" class="graf graf--li graf--empty graf-after--li"><br></li><li name="dad5" id="dad5" class="graf graf--li graf-after--li">死锁</li><li name="1fbc" id="1fbc" class="graf graf--li graf--empty graf-after--li"><br></li><li name="4783" id="4783" class="graf graf--li graf-after--li">当接收者向发送者发送了一个窗口为0的应答，那么发送者便会停止发送，等待接收者的下一个应答。</li><li name="a6c8" id="a6c8" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1de3" id="1de3" class="graf graf--li graf-after--li">如果接收者的下一个窗口不为0的应答丢失，那么发送者就会一直等下去，直到等到下一个应答。</li><li name="b92f" id="b92f" class="graf graf--li graf--empty graf-after--li"><br></li><li name="7359" id="7359" class="graf graf--li graf-after--li">但是接收者会认为应答已经发送，因此接收者会等待发送者发来信息，双方都不会发信息，因此产生死锁现象。</li><li name="68c8" id="68c8" class="graf graf--li graf--empty graf-after--li"><br></li><li name="f620" id="f620" class="graf graf--li graf-after--li">为了避免这一情况，TCP协议引入了持续计时器的概念，过程如下：</li><li name="d26f" id="d26f" class="graf graf--li graf--empty graf-after--li"><br></li><li name="0ddb" id="0ddb" class="graf graf--li graf-after--li">发送者收到一个窗口为0的应答，启动持续计时器。</li><li name="2728" id="2728" class="graf graf--li graf--empty graf-after--li"><br></li><li name="094b" id="094b" class="graf graf--li graf-after--li">持续计时器时间到，发送者向接收者请求窗口。</li><li name="6684" id="6684" class="graf graf--li graf--empty graf-after--li"><br></li><li name="a967" id="a967" class="graf graf--li graf-after--li">如果接收者应答报文中窗口为0，发送者等待下一个计时器重新请求窗口。</li><li name="0d2b" id="0d2b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="c80a" id="c80a" class="graf graf--li graf-after--li">如果接收者应答报文丢失，发送者等待下一个计时器重新请求窗口。</li><li name="514c" id="514c" class="graf graf--li graf--empty graf-after--li"><br></li><li name="cac1" id="cac1" class="graf graf--li graf-after--li">如果接收者应答报文中窗口不为0，发送者根据窗口字段传输数据。</li><li name="2250" id="2250" class="graf graf--li graf--empty graf-after--li"><br></li><li name="b0b3" id="b0b3" class="graf graf--li graf-after--li">拥塞和拥塞控制</li><li name="eaf4" id="eaf4" class="graf graf--li graf--empty graf-after--li"><br></li><li name="0a51" id="0a51" class="graf graf--li graf-after--li">拥塞现象：网络上充斥的数据包不能够被及时发送，造成信息传递延迟。</li><li name="b8e8" id="b8e8" class="graf graf--li graf--empty graf-after--li"><br></li><li name="bc4e" id="bc4e" class="graf graf--li graf-after--li">拥塞控制：TCP协议设计了几种算法，这些算法可以在发生拥塞现象之后及时调整数据的发送策略，减少数据包的发送从而减少网络的压力。</li><li name="4a8b" id="4a8b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="5881" id="5881" class="graf graf--li graf-after--li">拥塞窗口cwnd：</li><li name="1cbf" id="1cbf" class="graf graf--li graf--empty graf-after--li"><br></li><li name="726b" id="726b" class="graf graf--li graf-after--li">是拥塞控制算法中的重要状态变量。</li><li name="9ad0" id="9ad0" class="graf graf--li graf--empty graf-after--li"><br></li><li name="a44f" id="a44f" class="graf graf--li graf-after--li">拥塞窗口的大叫应该取决于网络的拥塞程度，并且实时动态变化。</li><li name="7874" id="7874" class="graf graf--li graf--empty graf-after--li"><br></li><li name="f62a" id="f62a" class="graf graf--li graf-after--li">另外需要考虑接收方的接收速度。</li><li name="513d" id="513d" class="graf graf--li graf--empty graf-after--li"><br></li><li name="6e01" id="6e01" class="graf graf--li graf-after--li">通常情况下会要求发送窗口&lt;拥塞窗口。</li><li name="91f4" id="91f4" class="graf graf--li graf--empty graf-after--li"><br></li><li name="5a94" id="5a94" class="graf graf--li graf-after--li">收到ACK：ACK指的是确认收到的报文，信息接收方会对报文进行检查，如果未发现错误，则向发送方发出ACK。发送方收到ACK表示信息被接收方正确接收。</li><li name="b025" id="b025" class="graf graf--li graf--empty graf-after--li"><br></li><li name="a975" id="a975" class="graf graf--li graf-after--li">往返时间延迟RTT：RTT指的是从发送方发送报文开始到接收到ACK应答所消耗的时间</li><li name="b2e4" id="b2e4" class="graf graf--li graf--empty graf-after--li"><br></li><li name="4cf8" id="4cf8" class="graf graf--li graf-after--li">慢启动阈门ssthresh：是决定执行拥塞避免算法和慢启动算法的阈值，超过该值只能执行拥塞避免算法。通常情况下该值的初始值手动规定为16。</li><li name="f35c" id="f35c" class="graf graf--li graf--empty graf-after--li"><br></li><li name="aafc" id="aafc" class="graf graf--li graf-after--li">拥塞控制的四个算法</li><li name="ab09" id="ab09" class="graf graf--li graf--empty graf-after--li"><br></li><li name="c2f4" id="c2f4" class="graf graf--li graf-after--li">拥塞窗口控制算法目的：控制拥塞窗口的大小和增长速度</li><li name="fdee" id="fdee" class="graf graf--li graf--empty graf-after--li"><br></li><li name="a1bf" id="a1bf" class="graf graf--li graf-after--li">慢启动算法【增加函数为2的指数】</li><li name="a5c9" id="a5c9" class="graf graf--li graf--empty graf-after--li"><br></li><li name="f259" id="f259" class="graf graf--li graf-after--li">默认cwnd=0，初始化cwnd=1</li><li name="da76" id="da76" class="graf graf--li graf--empty graf-after--li"><br></li><li name="5031" id="5031" class="graf graf--li graf-after--li">令发送窗口=cwnd，进行发送</li><li name="2113" id="2113" class="graf graf--li graf--empty graf-after--li"><br></li><li name="a728" id="a728" class="graf graf--li graf-after--li">经过一个RTT，cwnd = cnwd * 2（算法层面实现是每收到一个ACK，cwnd++）</li><li name="3eb3" id="3eb3" class="graf graf--li graf--empty graf-after--li"><br></li><li name="c366" id="c366" class="graf graf--li graf-after--li">重复第二步和第三步直到cwnd &gt; ssthresh</li><li name="7907" id="7907" class="graf graf--li graf--empty graf-after--li"><br></li><li name="fce7" id="fce7" class="graf graf--li graf-after--li">如果cwnd &gt; ssthresh，执行拥塞避免算法</li><li name="43fc" id="43fc" class="graf graf--li graf--empty graf-after--li"><br></li><li name="73c6" id="73c6" class="graf graf--li graf-after--li">拥塞避免【增加函数为线型】</li><li name="807d" id="807d" class="graf graf--li graf--empty graf-after--li"><br></li><li name="d68c" id="d68c" class="graf graf--li graf-after--li">当cwnd &gt; ssthresh，执行拥塞避免算法</li><li name="4fbf" id="4fbf" class="graf graf--li graf--empty graf-after--li"><br></li><li name="7314" id="7314" class="graf graf--li graf-after--li">令发送窗口=cwnd，进行发送</li><li name="ef6f" id="ef6f" class="graf graf--li graf--empty graf-after--li"><br></li><li name="51db" id="51db" class="graf graf--li graf-after--li">经过一个RTT，cnwd++（算法层面实现是每收到一个ACK，cwnd = cwnd + 1/cwnd）</li><li name="f3f5" id="f3f5" class="graf graf--li graf--empty graf-after--li"><br></li><li name="d1af" id="d1af" class="graf graf--li graf-after--li">重复第二步和第三步直到发生拥塞现象（判断出现拥塞现象的要求是出现丢包）</li><li name="cdf8" id="cdf8" class="graf graf--li graf--empty graf-after--li"><br></li><li name="34aa" id="34aa" class="graf graf--li graf-after--li">令ssthresh = cwnd/2，cwnd=1，执行慢启动算法</li><li name="d4c7" id="d4c7" class="graf graf--li graf--empty graf-after--li"><br></li><li name="8824" id="8824" class="graf graf--li graf-after--li">丢包控制算法目的：及时恢复丢失的数据包，且牺牲最小效率</li><li name="b373" id="b373" class="graf graf--li graf--empty graf-after--li"><br></li><li name="294b" id="294b" class="graf graf--li graf-after--li">快速重传</li><li name="8af6" id="8af6" class="graf graf--li graf--empty graf-after--li"><br></li><li name="3909" id="3909" class="graf graf--li graf-after--li">一般来说，接收方接收到的来自发送方的数据包是连续的，接收方每确认一个数据报，就发送一个确认报文ACK给发送方，这个报文中包括了确认的包M的信息。</li><li name="e4f1" id="e4f1" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1240" id="1240" class="graf graf--li graf-after--li">如果出现发送者发送的数据包丢失现象，对于之后接收到数据包，接收端并不能接收，这时启动快速重传算法。</li><li name="4dae" id="4dae" class="graf graf--li graf--empty graf-after--li"><br></li><li name="3e9a" id="3e9a" class="graf graf--li graf-after--li">快速重传算法是指新的数据包不需要经过确认，如果不是连续的，接收端可以直接应答ACK确认之前数据包M的信息。</li><li name="b564" id="b564" class="graf graf--li graf--empty graf-after--li"><br></li><li name="6d5d" id="6d5d" class="graf graf--li graf-after--li">当发送端收到连续三次对于统一数据包M的ACK确认报文，发送端就有理由认为数据包M的下一个数据包丢失了。</li><li name="bc0e" id="bc0e" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1a90" id="1a90" class="graf graf--li graf-after--li">快速恢复</li><li name="4cf1" id="4cf1" class="graf graf--li graf--empty graf-after--li"><br></li><li name="394a" id="394a" class="graf graf--li graf-after--li">在拥塞避免算法中，我们每次发生拥塞现象，都会将ssthresh = cwnd/2，并且令cwnd=1。</li><li name="6568" id="6568" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1f34" id="1f34" class="graf graf--li graf-after--li">在发生丢包的情况下，例如在快速重传算法中，我们也需要降低拥塞，但是我们不希望降低cwnd到1，因为这样会损失过多的传输效率</li><li name="f795" id="f795" class="graf graf--li graf--empty graf-after--li"><br></li><li name="d89f" id="d89f" class="graf graf--li graf-after--li">因此我们使用快速回复算法，也就是说在完成快速重传之后，我们更改参数ssthresh = cwnd/2，并且令cwnd = ssthresh。</li><li name="e90a" id="e90a" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9e8d" id="9e8d" class="graf graf--li graf-after--li">这样，我们就可以继续使用拥塞避免算法，减少效率的牺牲和损耗。</li><li name="6bc6" id="6bc6" class="graf graf--li graf--empty graf-after--li"><br></li><li name="357f" id="357f" class="graf graf--li graf-after--li">TCP超时重传机制</li><li name="c85b" id="c85b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="c0f8" id="c0f8" class="graf graf--li graf-after--li">四个定时器</li><li name="c692" id="c692" class="graf graf--li graf--empty graf-after--li"><br></li><li name="a469" id="a469" class="graf graf--li graf-after--li">重传计时器：</li><li name="19c5" id="19c5" class="graf graf--li graf--empty graf-after--li"><br></li><li name="8e39" id="8e39" class="graf graf--li graf-after--li">目的：在发生丢包的情况下及时重新传输报文</li><li name="36a8" id="36a8" class="graf graf--li graf--empty graf-after--li"><br></li><li name="f8b8" id="f8b8" class="graf graf--li graf-after--li">发送端每发送一个数据包，重传计时器就开始计时</li><li name="926e" id="926e" class="graf graf--li graf--empty graf-after--li"><br></li><li name="0ed6" id="0ed6" class="graf graf--li graf-after--li">重传时间：2*RTT</li><li name="5175" id="5175" class="graf graf--li graf--empty graf-after--li"><br></li><li name="3539" id="3539" class="graf graf--li graf-after--li">复位：经过重传时间，仍然没有收到ACK报文，重新发送数据包，并将重传计时器复位为0</li><li name="899d" id="899d" class="graf graf--li graf--empty graf-after--li"><br></li><li name="334c" id="334c" class="graf graf--li graf-after--li">撤销：在重传时间之内收到了ACK报文</li><li name="8226" id="8226" class="graf graf--li graf--empty graf-after--li"><br></li><li name="7bad" id="7bad" class="graf graf--li graf-after--li">持续计时器</li><li name="5d68" id="5d68" class="graf graf--li graf--empty graf-after--li"><br></li><li name="f7ca" id="f7ca" class="graf graf--li graf-after--li">目的：解决死锁问题</li><li name="ede9" id="ede9" class="graf graf--li graf--empty graf-after--li"><br></li><li name="8ed5" id="8ed5" class="graf graf--li graf-after--li">发送者收到一个窗口为0的应答，启动持续计时器</li><li name="22a2" id="22a2" class="graf graf--li graf--empty graf-after--li"><br></li><li name="9e56" id="9e56" class="graf graf--li graf-after--li">请求时间：一般为60s</li><li name="2d01" id="2d01" class="graf graf--li graf--empty graf-after--li"><br></li><li name="639a" id="639a" class="graf graf--li graf-after--li">复位：经过请求时间，仍然没有收到新的窗口应答，重新请求接受者窗口字段，如果仍然为0，将持续计时器复位为0</li><li name="2435" id="2435" class="graf graf--li graf--empty graf-after--li"><br></li><li name="b9ad" id="b9ad" class="graf graf--li graf-after--li">撤销：如果发送者收到了不为0的窗口字段，那么持续计时器将被撤销</li><li name="f253" id="f253" class="graf graf--li graf--empty graf-after--li"><br></li><li name="b5c6" id="b5c6" class="graf graf--li graf-after--li">保活计时器</li><li name="33be" id="33be" class="graf graf--li graf--empty graf-after--li"><br></li><li name="403e" id="403e" class="graf graf--li graf-after--li">目的：减少无意义连接</li><li name="1720" id="1720" class="graf graf--li graf--empty graf-after--li"><br></li><li name="5b6a" id="5b6a" class="graf graf--li graf-after--li">服务器端每次收到客户端的数据包时，启动保活计时器</li><li name="4846" id="4846" class="graf graf--li graf--empty graf-after--li"><br></li><li name="3f2f" id="3f2f" class="graf graf--li graf-after--li">复位：每次服务器端收到新的客户端的数据包时，将保活计时器复位为0</li><li name="641c" id="641c" class="graf graf--li graf--empty graf-after--li"><br></li><li name="dba9" id="dba9" class="graf graf--li graf-after--li">撤销：服务器端超过一段时间（一般为2小时）没有收到来自客户端的数据包，则每隔75s向客户端发送一个探测报文。如果发送10次探测报文后客户端仍然没有应答，服务器端可以认为客户端出现了问题，因此服务器端可以断开连接，撤销保活计时器</li><li name="a1f2" id="a1f2" class="graf graf--li graf--empty graf-after--li"><br></li><li name="221a" id="221a" class="graf graf--li graf-after--li">时间等待计时器</li><li name="1067" id="1067" class="graf graf--li graf--empty graf-after--li"><br></li><li name="834b" id="834b" class="graf graf--li graf-after--li">目的：确认第四次挥手成功进行</li><li name="8034" id="8034" class="graf graf--li graf--empty graf-after--li"><br></li><li name="cff8" id="cff8" class="graf graf--li graf-after--li">服务器端向客户端发送FIN报文，客户端向服务器端应答ACK后，时间等待计时器启动</li><li name="d1ff" id="d1ff" class="graf graf--li graf--empty graf-after--li"><br></li><li name="8caa" id="8caa" class="graf graf--li graf-after--li">等待时间：2*MSL</li><li name="9f44" id="9f44" class="graf graf--li graf--empty graf-after--li"><br></li><li name="32a3" id="32a3" class="graf graf--li graf-after--li">撤销：当经过两个期望报文寿命，客户端没有收到来自服务器端的任何报文时，可以认为服务器端已经关闭，因此客户端的连接也可以关闭，撤销时间等待计时器</li><li name="424f" id="424f" class="graf graf--li graf--empty graf-after--li"><br></li><li name="134f" id="134f" class="graf graf--li graf-after--li">为什么要第 3 次握手和4 次挥手？</li><li name="8e21" id="8e21" class="graf graf--li graf--empty graf-after--li"><br></li><li name="1b39" id="1b39" class="graf graf--li graf-after--li">第3次握手：</li><li name="efdd" id="efdd" class="graf graf--li graf--empty graf-after--li"><br></li><li name="bab4" id="bab4" class="graf graf--li graf-after--li">防止已过期的连接请求报文突然又传送到服务器，因而产生错误</li><li name="6a8b" id="6a8b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="4845" id="4845" class="graf graf--li graf-after--li">4 次挥手：</li><li name="3b79" id="3b79" class="graf graf--li graf--empty graf-after--li"><br></li><li name="af8a" id="af8a" class="graf graf--li graf-after--li">确保数据能够完成传输</li><li name="1eb8" id="1eb8" class="graf graf--li graf--empty graf-after--li"><br></li><li name="3c45" id="3c45" class="graf graf--li graf-after--li">当关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了。但未必你所有的数据都全部发送给对方了</li><li name="66b0" id="66b0" class="graf graf--li graf--empty graf-after--li"><br></li><li name="149c" id="149c" class="graf graf--li graf-after--li">为什么TCP/UDP都存在伪报头（伪首部）？</li><li name="e5bf" id="e5bf" class="graf graf--li graf--empty graf-after--li"><br></li><li name="83d6" id="83d6" class="graf graf--li graf-after--li">UDP(TCP)检验和：是根据 UDP(TCP)数据报和伪报头计算得到的差错检测值。</li><li name="879b" id="879b" class="graf graf--li graf--empty graf-after--li"><br></li><li name="c540" id="c540" class="graf graf--li graf-after--li">伪报头包含源和目的 IP 地址，以及来自 IP 数据报报头的协议值。IP 数据报在网络中传送时 包含 UDP 数据报。</li><li name="813c" id="813c" class="graf graf--li graf--empty graf-after--li"><br></li><li name="8468" id="8468" class="graf graf--li graf-after--li">伪报头并不会在网络中传送。</li><li name="1c98" id="1c98" class="graf graf--li graf--empty graf-after--li"><br></li><li name="dce8" id="dce8" class="graf graf--li graf-after--li">校验和中所包含的伪报头内容可以避免目的端错误地接收错误 路由的数据报。</li><li name="640f" id="640f" class="graf graf--li graf--empty graf-after--li"><br></li><li name="d7f3" id="d7f3" class="graf graf--li graf-after--li">校验和值的计算方法和 IP 报头检验和的计算方法类似</li><li name="fdaa" id="fdaa" class="graf graf--li graf--empty graf-after--li"><br></li><li name="eb73" id="eb73" class="graf graf--li graf-after--li">为什么要等待2MSL呢?</li><li name="41d9" id="41d9" class="graf graf--li graf--empty graf-after--li"><br></li><li name="8de7" id="8de7" class="graf graf--li graf-after--li">MSL即Maximum Segment Lifetime，也就是最大报文生存时间。</li><li name="ebee" id="ebee" class="graf graf--li graf--empty graf-after--li"><br></li><li name="fed0" id="fed0" class="graf graf--li graf-after--li">它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</li><li name="8c1d" id="8c1d" class="graf graf--li graf--empty graf-after--li"><br></li><li name="428e" id="428e" class="graf graf--li graf-after--li">引用《TCP/IP详解》中的话：“它(MSL)是任何报文段被丢弃前在网络内的最长时间”。RFC793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</li></ol><p name="f7df" id="f7df" class="graf graf--p graf--empty graf-after--li"><br></p><p name="3c4d" id="3c4d" class="graf graf--p graf--empty graf-after--p graf--trailing"><br></p></div></div></section>
</section>
<footer><p><a href="https://medium.com/p/228470b240f4">View original.</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 15, 2021.</p></footer></article></body></html>